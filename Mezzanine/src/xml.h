 
 
 
<!DOCTYPE html> 
<html> 
  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# githubog: http://ogp.me/ns/fb/githubog#"> 
	<meta charset='utf-8'> 
	<meta http-equiv="X-UA-Compatible" content="IE=edge"> 
		<title>Mezzanine/docs/Tools - PugiXML/ifdef.txt at 32aabbba8dec66dc9e74062cf6246fc9eba438b2 · BlackToppStudios/Mezzanine · GitHub</title> 
	<link rel="search" Type="application/opensearchDescription+xml" href="/opensearch.xml" title="GitHub" /> 
	<link rel="fluid-icon" href="https://github.com/fluidicon.png" title="GitHub" /> 
	<link rel="shortcut icon" href="/favicon.ico" Type="image/x-icon" /> 
 
	 
	 
 
	<meta content="authenticity_token" Name="csrf-param" /> 
<meta content="c9V7Fh5sRHEJhrSa5/WCxMlUPae5wBrG3kP6No4wlj8=" Name="csrf-token" /> 
 
	<link href="https://a248.e.akamai.net/assets.github.com/stylesheets/bundles/github-e50ba0f9506b220dce08af71ef80664231f7dd57.css" media="screen" rel="stylesheet" Type="text/css" /> 
	<link href="https://a248.e.akamai.net/assets.github.com/stylesheets/bundles/github2-387859b7528ac68fea78f3087e1109b39a1f23a8.css" media="screen" rel="stylesheet" Type="text/css" /> 
	 
	 
 
 
	<script src="https://a248.e.akamai.net/assets.github.com/javascripts/bundles/frameworks-e417ea70cc7daa9aad62382cb6b5d0c94acfb8f4.js" Type="text/javascript"></script> 
	 
	<script defer="defer" src="https://a248.e.akamai.net/assets.github.com/javascripts/bundles/github-3109083411e0a9bbb3c7d34b713ad52d826357bf.js" Type="text/javascript"></script> 
	 
	 
 
	  <link rel='permalink' href='/BlackToppStudios/Mezzanine/blob/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs/Tools%20-%20PugiXML/ifdef.txt'> 
	<meta property="og:title" content="Mezzanine"/> 
	<meta property="og:Type" content="githubog:gitrepository"/> 
	<meta property="og:url" content="https://github.com/BlackToppStudios/Mezzanine"/> 
	<meta property="og:image" content="https://a248.e.akamai.net/assets.github.com/images/gravatars/gravatar-140.png?1329275859"/> 
	<meta property="og:site_Name" content="GitHub"/> 
	<meta property="og:Description" content="Mezzanine - A game engine that supports high performance 3d graphics physics and sound"/> 
 
	<meta Name="Description" content="Mezzanine - A game engine that supports high performance 3d graphics physics and sound" /> 
 
  <link href="https://github.com/BlackToppStudios/Mezzanine/commits/32aabbba8dec66dc9e74062cf6246fc9eba438b2.atom" rel="alternate" title="Recent Commits to Mezzanine:32aabbba8dec66dc9e74062cf6246fc9eba438b2" Type="application/atom+xml" /> 
 
  </head> 
 
 
  <body class="logged_out page-blob linux vis-public env-production " data-blob-contribs-enabled="yes"> 
	<div id="wrapper"> 
 
	 
	 
	 
 
	  <div id="header" class="true clearfix"> 
		<div class="container clearfix"> 
		  <a class="site-logo" href="https://github.com/"> 
			<!--[if IE]> 
			<img alt="GitHub" class="github-logo" src="https://a248.e.akamai.net/assets.github.com/images/modules/header/logov7.png?1323882717" /> 
			<img alt="GitHub" class="github-logo-hover" src="https://a248.e.akamai.net/assets.github.com/images/modules/header/logov7-hover.png?1324325376" /> 
			<![endif]--> 
			<img alt="GitHub" class="github-logo-4x" height="30" src="https://a248.e.akamai.net/assets.github.com/images/modules/header/logov7@4x.png?1337118068" /> 
			<img alt="GitHub" class="github-logo-4x-hover" height="30" src="https://a248.e.akamai.net/assets.github.com/images/modules/header/logov7@4x-hover.png?1337118068" /> 
		  </a> 
 
				  <!-- 
	  make sure to use fully qualified URLs here since this nav 
	  is used on error pages on other domains 
	--> 
	<ul class="top-nav logged_out"> 
		<li class="pricing"><a href="https://github.com/plans">Signup and Pricing</a></li> 
		<li class="explore"><a href="https://github.com/explore">Explore GitHub</a></li> 
	  <li class="features"><a href="https://github.com/features">Features</a></li> 
		<li class="blog"><a href="https://github.com/blog">Blog</a></li> 
	  <li class="login"><a href="https://github.com/login?return_to=%2FBlackToppStudios%2FMezzanine%2Fblob%2F32aabbba8dec66dc9e74062cf6246fc9eba438b2%2Fdocs%2FTools%2520-%2520PugiXML%2Fifdef.txt">Login</a></li> 
	</ul> 
 
 
 
		   
		</div> 
	  </div> 
 
	   
 
			<div class="site hfeed" itemscope itemType="http://schema.org/WebPage"> 
	  <div class="container hentry"> 
		<div class="pagehead repohead instapaper_ignore readability-menu"> 
		<div class="title-actions-bar"> 
		   
 
 
 
			  <ul class="pagehead-actions"> 
 
 
 
		  <li> 
			<span class="watch-button"><a href="/login?return_to=%2FBlackToppStudios%2FMezzanine" class="minibutton btn-watch js-toggler-target entice tooltipped leftwards" title="You must be logged in to use this feature" rel="nofollow"><span class="icon"></span> Watch</a><a class="social-count js-social-count" href="/BlackToppStudios/Mezzanine/watchers">2</a></span> 
		  </li> 
		  <li> 
			<a href="/login?return_to=%2FBlackToppStudios%2FMezzanine" class="minibutton btn-fork js-toggler-target fork-button entice tooltipped leftwards"  title="You must be logged in to use this feature" rel="nofollow"><span class="icon"></span>Fork</a><a href="/BlackToppStudios/Mezzanine/network" class="social-count">1</a> 
		  </li> 
 
	</ul> 
 
		  <h1 itemscope itemType="http://data-vocabulary.org/Breadcrumb" class="entry-title"> 
			<span class="repo-label"><span class="public">public</span></span> 
			<span class="mega-icon public-repo"></span> 
			<span class="author vcard"> 
<a href="/BlackToppStudios" class="url fn" itemprop="url" rel="author">			  <span itemprop="title">BlackToppStudios</span> 
			  </a></span> / 
			<strong><a href="/BlackToppStudios/Mezzanine" class="js-current-repository">Mezzanine</a></strong> 
		  </h1> 
		</div> 
 
		   
 
  <ul class="tabs"> 
	<li><a href="/BlackToppStudios/Mezzanine/tree/" class="selected" highlight="repo_sourcerepo_downLoadsrepo_commitsrepo_tagsrepo_branches">Code</a></li> 
	<li><a href="/BlackToppStudios/Mezzanine/network" highlight="repo_network">Network</a> 
	<li><a href="/BlackToppStudios/Mezzanine/pulls" highlight="repo_pulls">Pull Requests <span class='counter'>0</span></a></li> 
 
 
 
	<li><a href="/BlackToppStudios/Mezzanine/graphs" highlight="repo_graphsrepo_contributors">Graphs</a></li> 
 
  </ul> 
  
<div class="frame frame-center tree-finder" style="display:none" 
	  data-tree-list-url="/BlackToppStudios/Mezzanine/tree-list/32aabbba8dec66dc9e74062cf6246fc9eba438b2" 
	  data-blob-url-prefix="/BlackToppStudios/Mezzanine/blob/32aabbba8dec66dc9e74062cf6246fc9eba438b2" 
	> 
 
  <div class="breadcrumb"> 
	<span class="bold"><a href="/BlackToppStudios/Mezzanine">Mezzanine</a></span> / 
	<input class="tree-finder-input js-navigation-enable" Type="text" Name="query" autocomplete="off" spellcheck="false"> 
  </div> 
 
	<div class="octotip"> 
	  <p> 
		<a href="/BlackToppStudios/Mezzanine/dismiss-tree-finder-help" class="dismiss js-dismiss-tree-list-help" title="Hide this notice forever" rel="nofollow">Dismiss</a> 
		<span class="bold">Octotip:</span> You've activated the <em>file finder</em> 
		by pressing <span class="kbd">t</span> Start typing to filter the 
		file list. Use <span class="kbd badmono">↑</span> and 
		<span class="kbd badmono">↓</span> to navigate, 
		<span class="kbd">enter</span> to view files. 
	  </p> 
	</div> 
 
  <table class="tree-browser" cellpadding="0" cellspacing="0"> 
	<tr class="js-header"><th>&nbsp;</th><th>Name</th></tr> 
	<tr class="js-no-results no-results" style="display: none"> 
	  <th colspan="2">No matching files</th> 
	</tr> 
	<tbody class="js-results-list js-navigation-container"> 
	</tbody> 
  </table> 
</div> 
 
<div id="jump-to-line" style="display:none"> 
  <h2>Jump to Line</h2> 
  <form accept-charset="UTF-8"> 
	<input class="textfield" Type="text"> 
	<div class="full-button"> 
	  <button Type="submit" class="classy"> 
		<span>Go</span> 
	  </button> 
	</div> 
  </form> 
</div> 
 
 
<div class="subnav-bar"> 
 
  <ul class="actions subnav"> 
	<li><a href="/BlackToppStudios/Mezzanine/tags" class="blank" highlight="repo_tags">Tags <span class="counter">0</span></a></li> 
	<li><a href="/BlackToppStudios/Mezzanine/downLoads" class="blank downLoads-blank" highlight="repo_downLoads">DownLoads <span class="counter">0</span></a></li> 
	 
  </ul> 
 
  <ul class="scope"> 
	<li class="switcher"> 
 
	  <div class="context-menu-container js-menu-container js-context-menu"> 
		<a href="#" 
		   class="minibutton bigger switcher js-menu-target js-commitish-button btn-tree repo-tree" 
		   data-hotkey="w" 
		   data-master-branch="master" 
		   data-ref=""> 
		   <span><span class="icon"></span><i>tree:</i> 32aabbba8d</span> 
		</a> 
 
		<div class="context-pane commitish-context js-menu-content"> 
		  <a href="javascript:;" class="close js-menu-close"><span class="mini-icon remove-close"></span></a> 
		  <div class="context-title">Switch Branches/Tags</div> 
		  <div class="context-body pane-selector commitish-selector js-navigation-container"> 
			<div class="filterbar"> 
			  <input Type="text" id="context-commitish-filter-field" class="js-navigation-enable" placeholder="Filter branches/tags" data-filterable /> 
 
			  <ul class="tabs"> 
				<li><a href="#" data-filter="branches" class="selected">Branches</a></li> 
				<li><a href="#" data-filter="tags">Tags</a></li> 
			  </ul> 
			</div> 
 
			<div class="js-filter-tab js-filter-branches" data-filterable-for="context-commitish-filter-field"> 
			  <div class="no-results js-not-filterable">Nothing to show</div> 
				<div class="commitish-item branch-commitish selector-item js-navigation-item js-navigation-target"> 
				  <h4> 
					  <a href="/BlackToppStudios/Mezzanine/blob/master/docs/Tools%20-%20PugiXML/ifdef.txt" class="js-navigation-open" data-Name="master" rel="nofollow">master</a> 
				  </h4> 
				</div> 
			</div> 
 
			<div class="js-filter-tab js-filter-tags" style="display:none" data-filterable-for="context-commitish-filter-field"> 
			  <div class="no-results js-not-filterable">Nothing to show</div> 
			</div> 
		  </div> 
		</div><!-- /.commitish-context-context --> 
	  </div> 
 
	</li> 
  </ul> 
 
  <ul class="subnav with-scope"> 
 
	<li><a href="/BlackToppStudios/Mezzanine/tree/" class="selected" highlight="repo_source">Files</a></li> 
	<li><a href="/BlackToppStudios/Mezzanine/commits/" highlight="repo_commits">Commits</a></li> 
	<li><a href="/BlackToppStudios/Mezzanine/branches" class="" highlight="repo_branches" rel="nofollow">Branches <span class="counter">1</span></a></li> 
  </ul> 
 
</div> 
 
   
   
   
 
 
		   
 
		</div><!-- /.repohead --> 
 
		 
 
 
 
 
 
<!-- block_view_fragment_key: views8/v8/blob:v21:f057ed0ef27e1fb813863cac11e1d7df --> 
  <div id="slider"> 
 
	<div class="breadcrumb" data-Path="docs/Tools - PugiXML/ifdef.txt/"> 
	  <b itemscope="" itemType="http://data-vocabulary.org/Breadcrumb"><a href="/BlackToppStudios/Mezzanine/tree/32aabbba8dec66dc9e74062cf6246fc9eba438b2" class="js-reWrite-sha" itemprop="url"><span itemprop="title">Mezzanine</span></a></b> / <span itemscope="" itemType="http://data-vocabulary.org/Breadcrumb"><a href="/BlackToppStudios/Mezzanine/tree/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs" class="js-reWrite-sha" itemscope="url"><span itemprop="title">docs</span></a></span> / <span itemscope="" itemType="http://data-vocabulary.org/Breadcrumb"><a href="/BlackToppStudios/Mezzanine/tree/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs/Tools%20-%20PugiXML" class="js-reWrite-sha" itemscope="url"><span itemprop="title">Tools - PugiXML</span></a></span> / <strong class="final-Path">ifdef.txt</strong> <span class="js-clippy mini-icon clippy " data-clipboard-text="docs/Tools - PugiXML/ifdef.txt" data-copied-hint="copied!" data-copy-hint="copy to clipboard"></span> 
	</div> 
 
 
	  <div class="commit file-history-tease" data-Path="docs/Tools - PugiXML/ifdef.txt/"> 
		<img class="main-avatar" height="24" src="https://secure.gravatar.com/avatar/5e70d6a10e779d77b290891386147702?s=140&amp;d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-140.png" width="24" /> 
		<span class="author">Sqeaky</span> 
		<time class="js-relative-date" datetime="2011-11-06T11:50:14-08:00" title="2011-11-06 11:50:14">November 06, 2011</time> 
		<div class="commit-title"> 
			<a href="/BlackToppStudios/Mezzanine/commit/7d7dc50b77dd99cf95cea20e2eed28389e7de057" class="message">Cleaned the docs folder a little bit. I cannot remove the duplicate g…</a> 
		</div> 
 
		<div class="participation"> 
		  <p class="quickstat"><a href="#blob_contributors_box" rel="facebox"><strong>0</strong> contributors</a></p> 
		   
		</div> 
		<div id="blob_contributors_box" style="display:none"> 
		  <h2>Users on GitHub who have contributed to this file</h2> 
		  <ul class="facebox-user-list"> 
		  </ul> 
		</div> 
	  </div> 
 
	<div class="frames"> 
	  <div class="frame frame-center" data-Path="docs/Tools - PugiXML/ifdef.txt/" data-permalink-url="/BlackToppStudios/Mezzanine/blob/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs/Tools%20-%20PugiXML/ifdef.txt" data-title="Mezzanine/docs/Tools - PugiXML/ifdef.txt at 32aabbba8dec66dc9e74062cf6246fc9eba438b2 · BlackToppStudios/Mezzanine · GitHub" data-Type="blob"> 
 
		<div id="files" class="bubble"> 
		  <div class="file"> 
			<div class="meta"> 
			  <div class="info"> 
				<span class="icon"><b class="mini-icon text-file"></b></span> 
				<span class="mode" title="File Mode">100644</span> 
				  <span>2 lines (1 sloc)</span> 
				<span>0.015 kb</span> 
			  </div> 
			  <ul class="button-group actions"> 
				  <li> 
					<a class="grouped-button file-edit-link minibutton bigger lighter js-reWrite-sha" href="/BlackToppStudios/Mezzanine/edit/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs/Tools%20-%20PugiXML/ifdef.txt" data-method="post" rel="nofollow" data-hotkey="e">Edit this file</a> 
				  </li> 
 
				<li> 
				  <a href="/BlackToppStudios/Mezzanine/raw/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs/Tools%20-%20PugiXML/ifdef.txt" class="minibutton btn-raw grouped-button bigger lighter" id="raw-url"><span class="icon"></span>Raw</a> 
				</li> 
				  <li> 
					<a href="/BlackToppStudios/Mezzanine/blame/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs/Tools%20-%20PugiXML/ifdef.txt" class="minibutton btn-blame grouped-button bigger lighter"><span class="icon"></span>Blame</a> 
				  </li> 
				<li> 
				  <a href="/BlackToppStudios/Mezzanine/commits/32aabbba8dec66dc9e74062cf6246fc9eba438b2/docs/Tools - PugiXML/ifdef.txt" class="minibutton btn-history grouped-button bigger lighter" rel="nofollow"><span class="icon"></span>History</a> 
				</li> 
			  </ul> 
			</div> 
			  <div class="data Type-text"> 
	  <table cellpadding="0" cellspacing="0" class="lines"> 
		<tr> 
		  <td> 
			<pre class="line_numbers"><span id="L1" rel="#L1">1</span> 
</pre> 
		  </td> 
		  <td width="100%"> 
				<div class="highlight"><pre><div class='line' id='LC1'>#ifdef PHYSXML</div></pre></div> 
		  </td> 
		</tr> 
	  </table> 
  </div> 
 
		  </div> 
		</div> 
	  </div> 
	</div> 
 
  </div> 
 
<div class="frame frame-Loading large-Loading-area" style="display:none;" data-tree-list-url="/BlackToppStudios/Mezzanine/tree-list/32aabbba8dec66dc9e74062cf6246fc9eba438b2" data-blob-url-prefix="/BlackToppStudios/Mezzanine/blob/32aabbba8dec66dc9e74062cf6246fc9eba438b2"> 
  <img src="https://a248.e.akamai.net/assets.github.com/images/spinners/octocat-spinner-64.gif?1329872007" height="64" width="64"> 
</div> 
 
	  </div> 
	  <div class="context-overlay"></div> 
	</div> 
 
	  <div id="footer-push"></div><!-- hack for sticky footer --> 
	</div><!-- end of wrapper - hack for sticky footer --> 
 
	  <!-- footer --> 
	  <div id="footer" > 
		 
  <div class="upper_footer"> 
	 <div class="container clearfix"> 
 
	   <!--[if IE]><h4 id="blacktocat_ie">GitHub Links</h4><![endif]--> 
	   <![if !IE]><h4 id="blacktocat">GitHub Links</h4><![endif]> 
 
	   <ul class="footer_nav"> 
		 <h4>GitHub</h4> 
		 <li><a href="https://github.com/about">About</a></li> 
		 <li><a href="https://github.com/blog">Blog</a></li> 
		 <li><a href="https://github.com/features">Features</a></li> 
		 <li><a href="https://github.com/contact">Contact &amp; Support</a></li> 
		 <li><a href="https://github.com/training">Training</a></li> 
		 <li><a href="http://enterprise.github.com/">GitHub Enterprise</a></li> 
		 <li><a href="http://Status.github.com/">Site Status</a></li> 
	   </ul> 
 
	   <ul class="footer_nav"> 
		 <h4>Tools</h4> 
		 <li><a href="http://get.gaug.es/">Gauges: Analyze web traffic</a></li> 
		 <li><a href="http://speakerdeck.com">Speaker Deck: Presentations</a></li> 
		 <li><a href="https://gist.github.com">Gist: Code snippets</a></li> 
		 <li><a href="http://mac.github.com/">GitHub for Mac</a></li> 
		 <li><a href="http://windows.github.com/">GitHub for Windows</a></li> 
		 <li><a href="http://mobile.github.com/">Issues for iPhone</a></li> 
		 <li><a href="http://jobs.github.com/">Job Board</a></li> 
	   </ul> 
 
	   <ul class="footer_nav"> 
		 <h4>Extras</h4> 
		 <li><a href="http://shop.github.com/">GitHub Shop</a></li> 
		 <li><a href="http://octodex.github.com/">The Octodex</a></li> 
	   </ul> 
 
	   <ul class="footer_nav"> 
		 <h4>Documentation</h4> 
		 <li><a href="http://help.github.com/">GitHub Help</a></li> 
		 <li><a href="http://developer.github.com/">Developer API</a></li> 
		 <li><a href="http://github.github.com/github-flavored-markdown/">GitHub Flavored Markdown</a></li> 
		 <li><a href="http://pages.github.com/">GitHub Pages</a></li> 
	   </ul> 
 
	 </div><!-- /.site --> 
  </div><!-- /.upper_footer --> 
 
<div class="lower_footer"> 
  <div class="container clearfix"> 
	<!--[if IE]><div id="legal_ie"><![endif]--> 
	<![if !IE]><div id="legal"><![endif]> 
	  <ul> 
		  <li><a href="https://github.com/site/terms">Terms of Service</a></li> 
		  <li><a href="https://github.com/site/privacy">Privacy</a></li> 
		  <li><a href="https://github.com/security">Security</a></li> 
	  </ul> 
 
	  <p>&copy; 2012 <span title="0.06176s from fe11.rs.github.com">GitHub</span> Inc. All rights reserved.</p> 
	</div><!-- /#legal or /#legal_ie--> 
 
	  <div class="sponsor"> 
		<a href="http://www.rackspace.com" class="logo"> 
		  <img alt="Dedicated Server" height="36" src="https://a248.e.akamai.net/assets.github.com/images/modules/footer/rackspaces_logo.png?1329521039" width="38" /> 
		</a> 
		Powered by the <a href="http://www.rackspace.com ">Dedicated 
		Servers</a> and<br/> <a href="http://www.rackspacecloud.com">Cloud 
		Computing</a> of Rackspace Hosting<span>&reg;</span> 
	  </div> 
  </div><!-- /.site --> 
</div><!-- /.lower_footer --> 
 
	  </div><!-- /#footer --> 
 
	 
 
<div id="keyboard_shortcuts_pane" class="instapaper_ignore readability-extra" style="display:none"> 
  <h2>Keyboard Shortcuts <small><a href="#" class="js-see-all-keyboard-shortcuts">(see all)</a></small></h2> 
 
  <div class="columns threecols"> 
	<div class="column first"> 
	  <h3>Site wide shortcuts</h3> 
	  <dl class="keyboard-mappings"> 
		<dt>s</dt> 
		<dd>Focus site search</dd> 
	  </dl> 
	  <dl class="keyboard-mappings"> 
		<dt>?</dt> 
		<dd>Bring up this help dialog</dd> 
	  </dl> 
	</div><!-- /.column.first --> 
 
	<div class="column middle" style='display:none'> 
	  <h3>Commit list</h3> 
	  <dl class="keyboard-mappings"> 
		<dt>j</dt> 
		<dd>Move selection down</dd> 
	  </dl> 
	  <dl class="keyboard-mappings"> 
		<dt>k</dt> 
		<dd>Move selection up</dd> 
	  </dl> 
	  <dl class="keyboard-mappings"> 
		<dt>c <em>or</em> o <em>or</em> enter</dt> 
		<dd>Open commit</dd> 
	  </dl> 
	  <dl class="keyboard-mappings"> 
		<dt>y</dt> 
		<dd>Expand URL to its canonical form</dd> 
	  </dl> 
	</div><!-- /.column.first --> 
 
	<div class="column last" style='display:none'> 
	  <h3>Pull request list</h3> 
	  <dl class="keyboard-mappings"> 
		<dt>j</dt> 
		<dd>Move selection down</dd> 
	  </dl> 
	  <dl class="keyboard-mappings"> 
		<dt>k</dt> 
		<dd>Move selection up</dd> 
	  </dl> 
	  <dl class="keyboard-mappings"> 
		<dt>o <em>or</em> enter</dt> 
		<dd>Open issue</dd> 
	  </dl> 
	  <dl class="keyboard-mappings"> 
		<dt><span class="platform-mac">⌘</span><span class="platform-other">ctrl</span> <em>+</em> enter</dt> 
		<dd>Submit comment</dd> 
	  </dl> 
	</div><!-- /.columns.last --> 
 
  </div><!-- /.columns.equacols --> 
 
  <div style='display:none'> 
	<div class="rule"></div> 
 
	<h3>Issues</h3> 
 
	<div class="columns threecols"> 
	  <div class="column first"> 
		<dl class="keyboard-mappings"> 
		  <dt>j</dt> 
		  <dd>Move selection down</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>k</dt> 
		  <dd>Move selection up</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>x</dt> 
		  <dd>Toggle selection</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>o <em>or</em> enter</dt> 
		  <dd>Open issue</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt><span class="platform-mac">⌘</span><span class="platform-other">ctrl</span> <em>+</em> enter</dt> 
		  <dd>Submit comment</dd> 
		</dl> 
	  </div><!-- /.column.first --> 
	  <div class="column last"> 
		<dl class="keyboard-mappings"> 
		  <dt>c</dt> 
		  <dd>Create issue</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>l</dt> 
		  <dd>Create label</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>i</dt> 
		  <dd>Back to inbox</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>u</dt> 
		  <dd>Back to issues</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>/</dt> 
		  <dd>Focus issues search</dd> 
		</dl> 
	  </div> 
	</div> 
  </div> 
 
  <div style='display:none'> 
	<div class="rule"></div> 
 
	<h3>Issues Dashboard</h3> 
 
	<div class="columns threecols"> 
	  <div class="column first"> 
		<dl class="keyboard-mappings"> 
		  <dt>j</dt> 
		  <dd>Move selection down</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>k</dt> 
		  <dd>Move selection up</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>o <em>or</em> enter</dt> 
		  <dd>Open issue</dd> 
		</dl> 
	  </div><!-- /.column.first --> 
	</div> 
  </div> 
 
  <div style='display:none'> 
	<div class="rule"></div> 
 
	<h3>Network Graph</h3> 
	<div class="columns equacols"> 
	  <div class="column first"> 
		<dl class="keyboard-mappings"> 
		  <dt><span class="badmono">←</span> <em>or</em> h</dt> 
		  <dd>Scroll left</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt><span class="badmono">→</span> <em>or</em> l</dt> 
		  <dd>Scroll right</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt><span class="badmono">↑</span> <em>or</em> k</dt> 
		  <dd>Scroll up</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt><span class="badmono">↓</span> <em>or</em> j</dt> 
		  <dd>Scroll down</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>t</dt> 
		  <dd>Toggle visibility of head labels</dd> 
		</dl> 
	  </div><!-- /.column.first --> 
	  <div class="column last"> 
		<dl class="keyboard-mappings"> 
		  <dt>shift <span class="badmono">←</span> <em>or</em> shift h</dt> 
		  <dd>Scroll all the way left</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>shift <span class="badmono">→</span> <em>or</em> shift l</dt> 
		  <dd>Scroll all the way right</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>shift <span class="badmono">↑</span> <em>or</em> shift k</dt> 
		  <dd>Scroll all the way up</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>shift <span class="badmono">↓</span> <em>or</em> shift j</dt> 
		  <dd>Scroll all the way down</dd> 
		</dl> 
	  </div><!-- /.column.last --> 
	</div> 
  </div> 
 
  <div > 
	<div class="rule"></div> 
	<div class="columns threecols"> 
	  <div class="column first" > 
		<h3>Source Code Browsing</h3> 
		<dl class="keyboard-mappings"> 
		  <dt>t</dt> 
		  <dd>Activates the file finder</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>l</dt> 
		  <dd>Jump to line</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>w</dt> 
		  <dd>Switch branch/tag</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>y</dt> 
		  <dd>Expand URL to its canonical form</dd> 
		</dl> 
	  </div> 
	</div> 
  </div> 
 
  <div style='display:none'> 
	<div class="rule"></div> 
	<div class="columns threecols"> 
	  <div class="column first"> 
		<h3>Browsing Commits</h3> 
		<dl class="keyboard-mappings"> 
		  <dt><span class="platform-mac">⌘</span><span class="platform-other">ctrl</span> <em>+</em> enter</dt> 
		  <dd>Submit comment</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>escape</dt> 
		  <dd>Close form</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>p</dt> 
		  <dd>Parent commit</dd> 
		</dl> 
		<dl class="keyboard-mappings"> 
		  <dt>o</dt> 
		  <dd>Other GetParent commit</dd> 
		</dl> 
	  </div> 
	</div> 
  </div> 
</div> 
 
	<div id="markdown-help" class="instapaper_ignore readability-extra"> 
  <h2>Markdown Cheat Sheet</h2> 
 
  <div class="cheatsheet-content"> 
 
  <div class="mod"> 
	<div class="col"> 
	  <h3>Format Text</h3> 
	  <p>Headers</p> 
	  <pre> 
# This is an &lt;h1&gt; tag 
## This is an &lt;h2&gt; tag 
###### This is an &lt;h6&gt; tag</pre> 
	 <p>Text styles</p> 
	 <pre> 
*This text will be italic* 
_This will also be italic_ 
**This text will be bold** 
__This will also be bold__ 
 
*You **can** combine them* 
</pre> 
	</div> 
	<div class="col"> 
	  <h3>Lists</h3> 
	  <p>Unordered</p> 
	  <pre> 
* Item 1 
* Item 2 
  * Item 2a 
  * Item 2b</pre> 
	 <p>Ordered</p> 
	 <pre> 
1. Item 1 
2. Item 2 
3. Item 3 
   * Item 3a 
   * Item 3b</pre> 
	</div> 
	<div class="col"> 
	  <h3>Miscellaneous</h3> 
	  <p>Images</p> 
	  <pre> 
![GitHub Logo](/images/logo.png) 
Format: ![Alt Text](url) 
</pre> 
	 <p>Links</p> 
	 <pre> 
http://github.com - automatic! 
[GitHub](http://github.com)</pre> 
<p>Blockquotes</p> 
	 <pre> 
As Kanye West said: 
 
> We're living the future so 
> the present is our past. 
</pre> 
	</div> 
  </div> 
  <div class="rule"></div> 
 
  <h3>Code Examples in Markdown</h3> 
  <div class="col"> 
	  <p>Syntax highlighting with <a href="http://github.github.com/github-flavored-markdown/" title="GitHub Flavored Markdown" target="_blank">GFM</a></p> 
	  <pre> 
```javascript 
function fancyAlert(arg) { 
  if(arg) { 
	$.facebox({div:'#foo'}) 
  } 
} 
```</pre> 
	</div> 
	<div class="col"> 
	  <p>Or, indent your code 4 spaces</p> 
	  <pre> 
Here is a Python code example 
without syntax highlighting: 
 
	def foo: 
	  if not bar: 
		return true</pre> 
	</div> 
	<div class="col"> 
	  <p>Inline code for comments</p> 
	  <pre> 
I think you should use an 
`&lt;addr&gt;` element here instead.</pre> 
	</div> 
  </div> 
 
  </div> 
</div> 
 
 
	<div class="ajax-error-message"> 
	  <p><span class="mini-icon exclamation"></span> Something went wrong with that request. Please try again. <a href="javascript:;" class="ajax-error-dismiss">Dismiss</a></p> 
	</div> 
 
	<div id="logo-popup"> 
	  <h2>Looking for the GitHub logo?</h2> 
	  <ul> 
		<li> 
		  <h4>GitHub Logo</h4> 
		  <a href="http://github-media-downLoads.s3.amazonaws.com/GitHub_Logos.zip"><img alt="Github_logo" src="https://a248.e.akamai.net/assets.github.com/images/modules/about_page/github_logo.png?1315928456" /></a> 
		  <a href="http://github-media-downLoads.s3.amazonaws.com/GitHub_Logos.zip" class="minibutton btn-downLoad downLoad"><span class="icon"></span>DownLoad</a> 
		</li> 
		<li> 
		  <h4>The Octocat</h4> 
		  <a href="http://github-media-downLoads.s3.amazonaws.com/Octocats.zip"><img alt="Octocat" src="https://a248.e.akamai.net/assets.github.com/images/modules/about_page/octocat.png?1315928456" /></a> 
		  <a href="http://github-media-downLoads.s3.amazonaws.com/Octocats.zip" class="minibutton btn-downLoad downLoad"><span class="icon"></span>DownLoad</a> 
		</li> 
	  </ul> 
	</div> 
 
	 
	 
	 
	<span id='server_response_time' data-time='0.06478' data-host='fe11'></span> 
  </body> 
</html> 
 
/* 
 * pugixml parser - version 1.2 
 * -------------------------------------------------------- 
 * Copyright © 2006-2012, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com) 
 * Report bugs and downLoad new versions at http://pugixml.org/ 
 * 
 * This library is distributed under the MIT License. See notice at the end 
 * of this file. 
 * 
 * This work is based on the pugxml parser, which is: 
 * Copyright © 2003, by Kristen Wegner (kristen@tima.net) 
 */ 
 
#ifndef _XMLCONFIG_H 
#define _XMLCONFIG_H 
 
// Uncomment this to enable wchar_t mode 
// #define XML_WCHAR_MODE 
 
// Uncomment this to disable XPath 
// #define XML_NO_XPATH 
 
// Uncomment this to disable STL 
// #define XML_NO_STL 
 
// Uncomment this to disable exceptions 
// #define XML_NO_EXCEPTIONS 
 
// Set this to control attributes for public classes/functions, i.e.: 
// #define MEZZ_LIB __declspec(dllexport) // to export all public symbols from DLL 
// #define MEZZ_LIB __declspec(dllimport) // to import all classes from DLL 
// #define MEZZ_LIB __fastcall // to set calling conventions to all public functions to fastcall 
// In absence of MEZZ_LIB/MEZZ_LIB definitions MEZZ_LIB is used instead 
 
// Uncomment this to switch to header-only version 
// #define XML_HEADER_ONLY 
// #include "pugixml.cpp" 
 
// Tune these constants to adjust memory-related behavior 
// #define XML_MEMORY_PAGE_SIZE 32768 
// #define XML_MEMORY_OUTPUT_STACK 10240 
// #define XML_MEMORY_XPATH_PAGE_SIZE 4096 
 
#endif 
 
#ifndef XML_VERSION 
// Define version macro; evaluates to major * 100 + minor so that it's safe to use in less-than comparisons 
#	define XML_VERSION 120 
#endif 
 
// Include user configuration file (this can define various configuration macros) 
#include "crossplatform.h" 
#include "xmldoc.h" 
#include "exception.h" 
 
#ifndef _XML_H 
#define _XML_H 
 
// Include stddef.h for size_t and ptrdiff_t 
#include <stddef.h> 
 
// Include exception header for XPath 
#if !defined(XML_NO_XPATH) && !defined(XML_NO_EXCEPTIONS) 
#	include <exception> 
#endif 
 
// Include STL headers 
#ifndef XML_NO_STL 
#	include <iterator> 
#	include <iosfwd> 
#	include <string> 
#endif 
 
// Macro for deprecated features 
#ifndef XML_DEPRECATED 
#	if defined(__GNUC__) 
#		define XML_DEPRECATED __attribute__((deprecated)) 
#	elif defined(_MSC_VER) && _MSC_VER >= 1300 
#		define XML_DEPRECATED __declspec(deprecated) 
#	else 
#		define XML_DEPRECATED 
#	endif 
#endif 
 
// If no API is defined, assume default 
#ifndef MEZZ_LIB 
#	define MEZZ_LIB 
#endif 
 
// If no API for classes is defined, assume default 
#ifndef MEZZ_LIB 
#	define MEZZ_LIB MEZZ_LIB 
#endif 
 
// If no API for functions is defined, assume default 
#ifndef MEZZ_LIB 
#	define MEZZ_LIB MEZZ_LIB 
#endif 
 
// Character interface macros 
#ifdef XML_WCHAR_MODE 
#	define XML_TEXT(t) L ## t 
#	define XML_CHAR wchar_t 
#else 
#	define XML_TEXT(t) t 
#	define XML_CHAR char 
#endif 
 

namespace Mezzanine
{ namespace xml
{ 
	// Character Type used for all internal storage and operations; depends on XML_WCHAR_MODE 
	typedef Character char_t; 
 
#ifndef XML_NO_STL 
	// String Type used for operations that work with STL string; depends on XML_WCHAR_MODE 
	typedef std::basic_string<XML_CHAR, std::char_traits<XML_CHAR>, std::allocator<XML_CHAR> > String; 
#endif 
} 
} // \Mezzanine
 
// The PugiXML namespace 

namespace Mezzanine
{ namespace xml
{ 
	// Tree node Types 
	enum NodeType 
	{ 
		NodeNull,			// Empty (null) node handle 
		NodeDocument,		// A document tree's absolute GetRoot 
		NodeElement,		// Element tag, i.e. '<node/>' 
		NodePcdata,		// Plain character data, i.e. 'text' 
		NodeCdata,			// Character data, i.e. '<![CDATA[text]]>' 
		NodeComment,		// Comment tag, i.e. '<!-- text -->' 
		NodePi,			// Processing instruction, i.e. '<?Name?>' 
		NodeDeclaration,	// Document declaration, i.e. '<?xml version="1.0"?>' 
		NodeDocType		// Document Type declaration, i.e. '<!DOCTYPE doc>' 
	}; 
 
	// Parsing options 
 
	// Minimal parsing mode (equivalent to turning all other flags off). 
	// Only elements and PCDATA sections are added to the DOM tree, no text conversions are performed. 
	const unsigned int ParseMinimal = 0x0000; 
 
	// This flag determines if processing instructions (NodePi) are added to the DOM tree. This flag is off by default. 
	const unsigned int ParsePi = 0x0001; 
 
	// This flag determines if comments (NodeComment) are added to the DOM tree. This flag is off by default. 
	const unsigned int ParseComments = 0x0002; 
 
	// This flag determines if CDATA sections (NodeCdata) are added to the DOM tree. This flag is on by default. 
	const unsigned int ParseCdata = 0x0004; 
 
	// This flag determines if plain character data (NodePcdata) that consist only of whitespace are added to the DOM tree. 
	// This flag is off by default; turning it on usually results in slower parsing and more memory consumption. 
	const unsigned int ParseWsPcdata = 0x0008; 
 
	// This flag determines if character and entity references are expanded during parsing. This flag is on by default. 
	const unsigned int ParseEscapes = 0x0010; 
 
	// This flag determines if EOL characters are normalized (converted to #xA) during parsing. This flag is on by default. 
	const unsigned int ParseEol = 0x0020; 
	 
	// This flag determines if GetAttribute Values are normalized using CDATA normalization rules during parsing. This flag is on by default. 
	const unsigned int ParseWconvAttribute = 0x0040; 
 
	// This flag determines if GetAttribute Values are normalized using NMTOKENS normalization rules during parsing. This flag is off by default. 
	const unsigned int ParseWnormAttribute = 0x0080; 
	 
	// This flag determines if document declaration (NodeDeclaration) is added to the DOM tree. This flag is off by default. 
	const unsigned int ParseDeclaration = 0x0100; 
 
	// This flag determines if document Type declaration (NodeDocType) is added to the DOM tree. This flag is off by default. 
	const unsigned int ParseDocType = 0x0200; 
 
	// This flag determines if plain character data (NodePcdata) that is the only GetChild of the GetParent node and that consists only 
	// of whitespace is added to the DOM tree. 
	// This flag is off by default; turning it on may result in slower parsing and more memory consumption. 
	const unsigned int ParseWsPcdata_single = 0x0400; 
 
	// The default parsing mode. 
	// Elements, PCDATA and CDATA sections are added to the DOM tree, character/reference entities are expanded, 
	// End-of-Line characters are normalized, GetAttribute Values are normalized using CDATA normalization rules. 
	const unsigned int ParseDefault = ParseCdata | ParseEscapes | ParseWconvAttribute | ParseEol; 
 
	// The full parsing mode. 
	// Nodes of all Types are added to the DOM tree, character/reference entities are expanded, 
	// End-of-Line characters are normalized, GetAttribute Values are normalized using CDATA normalization rules. 
	const unsigned int ParseFull = ParseDefault | ParsePi | ParseComments | ParseDeclaration | ParseDocType; 
 
	// These flags determine the DocumentEncoding of input data for XML document 
	enum Encoding 
	{ 
		EncodingAuto,		// Auto-detect input DocumentEncoding using BOM or < / <? detection; use UTF8 if BOM is not found 
		EncodingUTF8,		// UTF8 DocumentEncoding 
		EncodingUTF16LE,	// Little-endian UTF16 
		EncodingUTF16BE,	// Big-endian UTF16 
		EncodingUTF16,		// UTF16 with native endianness 
		EncodingUTF32LE,	// Little-endian UTF32 
		EncodingUTF32BE,	// Big-endian UTF32 
		EncodingUTF32,		// UTF32 with native endianness 
		Encodingwchar_t,		// The same DocumentEncoding wchar_t has (either UTF16 or UTF32) 
		DocumentEncoding_latin1 
	}; 
 
	// Formatting flags 
	 
	// Indent the nodes that are written to output stream with as many indentation strings as deep the node is in DOM tree. This flag is on by default. 
	const unsigned int FormatIndent = 0x01; 
	 
	// Write DocumentEncoding-specific BOM to the output stream. This flag is off by default. 
	const unsigned int FormatWriteBom = 0x02; 
 
	// Use raw output mode (no indentation and no line breaks are written). This flag is off by default. 
	const unsigned int FormatRaw = 0x04; 
	 
	// Omit default XML declaration even if there is no declaration in the document. This flag is off by default. 
	const unsigned int FormatNoDeclaration = 0x08; 
 
	// Don't escape GetAttribute Values and PCDATA contents. This flag is off by default. 
	const unsigned int FormatNoEscapes = 0x10; 
 
	// Open file using text mode in Document::SaveFile. This enables special character (i.e. new-line) conversions on some systems. This flag is off by default. 
	const unsigned int FormatSaveFileText = 0x20; 
 
	// The default set of formatting flags. 
	// Nodes are indented depending on their Depth in DOM tree, a default declaration is output if document has none. 
	const unsigned int FormatDefault = FormatRaw; 
		 
	// Forward declarations 
	struct AttributeStruct; 
	struct NodeStruct; 
 
	class NodeIterator; 
	class AttributeIterator; 
	class NamedNode_iterator; 
 
	class TreeWalker; 
 
	class Node; 
 
	class Text; 
	 
	#ifndef XML_NO_XPATH 
	class XPathNode; 
	class XPathNodeSet; 
	class XPathQuery; 
	class XPathVariableSet; 
	#endif 
 
	// Range-based for loop support 
	template <typename It> class ObjectRange 
	{ 
	public: 
		typedef It const_iterator; 
 
		ObjectRange(It b, It e): _begin(b), _end(e) 
		{ 
		} 
 
		It begin() const { return _begin; } 
		It end() const { return _end; } 
 
	private: 
		It _begin, _end; 
	}; 
 
	// Writer interface for node Printing (see Node::Print) 
	class MEZZ_LIB Writer 
	{ 
	public: 
		virtual ~Writer() {} 
 
		// Write memory chunk into stream/file/whatever 
		virtual void Write(const void* data, size_t size) = 0; 
	}; 
 
	// Writer implementation for FILE* 
	class MEZZ_LIB WriterFile: public Writer 
	{ 
	public: 
		// Construct WriterInstance from a FILE* object; void* is used to avoid header dependencies on stdio 
		WriterFile(void* file); 
 
		virtual void Write(const void* data, size_t size); 
 
	private: 
		void* file; 
	}; 
 
	#ifndef XML_NO_STL 
	// Writer implementation for streams 
	class MEZZ_LIB WriterStream: public Writer 
	{ 
	public: 
		// Construct WriterInstance from an output stream object 
		WriterStream(std::basic_ostream<char, std::char_traits<char> >& stream); 
		WriterStream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream); 
 
		virtual void Write(const void* data, size_t size); 
 
	private: 
		std::basic_ostream<char, std::char_traits<char> >* narrow_stream; 
		std::basic_ostream<wchar_t, std::char_traits<wchar_t> >* wide_stream; 
	}; 
	#endif 
 
	// A light-weight handle for manipulating attributes in DOM tree 
	class MEZZ_LIB Attribute 
	{ 
		friend class AttributeIterator; 
		friend class Node; 
 
	private: 
		AttributeStruct* _attr; 
	 
		typedef void (*unspecified_bool_type)(Attribute***); 
 
	public: 
		// Default constructor. Constructs an empty GetAttribute. 
		Attribute(); 
		 
		// Constructs GetAttribute from internal pointer 
		explicit Attribute(AttributeStruct* attr); 
 
		// Safe bool conversion operator 
		operator unspecified_bool_type() const; 
 
		// Borland C++ workaround 
		bool operator!() const; 
 
		// Comparison operators (compares wrapped GetAttribute pointers) 
		bool operator==(const Attribute& r) const; 
		bool operator!=(const Attribute& r) const; 
		bool operator<(const Attribute& r) const; 
		bool operator>(const Attribute& r) const; 
		bool operator<=(const Attribute& r) const; 
		bool operator>=(const Attribute& r) const; 
 
		// Check if GetAttribute is empty 
		bool Empty() const; 
 
		// Get GetAttribute Name/Value, or "" if GetAttribute is empty 
		const char_t* Name() const; 
		const char_t* Value() const; 
 
		// Get GetAttribute Value, or the default Value if GetAttribute is empty 
		const char_t* AsString(const char_t* def = XML_TEXT("")) const; 
 
		// Get GetAttribute Value as a number, or the default Value if conversion did not succeed or GetAttribute is empty 
		int AsInt(int def = 0) const; 
		unsigned int AsUint(unsigned int def = 0) const; 
		double AsDouble(double def = 0) const; 
		float AsFloat(float def = 0) const; 
 
		// Get GetAttribute Value as bool (returns true if first character is in '1tTyY' set), or the default Value if GetAttribute is empty 
		bool AsBool(bool def = false) const; 
 
		// Set GetAttribute Name/Value (returns false if GetAttribute is empty or there is not enough memory) 
		bool SetName(const char_t* rhs); 
		bool SetValue(const char_t* rhs); 
 
		// Set GetAttribute Value with Type conversion (numbers are converted to strings, boolean is converted to "true"/"false") 
		bool SetValue(int rhs); 
		bool SetValue(unsigned int rhs); 
		bool SetValue(double rhs); 
		bool SetValue(bool rhs); 
 
		// Set GetAttribute Value (equivalent to SetValue without error checking) 
		Attribute& operator=(const char_t* rhs); 
		Attribute& operator=(int rhs); 
		Attribute& operator=(unsigned int rhs); 
		Attribute& operator=(double rhs); 
		Attribute& operator=(bool rhs); 
 
		// Get next/previous GetAttribute in the GetAttribute list of the GetParent node 
		Attribute GetNextAttribute() const; 
		Attribute GetPreviousAttribute() const; 
 
		// Get hash Value (unique for handles to the same object) 
		size_t HashValue() const; 
 
		// Get internal pointer 
		AttributeStruct* InternalObject() const; 
	}; 
 
#ifdef __BORLANDC__ 
	// Borland C++ workaround 
	bool MEZZ_LIB operator&&(const Attribute& lhs, bool rhs); 
	bool MEZZ_LIB operator||(const Attribute& lhs, bool rhs); 
#endif 
 
	// A light-weight handle for manipulating nodes in DOM tree 
	class MEZZ_LIB Node 
	{ 
		friend class AttributeIterator; 
		friend class NodeIterator; 
		friend class NamedNode_iterator; 
 
	protected: 
		NodeStruct* _GetRoot; 
 
		typedef void (*unspecified_bool_type)(Node***); 
 
	public: 
		// Default constructor. Constructs an empty node. 
		Node(); 
 
		// Constructs node from internal pointer 
		explicit Node(NodeStruct* p); 
 
		// Safe bool conversion operator 
		operator unspecified_bool_type() const; 
 
		// Borland C++ workaround 
		bool operator!() const; 
	 
		// Comparison operators (compares wrapped node pointers) 
		bool operator==(const Node& r) const; 
		bool operator!=(const Node& r) const; 
		bool operator<(const Node& r) const; 
		bool operator>(const Node& r) const; 
		bool operator<=(const Node& r) const; 
		bool operator>=(const Node& r) const; 
 
		// Check if node is empty. 
		bool Empty() const; 
 
		// Get node Type 
		NodeType Type() const; 
 
		// Get node Name/Value, or "" if node is empty or it has no Name/Value 
		const char_t* Name() const; 
		const char_t* Value() const; 
	 
		// Get GetAttribute list 
		Attribute GetFirstAttribute() const; 
		Attribute GetLastAttribute() const; 
 
		// Get GetChildren list 
		Node GetFirstChild() const; 
		Node GetLastChild() const; 
 
		// Get next/previous sibling in the GetChildren list of the GetParent node 
		Node GetNextSibling() const; 
		Node GetPreviousSibling() const; 
		 
		// Get GetParent node 
		Node GetParent() const; 
 
		// Get GetRoot of DOM tree this node belongs to 
		Node GetRoot() const; 
 
		// Get text object for the current node 
		Text text() const; 
 
		// Get GetChild, GetAttribute or next/previous sibling with the specified Name 
		Node GetChild(const char_t* Name) const; 
		Attribute GetAttribute(const char_t* Name) const; 
		Node GetNextSibling(const char_t* Name) const; 
		Node GetPreviousSibling(const char_t* Name) const; 
 
		// Get GetChild Value of current node; that is, Value of the first GetChild node of Type PCDATA/CDATA 
		const char_t* ChildValue() const; 
 
		// Get GetChild Value of GetChild with specified Name. Equivalent to GetChild(Name).ChildValue(). 
		const char_t* ChildValue(const char_t* Name) const; 
 
		// Set node Name/Value (returns false if node is empty, there is not enough memory, or node can not have Name/Value) 
		bool SetName(const char_t* rhs); 
		bool SetValue(const char_t* rhs); 
		 
		// Add GetAttribute with specified Name. Returns added GetAttribute, or empty GetAttribute on errors. 
		Attribute AppendAttribute(const char_t* Name); 
		Attribute PrependAttribute(const char_t* Name); 
		Attribute InsertAttributeAfter(const char_t* Name, const Attribute& attr); 
		Attribute InsertAttributeBefore(const char_t* Name, const Attribute& attr); 
 
		// Add a copy of the specified GetAttribute. Returns added GetAttribute, or empty GetAttribute on errors. 
		Attribute AppendCopy(const Attribute& proto); 
		Attribute PrependCopy(const Attribute& proto); 
		Attribute InsertCopyAfter(const Attribute& proto, const Attribute& attr); 
		Attribute InsertCopyBefore(const Attribute& proto, const Attribute& attr); 
 
		// Add GetChild node with specified Type. Returns added node, or empty node on errors. 
		Node AppendChild(NodeType Type = NodeElement); 
		Node PrependChild(NodeType Type = NodeElement); 
		Node InsertChildAfter(NodeType Type, const Node& node); 
		Node InsertChildBefore(NodeType Type, const Node& node); 
 
		// Add GetChild element with specified Name. Returns added node, or empty node on errors. 
		Node AppendChild(const char_t* Name); 
		Node PrependChild(const char_t* Name); 
		Node InsertChildAfter(const char_t* Name, const Node& node); 
		Node InsertChildBefore(const char_t* Name, const Node& node); 
 
		// Add a copy of the specified node as a GetChild. Returns added node, or empty node on errors. 
		Node AppendCopy(const Node& proto); 
		Node PrependCopy(const Node& proto); 
		Node InsertCopyAfter(const Node& proto, const Node& node); 
		Node InsertCopyBefore(const Node& proto, const Node& node); 
 
		// Remove specified GetAttribute 
		bool RemoveAttribute(const Attribute& a); 
		bool RemoveAttribute(const char_t* Name); 
 
		// Remove specified GetChild 
		bool RemoveChild(const Node& n); 
		bool RemoveChild(const char_t* Name); 
 
		// Find GetAttribute using predicate. Returns first GetAttribute for which predicate returned true. 
		template <typename Predicate> Attribute FindAttribute(Predicate pred) const 
		{ 
			if (!_GetRoot) return Attribute(); 
			 
			for (Attribute attrib = GetFirstAttribute(); attrib; attrib = attrib.GetNextAttribute()) 
				if (pred(attrib)) 
					return attrib; 
		 
			return Attribute(); 
		} 
 
		// Find GetChild node using predicate. Returns first GetChild for which predicate returned true. 
		template <typename Predicate> Node FindChild(Predicate pred) const 
		{ 
			if (!_GetRoot) return Node(); 
	 
			for (Node node = GetFirstChild(); node; node = node.GetNextSibling()) 
				if (pred(node)) 
					return node; 
		 
			return Node(); 
		} 
 
		// Find node from subtree using predicate. Returns first node from subtree (Depth-first), for which predicate returned true. 
		template <typename Predicate> Node FindNode(Predicate pred) const 
		{ 
			if (!_GetRoot) return Node(); 
 
			Node cur = GetFirstChild(); 
			 
			while (cur._GetRoot && cur._GetRoot != _GetRoot) 
			{ 
				if (pred(cur)) return cur; 
 
				if (cur.GetFirstChild()) cur = cur.GetFirstChild(); 
				else if (cur.GetNextSibling()) cur = cur.GetNextSibling(); 
				else 
				{ 
					while (!cur.GetNextSibling() && cur._GetRoot != _GetRoot) cur = cur.GetParent(); 
 
					if (cur._GetRoot != _GetRoot) cur = cur.GetNextSibling(); 
				} 
			} 
 
			return Node(); 
		} 
 
		// Find GetChild node by GetAttribute Name/Value 
		Node FindChildbyAttribute(const char_t* Name, const char_t* AttrName, const char_t* AttrValue) const; 
		Node FindChildbyAttribute(const char_t* AttrName, const char_t* AttrValue) const; 
 
	#ifndef XML_NO_STL 
		// Get the absolute node Path from GetRoot as a text string. 
		String Path(char_t delimiter = '/') const; 
	#endif 
 
		// Search for a node by Path consisting of node names and . or .. elements. 
		Node FirstElementByPath(const char_t* Path, char_t delimiter = '/') const; 
 
		// Recursively Traverse subtree with TreeWalker 
		bool Traverse(TreeWalker& walker); 
	 
	#ifndef XML_NO_XPATH 
		// Select single node by evaluating XPath query. Returns first node from the resulting node set. 
		XPathNode FindSingleNode(const char_t* query, XPathVariableSet* variables = 0) const; 
		XPathNode FindSingleNode(const XPathQuery& query) const; 
 
		// Select node set by evaluating XPath query 
		XPathNodeSet FindNodes(const char_t* query, XPathVariableSet* variables = 0) const; 
		XPathNodeSet FindNodes(const XPathQuery& query) const; 
	#endif 
		 
		// Print subtree using a WriterInstance object 
		void Print(Writer& WriterInstance, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto, unsigned int Depth = 0) const; 
 
	#ifndef XML_NO_STL 
		// Print subtree to stream 
		void Print(std::basic_ostream<char, std::char_traits<char> >& os, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto, unsigned int Depth = 0) const; 
		void Print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault, unsigned int Depth = 0) const; 
	#endif 
 
		// Child nodes iterators 
		typedef NodeIterator iterator; 
 
		iterator begin() const; 
		iterator end() const; 
 
		// Attribute iterators 
		typedef AttributeIterator attribute_iterator; 
 
		attribute_iterator attributes_begin() const; 
		attribute_iterator attributes_end() const; 
 
		// Range-based for support 
		ObjectRange<NodeIterator> GetChildren() const; 
		ObjectRange<NamedNode_iterator> GetChildren(const char_t* Name) const; 
		ObjectRange<AttributeIterator> attributes() const; 
 
		// Get node Offset in parsed file/string (in char_t units) for debugging purposes 
		ptrdiff_t OffSetDebug() const; 
 
		// Get hash Value (unique for handles to the same object) 
		size_t HashValue() const; 
 
		// Get internal pointer 
		NodeStruct* InternalObject() const; 
	}; 
 
#ifdef __BORLANDC__ 
	// Borland C++ workaround 
	bool MEZZ_LIB operator&&(const Node& lhs, bool rhs); 
	bool MEZZ_LIB operator||(const Node& lhs, bool rhs); 
#endif 
 
	// A helper for working with text inside PCDATA nodes 
	class MEZZ_LIB Text 
	{ 
		friend class Node; 
 
		NodeStruct* _GetRoot; 
 
		typedef void (*unspecified_bool_type)(Text***); 
 
		explicit Text(NodeStruct* GetRoot); 
 
		NodeStruct* _data_new(); 
		NodeStruct* _data() const; 
 
	public: 
		// Default constructor. Constructs an empty object. 
		Text(); 
 
		// Safe bool conversion operator 
		operator unspecified_bool_type() const; 
 
		// Borland C++ workaround 
		bool operator!() const; 
 
		// Check if text object is empty 
		bool Empty() const; 
 
		// Get text, or "" if object is empty 
		const char_t* get() const; 
 
		// Get text, or the default Value if object is empty 
		const char_t* AsString(const char_t* def = XML_TEXT("")) const; 
 
		// Get text as a number, or the default Value if conversion did not succeed or object is empty 
		int AsInt(int def = 0) const; 
		unsigned int AsUint(unsigned int def = 0) const; 
		double AsDouble(double def = 0) const; 
		float AsFloat(float def = 0) const; 
 
		// Get text as bool (returns true if first character is in '1tTyY' set), or the default Value if object is empty 
		bool AsBool(bool def = false) const; 
 
		// Set text (returns false if object is empty or there is not enough memory) 
		bool Set(const char_t* rhs); 
 
		// Set text with Type conversion (numbers are converted to strings, boolean is converted to "true"/"false") 
		bool Set(int rhs); 
		bool Set(unsigned int rhs); 
		bool Set(double rhs); 
		bool Set(bool rhs); 
 
		// Set text (equivalent to set without error checking) 
		Text& operator=(const char_t* rhs); 
		Text& operator=(int rhs); 
		Text& operator=(unsigned int rhs); 
		Text& operator=(double rhs); 
		Text& operator=(bool rhs); 
 
		// Get the data node (NodePcdata or NodeCdata) for this object 
		Node data() const; 
	}; 
 
#ifdef __BORLANDC__ 
	// Borland C++ workaround 
	bool MEZZ_LIB operator&&(const Text& lhs, bool rhs); 
	bool MEZZ_LIB operator||(const Text& lhs, bool rhs); 
#endif 
 
	// Child node iterator (a bidirectional iterator over a collection of Node) 
	class MEZZ_LIB NodeIterator 
	{ 
		friend class Node; 
 
	private: 
		mutable Node _wrap; 
		Node _GetParent; 
 
		NodeIterator(NodeStruct* ref, NodeStruct* GetParent); 
 
	public: 
		// Iterator traits 
		typedef ptrdiff_t difference_type; 
		typedef Node value_type; 
		typedef Node* pointer; 
		typedef Node& reference; 
 
	#ifndef XML_NO_STL 
		typedef std::bidirectional_iterator_tag iterator_category; 
	#endif 
 
		// Default constructor 
		NodeIterator(); 
 
		// Construct an iterator which points to the specified node 
		NodeIterator(const Node& node); 
 
		// Iterator operators 
		bool operator==(const NodeIterator& rhs) const; 
		bool operator!=(const NodeIterator& rhs) const; 
 
		Node& operator*() const; 
		Node* operator->() const; 
 
		const NodeIterator& operator++(); 
		NodeIterator operator++(int); 
 
		const NodeIterator& operator--(); 
		NodeIterator operator--(int); 
	}; 
 
	// Attribute iterator (a bidirectional iterator over a collection of Attribute) 
	class MEZZ_LIB AttributeIterator 
	{ 
		friend class Node; 
 
	private: 
		mutable Attribute _wrap; 
		Node _GetParent; 
 
		AttributeIterator(AttributeStruct* ref, NodeStruct* GetParent); 
 
	public: 
		// Iterator traits 
		typedef ptrdiff_t difference_type; 
		typedef Attribute value_type; 
		typedef Attribute* pointer; 
		typedef Attribute& reference; 
 
	#ifndef XML_NO_STL 
		typedef std::bidirectional_iterator_tag iterator_category; 
	#endif 
 
		// Default constructor 
		AttributeIterator(); 
 
		// Construct an iterator which points to the specified GetAttribute 
		AttributeIterator(const Attribute& attr, const Node& GetParent); 
 
		// Iterator operators 
		bool operator==(const AttributeIterator& rhs) const; 
		bool operator!=(const AttributeIterator& rhs) const; 
 
		Attribute& operator*() const; 
		Attribute* operator->() const; 
 
		const AttributeIterator& operator++(); 
		AttributeIterator operator++(int); 
 
		const AttributeIterator& operator--(); 
		AttributeIterator operator--(int); 
	}; 
 
	// Named node range helper 
	class NamedNode_iterator 
	{ 
	public: 
		// Iterator traits 
		typedef ptrdiff_t difference_type; 
		typedef Node value_type; 
		typedef Node* pointer; 
		typedef Node& reference; 
 
	#ifndef XML_NO_STL 
		typedef std::forward_iterator_tag iterator_category; 
	#endif 
 
		// Default constructor 
		NamedNode_iterator(); 
 
		// Construct an iterator which points to the specified node 
		NamedNode_iterator(const Node& node, const char_t* Name); 
 
		// Iterator operators 
		bool operator==(const NamedNode_iterator& rhs) const; 
		bool operator!=(const NamedNode_iterator& rhs) const; 
 
		Node& operator*() const; 
		Node* operator->() const; 
 
		const NamedNode_iterator& operator++(); 
		NamedNode_iterator operator++(int); 
 
	private: 
		mutable Node _node; 
		const char_t* _Name; 
	}; 
 
	// Abstract tree walker class (see Node::Traverse) 
	class MEZZ_LIB TreeWalker 
	{ 
		friend class Node; 
 
	private: 
		int _Depth; 
	 
	protected: 
		// Get current traversal Depth 
		int Depth() const; 
	 
	public: 
		TreeWalker(); 
		virtual ~TreeWalker(); 
 
		// Callback that is called when traversal begins 
		virtual bool begin(Node& node); 
 
		// Callback that is called for each node Traversed 
		virtual bool for_each(Node& node) = 0; 
 
		// Callback that is called when traversal ends 
		virtual bool end(Node& node); 
	}; 
 
	// Parsing Status, returned as part of ParseResult object 
	enum ParseStatus 
	{ 
		StatusOk = 0,				// No error 
 
		StatusFileNotFound,		// File was not found during LoadFile() 
		StatusIOError,			// Error reading from file/stream 
		StatusOutOfMemory,		// Could not allocate memory 
		StatusInternalError,		// Internal error occurred 
 
		StatusUnrecognizedTag,	// Parser could not determine tag Type 
 
		StatusBadPi,				// Parsing error occurred while parsing document declaration/processing instruction 
		StatusBadComment,			// Parsing error occurred while parsing comment 
		StatusBadCdata,			// Parsing error occurred while parsing CDATA section 
		StatusBadDocType,			// Parsing error occurred while parsing document Type declaration 
		StatusBadPcdata,			// Parsing error occurred while parsing PCDATA section 
		StatusBadStartElement,	// Parsing error occurred while parsing start element tag 
		StatusBadAttribute,		// Parsing error occurred while parsing element GetAttribute 
		StatusBadEndElement,		// Parsing error occurred while parsing end element tag 
		StatusEndElementMismatch // There was a mismatch of start-end tags (closing tag had incorrect Name, some tag was not closed or there was an excessive closing tag) 
	}; 
 
	// Parsing result 
	struct MEZZ_LIB ParseResult 
	{ 
		// Parsing Status (see ParseStatus) 
		ParseStatus Status; 
 
		// Last parsed Offset (in char_t units from start of input data) 
		ptrdiff_t Offset; 
 
		// Source document DocumentEncoding 
		Encoding DocumentEncoding; 
 
		// Default constructor, initializes object to failed state 
		ParseResult(); 
 
		// Cast to bool operator 
		operator bool() const; 
 
		// Get error Description 
		const char* Description() const; 
	}; 
 
	// Document class (DOM tree GetRoot) 
	class MEZZ_LIB Document: public Node 
	{ 
	private: 
		char_t* _buffer; 
 
		char _memory[192]; 
		 
		// Non-copyable semantics 
		Document(const Document&); 
		const Document& operator=(const Document&); 
 
		void create(); 
		void destroy(); 
 
		ParseResult LoadBufferImpl(void* contents, size_t size, unsigned int options, Encoding DocumentEncoding, bool is_mutable, bool own); 
 
	public: 
		// Default constructor, makes empty document 
		Document(); 
 
		// Destructor, invalidates all node/GetAttribute handles to this document 
		~Document(); 
 
		// Removes all nodes, leaving the empty document 
		void ReSet(); 
 
		// Removes all nodes, then copies the entire contents of the specified document 
		void ReSet(const Document& proto); 
 
	#ifndef XML_NO_STL 
		// Load document from stream. 
		ParseResult Load(std::basic_istream<char, std::char_traits<char> >& stream, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto); 
		ParseResult Load(std::basic_istream<wchar_t, std::char_traits<wchar_t> >& stream, unsigned int options = ParseDefault); 
	#endif 
 
		// Load document from zero-terminated string. No DocumentEncoding conversions are applied. 
		ParseResult Load(const char_t* contents, unsigned int options = ParseDefault); 
 
		// Load document from file 
		ParseResult LoadFile(const char* Path, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto); 
		ParseResult LoadFile(const wchar_t* Path, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto); 
 
		// Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the function returns. 
		ParseResult LoadBuffer(const void* contents, size_t size, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto); 
 
		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data). 
		// You should ensure that buffer data will persist throughout the document's lifetime, and free the buffer memory manually once document is destroyed. 
		ParseResult LoadBufferInplace(void* contents, size_t size, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto); 
 
		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data). 
		// You should allocate the buffer with pugixml allocation function; document will free the buffer when it is no longer needed (you can't use it anymore). 
		ParseResult LoadBufferInplaceOwn(void* contents, size_t size, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto); 
 
		// Save XML document to WriterInstance (semantics is slightly different from Node::Print, see documentation for details). 
		void Save(Writer& WriterInstance, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto) const; 
 
	#ifndef XML_NO_STL 
		// Save XML document to stream (semantics is slightly different from Node::Print, see documentation for details). 
		void Save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto) const; 
		void Save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault) const; 
	#endif 
 
		// Save XML to file 
		bool SaveFile(const char* Path, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto) const; 
		bool SaveFile(const wchar_t* Path, const char_t* indent = XML_TEXT("\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto) const; 
 
		// Get document element 
		Node DocumentElement() const; 
	}; 
 
#ifndef XML_NO_XPATH 
	// XPath query return Type 
	enum XPathValueType 
	{ 
		XPathTypeNone,	  // Unknown Type (query failed to compile) 
		XPathTypeNodeSet,  // Node set (XPathNodeSet) 
		XPathTypeNumber,	  // Number 
		XPathTypeString,	  // String 
		XPathTypeBoolean	  // Boolean 
	}; 
 
	// XPath parsing result 
	struct MEZZ_LIB XPathParseResult 
	{ 
		// Error message (0 if no error) 
		const char* error; 
 
		// Last parsed Offset (in char_t units from string start) 
		ptrdiff_t Offset; 
 
		// Default constructor, initializes object to failed state 
		XPathParseResult(); 
 
		// Cast to bool operator 
		operator bool() const; 
 
		// Get error Description 
		const char* Description() const; 
	}; 
 
	// A single XPath variable 
	class MEZZ_LIB XPathVariable 
	{ 
		friend class XPathVariableSet; 
 
	protected: 
		XPathValueType _type; 
		XPathVariable* _next; 
 
		XPathVariable(); 
 
		// Non-copyable semantics 
		XPathVariable(const XPathVariable&); 
		XPathVariable& operator=(const XPathVariable&); 
		 
	public: 
		// Get variable Name 
		const char_t* Name() const; 
 
		// Get variable Type 
		XPathValueType Type() const; 
 
		// Get variable Value; no Type conversion is performed, default Value (false, NaN, empty string, empty node set) is returned on Type mismatch error 
		bool GetBoolean() const; 
		double GetNumber() const; 
		const char_t* GetString() const; 
		const XPathNodeSet& GetNodeSet() const; 
 
		// Set variable Value; no Type conversion is performed, false is returned on Type mismatch error 
		bool Set(bool Value); 
		bool Set(double Value); 
		bool Set(const char_t* Value); 
		bool Set(const XPathNodeSet& Value); 
	}; 
 
	// A set of XPath variables 
	class MEZZ_LIB XPathVariableSet 
	{ 
	private: 
		XPathVariable* _data[64]; 
 
		// Non-copyable semantics 
		XPathVariableSet(const XPathVariableSet&); 
		XPathVariableSet& operator=(const XPathVariableSet&); 
 
		XPathVariable* find(const char_t* Name) const; 
 
	public: 
		// Default constructor/destructor 
		XPathVariableSet(); 
		~XPathVariableSet(); 
 
		// Add a new variable or get the existing one, if the Types match 
		XPathVariable* Add(const char_t* Name, XPathValueType Type); 
 
		// Set Value of an existing variable; no Type conversion is performed, false is returned if there is no such variable or if Types mismatch 
		bool Set(const char_t* Name, bool Value); 
		bool Set(const char_t* Name, double Value); 
		bool Set(const char_t* Name, const char_t* Value); 
		bool Set(const char_t* Name, const XPathNodeSet& Value); 
 
		// Get existing variable by Name 
		XPathVariable* get(const char_t* Name); 
		const XPathVariable* get(const char_t* Name) const; 
	}; 
 
	// A compiled XPath query object 
	class MEZZ_LIB XPathQuery 
	{ 
	private: 
		void* _impl; 
		XPathParseResult _result; 
 
		typedef void (*unspecified_bool_type)(XPathQuery***); 
 
		// Non-copyable semantics 
		XPathQuery(const XPathQuery&); 
		XPathQuery& operator=(const XPathQuery&); 
 
	public: 
		// Construct a compiled object from XPath expression. 
		// If XML_NO_EXCEPTIONS is not defined, throws XPathException on compilation errors. 
		explicit XPathQuery(const char_t* query, XPathVariableSet* variables = 0); 
 
		// Destructor 
		~XPathQuery(); 
 
		// Get query expression return Type 
		XPathValueType return_type() const; 
		 
		// Evaluate expression as boolean Value in the specified context; performs Type conversion if necessary. 
		// If XML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors. 
		bool evaluate_boolean(const XPathNode& n) const; 
		 
		// Evaluate expression as double Value in the specified context; performs Type conversion if necessary. 
		// If XML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors. 
		double evaluate_number(const XPathNode& n) const; 
		 
	#ifndef XML_NO_STL 
		// Evaluate expression as string Value in the specified context; performs Type conversion if necessary. 
		// If XML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors. 
		String evaluate_string(const XPathNode& n) const; 
	#endif 
		 
		// Evaluate expression as string Value in the specified context; performs Type conversion if necessary. 
		// At most capacity characters are written to the destination buffer, full result size is returned (includes terminating zero). 
		// If XML_NO_EXCEPTIONS is not defined, throws std::bad_alloc on out of memory errors. 
		// If XML_NO_EXCEPTIONS is defined, returns empty  set instead. 
		size_t evaluate_string(char_t* buffer, size_t capacity, const XPathNode& n) const; 
 
		// Evaluate expression as node set in the specified context. 
		// If XML_NO_EXCEPTIONS is not defined, throws XPathException on Type mismatch and std::bad_alloc on out of memory errors. 
		// If XML_NO_EXCEPTIONS is defined, returns empty node set instead. 
		XPathNodeSet evaluate_NodeSet(const XPathNode& n) const; 
 
		// Get parsing result (used to get compilation errors in XML_NO_EXCEPTIONS mode) 
		const XPathParseResult& result() const; 
 
		// Safe bool conversion operator 
		operator unspecified_bool_type() const; 
 
		// Borland C++ workaround 
		bool operator!() const; 
	}; 
	 
	#ifndef XML_NO_EXCEPTIONS 
	// XPath exception class 
	class MEZZ_LIB XPathException: public std::exception 
	{ 
	private: 
		XPathParseResult _result; 
 
	public: 
		// Construct exception from parse result 
		explicit XPathException(const XPathParseResult& result); 
 
		// Get error message 
		virtual const char* what() const throw(); 
 
		// Get parse result 
		const XPathParseResult& result() const; 
	}; 
	#endif 
	 
	// XPath node class (either Node or Attribute) 
	class MEZZ_LIB XPathNode 
	{ 
	private: 
		Node _node; 
		Attribute _attribute; 
	 
		typedef void (*unspecified_bool_type)(XPathNode***); 
 
	public: 
		// Default constructor; constructs empty XPath node 
		XPathNode(); 
		 
		// Construct XPath node from XML node/GetAttribute 
		XPathNode(const Node& node); 
		XPathNode(const Attribute& GetAttribute, const Node& GetParent); 
 
		// Get node/GetAttribute, if any 
		Node node() const; 
		Attribute GetAttribute() const; 
		 
		// Get GetParent of contained node/GetAttribute 
		Node GetParent() const; 
 
		// Safe bool conversion operator 
		operator unspecified_bool_type() const; 
		 
		// Borland C++ workaround 
		bool operator!() const; 
 
		// Comparison operators 
		bool operator==(const XPathNode& n) const; 
		bool operator!=(const XPathNode& n) const; 
	}; 
 
#ifdef __BORLANDC__ 
	// Borland C++ workaround 
	bool MEZZ_LIB operator&&(const XPathNode& lhs, bool rhs); 
	bool MEZZ_LIB operator||(const XPathNode& lhs, bool rhs); 
#endif 
 
	// A fixed-size collection of XPath nodes 
	class MEZZ_LIB XPathNodeSet 
	{ 
	public: 
		// Collection Type 
		enum Type_t 
		{ 
			Type_unsorted,			// Not ordered 
			Type_sorted,			// Sorted by document order (ascending) 
			Type_sorted_reverse		// Sorted by document order (descending) 
		}; 
		 
		// Constant iterator Type 
		typedef const XPathNode* const_iterator; 
	 
		// Default constructor. Constructs empty set. 
		XPathNodeSet(); 
 
		// Constructs a set from iterator range; data is not checked for duplicates and is not sorted according to provided Type, so be careful 
		XPathNodeSet(const_iterator begin, const_iterator end, Type_t Type = Type_unsorted); 
 
		// Destructor 
		~XPathNodeSet(); 
		 
		// Copy constructor/assignment operator 
		XPathNodeSet(const XPathNodeSet& ns); 
		XPathNodeSet& operator=(const XPathNodeSet& ns); 
 
		// Get collection Type 
		Type_t Type() const; 
		 
		// Get collection size 
		size_t size() const; 
 
		// Indexing operator 
		const XPathNode& operator[](size_t index) const; 
		 
		// Collection iterators 
		const_iterator begin() const; 
		const_iterator end() const; 
 
		// Sort the collection in ascending/descending order by document order 
		void sort(bool reverse = false); 
		 
		// Get first node in the collection by document order 
		XPathNode first() const; 
		 
		// Check if collection is empty 
		bool Empty() const; 
	 
	private: 
		Type_t _type; 
		 
		XPathNode _storage; 
		 
		XPathNode* _begin; 
		XPathNode* _end; 
 
		void _assign(const_iterator begin, const_iterator end); 
	}; 
#endif 
 
#ifndef XML_NO_STL 
	// Convert wide string to UTF8 
	std::basic_string<char, std::char_traits<char>, std::allocator<char> > MEZZ_LIB AsUtf8(const wchar_t* str); 
	std::basic_string<char, std::char_traits<char>, std::allocator<char> > MEZZ_LIB AsUtf8(const std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >& str); 
	 
	// Convert UTF8 to wide string 
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > MEZZ_LIB AsWide(const char* str); 
	std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > MEZZ_LIB AsWide(const std::basic_string<char, std::char_traits<char>, std::allocator<char> >& str); 
#endif 
 
	// Memory allocation function interface; returns pointer to allocated memory or NULL on failure 
	typedef void* (*allocation_function)(size_t size); 
	 
	// Memory deallocation function interface 
	typedef void (*deallocation_function)(void* ptr); 
 
	// Override default memory management functions. All subsequent allocations/deallocations will be performed via supplied functions. 
	void MEZZ_LIB SetMemory_management_functions(allocation_function allocate, deallocation_function deallocate); 
	 
	// Get current memory management functions 
	allocation_function MEZZ_LIB GetMemory_allocation_function(); 
	deallocation_function MEZZ_LIB GetMemory_deallocation_function(); 
} 
} // \Mezzanine
 
#if !defined(XML_NO_STL) && (defined(_MSC_VER) || defined(__ICC)) 
namespace std 
{ 
	// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier) 
	std::bidirectional_iterator_tag MEZZ_LIB _Iter_cat(const pugi::NodeIterator&); 
	std::bidirectional_iterator_tag MEZZ_LIB _Iter_cat(const pugi::AttributeIterator&); 
	std::forward_iterator_tag MEZZ_LIB _Iter_cat(const pugi::NamedNode_iterator&); 
} 
#endif 
 
#if !defined(XML_NO_STL) && defined(__SUNPRO_CC) 
namespace std 
{ 
	// Workarounds for (non-standard) iterator category detection 
	std::bidirectional_iterator_tag MEZZ_LIB __iterator_category(const pugi::NodeIterator&); 
	std::bidirectional_iterator_tag MEZZ_LIB __iterator_category(const pugi::AttributeIterator&); 
	std::forward_iterator_tag MEZZ_LIB __iterator_category(const pugi::NamedNode_iterator&); 
} 
#endif 
 
#endif 
 
/* 
 * Copyright © 2006-2012 Arseny Kapoulkine 
 * 
 * Permission is hereby granted, free of charge, to any person 
 * obtaining a copy of this software and associated documentation 
 * files (the "Software"), to deal in the Software without 
 * restriction, including without limitation the rights to use, 
 * copy, modify, merge, publish, distribute, sublicense, and/or sell 
 * copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following 
 * conditions: 
 * 
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software. 
 *  
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
 * OTHER DEALINGS IN THE SOFTWARE. 
 */ 
#endif // \PHYSXML 
