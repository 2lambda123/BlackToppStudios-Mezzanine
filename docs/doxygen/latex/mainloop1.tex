\begin{Desc}
\item[\hyperlink{todo__todo000010}{Todo}]TODO finish test code, there is a bunch of sloppy test code for the robot in the gameinit \end{Desc}


The MainLoop is heart of most vidoe games and simulations.\hypertarget{mainloop1_overview1}{}\section{Main loop Overview}\label{mainloop1_overview1}
The Main loop runs in \hyperlink{classPhysWorld_a6d65a7412c1711497fbd1173f879243a}{PhysWorld::GameInit()}. By default this Method also starts the render, the physics andthe input systems. It does very little on it's own. It uses the default callback manager (which you can swap out if you want), which is the callback manager point to by \hyperlink{classPhysWorld_a080ea6f1584374b07d3c1f29c7ed64df}{PhysWorld::CallBacks} . Once started it runs the callbacks present in the callback manager until one of them returns false. It has a pretty specific work flow. Starting with input, then physics, then rendering. There is a callback before and after each of these tasks. \par
 \par
 The user input task is never started if there is no Pre or Post callback set. It won't crash or throw any weird error condtions, it was specifically designed this way. This allows the input buffering to be turned off by simply removing the callbacks. This might not sound like much, but if you simply don't need input this can be a little performance bump. It sounds even better when we say it works the same way for physics. If you do not have a pre or post physic callback set physics simply is not run. This allows for easy control over the state of motion in a world. Currently Rendering is performed each iteration of the main loop, regardless of what Callbacks are set. This may be changed at some point in the future, but no immediate plans to change it are in the works. \par
 \par
 One iteration of the main loops is about 1/60 of a second and will render 1 frame and step physics about 1/60 (1/62.5 usually) of a second. Currently there is no way to uncap the framerate, we did not see a need for more (we may change this in the future). Situations with low performance should automatically be handled but increasing the size of physics steps and automatically not rendering frames when not appropriate. There will be fewer calls on callbacks, but the engine will not inhibit gameplay below the the target framerate. \par
 \hypertarget{mainloop1_callbacks1}{}\section{1) Input Callbacks and Buffering}\label{mainloop1_callbacks1}
User input is the first task performed each main loop. This was done because in most games and simulations everything depends on the user input. \hypertarget{mainloop1_input1}{}\subsection{1.A) PreInputCallback}\label{mainloop1_input1}
This can be set using the function in \hyperlink{classPhysWorldCallBackManager}{PhysWorldCallBackManager} that have \char`\"{}PreInput\char`\"{} in their names. This is a great place to to do begining of loop items, like gathering data for computer controlled characters, checking if game goals are met, and other items that needs to be done it iteration of the game loop and don't directly relate to physics or Rendering. \hypertarget{mainloop1_input2}{}\subsection{1.B) Input Buffering}\label{mainloop1_input2}
During this step Input events are gathered fromt the input Subsystem (which could be any of a number of user input libraries), which are ultimately made by the Operating System and processed into \hyperlink{classPhysEventUserInput}{PhysEventUserInput} objects, and placed in the Default event manager ( check the pointer \hyperlink{classPhysWorld_a601b3c6093aaf2a69fcd3311dde9aadc}{PhysWorld::Events} ). \hypertarget{mainloop1_input3}{}\subsection{1.C) PostInputCallback}\label{mainloop1_input3}
This callback is your first chance to access the userinput Events and try to use them. This callback can be managed by using methods in \hyperlink{classPhysWorldCallBackManager}{PhysWorldCallBackManager} that have \char`\"{}PostInput\char`\"{} in their names. The functionality of this Callback slightly overlaps with the Prephysics Callbacks due to the timing of using them both. If both are used, one will be called immediately after the other. \par
 \hypertarget{mainloop1_callbacks2}{}\section{2) Physics callbacks and Event Buffering}\label{mainloop1_callbacks2}
This step runs between user input and rendering to allow for change to be immediately visible to the user. \hypertarget{mainloop1_physics1}{}\subsection{2.A) PrePhysicsCallback}\label{mainloop1_physics1}
The funtionality of this callback overlaps a great deal with the PostInputCallBack, but they both still exist to make organization easier when needed. You probably should have figured out by now how the Callbackmanager functions are named, the ones for this are ituitively named with \char`\"{}PrePhysics\char`\"{} in their name. \hypertarget{mainloop1_physics2}{}\subsection{2.B) Physics calculations and Event Buffering}\label{mainloop1_physics2}
Physics will be run here, but currently is not fully implemented. But eventually physics event will be generated here. Including a system for checking for certain types of collisions. \hypertarget{mainloop1_physics3}{}\subsection{2.C) PostPhysicsCallback}\label{mainloop1_physics3}
This Callback is you first chance to work with the physics events just generated. This is a good place to check if you want items to adjust hitpoints, explode, die or take some other action based on physics. \par
 \hypertarget{mainloop1_callbacks3}{}\section{3) Rendering}\label{mainloop1_callbacks3}
asdf \hypertarget{mainloop1_rendering1}{}\subsection{3.A)}\label{mainloop1_rendering1}
asdf \hypertarget{mainloop1_rendering2}{}\subsection{3.B)}\label{mainloop1_rendering2}
asdf \hypertarget{mainloop1_rendering3}{}\subsection{3.C)}\label{mainloop1_rendering3}
fdgsdfs \par
 \hypertarget{mainloop1_endingmainloop1}{}\section{Ending the Main Loop}\label{mainloop1_endingmainloop1}
ffgdfdfg 