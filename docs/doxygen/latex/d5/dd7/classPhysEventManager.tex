\hypertarget{classPhysEventManager}{
\section{PhysEventManager Class Reference}
\label{d5/dd7/classPhysEventManager}\index{PhysEventManager@{PhysEventManager}}
}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPhysEventManager_a217e7f6006aaf5e08e2872fa4d66e5e2}{PhysEventManager} ()
\item 
\hypertarget{classPhysEventManager_ab14d238e7abe9919be8e2d9eef388b64}{
unsigned int {\bfseries GetRemainingEventCount} ()}
\label{d5/dd7/classPhysEventManager_ab14d238e7abe9919be8e2d9eef388b64}

\item 
\hypertarget{classPhysEventManager_a6de94bc6c23dcbd7e15785cadee2e80b}{
\hyperlink{classPhysEvent}{PhysEvent} $\ast$ {\bfseries GetNextEvent} ()}
\label{d5/dd7/classPhysEventManager_a6de94bc6c23dcbd7e15785cadee2e80b}

\item 
\hypertarget{classPhysEventManager_a1f2d0506ce816176913e5bdfaa9fd724}{
\hyperlink{classPhysEventRenderTime}{PhysEventRenderTime} $\ast$ {\bfseries GetNextRenderTimeEvent} ()}
\label{d5/dd7/classPhysEventManager_a1f2d0506ce816176913e5bdfaa9fd724}

\item 
\hypertarget{classPhysEventManager_a4874a9b1138d2351bf28e527a66c02b8}{
\hyperlink{classPhysEventUserInput}{PhysEventUserInput} $\ast$ {\bfseries GetNextUserInputEvent} ()}
\label{d5/dd7/classPhysEventManager_a4874a9b1138d2351bf28e527a66c02b8}

\item 
\hypertarget{classPhysEventManager_a7c9bb46b17f6d9245817a402dc6a2f6f}{
void {\bfseries AddEvent} (\hyperlink{classPhysEvent}{PhysEvent} $\ast$EventToAdd)}
\label{d5/dd7/classPhysEventManager_a7c9bb46b17f6d9245817a402dc6a2f6f}

\item 
\hypertarget{classPhysEventManager_a77b22f706d22914602982cbcaf05bba9}{
bool {\bfseries DoQuitMessagesExist} ()}
\label{d5/dd7/classPhysEventManager_a77b22f706d22914602982cbcaf05bba9}

\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classPhysEventManager_a9783a16342acd71c9a11ade41a2e226b}{
static bool {\bfseries IgnoreQuitEvents} ()}
\label{d5/dd7/classPhysEventManager_a9783a16342acd71c9a11ade41a2e226b}

\item 
\hypertarget{classPhysEventManager_acc902586015a3cd903d14cb20cd51386}{
static void {\bfseries SetIgnoreQuitEvents} (bool Ignore)}
\label{d5/dd7/classPhysEventManager_acc902586015a3cd903d14cb20cd51386}

\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 55 of file physeventmanager.h.

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classPhysEventManager_a217e7f6006aaf5e08e2872fa4d66e5e2}{
\index{PhysEventManager@{PhysEventManager}!PhysEventManager@{PhysEventManager}}
\index{PhysEventManager@{PhysEventManager}!PhysEventManager@{PhysEventManager}}
\subsubsection[{PhysEventManager}]{\setlength{\rightskip}{0pt plus 5cm}PhysEventManager::PhysEventManager ()}}
\label{d5/dd7/classPhysEventManager_a217e7f6006aaf5e08e2872fa4d66e5e2}
\begin{Desc}
\item[\hyperlink{todo__todo000003}{Todo}]TODO: Make the \hyperlink{classPhysEventManager}{PhysEventManager} completely thread safe. IF this is completely thread safe, we can spawn numerous individual thread each accessing this and and the performance gain would almost scale directly with cpu core count increases. Look at boost scoped\_\-lock \end{Desc}


Definition at line 58 of file physeventmanager.cpp.

The documentation for this class was generated from the following files:\begin{DoxyCompactItemize}
\item 
physeventmanager.h\item 
physeventmanager.cpp\end{DoxyCompactItemize}
