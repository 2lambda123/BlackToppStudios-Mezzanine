\hypertarget{Serialization_SerializationMain}{}\subsection{SerializationMain}\label{Serialization_SerializationMain}
Serialization is the process of converting a class instance into a serial sequence of bits. DeSerialization is taking those bits and reconstructing th e original object without losing anything of value (in practice the only things not saved are cached values or values calulated as they are needed). These bits could be just about anything, because of its ubiquity we chose to serialize to xml (or something so similar as to be indistinguishable from standard xml). This allows a wide variety of tools to be used when working with and verifying these serialized classes. Additionally, transmitting and storing xml is easy to do, and can be done with a variety of other factors in mind. The xml text can be sent down any stream, put in any file, compressed, queried. You should see \hyperlink{XMLManual}{phys::xml Manual} for information about the xml system itself. \par
 \par
 Topics:
\begin{DoxyItemize}
\item \hyperlink{Serialization_serializationxml}{Serialization and XML}
\item \hyperlink{Serialization_serializationintegration}{Integrate Serialization into Your Code}
\begin{DoxyItemize}
\item \hyperlink{Serialization_serializationmaking}{Make a Serializable or a DeSerializable}
\item \hyperlink{Serialization_serializationserializers}{Working with Serializers and Deserializers}
\item \hyperlink{Serialization_serializationlegacy}{Integrating with External XML Providers}
\end{DoxyItemize}
\item \hyperlink{Serialization_serializationoperators}{Serialization Operators}
\item \hyperlink{Serialization_serializationmisc}{Other little Things} 
\end{DoxyItemize}\hypertarget{Serialization_serializationxml}{}\subsubsection{Serialization and XML}\label{Serialization_serializationxml}
The process of serializing doesn't just convert from class instance to text. Since our end goal is to convert live objects to XML it only make sense to closely integrate with the \hyperlink{namespacephys_1_1xml}{phys::xml} portion of the engine. If you plan on writing serialization and deserialization code you should read the following parts of the \hyperlink{XMLManual}{phys::xml Manual} at a minimum:
\begin{DoxyItemize}
\item \hyperlink{XMLManual_XMLDOM}{Document Object Model}
\item \hyperlink{XMLManual_XMLAccessingBasics}{Basic traversal functions}
\item \hyperlink{XMLManual_XMLModifyingNodeData}{Setting Node Data}
\item \hyperlink{XMLManual_XMLModifyingAttributeData}{Setting Attribute Data}
\end{DoxyItemize}

The central object that will carry information during this process is the \hyperlink{classphys_1_1xml_1_1Node}{phys::xml::Node}. The \hyperlink{classphys_1_1xml_1_1Node}{phys::xml::Node} is an excellent tool for converting and storing data in a single unified heirarchy. \par
 \par
 C++ and most object oriented languages heavily imply that class inheritance should be structured as hierarchies. Additionally Hierarchies are implied when complex class have other complex class or datatypes as members. Both of these structures map cleanly onto the kind of hierarchies that a well formed xml documents provide. \par
 \par
 There are some relationships in video game objects that cross normal hierarchical boundaries. For example, A constraint references two actors, and defines a relationship between them. When serialized the constraint simply stores the name of the actor and looks it up in the actor manager during deserialization. This implies that the actors exist already, or that there is some mechanism to create the constraint and fill in the actor later. Several mechanisms were discussed to accomplish this, some include: two passes of processing were constraintw would be done in the second pass, a work queue that would store objects that couldn't be deserialized yet, a prefetcher that would dig through the xml to find the required object. \par
 \par
 Those methods all likely could have been made to work. However, they are not optimal for a variety of reasons. All of them have a set of preconditions and require more computing resources and could potentially delay loading or transmission times. Some of them heavily imply that all of the items to deserialize must be stored in the same xml source. Some demand access to xml that may not have been transmitted yet. \par
 \par
 The simplest, most performant way to work around the issues that cross-\/hierarchical relationships presented was to ignore them. More specifically, throw an exception if an object reference during deserialization is not present. Then we ask that programmers who write could that must store, transmit and reconstruct class instances be aware of the following preconditions So can produce their own solutions:
\begin{DoxyItemize}
\item Actors must come before constraints.
\item Currently WorldNodes try to find the objects that are attached to them, and the attached tries to find the world node. (if one does not exist, this silently fails)
\item WorldNodes should come before Actors, \hyperlink{classphys_1_1Light}{Light} and particle effects. (this is still work in progress).
\end{DoxyItemize}

The easyiest way to meet these conditions and not consume an inordinate amount of computing resources, is to pay attention to the order that items are serialized in. If a program serializes the worldnodes, then the actors, then everything else it will have relatively little trouble making it work. \hypertarget{Serialization_serializationintegration}{}\subsubsection{Integrate Serialization into Your Code}\label{Serialization_serializationintegration}
There several ways to interact with the current serialization system. One might have to create a class that can be serialized or deserialized. There may be situations where another system is emitting xml and it must be intergrated into an existing game. It may be desired to create a 'factory' that produces objects from and xml source or create a sink to put objects into so they can be serialized. Here we will discuss some of the ways that the serialization system can be extended and what kind of assumptions it makes, so that anyone can write software that interacts with it cleanly. \hypertarget{Serialization_serializationmaking}{}\paragraph{Make a Serializable or a DeSerializable}\label{Serialization_serializationmaking}
Creating a class that be serialized is easy. There is just one function that it must implement. If a class implements this, it is said to be Serializable: 
\begin{DoxyCode}
 void SerializableClass::ProtoSerialize(xml::Node&) const;
\end{DoxyCode}
 The member ProtoSerialize(xml::Node\&) is expected to accept a \hyperlink{classphys_1_1xml_1_1Node}{phys::xml::Node} and attach exactly one Node to it. This new Serialized node should contain all the data stored in the current state of the object being serialized. Storing data outside of this one node could cause undefined behavior. \par
 \par
 The exact layout of the data in the Serialized Node is not pre-\/determined. The creator of that function need only take into account any difficulties DeSerializing when creating this. Because of this concern it is advisable name the Serialized node something unique and appropriate and to include a 'Version' attribute on it. If the class changes, the DeSerialization function will only need to check the 'Version' attribute to know if and how it can handle it. \par
 \par
 Integrating with the DeSerialization code is pretty easy too. There are two functions you are expected to implement to create a DeSerializable: 
\begin{DoxyCode}
 void DeSerializableClass::ProtoDeSerialize(const xml::Node&);
 static String DeSerializableClass::SerializableName();
\end{DoxyCode}
 The SerializableName() is expected to simply return the name of the xml elements this class will DeSerialize. For example A \hyperlink{classphys_1_1Vector3}{phys::Vector3} returns \char`\"{}Vector3\char`\"{}, and a \hyperlink{classphys_1_1ActorRigid}{phys::ActorRigid} return \char`\"{}ActorRigid\char`\"{}. If a class is both DeSerializable and serializable it makes sense to call this function when assigning the name to the Serialized Node it creates. \par
 \par
 ProtoDeSerialize(const xml::Node\&), accepts a \hyperlink{classphys_1_1xml_1_1Node}{phys::xml::Node}. The Node passed to it would correspond to the Serialized Node created by the ProtoSerialize(xml::Node\&) function listed above. If xml is created by something then this is calling code is expecting this function to be the correct deserialization function. It is advisable but not required to verify the name of the xml node matches what is expected and that the 'Version' is something this code can handle. It is also advisable that every piece of data pulled out is verified the best it can be. If exceptions are thrown for every discrepency, then programmers using this will create xml and code that produce no discrepencies. \par
 \par
 The following template make use of only the 3 functions described above to Serialize or DeSerialize class instances: 
\begin{DoxyCode}
 template <class T> std::ostream& Serialize(std::ostream& Stream, const T& Conver
      ted, const String& Indent = String("") );
 template <class T> std::istream& DeSerialize(std::istream& Stream, T& Converted)
      ;
\end{DoxyCode}
 The functions make calls on the \hyperlink{namespacephys_1_1xml}{phys::xml} system and expect a fairly basic set of conditions to be met before they are used. Serialize accepts an output stream and the class instance to be Serialized. It will create an \hyperlink{classphys_1_1xml_1_1Document}{xml::Document} and populate it data from the class provided and then emit that into the stream. DeSerialize accepts an inputstream and the object to be populated. It expects the next xml element in the stream to be a serialized version of the passed object and will then overwrite as many of the values of the passed object as possible with the serialized values. For small items DeSerialize is fine, where possible it is better to have the \hyperlink{classphys_1_1xml_1_1Document}{xml::Document} open the file or stream itself as to prevent the second pass through to find exactly one xml element. \par
 \par
 \hypertarget{Serialization_serializationserializers}{}\paragraph{Working with Serializers and Deserializers}\label{Serialization_serializationserializers}
In some cases, there are some pieces of information that cannot be supplied or entered by the class itself. This data must be provided by another class or upon creation of the class. This other class can implement the \hyperlink{classphys_1_1Serializer}{Serializer}, \hyperlink{classphys_1_1DeSerializer}{DeSerializer}, or both interfaces to make working with large amounts of serialization easier. \par
 \par
 For example actors can only accept a mesh upon construction. So overwriting an existing actor is impossible to do completely. It expected to be partially implemented, to the extent possible, in the class members. But if you have the need to create Actors on the fly from data stored in files it makes sense to have a dedicated class or interface than can create these. Here is what goes into a \hyperlink{classphys_1_1Serializer}{Serializer}: 
\begin{DoxyCode}
 template <class Serializable> class Serializer
 {
     virtual void Serializer::ProtoSerializeAll(xml::Node& CurrentRoot) const = 0
      ;
     virtual std::ostream& Serializer::SerializeAll(std::ostream& Stream) const;
     virtual void Serializer::ProtoSerialize(const Serializable& Target, xml::Nod
      e& CurrentRoot) = 0;
     virtual std::ostream& Serializer::Serialize(std::ostream& Stream, const Seri
      alizable& Target)
 };
\end{DoxyCode}
 \hyperlink{classphys_1_1Serializer_a337a685f966e6d06bfb382905b29db5a}{Serializer::ProtoSerialize()} when implement should take the required steps to attach a Serialized Node to the Passed \hyperlink{classphys_1_1xml_1_1Node}{xml::Node} that represent the Serialization target. It is expected to get the extra information that the target cannot provide from somewhere else. Ideally the the \hyperlink{classphys_1_1Serializer}{Serializer} can be, or be associated with, a manager or container of some kind. There is not default implementation of this. \par
 \par
 \hyperlink{classphys_1_1Serializer_a013ef8c6c9be4d9d3e85488e039b9772}{Serializer::Serialize()} Goes one step further than \hyperlink{classphys_1_1Serializer_a337a685f966e6d06bfb382905b29db5a}{Serializer::ProtoSerialize()} and also sends it down a stream. The default implements use \hyperlink{classphys_1_1Serializer_a337a685f966e6d06bfb382905b29db5a}{Serializer::ProtoSerialize()}. \par
 \par
 \hyperlink{classphys_1_1Serializer_abb5e6f46de9edbf72a7b3e88e955bd69}{Serializer::ProtoSerializeAll()} performs a similar role to \hyperlink{classphys_1_1Serializer_a337a685f966e6d06bfb382905b29db5a}{Serializer::ProtoSerialize()}, but again, it goes one step further. Rather than accept a single Target to serialize it is expected that the \hyperlink{classphys_1_1Serializer}{Serializer} go to the source of the Targets and serialize all of them that are available. All of the target should be contained in one Node attached to the Node the function accepts. This is not implemented by default, the logic is too specific to the items to be serialized. \par
 \par
 \hyperlink{classphys_1_1Serializer_a45fe456179603bb2f19a978d135439a1}{Serializer::SerializeAll()} uses \hyperlink{classphys_1_1Serializer_abb5e6f46de9edbf72a7b3e88e955bd69}{Serializer::ProtoSerializeAll()} to send all of the available Targets in Serialized down a stream. \par
 \par
 The logic behind a \hyperlink{classphys_1_1DeSerializer}{DeSerializer} is similar to a \hyperlink{classphys_1_1Serializer}{Serializer}. The same types of methods, even similar implementations if the function is implemented. Like the ProtoDeSerialize() individual DeSerializables implement, the functions on a \hyperlink{classphys_1_1DeSerializer}{DeSerializer} will be passed the nodes that would correspond to the those created by their counterparts on the \hyperlink{classphys_1_1Serializer}{Serializer}. Here is the contents of a Deserializer: 
\begin{DoxyCode}
 template <class DeSerializable> class DeSerializer
 {
     virtual void DeSerializer::ProtoDeSerializeAll(const xml::Node& OneNode) = 0
      ;
     virtual std::istream& DeSerializer::DeSerializeAll(std::istream& Stream)
     virtual DeSerializable* DeSerializer::ProtoDeSerialize(const xml::Node& OneN
      ode) = 0;
     virtual std::istream& DeSerializer::DeSerialize(std::istream& Stream)
 };
\end{DoxyCode}
 There is no technical reason why a class cannot be both a serializer and a deserializer, or even multiple kinds of Serializers or DeSerializers. To keep things simple the Managers provided by the physgame engine will store a pointer to the appropriate \hyperlink{classphys_1_1Serializer}{Serializer} when one is required. \hypertarget{Serialization_serializationlegacy}{}\paragraph{Integrating with External XML Providers}\label{Serialization_serializationlegacy}
Sometimes yu will be forced to work with a system that produces xml that is not structured in a similar way to this system. Sometimes it may be too costly or not possible to modify the code to integrate it. For these the following function exists: 
\begin{DoxyCode}
 template <class T> void SloppyProtoSerialize(const T& Converted, xml::Node& Curr
      entRoot)
\end{DoxyCode}
 This function will make a call on the the stream insertion operator of the class passed in. If one doesn't exist it is easy to add one in your code without chaning the original source. If one does exist than you should probably copy/paste the whole function and re-\/implement it calling the functions that emit the XML string or stream. If you want to implement a stream insertion operator, the function prototype should be similar to the stream insertion operator in the \hyperlink{Serialization_serializationoperators}{Serialization Operators} section. \hypertarget{Serialization_serializationoperators}{}\subsubsection{Serialization Operators}\label{Serialization_serializationoperators}
The stream insertion ($<$$<$) and stream extraction ($>$$>$) operators can be used for serializing and deserializing most items in the physgame engine.

Unfortunately due to conflict with the stream insertion operators provided with the iostreams library these couldn't be made into a template. That doesn't mean that they are difficult to implemt. Here is a typical implemenation of stream insertion operators for XML serialization: 
\begin{DoxyCode}
 #ifdef PHYSXML

 std::ostream& operator << (std::ostream& stream, const phys::ActorRigid& ActorTo
      Serialize)
 {
     Serialize(stream, ActorToSerialize);
     return stream;
 }

 std::istream& operator >> (std::istream& stream, phys::ActorRigid& x)
     { return DeSerialize(stream, x); }

 void operator >> (const phys::xml::Node& OneNode, phys::ActorRigid& x)
     { x.ProtoDeSerialize(OneNode); }

 #endif  // \physxml
\end{DoxyCode}
 You will want to implement these functions with the appropriate type. The type \hyperlink{classphys_1_1ActorRigid}{phys::ActorRigid} is used purely as example Though this is actual working code and was in the engine at one point. The \char`\"{}\#ifdef PHYSXML\char`\"{} Tells the compiler to skip this chunk of code if PHYSXML is not enable. Since this is a configuration option of the engine you may wish for you code to be aware of it. More sophisticate handling of this is possible, for example The \hyperlink{classphys_1_1Vector3}{phys::Vector3} emits a string in the form of \mbox{[}X,Y,Z\mbox{]}, if physxml is not enabled. \par
 \par
 The function operator$<$$<$ simply calls Serialize and returns the stream, so it has all the pre and cost conditions of the Serialize function listed in the \hyperlink{Serialization_serializationmaking}{Make a Serializable or a DeSerializable} section. \par
 \par
 The stream extraction operators are a little bit more interesting. The operator$>$$>$(istream,YourType), by virtue of calling Deserialize will wind up taking two passes over the XML. One looking for the ending tag that matches the first (it gets all the children of that tag too) and one performing the actual parsing. The operator$>$$>$(istream,YourType) will work only with completely parsed objects in memory. With the combination of these two all the heavy lifting of parsing is done up front, and the rest of the deserialization is just a bunch of pointer and string manipulation. Another possibility with your stream extraction operator, if you new that it had exactly one parent xml node ,you create without that first pass for improved performance. \hypertarget{Serialization_serializationmisc}{}\subsubsection{Other little Things}\label{Serialization_serializationmisc}
To simplify and standardize errors thrown, the following functions exist: 
\begin{DoxyCode}
 void SerializeError(const String& FailedTo, const String& ClassName, bool SOrD =
       true);
 void DeSerializeError(const String& FailedTo, const String& ClassName, bool SOrD
       = false);
\end{DoxyCode}
 Both of these functions throw a \hyperlink{classphys_1_1Exception}{phys::Exception} with the descriptive text of \char`\"{}Could not \{FailedTo\} during \{ClassName\} \mbox{[}De\mbox{]}Serialization.\char`\"{} If SOrD (Serialize Or Deserialize) is true the \char`\"{}De\char`\"{} is not printed. 