<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MezzanineEngine: xmldoc.h Source File</title>
<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<!-- <link href="doxygen.css" rel="stylesheet" type="text/css"/> -->
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"></a>MezzanineEngine&#160;<span id="projectnumber">Dec 2, 2011</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>xmldoc.h</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//© Copyright 2010 - 2011 BlackTopp Studios Inc.</span>
<a name="l00002"></a>00002 <span class="comment">/* This file is part of The Mezzanine Engine.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">    The Mezzanine Engine is free software: you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment">    it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment">    the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00007"></a>00007 <span class="comment">    (at your option) any later version.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">    The Mezzanine Engine is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00012"></a>00012 <span class="comment">    GNU General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">    You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment">    along with The Mezzanine Engine.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00016"></a>00016 <span class="comment">*/</span>
<a name="l00017"></a>00017 <span class="comment">/* The original authors have included a copy of the license specified above in the</span>
<a name="l00018"></a>00018 <span class="comment">   &#39;Docs&#39; folder. See &#39;gpl.txt&#39;</span>
<a name="l00019"></a>00019 <span class="comment">*/</span>
<a name="l00020"></a>00020 <span class="comment">/* We welcome the use of the Mezzanine engine to anyone, including companies who wish to</span>
<a name="l00021"></a>00021 <span class="comment">   Build professional software and charge for their product.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">   However there are some practical restrictions, so if your project involves</span>
<a name="l00024"></a>00024 <span class="comment">   any of the following you should contact us and we will try to work something</span>
<a name="l00025"></a>00025 <span class="comment">   out:</span>
<a name="l00026"></a>00026 <span class="comment">    - DRM or Copy Protection of any kind(except Copyrights)</span>
<a name="l00027"></a>00027 <span class="comment">    - Software Patents You Do Not Wish to Freely License</span>
<a name="l00028"></a>00028 <span class="comment">    - Any Kind of Linking to Non-GPL licensed Works</span>
<a name="l00029"></a>00029 <span class="comment">    - Are Currently In Violation of Another Copyright Holder&#39;s GPL License</span>
<a name="l00030"></a>00030 <span class="comment">    - If You want to change our code and not add a few hundred MB of stuff to</span>
<a name="l00031"></a>00031 <span class="comment">        your distribution</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00033"></a>00033 <span class="comment">   These and other limitations could cause serious legal problems if you ignore</span>
<a name="l00034"></a>00034 <span class="comment">   them, so it is best to simply contact us or the Free Software Foundation, if</span>
<a name="l00035"></a>00035 <span class="comment">   you have any questions.</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">   Joseph Toppi - toppij@gmail.com</span>
<a name="l00038"></a>00038 <span class="comment">   John Blackwood - makoenergy02@gmail.com</span>
<a name="l00039"></a>00039 <span class="comment">*/</span>
<a name="l00040"></a>00040 <span class="comment">/*</span>
<a name="l00041"></a>00041 <span class="comment"> *</span>
<a name="l00042"></a>00042 <span class="comment"> * Software, Files, Libraries and all other items referenced in this clause refers only</span>
<a name="l00043"></a>00043 <span class="comment"> * to the contents of this file and associated documentation.</span>
<a name="l00044"></a>00044 <span class="comment"> *</span>
<a name="l00045"></a>00045 <span class="comment"> * Pugixml parser - version 1.0</span>
<a name="l00046"></a>00046 <span class="comment"> * --------------------------------------------------------</span>
<a name="l00047"></a>00047 <span class="comment"> * Copyright © 2006-2010, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)</span>
<a name="l00048"></a>00048 <span class="comment"> * Report bugs and download new versions at http://pugixml.org/</span>
<a name="l00049"></a>00049 <span class="comment"> *</span>
<a name="l00050"></a>00050 <span class="comment"> * This library is distributed under the MIT License. See notice at the end</span>
<a name="l00051"></a>00051 <span class="comment"> * of this file.</span>
<a name="l00052"></a>00052 <span class="comment"> *</span>
<a name="l00053"></a>00053 <span class="comment"> * This work is based on the pugxml parser, which is:</span>
<a name="l00054"></a>00054 <span class="comment"> * Copyright © 2003, by Kristen Wegner (kristen@tima.net)</span>
<a name="l00055"></a>00055 <span class="comment"> */</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="comment">// To provide compilation option via cmake</span>
<a name="l00058"></a>00058 <span class="preprocessor">#ifdef MEZZXML</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;datatypes.h&quot;</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="preprocessor">#ifndef _xmldoc_h</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#define _xmldoc_h</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="keyword">namespace </span>Mezzanine
<a name="l00065"></a>00065 {<span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">    ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l00067"></a>00067 <span class="comment">    /// @namespace Mezzanine::xml</span>
<a name="l00068"></a>00068 <span class="comment">    /// @brief This is where bulk of the XML subsystem resides, (See @ref XMLManual &quot;Mezzanine::xml Manual&quot; for details) there are numerous class that are all tighlty integrated so one file seemed appropriate.</span>
<a name="l00069"></a>00069 <span class="comment">    /// @details Our XML Parser IS a copy of PugiXML. It is simply the fastest, most stable, most reliable, feature rich, and robust XML parser we were</span>
<a name="l00070"></a>00070 <span class="comment">    /// aware of. We are using it with permission per it&#39;s included license. See the licenses folder, in either the docs folder, or the data/common folder.</span>
<a name="l00071"></a>00071 <span class="comment">    /// \n \n</span>
<a name="l00072"></a>00072 <span class="comment">    /// This XML parser uses an &#39;in place&#39; design. It attempts to load all of an XML document to one contiguous location in memory, then create a tree</span>
<a name="l00073"></a>00073 <span class="comment">    /// of meta data that references the already loaded document text. In testing this has been shown to be extremely fast. See pugixml.org for more</span>
<a name="l00074"></a>00074 <span class="comment">    /// details on the performace.</span>
<a name="l00075"></a>00075 <span class="comment">    /// \n \n</span>
<a name="l00076"></a>00076 <span class="comment">    /// The one drawback PugiXML had was that it has a completely different naming</span>
<a name="l00077"></a>00077 <span class="comment">    /// convention from our code. So we created a script (docs/tools/PugiConversion)</span>
<a name="l00078"></a>00078 <span class="comment">    /// to convert future versions to our naming convention.</span>
<a name="l00079"></a>00079 <span class="comment">    /// \n \n</span>
<a name="l00080"></a>00080 <span class="comment">    /// For the complete XML Documentation, please see the @ref XMLManual &quot;Mezzanine::xml Manual&quot;</span>
<a name="l00081"></a>00081 <span class="comment">    /// @page XMLManual Mezzanine::xml Manual</span>
<a name="l00082"></a>00082 <span class="comment">    /// @section XMLTOC Table Of Contents</span>
<a name="l00083"></a>00083 <span class="comment">    ///     - @ref XMLOverview</span>
<a name="l00084"></a>00084 <span class="comment">    ///         - @ref XMLIntroduction</span>
<a name="l00085"></a>00085 <span class="comment">    ///         - @ref XMLFeedBack</span>
<a name="l00086"></a>00086 <span class="comment">    ///         - @ref XMLAcknowledgments</span>
<a name="l00087"></a>00087 <span class="comment">    ///         - @ref XMLLicense</span>
<a name="l00088"></a>00088 <span class="comment">    ///     - @ref XMLDOM</span>
<a name="l00089"></a>00089 <span class="comment">    ///         - @ref XMLTreeStructure</span>
<a name="l00090"></a>00090 <span class="comment">    ///         - @ref XMLInterface</span>
<a name="l00091"></a>00091 <span class="comment">    ///         - @ref XMLUnicode</span>
<a name="l00092"></a>00092 <span class="comment">    ///         - @ref XMLThreadSafety</span>
<a name="l00093"></a>00093 <span class="comment">    ///         - @ref XMLExceptionSafety</span>
<a name="l00094"></a>00094 <span class="comment">    ///         - @ref XMLMemory</span>
<a name="l00095"></a>00095 <span class="comment">    ///             - @ref XMLCustomAlloc</span>
<a name="l00096"></a>00096 <span class="comment">    ///             - @ref XMLMemoryInternals</span>
<a name="l00097"></a>00097 <span class="comment">    ///     - @ref XMLLoading</span>
<a name="l00098"></a>00098 <span class="comment">    ///         - @ref XMLLoadingFiles</span>
<a name="l00099"></a>00099 <span class="comment">    ///         - @ref XMLLoadingFromMemory</span>
<a name="l00100"></a>00100 <span class="comment">    ///         - @ref XMLLoadingStreams</span>
<a name="l00101"></a>00101 <span class="comment">    ///         - @ref XMLLoadingErrors</span>
<a name="l00102"></a>00102 <span class="comment">    ///         - @ref XMLLoadingParsingOptions</span>
<a name="l00103"></a>00103 <span class="comment">    ///         - @ref XMLLoadingEncodings</span>
<a name="l00104"></a>00104 <span class="comment">    ///         - @ref XMLLoadingStandards</span>
<a name="l00105"></a>00105 <span class="comment">    ///     - @ref XMLAccessing</span>
<a name="l00106"></a>00106 <span class="comment">    ///         - @ref XMLAccessingBasics</span>
<a name="l00107"></a>00107 <span class="comment">    ///         - @ref XMLAccessingNodeData</span>
<a name="l00108"></a>00108 <span class="comment">    ///         - @ref XMLAccessingAttributeData</span>
<a name="l00109"></a>00109 <span class="comment">    ///         - @ref XMLAccessingContentBased</span>
<a name="l00110"></a>00110 <span class="comment">    ///         - @ref XMLAccessingIterators</span>
<a name="l00111"></a>00111 <span class="comment">    ///         - @ref XMLAccessingWalker</span>
<a name="l00112"></a>00112 <span class="comment">    ///         - @ref XMLAccessingPredicates</span>
<a name="l00113"></a>00113 <span class="comment">    ///         - @ref XMLAccessingMisc</span>
<a name="l00114"></a>00114 <span class="comment">    ///     - @ref XMLModifying</span>
<a name="l00115"></a>00115 <span class="comment">    ///         - @ref XMLModifyingNodeData</span>
<a name="l00116"></a>00116 <span class="comment">    ///         - @ref XMLModifyingAttributeData</span>
<a name="l00117"></a>00117 <span class="comment">    ///         - @ref XMLModifyingAdding</span>
<a name="l00118"></a>00118 <span class="comment">    ///         - @ref XMLModifyingRemoving</span>
<a name="l00119"></a>00119 <span class="comment">    ///         - @ref XMLModifyingCloning</span>
<a name="l00120"></a>00120 <span class="comment">    ///     - @ref XMLSaving</span>
<a name="l00121"></a>00121 <span class="comment">    ///         - @ref XMLSavingFile</span>
<a name="l00122"></a>00122 <span class="comment">    ///         - @ref XMLSavingStreams</span>
<a name="l00123"></a>00123 <span class="comment">    ///         - @ref XMLSavingWriter</span>
<a name="l00124"></a>00124 <span class="comment">    ///         - @ref XMLSavingSubtree</span>
<a name="l00125"></a>00125 <span class="comment">    ///         - @ref XMLSavingOptions</span>
<a name="l00126"></a>00126 <span class="comment">    ///         - @ref XMLSavingEncodings</span>
<a name="l00127"></a>00127 <span class="comment">    ///     - @ref XMLXPath</span>
<a name="l00128"></a>00128 <span class="comment">    ///         - @ref XMLXPathTypes</span>
<a name="l00129"></a>00129 <span class="comment">    ///         - @ref XMLXPathSelecting</span>
<a name="l00130"></a>00130 <span class="comment">    ///         - @ref XMLXPathQuery</span>
<a name="l00131"></a>00131 <span class="comment">    ///         - @ref XMLXPathVariables</span>
<a name="l00132"></a>00132 <span class="comment">    ///         - @ref XMLXPathError</span>
<a name="l00133"></a>00133 <span class="comment">    ///         - @ref XMLXPathStandards</span>
<a name="l00134"></a>00134 <span class="comment">    ///</span>
<a name="l00135"></a>00135 <span class="comment">    /// \n \n</span>
<a name="l00136"></a>00136 <span class="comment">    /// @section XMLOverview Overview</span>
<a name="l00137"></a>00137 <span class="comment">    ///     - @ref XMLIntroduction</span>
<a name="l00138"></a>00138 <span class="comment">    ///     - @ref XMLFeedBack</span>
<a name="l00139"></a>00139 <span class="comment">    ///     - @ref XMLAcknowledgments</span>
<a name="l00140"></a>00140 <span class="comment">    ///     - @ref XMLLicense</span>
<a name="l00141"></a>00141 <span class="comment">    ///</span>
<a name="l00142"></a>00142 <span class="comment">    /// @subsection XMLIntroduction Introduction</span>
<a name="l00143"></a>00143 <span class="comment">    /// Mezzanine::xml is a light-weight C++ XML processing library. It consists of a DOM-like interface with rich traversal/modification capabilities, an</span>
<a name="l00144"></a>00144 <span class="comment">    /// extremely fast XML parser which constructs the DOM tree from an XML file/buffer, and an @ref Mezzanine::xml::XPathQuery &quot;XPath 1.0 implementation&quot;</span>
<a name="l00145"></a>00145 <span class="comment">    /// for complex data-driven tree queries. Full Unicode support is also available, with @ref XMLUnicode &quot;two Unicode interface variants&quot; and</span>
<a name="l00146"></a>00146 <span class="comment">    /// conversions between different Unicode encodings (which happen automatically during parsing/saving).</span>
<a name="l00147"></a>00147 <span class="comment">    /// \n \n</span>
<a name="l00148"></a>00148 <span class="comment">    /// Mezzanine::xml enables very fast, convenient and memory-efficient XML document processing. However, since Mezzanine::xml has a DOM parser, it can&#39;t process</span>
<a name="l00149"></a>00149 <span class="comment">    /// XML documents that do not fit in memory; also the parser is a non-validating one, so if you need DTD or XML Schema validation, the XML parser</span>
<a name="l00150"></a>00150 <span class="comment">    /// is not for you.</span>
<a name="l00151"></a>00151 <span class="comment">    /// \n \n</span>
<a name="l00152"></a>00152 <span class="comment">    /// @subsection XMLFeedBack FeedBack</span>
<a name="l00153"></a>00153 <span class="comment">    /// If you believe you&#39;ve found a bug in Mezzanine::xml (bugs include compilation problems (errors/warnings), crashes, performance degradation and incorrect</span>
<a name="l00154"></a>00154 <span class="comment">    /// behavior), please contact Blacktopp Studios Inc ( http://www.blacktoppstudios.com/ ) . We check the the Forums ( http://www.blacktoppstudios.com/?page_id=753 )</span>
<a name="l00155"></a>00155 <span class="comment">    /// and items sent by our contact form ( http://www.blacktoppstudios.com/?page_id=33 ) regularly. Be sure to include the relevant information so that</span>
<a name="l00156"></a>00156 <span class="comment">    /// the bug can be reproduced: the version of Mezzanine::xml, compiler version and target architecture, the code that uses Mezzanine::xml and exhibits the bug, etc.</span>
<a name="l00157"></a>00157 <span class="comment">    /// \n \n</span>
<a name="l00158"></a>00158 <span class="comment">    /// Feature requests can be reported the same way as bugs, so if you&#39;re missing some functionality in Mezzanine::xml or if the API is rough in some places</span>
<a name="l00159"></a>00159 <span class="comment">    /// and you can suggest an improvement, please let us know. However, please note that there are many factors when considering API changes (compatibility</span>
<a name="l00160"></a>00160 <span class="comment">    /// with previous versions, API redundancy, etc.).</span>
<a name="l00161"></a>00161 <span class="comment">    /// \n \n</span>
<a name="l00162"></a>00162 <span class="comment">    /// If you have a contribution to Mezzanine::xml, such as build script for some build system/IDE, or a well-designed set of helper functions, or a binding</span>
<a name="l00163"></a>00163 <span class="comment">    /// to some language other than C++, please let us know. You can include the relevant patches as issue attachments. We will have to communicate on the</span>
<a name="l00164"></a>00164 <span class="comment">    /// Licensing terms of your contribution though.</span>
<a name="l00165"></a>00165 <span class="comment">    /// \n \n</span>
<a name="l00166"></a>00166 <span class="comment">    /// If the provided methods of contact have an issue or not possible due to privacy or other concerns, you can contact the Mezzanine::xml author ( toppij@blacktoppstudios.com )</span>
<a name="l00167"></a>00167 <span class="comment">    /// or pugixml author ( arseny.kapoulkine@gmail.com ) by e-mail directly. If you have an issue that pertains to pugixml and not Mezzanine::xml you can visit the</span>
<a name="l00168"></a>00168 <span class="comment">    /// pugixml issue submission form ( http://code.google.com/p/pugixml/issues/entry ) of the pugixml feature request form</span>
<a name="l00169"></a>00169 <span class="comment">    /// ( http://code.google.com/p/pugixml/issues/entry?template=Feature%20request ).</span>
<a name="l00170"></a>00170 <span class="comment">    /// \n \n</span>
<a name="l00171"></a>00171 <span class="comment">    /// @subsection XMLAcknowledgments Acknowledgments</span>
<a name="l00172"></a>00172 <span class="comment">    /// Mezzanine::xml and pugixml could not be developed without the help from many people; some of them are listed in this section. If you&#39;ve played a part in</span>
<a name="l00173"></a>00173 <span class="comment">    /// Mezzanine::xml or pugixml development and you can not find yourself on this list, I&#39;m truly sorry; please send me an e-mail ( toppij@blacktoppstudios.com )</span>
<a name="l00174"></a>00174 <span class="comment">    /// so I can fix this.</span>
<a name="l00175"></a>00175 <span class="comment">    /// \n \n</span>
<a name="l00176"></a>00176 <span class="comment">    /// Thanks to \b Arseny \b Kapoulkine for pugixml parser, which was used as a basis for Mezzanine::xml.</span>
<a name="l00177"></a>00177 <span class="comment">    /// \n \n</span>
<a name="l00178"></a>00178 <span class="comment">    /// Thanks to \b Kristen \b Wegner for pugxml parser, which was used as a basis for pugixml.</span>
<a name="l00179"></a>00179 <span class="comment">    /// \n \n</span>
<a name="l00180"></a>00180 <span class="comment">    /// Thanks to \b Neville \b Franks for contributions to pugxml parser.</span>
<a name="l00181"></a>00181 <span class="comment">    /// \n \n</span>
<a name="l00182"></a>00182 <span class="comment">    /// Thanks to \b Artyom \b Palvelev for suggesting a lazy gap contraction approach.</span>
<a name="l00183"></a>00183 <span class="comment">    /// \n \n</span>
<a name="l00184"></a>00184 <span class="comment">    /// Thanks to \b Vyacheslav \b Egorov for documentation proofreading.</span>
<a name="l00185"></a>00185 <span class="comment">    /// \n \n</span>
<a name="l00186"></a>00186 <span class="comment">    /// @subsection XMLLicense License</span>
<a name="l00187"></a>00187 <span class="comment">    /// With written permission as per @ref OriginalpugixmlLicense &quot;The original pugixml license&quot; we he sublicensed Mezzanine::xml under the @ref GPLLicense &quot;GPL Version 3&quot;. In short</span>
<a name="l00188"></a>00188 <span class="comment">    /// This allows you to use Mezzanine::xml however you like with a few restrictions. If you change Mezzanine::xml you need to make the changes publically available.</span>
<a name="l00189"></a>00189 <span class="comment">    /// If you make software using Mezzanine::xml you need to make the source code publicly available. You may not use and Digital Rights Management (DRM) software</span>
<a name="l00190"></a>00190 <span class="comment">    /// to limit how others use the combined work you make. You can sell resulting works, but not through a digital distribution store that uses DRM.</span>
<a name="l00191"></a>00191 <span class="comment">    ///</span>
<a name="l00192"></a>00192 <span class="comment">    /// \n \n</span>
<a name="l00193"></a>00193 <span class="comment">    /// @section XMLDOM Document Object Model</span>
<a name="l00194"></a>00194 <span class="comment">    /// Mezzanine::xml stores XML data in DOM-like way: the entire XML document (both document structure and element data) is stored in memory as a tree. The tree can be</span>
<a name="l00195"></a>00195 <span class="comment">    /// loaded from a character stream (file, string, C++ I/O stream), then traversed with the special API or XPath expressions. The whole tree is mutable: both node</span>
<a name="l00196"></a>00196 <span class="comment">    /// structure and node/attribute data can be changed at any time. Finally, the result of document transformations can be saved to a character stream (file, C++</span>
<a name="l00197"></a>00197 <span class="comment">    /// I/O stream or custom transport).</span>
<a name="l00198"></a>00198 <span class="comment">    ///     - @ref XMLTreeStructure</span>
<a name="l00199"></a>00199 <span class="comment">    ///     - @ref XMLInterface</span>
<a name="l00200"></a>00200 <span class="comment">    ///     - @ref XMLUnicode</span>
<a name="l00201"></a>00201 <span class="comment">    ///     - @ref XMLThreadSafety</span>
<a name="l00202"></a>00202 <span class="comment">    ///     - @ref XMLExceptionSafety</span>
<a name="l00203"></a>00203 <span class="comment">    ///     - @ref XMLMemory</span>
<a name="l00204"></a>00204 <span class="comment">    ///         - @ref XMLCustomAlloc</span>
<a name="l00205"></a>00205 <span class="comment">    ///         - @ref XMLMemoryInternals</span>
<a name="l00206"></a>00206 <span class="comment">    ///</span>
<a name="l00207"></a>00207 <span class="comment">    /// @subsection XMLTreeStructure Tree structure</span>
<a name="l00208"></a>00208 <span class="comment">    /// The XML document is represented with a tree data structure. The root of the tree is the document itself, which corresponds to C++ type Mezzanine::xml::Document.</span>
<a name="l00209"></a>00209 <span class="comment">    /// A Document has one or more child nodes, which correspond to C++ type Mezzanine::xml::Node. Nodes have different types; depending on a type, a node can have a</span>
<a name="l00210"></a>00210 <span class="comment">    /// collection of child nodes, a collection of attributes, which correspond to C++ type Mezzanine::xml::Attribute, and some additional data (i.e. Name).</span>
<a name="l00211"></a>00211 <span class="comment">    /// \n \n</span>
<a name="l00212"></a>00212 <span class="comment">    /// The tree nodes can be of one of the following types (which together form the enumeration Mezzanine::xml::NodeType):</span>
<a name="l00213"></a>00213 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDocument Document node&quot; - This is the root of the tree, which consists of several child nodes. This node corresponds</span>
<a name="l00214"></a>00214 <span class="comment">    ///     to Mezzanine::xml::Document class; note that Mezzanine::xml::Document is a sub-class of Mezzanine::xml::Node, so the entire node interface is also available. However,</span>
<a name="l00215"></a>00215 <span class="comment">    ///     document nodes are special in several ways, which are covered below. There can be only one document node in the tree; document node does not have any XML</span>
<a name="l00216"></a>00216 <span class="comment">    ///     representation. \n</span>
<a name="l00217"></a>00217 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeElement Element/tag node&quot; - This is the most common type of node, which represents XML elements. Element nodes</span>
<a name="l00218"></a>00218 <span class="comment">    ///     have a name, a collection of attributes and a collection of child nodes (both of which may be empty). The attribute is a simple name/value pair. The example</span>
<a name="l00219"></a>00219 <span class="comment">    ///     XML representation of element nodes is as follows:</span>
<a name="l00220"></a>00220 <span class="comment">    ///     @code &lt;node attr=&quot;value&quot;&gt;&lt;child/&gt;&lt;/node&gt; @endcode</span>
<a name="l00221"></a>00221 <span class="comment">    ///     There are two element nodes here: one has name &quot;node&quot;, single attribute &quot;attr&quot; and the single child &quot;child&quot; which has the name &quot;child&quot; and does not have</span>
<a name="l00222"></a>00222 <span class="comment">    ///     any attributes or child nodes. \n</span>
<a name="l00223"></a>00223 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodePcdata Plain character data node&quot; - Represent plain text in XML. PCDATA nodes have a value, but do not have a name</span>
<a name="l00224"></a>00224 <span class="comment">    ///     or children/attributes. Note that plain character data is not a part of the element node but instead has its own node; for example, an element node can have</span>
<a name="l00225"></a>00225 <span class="comment">    ///     several child PCDATA nodes. The example XML representation of text nodes is as follows:</span>
<a name="l00226"></a>00226 <span class="comment">    ///     @code &lt;node&gt; text1 &lt;child/&gt; text2 &lt;/node&gt; @endcode</span>
<a name="l00227"></a>00227 <span class="comment">    ///     Here &quot;node&quot; element has three children, two of which are PCDATA nodes with values &quot;text1&quot; and &quot;text2&quot;. \n</span>
<a name="l00228"></a>00228 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeCdata Character data nodes&quot; - These represent text in XML that is quoted in a special way. CDATA nodes do not differ</span>
<a name="l00229"></a>00229 <span class="comment">    ///     from PCDATA nodes except in XML representation - the above text example looks like this with CDATA:</span>
<a name="l00230"></a>00230 <span class="comment">    ///     @code &lt;node&gt; &lt;![CDATA[[text1]]&gt; &lt;child/&gt; &lt;![CDATA[[text2]]&gt; &lt;/node&gt; @endcode</span>
<a name="l00231"></a>00231 <span class="comment">    ///     CDATA nodes make it easy to include non-escaped &lt;, \&amp; and &gt; characters in plain text. CDATA value can not contain the character sequence ]]&gt;, since it is</span>
<a name="l00232"></a>00232 <span class="comment">    ///     used to determine the end of node contents. \n</span>
<a name="l00233"></a>00233 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeComment Comment nodes&quot; - represent comments in XML. Comment nodes have a value, but do not have a name or</span>
<a name="l00234"></a>00234 <span class="comment">    ///     children/attributes. The example XML representation of a comment node is as follows:</span>
<a name="l00235"></a>00235 <span class="comment">    ///     @code &lt;!-- comment text --&gt; @endcode</span>
<a name="l00236"></a>00236 <span class="comment">    ///     Here the comment node has value &quot;comment text&quot;. By default comment nodes are treated as non-essential part of XML markup and are not loaded during XML parsing.</span>
<a name="l00237"></a>00237 <span class="comment">    ///     You can override this behavior with Mezzanine::xml::ParseComments flag. \n</span>
<a name="l00238"></a>00238 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodePi Processing instruction node&quot; - Represent Processing Instructions (PI) in XML. PI nodes have a name and an optional</span>
<a name="l00239"></a>00239 <span class="comment">    ///     value, but do not have children/attributes. The example XML representation of a PI node is as follows:</span>
<a name="l00240"></a>00240 <span class="comment">    ///     @code &lt;?name value?&gt; @endcode</span>
<a name="l00241"></a>00241 <span class="comment">    ///     Here the name (also called PI target) is &quot;name&quot;, and the value is &quot;value&quot;. By default PI nodes are treated as non-essential part of XML markup and are not</span>
<a name="l00242"></a>00242 <span class="comment">    ///     loaded during XML parsing. You can override this behavior with Mezzanine::xml::ParsePi flag. \n</span>
<a name="l00243"></a>00243 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDeclaration Declaration node&quot; - Represents document declarations in XML. Declaration nodes have a name (&quot;xml&quot;) and an</span>
<a name="l00244"></a>00244 <span class="comment">    ///     optional collection of attributes, but do not have value or children. There can be only one declaration node in a document; moreover, it should be the topmost</span>
<a name="l00245"></a>00245 <span class="comment">    ///     node (its parent should be the document). The example XML representation of a declaration node is as follows:</span>
<a name="l00246"></a>00246 <span class="comment">    ///     @code &lt;?xml version=&quot;1.0&quot;?&gt; @endcode</span>
<a name="l00247"></a>00247 <span class="comment">    ///     Here the node has name &quot;xml&quot; and a single attribute with name &quot;version&quot; and value &quot;1.0&quot;. By default declaration nodes are treated as non-essential part of XML</span>
<a name="l00248"></a>00248 <span class="comment">    ///     markup and are not loaded during XML parsing. You can override this behavior with Mezzanine::xml::ParseDeclaration flag. Also, by default a dummy declaration is</span>
<a name="l00249"></a>00249 <span class="comment">    ///     output when XML document is saved unless there is already a declaration in the document; you can disable this with Mezzanine::xml::FormatNoDeclaration flag. \n</span>
<a name="l00250"></a>00250 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDocType Document type declaration node&quot; - Represents document type declarations in XML. Document type declaration nodes</span>
<a name="l00251"></a>00251 <span class="comment">    ///     have a value, which corresponds to the entire document type contents; no additional nodes are created for inner elements like &lt;!ENTITY&gt;. There can be only one</span>
<a name="l00252"></a>00252 <span class="comment">    ///     document type declaration node in a document; moreover, it should be the topmost node (its parent should be the document). The example XML representation of a</span>
<a name="l00253"></a>00253 <span class="comment">    ///     document type declaration node is as follows:</span>
<a name="l00254"></a>00254 <span class="comment">    ///     @code &lt;!DOCTYPE greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]&gt; @endcode</span>
<a name="l00255"></a>00255 <span class="comment">    ///     Here the node has value &quot;greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]&quot;. By default document type declaration nodes are treated as non-essential part of XML markup</span>
<a name="l00256"></a>00256 <span class="comment">    ///     and are not loaded during XML parsing. You can override this behavior with Mezzanine::xml::ParseDocType flag. \n</span>
<a name="l00257"></a>00257 <span class="comment">    /// \n \n</span>
<a name="l00258"></a>00258 <span class="comment">    /// Finally, here is a complete example of XML document and the corresponding tree representation:</span>
<a name="l00259"></a>00259 <span class="comment">    /// @code</span>
<a name="l00260"></a>00260 <span class="comment">    /// &lt;?xml version=&quot;1.0&quot;?&gt;</span>
<a name="l00261"></a>00261 <span class="comment">    /// &lt;mesh name=&quot;mesh_root&quot;&gt;</span>
<a name="l00262"></a>00262 <span class="comment">    ///     &lt;!-- here is a mesh node --&gt;</span>
<a name="l00263"></a>00263 <span class="comment">    ///     some text</span>
<a name="l00264"></a>00264 <span class="comment">    ///     &lt;![CDATA[someothertext]]&gt;</span>
<a name="l00265"></a>00265 <span class="comment">    ///     some more text</span>
<a name="l00266"></a>00266 <span class="comment">    ///     &lt;node attr1=&quot;value1&quot; attr2=&quot;value2&quot; /&gt;</span>
<a name="l00267"></a>00267 <span class="comment">    ///     &lt;node attr1=&quot;value2&quot;&gt;</span>
<a name="l00268"></a>00268 <span class="comment">    ///         &lt;innernode/&gt;</span>
<a name="l00269"></a>00269 <span class="comment">    ///     &lt;/node&gt;</span>
<a name="l00270"></a>00270 <span class="comment">    /// &lt;/mesh&gt;</span>
<a name="l00271"></a>00271 <span class="comment">    /// &lt;?include somedata?&gt;</span>
<a name="l00272"></a>00272 <span class="comment">    /// @endcode</span>
<a name="l00273"></a>00273 <span class="comment">    /// @image html SampleTree.jpg &quot;Complete Tree Representation of the Sample&quot;</span>
<a name="l00274"></a>00274 <span class="comment">    /// @image latex SampleTree.jpg &quot;Complete Tree Representation of the Sample&quot;</span>
<a name="l00275"></a>00275 <span class="comment">    /// @image rtf SampleTree.jpg &quot;Complete Tree Representation of the Sample&quot;</span>
<a name="l00276"></a>00276 <span class="comment">    /// @subsection XMLInterface C++ interface</span>
<a name="l00277"></a>00277 <span class="comment">    /// Despite the fact that there are several node types, there are only three C++ classes representing the tree (Mezzanine::xml::Document, Mezzanine::xml::Node, Mezzanine::xml::Attribute);</span>
<a name="l00278"></a>00278 <span class="comment">    /// some operations on Mezzanine::xml::Node are only valid for certain node types. The classes are described below.</span>
<a name="l00279"></a>00279 <span class="comment">    /// \n \n</span>
<a name="l00280"></a>00280 <span class="comment">    /// Mezzanine::xml::Document is the owner of the entire document structure; it is a non-copyable class. The interface of Mezzanine::xml::Document consists of loading functions</span>
<a name="l00281"></a>00281 <span class="comment">    /// ( see @ref XMLLoading ), saving functions ( see @ref XMLSaving ) and the entire interface of Mezzanine::xml::Node, which allows for document inspection and/or modification.</span>
<a name="l00282"></a>00282 <span class="comment">    /// Note that while Mezzanine::xml::Document is a sub-class of Mezzanine::xml::Node, Mezzanine::xml::Node is not a polymorphic type; the inheritance is present only to simplify usage.</span>
<a name="l00283"></a>00283 <span class="comment">    /// Alternatively you can use the Mezzanine::xml::Document::DocumentElement function to get the element node that&#39;s the immediate child of the document.</span>
<a name="l00284"></a>00284 <span class="comment">    /// \n \n</span>
<a name="l00285"></a>00285 <span class="comment">    /// Default constructor of Mezzanine::xml::Document initializes the document to the tree with only a root node ( Mezzanine::xml::Document node). You can then populate it with data</span>
<a name="l00286"></a>00286 <span class="comment">    /// using either tree modification functions or loading functions; all loading functions destroy the previous tree with all occupied memory, which puts existing</span>
<a name="l00287"></a>00287 <span class="comment">    /// node/attribute handles for this document to invalid state. If you want to destroy the previous tree, you can use the Mezzanine::xml::Document::Reset function; it destroys</span>
<a name="l00288"></a>00288 <span class="comment">    /// the tree and replaces it with either an empty one or a copy of the specified document. Destructor of Mezzanine::xml::Document also destroys the tree, thus the lifetime of</span>
<a name="l00289"></a>00289 <span class="comment">    /// the document object should exceed the lifetimes of any node/attribute handles that point to the tree.</span>
<a name="l00290"></a>00290 <span class="comment">    /// @warning While technically node/attribute handles can be alive when the tree they&#39;re referring to is destroyed, calling any member function for these handles results</span>
<a name="l00291"></a>00291 <span class="comment">    /// in undefined behavior. Thus it is recommended to make sure that the document is destroyed only after all references to its nodes/attributes are destroyed.</span>
<a name="l00292"></a>00292 <span class="comment">    ///</span>
<a name="l00293"></a>00293 <span class="comment">    /// Mezzanine::xml::Node is the handle to a document node; it can point to any node in the document, including the document node itself. There is a common interface for nodes</span>
<a name="l00294"></a>00294 <span class="comment">    /// of all types; the actual node type can be queried via the Mezzanine::xml::Node::Type() method. Note that Mezzanine::xml::Node is only a handle to the actual node, not the node</span>
<a name="l00295"></a>00295 <span class="comment">    /// itself - you can have several Mezzanine::xml::node handles pointing to the same underlying object. Destroying Mezzanine::xml::Node handle does not destroy the node and does not</span>
<a name="l00296"></a>00296 <span class="comment">    /// remove it from the tree. The size of Mezzanine::xml::Node is equal to that of a pointer, so it is nothing more than a lightweight wrapper around a pointer; you can safely</span>
<a name="l00297"></a>00297 <span class="comment">    /// pass or return Mezzanine::xml:Node objects by value without additional overhead.</span>
<a name="l00298"></a>00298 <span class="comment">    /// \n \n</span>
<a name="l00299"></a>00299 <span class="comment">    /// There is a special value of Mezzanine::xml::Node type, known as null node or empty node (such nodes have type NodeNull). It does not correspond to any node in any document,</span>
<a name="l00300"></a>00300 <span class="comment">    /// and thus resembles null pointer. However, all operations are defined on empty nodes; generally the operations don&#39;t do anything and return empty nodes/attributes or</span>
<a name="l00301"></a>00301 <span class="comment">    /// empty strings as their result (see documentation for specific functions for more detailed information). This is useful for chaining calls; i.e. you can get the</span>
<a name="l00302"></a>00302 <span class="comment">    /// grandparent of a node like so: node.GetParent().GetParent(); if a node is a null node or it does not have a parent, the first Node::GetParent() call returns null node;</span>
<a name="l00303"></a>00303 <span class="comment">    /// the second GetParent() call then also returns null node, which can make error handling easier.</span>
<a name="l00304"></a>00304 <span class="comment">    /// \n \n</span>
<a name="l00305"></a>00305 <span class="comment">    /// Mezzanine::xml::Attribute is a handle to an XML attribute; it has the same semantics as Mezzanine::xml::Node, i.e. there can be several Mezzanine::xml::Attribute handles pointing to</span>
<a name="l00306"></a>00306 <span class="comment">    /// the same underlying object and there is a special null attribute value, which propagates to function results.</span>
<a name="l00307"></a>00307 <span class="comment">    /// \n \n</span>
<a name="l00308"></a>00308 <span class="comment">    /// Both Mezzanine::xml::Node and Mezzanine::xml::Attribute have the default constructor which initializes them to null objects.</span>
<a name="l00309"></a>00309 <span class="comment">    /// \n \n</span>
<a name="l00310"></a>00310 <span class="comment">    /// Mezzanine::xml::Node and Mezzanine::xml::Attribute try to behave like pointers, that is, they can be compared with other objects of the same type, making it possible to use them</span>
<a name="l00311"></a>00311 <span class="comment">    /// as keys in associative containers. All handles to the same underlying object are equal, and any two handles to different underlying objects are not equal. Null handles</span>
<a name="l00312"></a>00312 <span class="comment">    /// only compare as equal to themselves. The result of relational comparison can not be reliably determined from the order of nodes in file or in any other way. Do not use</span>
<a name="l00313"></a>00313 <span class="comment">    /// relational comparison operators except for search optimization (i.e. associative container keys).</span>
<a name="l00314"></a>00314 <span class="comment">    /// \n \n</span>
<a name="l00315"></a>00315 <span class="comment">    /// If you want to use Mezzanine::xml::Node or Mezzanine::xml::Attribute objects as keys in hash-based associative containers, you can use the Mezzanine::xml::Node::HashValue or</span>
<a name="l00316"></a>00316 <span class="comment">    /// Mezzanine::xml::Attribute::HashValue member functions. They return the hash values that are guaranteed to be the same for all handles to the same underlying object. The hash</span>
<a name="l00317"></a>00317 <span class="comment">    /// value for null handles is 0.</span>
<a name="l00318"></a>00318 <span class="comment">    /// \n \n</span>
<a name="l00319"></a>00319 <span class="comment">    /// Finally handles can be implicitly cast to boolean-like objects, so that you can test if the node/attribute is empty with the following code: if (node) { ... } or if</span>
<a name="l00320"></a>00320 <span class="comment">    /// (!node) { ... } else { ... }. Alternatively you can check if a given Node/Attribute handle is null by calling the Mezzanine::xml::Attribute::Empty or the</span>
<a name="l00321"></a>00321 <span class="comment">    /// Mezzanine::xml::Node::Empty Methods.</span>
<a name="l00322"></a>00322 <span class="comment">    /// \n \n</span>
<a name="l00323"></a>00323 <span class="comment">    /// Nodes and attributes do not exist without a document tree, so you can&#39;t create them without adding them to some document. Once underlying node/attribute objects are</span>
<a name="l00324"></a>00324 <span class="comment">    /// destroyed, the handles to those objects become invalid. While this means that destruction of the entire tree invalidates all node/attribute handles, it also means that</span>
<a name="l00325"></a>00325 <span class="comment">    /// destroying a subtree ( by calling Mezzanine::xml::Node::RemoveChild ) or removing an attribute invalidates the corresponding handles. There is no way to check handle</span>
<a name="l00326"></a>00326 <span class="comment">    /// validity; you have to ensure correctness through external mechanisms.</span>
<a name="l00327"></a>00327 <span class="comment">    /// \n \n</span>
<a name="l00328"></a>00328 <span class="comment">    /// @subsection XMLUnicode Unicode Interface</span>
<a name="l00329"></a>00329 <span class="comment">    /// There are two choices of interface and internal representation when working with Mezzanine::xml : you can either choose the UTF-8 (also called char) interface or UTF-16/32</span>
<a name="l00330"></a>00330 <span class="comment">    /// (also called wchar_t) one. The choice is controlled via XML_WCHAR_MODE define; you can set it via xml.h or via preprocessor options beore engine compilation. If this</span>
<a name="l00331"></a>00331 <span class="comment">    /// define is set, the wchar_t interface is used; otherwise (by default) the char interface is used. The exact wide character encoding is assumed to be either UTF-16 or</span>
<a name="l00332"></a>00332 <span class="comment">    /// UTF-32 and is determined based on the size of wchar_t type.</span>
<a name="l00333"></a>00333 <span class="comment">    /// @warning There are a few places that the reset of the engine assumes the use of the UTF-8/char interface. The task of integrating this cleanly is currently considered</span>
<a name="l00334"></a>00334 <span class="comment">    /// a low priority. If you use XML_WCHAR_MODE you will encounter bugs, they could be tiny or huge. Since we didn&#39;t test it, we assumed it doesn&#39;t work.</span>
<a name="l00335"></a>00335 <span class="comment">    ///</span>
<a name="l00336"></a>00336 <span class="comment">    /// @note If the size of wchar_t is 2, Mezzanine::xml assumes UTF-16 encoding instead of UCS-2, which means that some characters are represented as two code points.</span>
<a name="l00337"></a>00337 <span class="comment">    ///</span>
<a name="l00338"></a>00338 <span class="comment">    /// All tree functions that work with strings work with either C-style null terminated strings or STL strings of the selected character type. For example, node name</span>
<a name="l00339"></a>00339 <span class="comment">    /// accessors look like this in char mode:</span>
<a name="l00340"></a>00340 <span class="comment">    /// @code</span>
<a name="l00341"></a>00341 <span class="comment">    /// const char* Mezzanine::xml::Node::Name() const;</span>
<a name="l00342"></a>00342 <span class="comment">    /// bool Mezzanine::xml::Node::SetName(const char* value);</span>
<a name="l00343"></a>00343 <span class="comment">    /// bool Mezzanine::xml::Node::SetName(const String&amp; value);</span>
<a name="l00344"></a>00344 <span class="comment">    /// @endcode</span>
<a name="l00345"></a>00345 <span class="comment">    /// and like this in wchar_t mode:</span>
<a name="l00346"></a>00346 <span class="comment">    /// @code</span>
<a name="l00347"></a>00347 <span class="comment">    /// const wchar_t* Mezzanine::xml::Node::Name() const;</span>
<a name="l00348"></a>00348 <span class="comment">    /// bool Mezzanine::xml::Node::SetName(const wchar_t* value);</span>
<a name="l00349"></a>00349 <span class="comment">    /// @endcode</span>
<a name="l00350"></a>00350 <span class="comment">    /// There is a special type, Mezzanine::xml::char_t, that is defined as the character type and depends on the engine configuration; it will be also used in the documentation</span>
<a name="l00351"></a>00351 <span class="comment">    /// hereafter. There is also a type Mezzanine::xml::string_t, which is defined as the STL string of the character type; it corresponds to std::string in char mode and to</span>
<a name="l00352"></a>00352 <span class="comment">    /// std::wstring in wchar_t mode.</span>
<a name="l00353"></a>00353 <span class="comment">    /// \n \n</span>
<a name="l00354"></a>00354 <span class="comment">    /// The version of this function that accepts a String simply converts it to a c-style string and calls the other SetName function.</span>
<a name="l00355"></a>00355 <span class="comment">    /// \n \n</span>
<a name="l00356"></a>00356 <span class="comment">    /// In addition to the interface, the internal implementation changes to store XML data as Mezzanine::xml::char_t; this means that these two modes have different memory usage</span>
<a name="l00357"></a>00357 <span class="comment">    /// characteristics. The conversion to Mezzanine::xml::char_t upon document loading and from Mezzanine::xml::char_t upon document saving happen automatically, which also carries</span>
<a name="l00358"></a>00358 <span class="comment">    /// minor performance penalty. The general advice however is to select the character mode based on usage scenario, i.e. if UTF-8 is inconvenient to process and most of</span>
<a name="l00359"></a>00359 <span class="comment">    /// your XML data is non-ASCII, wchar_t mode is probably a better choice (if this is the case any patches, notifications or bugfixes that could be sent our way would</span>
<a name="l00360"></a>00360 <span class="comment">    /// help.)</span>
<a name="l00361"></a>00361 <span class="comment">    /// \n \n</span>
<a name="l00362"></a>00362 <span class="comment">    /// There are cases when you&#39;ll have to convert string data between UTF-8 and wchar_t encodings; the following helper functions are provided for such purposes:</span>
<a name="l00363"></a>00363 <span class="comment">    /// @code</span>
<a name="l00364"></a>00364 <span class="comment">    /// std::string AsUtf8(const wchar_t* str);</span>
<a name="l00365"></a>00365 <span class="comment">    /// std::wstring AsUtf8(const char* str);</span>
<a name="l00366"></a>00366 <span class="comment">    /// @endcode</span>
<a name="l00367"></a>00367 <span class="comment">    /// Both functions accept a null-terminated string as an argument str, and return the converted string. AsUtf8 performs conversion from UTF-16/32 to UTF-8; AsWide performs</span>
<a name="l00368"></a>00368 <span class="comment">    /// conversion from UTF-8 to UTF-16/32. Invalid UTF sequences are silently discarded upon conversion. str has to be a valid string; passing null pointer results in</span>
<a name="l00369"></a>00369 <span class="comment">    /// undefined behavior. There are also two overloads with the same semantics which accept a string as an argument:</span>
<a name="l00370"></a>00370 <span class="comment">    /// @code</span>
<a name="l00371"></a>00371 <span class="comment">    /// std::string AsUtf8(const std::wstring&amp; str);</span>
<a name="l00372"></a>00372 <span class="comment">    /// std::wstring AsWide(const std::string&amp; str);</span>
<a name="l00373"></a>00373 <span class="comment">    /// @endcode</span>
<a name="l00374"></a>00374 <span class="comment">    /// @note</span>
<a name="l00375"></a>00375 <span class="comment">    /// Most examples in this documentation assume char interface and therefore will not compile with XML_WCHAR_MODE. This is done to simplify the documentation; usually the</span>
<a name="l00376"></a>00376 <span class="comment">    /// only changes you&#39;ll have to make is to pass wchar_t string literals, i.e. instead of</span>
<a name="l00377"></a>00377 <span class="comment">    /// \n \n</span>
<a name="l00378"></a>00378 <span class="comment">    /// @code Mezzanine::xml::Node node = doc.GetChild(&quot;bookstore&quot;).FindChildbyAttribute(&quot;book&quot;, &quot;id&quot;, &quot;12345&quot;); @endcode</span>
<a name="l00379"></a>00379 <span class="comment">    /// \n \n</span>
<a name="l00380"></a>00380 <span class="comment">    /// you&#39;ll have to do</span>
<a name="l00381"></a>00381 <span class="comment">    /// \n \n</span>
<a name="l00382"></a>00382 <span class="comment">    /// @code Mezzanine::xml::Node node = doc.GetChild(L&quot;bookstore&quot;).FindChildbyAttribute(L&quot;book&quot;, L&quot;id&quot;, L&quot;12345&quot;); @endcode</span>
<a name="l00383"></a>00383 <span class="comment">    /// \n \n</span>
<a name="l00384"></a>00384 <span class="comment">    /// @subsection XMLThreadSafety Thread-safety guarantees</span>
<a name="l00385"></a>00385 <span class="comment">    ///Almost all functions in Mezzanine::xml have the following thread-safety guarantees:</span>
<a name="l00386"></a>00386 <span class="comment">    ///     - It is safe to call free (non-member) functions from multiple threads</span>
<a name="l00387"></a>00387 <span class="comment">    ///     - It is safe to perform concurrent read-only accesses to the same tree (all constant member functions do not modify the tree)</span>
<a name="l00388"></a>00388 <span class="comment">    ///     - It is safe to perform concurrent read/write accesses, if there is only one read or write access to the single tree at a time</span>
<a name="l00389"></a>00389 <span class="comment">    ///</span>
<a name="l00390"></a>00390 <span class="comment">    /// Concurrent modification and traversing of a single tree requires synchronization, for example via reader-writer lock. Modification includes altering document structure</span>
<a name="l00391"></a>00391 <span class="comment">    /// and altering individual node/attribute data, i.e. changing names/values.</span>
<a name="l00392"></a>00392 <span class="comment">    /// \n \n</span>
<a name="l00393"></a>00393 <span class="comment">    /// The only exception is Mezzanine::xml::SetMemory_management_functions; it modifies global variables and as such is not thread-safe. Its usage policy has more restrictions, see</span>
<a name="l00394"></a>00394 <span class="comment">    /// @ref XMLCustomAlloc .</span>
<a name="l00395"></a>00395 <span class="comment">    /// \n \n</span>
<a name="l00396"></a>00396 <span class="comment">    /// @subsection XMLExceptionSafety Exception guarantees</span>
<a name="l00397"></a>00397 <span class="comment">    /// With the exception of XPath, Mezzanine::xml itself does not throw any exceptions. Additionally, most Mezzanine::xml functions have a no-throw exception guarantee.</span>
<a name="l00398"></a>00398 <span class="comment">    /// \n \n</span>
<a name="l00399"></a>00399 <span class="comment">    /// This is not applicable to functions that operate on STL strings or IOstreams; such functions have either strong guarantee (functions that operate on strings) or basic</span>
<a name="l00400"></a>00400 <span class="comment">    /// guarantee (functions that operate on streams). Also functions that call user-defined callbacks (i.e. Mezzanine::xml::Node::Traverse or Mezzanine::xml::Node::FindNode) do not</span>
<a name="l00401"></a>00401 <span class="comment">    /// provide any exception guarantees beyond the ones provided by the callback.</span>
<a name="l00402"></a>00402 <span class="comment">    /// \n \n</span>
<a name="l00403"></a>00403 <span class="comment">    /// If exception handling is not disabled with XML_NO_EXCEPTIONS define, XPath functions may throw Mezzanine::xml::XPathException on parsing errors; also, XPath functions may</span>
<a name="l00404"></a>00404 <span class="comment">    /// throw std::bad_alloc in low memory conditions. Still, XPath functions provide strong exception guarantee.</span>
<a name="l00405"></a>00405 <span class="comment">    /// \n \n</span>
<a name="l00406"></a>00406 <span class="comment">    /// @subsection XMLMemory Memory management</span>
<a name="l00407"></a>00407 <span class="comment">    /// Mezzanine::xml requests the memory needed for document storage in big chunks, and allocates document data inside those chunks. This section discusses replacing functions</span>
<a name="l00408"></a>00408 <span class="comment">    /// used for chunk allocation and internal memory management implementation.</span>
<a name="l00409"></a>00409 <span class="comment">    /// \n \n</span>
<a name="l00410"></a>00410 <span class="comment">    /// @warning The Mezzanine::xml memory system is pending tighter integration with memory management from the rest of the system. The functions and features described here should be</span>
<a name="l00411"></a>00411 <span class="comment">    /// considered deprecated and internal to the engine. It is highly likely they will be replaced without warning by a global system to allocate memory in a more efficient way.</span>
<a name="l00412"></a>00412 <span class="comment">    ///</span>
<a name="l00413"></a>00413 <span class="comment">    /// \n \n</span>
<a name="l00414"></a>00414 <span class="comment">    /// @subsubsection XMLCustomAlloc Custom memory allocation/deallocation functions</span>
<a name="l00415"></a>00415 <span class="comment">    /// All memory for tree structure, tree data and XPath objects is allocated via globally specified functions, which default to malloc/free. You can set your own allocation</span>
<a name="l00416"></a>00416 <span class="comment">    /// functions with Mezzanine::xml::SetMemory_management_functions function. The function interfaces are the same as that of malloc/free:</span>
<a name="l00417"></a>00417 <span class="comment">    /// @code</span>
<a name="l00418"></a>00418 <span class="comment">    /// typedef void* (*AllocationFunction)(size_t size);</span>
<a name="l00419"></a>00419 <span class="comment">    /// typedef void (*deAllocationFunction)(void* ptr);</span>
<a name="l00420"></a>00420 <span class="comment">    /// @endcode</span>
<a name="l00421"></a>00421 <span class="comment">    /// You can use the following accessor functions to change or get current memory management functions:</span>
<a name="l00422"></a>00422 <span class="comment">    /// @code</span>
<a name="l00423"></a>00423 <span class="comment">    /// void Mezzanine::xml::SetMemory_management_functions(AllocationFunction allocate, deAllocationFunction deallocate);</span>
<a name="l00424"></a>00424 <span class="comment">    /// AllocationFunction GetMemoryAllocationFunctionn();</span>
<a name="l00425"></a>00425 <span class="comment">    /// deAllocationFunction GetMemoryDeallocationFunction();</span>
<a name="l00426"></a>00426 <span class="comment">    /// @endcode</span>
<a name="l00427"></a>00427 <span class="comment">    /// Allocation function is called with the size (in bytes) as an argument and should return a pointer to a memory block with alignment that is suitable for storage of primitive</span>
<a name="l00428"></a>00428 <span class="comment">    /// types (usually a maximum of void* and double types alignment is sufficient) and size that is greater than or equal to the requested one. If the allocation fails, the function</span>
<a name="l00429"></a>00429 <span class="comment">    /// has to return null pointer (throwing an exception from allocation function results in undefined behavior).</span>
<a name="l00430"></a>00430 <span class="comment">    /// \n \n</span>
<a name="l00431"></a>00431 <span class="comment">    /// Deallocation function is called with the pointer that was returned by some call to allocation function; it is never called with a null pointer. If memory management functions</span>
<a name="l00432"></a>00432 <span class="comment">    /// are not thread-safe, library thread safety is not guaranteed.</span>
<a name="l00433"></a>00433 <span class="comment">    /// \n \n</span>
<a name="l00434"></a>00434 <span class="comment">    /// When setting new memory management functions, care must be taken to make sure that there are no live Mezzanine::xml objects. Otherwise when the objects are destroyed, the new</span>
<a name="l00435"></a>00435 <span class="comment">    /// deallocation function will be called with the memory obtained by the old allocation function, resulting in undefined behavior.</span>
<a name="l00436"></a>00436 <span class="comment">    /// \n \n</span>
<a name="l00437"></a>00437 <span class="comment">    /// @subsubsection XMLMemoryInternals Document memory management internals</span>
<a name="l00438"></a>00438 <span class="comment">    /// Constructing a document object using the default constructor does not result in any allocations; document node is stored inside the Mezzanine::xml::Document object</span>
<a name="l00439"></a>00439 <span class="comment">    /// \n \n</span>
<a name="l00440"></a>00440 <span class="comment">    /// When the document is loaded from file/buffer, unless an inplace loading function is used ( see @ref XMLLoadingFromMemory ), a complete copy of character stream is made; all</span>
<a name="l00441"></a>00441 <span class="comment">    /// names/values of nodes and attributes are allocated in this buffer. This buffer is allocated via a single large allocation and is only freed when document memory is reclaimed</span>
<a name="l00442"></a>00442 <span class="comment">    /// (i.e. if the Mezzanine::xml::Document object is destroyed or if another document is loaded in the same object). Also when loading from file or stream, an additional large allocation</span>
<a name="l00443"></a>00443 <span class="comment">    /// may be performed if encoding conversion is required; a temporary buffer is allocated, and it is freed before load function returns.</span>
<a name="l00444"></a>00444 <span class="comment">    /// \n \n</span>
<a name="l00445"></a>00445 <span class="comment">    /// All additional memory, such as memory for document structure (node/attribute objects) and memory for node/attribute names/values is allocated in pages on the order of 32</span>
<a name="l00446"></a>00446 <span class="comment">    /// kilobytes; actual objects are allocated inside the pages using a memory management scheme optimized for fast allocation/deallocation of many small objects. Because of the</span>
<a name="l00447"></a>00447 <span class="comment">    /// scheme specifics, the pages are only destroyed if all objects inside them are destroyed; also, generally destroying an object does not mean that subsequent object creation</span>
<a name="l00448"></a>00448 <span class="comment">    /// will reuse the same memory. This means that it is possible to devise a usage scheme which will lead to higher memory usage than expected; one example is adding a lot of nodes,</span>
<a name="l00449"></a>00449 <span class="comment">    /// and them removing all even numbered ones; not a single page is reclaimed in the process. However this is an example specifically crafted to produce unsatisfying behavior;</span>
<a name="l00450"></a>00450 <span class="comment">    /// in all practical usage scenarios the memory consumption is less than that of a general-purpose allocator because allocation meta-data is very small in size.</span>
<a name="l00451"></a>00451 <span class="comment">    /// \n \n</span>
<a name="l00452"></a>00452 <span class="comment">    /// @section XMLLoading Loading Documents</span>
<a name="l00453"></a>00453 <span class="comment">    ///     - @ref XMLLoadingFiles</span>
<a name="l00454"></a>00454 <span class="comment">    ///     - @ref XMLLoadingFromMemory</span>
<a name="l00455"></a>00455 <span class="comment">    ///     - @ref XMLLoadingStreams</span>
<a name="l00456"></a>00456 <span class="comment">    ///     - @ref XMLLoadingErrors</span>
<a name="l00457"></a>00457 <span class="comment">    ///     - @ref XMLLoadingParsingOptions</span>
<a name="l00458"></a>00458 <span class="comment">    ///     - @ref XMLLoadingEncodings</span>
<a name="l00459"></a>00459 <span class="comment">    ///     - @ref XMLLoadingStandards</span>
<a name="l00460"></a>00460 <span class="comment">    ///</span>
<a name="l00461"></a>00461 <span class="comment">    /// Mezzanine::xml provides several functions for loading XML data from various places - files, C++ iostreams, memory buffers. All functions use an extremely fast non-validating parser.</span>
<a name="l00462"></a>00462 <span class="comment">    /// This parser is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject</span>
<a name="l00463"></a>00463 <span class="comment">    /// invalid XML documents, some validation is not performed for performance reasons. Also some XML transformations (i.e. EOL handling or attribute value normalization) can impact</span>
<a name="l00464"></a>00464 <span class="comment">    /// parsing speed and thus can be disabled. However for vast majority of XML documents there is no performance difference between different parsing options. Parsing options also</span>
<a name="l00465"></a>00465 <span class="comment">    /// control whether certain XML nodes are parsed; see @ref XMLLoadingParsingOptions for more information.</span>
<a name="l00466"></a>00466 <span class="comment">    /// \n \n</span>
<a name="l00467"></a>00467 <span class="comment">    /// XML data is always converted to internal character format ( see @ref XMLUnicode ) before parsing. Mezzanine::xml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little</span>
<a name="l00468"></a>00468 <span class="comment">    /// endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it&#39;s a strict subset of UTF-16) and handles all encoding conversions automatically. Unless explicit</span>
<a name="l00469"></a>00469 <span class="comment">    /// encoding is specified, loading functions perform automatic encoding detection based on first few characters of XML data, so in almost all cases you do not have to specify</span>
<a name="l00470"></a>00470 <span class="comment">    /// document encoding. Encoding conversion is described in more detail in @ref XMLLoadingEncodings.</span>
<a name="l00471"></a>00471 <span class="comment">    /// \n \n</span>
<a name="l00472"></a>00472 <span class="comment">    /// @subsection XMLLoadingFiles Loading Document from a File</span>
<a name="l00473"></a>00473 <span class="comment">    /// The most common source of XML data is files; Mezzanine::xml provides dedicated functions for loading an XML document from file:</span>
<a name="l00474"></a>00474 <span class="comment">    /// @code</span>
<a name="l00475"></a>00475 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::LoadFile(const char* path, unsigned int options = ParseDefault, Mezzanine::xml::Encoding DocumentEncoding = EncodingAuto);</span>
<a name="l00476"></a>00476 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::LoadFile(const wchar_t* path, unsigned int options = ParseDefault, Mezzanine::xml::Encoding DocumentEncoding = EncodingAuto);</span>
<a name="l00477"></a>00477 <span class="comment">    /// @endcode</span>
<a name="l00478"></a>00478 <span class="comment">    /// These functions accept the file path as its first argument, and also two optional arguments, which specify parsing options (see Parsing options) and input data encoding ( see</span>
<a name="l00479"></a>00479 <span class="comment">    /// @ref XMLLoadingEncodings ). The path has the target operating system format, so it can be a relative or absolute one, it should have the delimiters of the target system, it</span>
<a name="l00480"></a>00480 <span class="comment">    /// should have the exact case if the target file system is case-sensitive, and is subject to any other restrictions of the underlying filesystem.</span>
<a name="l00481"></a>00481 <span class="comment">    /// \n \n</span>
<a name="l00482"></a>00482 <span class="comment">    /// File path is passed to the system file opening function as is in case of the first function (which accepts const char* path); the second function either uses a special file</span>
<a name="l00483"></a>00483 <span class="comment">    /// opening function if it is provided by the runtime library or converts the path to UTF-8 and uses the system file opening function.</span>
<a name="l00484"></a>00484 <span class="comment">    /// \n \n</span>
<a name="l00485"></a>00485 <span class="comment">    /// Document::LoadFile destroys the existing document tree and then tries to load the new tree from the specified file. The result of the operation is returned in an</span>
<a name="l00486"></a>00486 <span class="comment">    /// Mezzanine::xml::ParseResult object; this object contains the operation status and the related information (i.e. last successfully parsed position in the input file, if parsing</span>
<a name="l00487"></a>00487 <span class="comment">    /// fails). See @ref XMLLoadingErrors for error handling details.</span>
<a name="l00488"></a>00488 <span class="comment">    /// \n \n</span>
<a name="l00489"></a>00489 <span class="comment">    /// This is an example of loading XML document from file:</span>
<a name="l00490"></a>00490 <span class="comment">    /// @code</span>
<a name="l00491"></a>00491 <span class="comment">    /// Mezzanine::xml::Document Doc;</span>
<a name="l00492"></a>00492 <span class="comment">    /// Mezzanine::xml::ParseResult Result = Doc.LoadFile(&quot;tree.xml&quot;);</span>
<a name="l00493"></a>00493 <span class="comment">    /// std::cout &lt;&lt; &quot;Load result: &quot; &lt;&lt; Result.Description() &lt;&lt; std::endl;</span>
<a name="l00494"></a>00494 <span class="comment">    /// @endcode</span>
<a name="l00495"></a>00495 <span class="comment">    /// @subsection XMLLoadingFromMemory Loading document from memory</span>
<a name="l00496"></a>00496 <span class="comment">    /// Sometimes XML data should be loaded from some other source than a file, i.e. HTTP URL; also you may want to load XML data from file using non-standard functions, i.e. to use</span>
<a name="l00497"></a>00497 <span class="comment">    /// your virtual file system facilities or to load XML from gzip-compressed files. All these scenarios require loading document from memory. First you should prepare a contiguous</span>
<a name="l00498"></a>00498 <span class="comment">    /// memory block with all XML data; then you have to invoke one of buffer loading functions. These functions will handle the necessary encoding conversions, if any, and then will</span>
<a name="l00499"></a>00499 <span class="comment">    /// parse the data into the corresponding XML tree. There are several buffer loading functions, which differ in the behavior and thus in performance/memory usage:</span>
<a name="l00500"></a>00500 <span class="comment">    /// @code</span>
<a name="l00501"></a>00501 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::LoadBuffer (const void *contents, size_t size, unsigned int options=ParseDefault, Encoding DocumentEncoding=EncodingAuto);</span>
<a name="l00502"></a>00502 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::LoadBufferInplace (void *contents, size_t size, unsigned int options=ParseDefault, Encoding DocumentEncoding=EncodingAuto);</span>
<a name="l00503"></a>00503 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::LoadBufferInplaceOwn (void *contents, size_t size, unsigned int options=ParseDefault, Encoding DocumentEncoding=EncodingAuto)</span>
<a name="l00504"></a>00504 <span class="comment">    /// @endcode</span>
<a name="l00505"></a>00505 <span class="comment">    /// All functions accept the buffer which is represented by a pointer to XML data, contents, and data size in bytes. Also there are two optional arguments, which specify parsing</span>
<a name="l00506"></a>00506 <span class="comment">    /// options ( see @ref XMLLoadingParsingOptions ) and input data encoding ( see @ref XMLLoadingEncodings ). The buffer does not have to be zero-terminated.</span>
<a name="l00507"></a>00507 <span class="comment">    /// \n \n</span>
<a name="l00508"></a>00508 <span class="comment">    /// Mezzanine::xml::Document::LoadBuffer function works with immutable buffer - it does not ever modify the buffer. Because of this restriction it has to create a private buffer and</span>
<a name="l00509"></a>00509 <span class="comment">    /// copy XML data to it before parsing (applying encoding conversions if necessary). This copy operation carries a performance penalty, so inplace functions are provided -</span>
<a name="l00510"></a>00510 <span class="comment">    /// Mezzanine::xml::Document::LoadBufferInplace and Mezzanine::xml::Document::LoadBufferInplaceOwn store the document data in the buffer, modifying it in the process. In order for the</span>
<a name="l00511"></a>00511 <span class="comment">    /// document to stay valid, you have to make sure that the buffer&#39;s lifetime exceeds that of the tree if you&#39;re using inplace functions. In addition to that,</span>
<a name="l00512"></a>00512 <span class="comment">    /// Mezzanine::xml::Document::LoadBufferInplace does not assume ownership of the buffer, so you&#39;ll have to destroy it yourself; Mezzanine::xml::Document::LoadBufferInplaceOwn assumes</span>
<a name="l00513"></a>00513 <span class="comment">    /// ownership of the buffer and destroys it once it is not needed. This means that if you&#39;re using Mezzanine::xml::Document::LoadBufferInplaceOwn, you have to allocate memory with</span>
<a name="l00514"></a>00514 <span class="comment">    /// Mezzanine::xml allocation function ( Not recomended, the Allocation API may be getting updates in the near future ).</span>
<a name="l00515"></a>00515 <span class="comment">    /// \n \n</span>
<a name="l00516"></a>00516 <span class="comment">    /// The best way from the performance/memory point of view is to load document using Mezzanine::xml::Document::LoadBufferInplaceOwn; this function has maximum control of the buffer</span>
<a name="l00517"></a>00517 <span class="comment">    /// with XML data so it is able to avoid redundant copies and reduce peak memory usage while parsing. However, this is not recommendeded unless you have to load the document</span>
<a name="l00518"></a>00518 <span class="comment">    /// from memory and performance is critical. Once the memory portion of the API has stabilized this will become the ideal</span>
<a name="l00519"></a>00519 <span class="comment">    /// \n \n</span>
<a name="l00520"></a>00520 <span class="comment">    /// There is also a simple helper function for cases when you want to load the XML document from null-terminated character string:</span>
<a name="l00521"></a>00521 <span class="comment">    /// @code</span>
<a name="l00522"></a>00522 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::Load(const char_t *contents, unsigned int options=ParseDefault);</span>
<a name="l00523"></a>00523 <span class="comment">    /// @endcode</span>
<a name="l00524"></a>00524 <span class="comment">    /// It is equivalent to calling Mezzanine::xml::Document::LoadBuffer with size being either strlen(contents) or wcslen(contents) * sizeof(wchar_t), depending on the character type.</span>
<a name="l00525"></a>00525 <span class="comment">    /// This function assumes native encoding for input data, so it does not do any encoding conversion. In general, this function is fine for loading small documents from string</span>
<a name="l00526"></a>00526 <span class="comment">    /// literals, but has more overhead and less functionality than the buffer loading functions.</span>
<a name="l00527"></a>00527 <span class="comment">    /// \n \n</span>
<a name="l00528"></a>00528 <span class="comment">    /// This is an example of loading XML document from memory using LoadBuffer:</span>
<a name="l00529"></a>00529 <span class="comment">    /// @code</span>
<a name="l00530"></a>00530 <span class="comment">    /// const char Source[] = &quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;;</span>
<a name="l00531"></a>00531 <span class="comment">    /// size_t Size = sizeof(Source);</span>
<a name="l00532"></a>00532 <span class="comment">    ///</span>
<a name="l00533"></a>00533 <span class="comment">    /// // You can use LoadBuffer to load the document from an immutable memory block:</span>
<a name="l00534"></a>00534 <span class="comment">    /// Mezzanine::xml::ParseResult Result = doc.LoadBuffer(Source, Size);</span>
<a name="l00535"></a>00535 <span class="comment">    /// @endcode</span>
<a name="l00536"></a>00536 <span class="comment">    /// This is an example of loading XML document from memory using LoadBufferInplace:</span>
<a name="l00537"></a>00537 <span class="comment">    /// @code</span>
<a name="l00538"></a>00538 <span class="comment">    /// const char Source[] = &quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;;</span>
<a name="l00539"></a>00539 <span class="comment">    /// size_t Size = sizeof(Source);</span>
<a name="l00540"></a>00540 <span class="comment">    ///</span>
<a name="l00541"></a>00541 <span class="comment">    /// // You can use LoadBufferInplace to load document from mutable memory block</span>
<a name="l00542"></a>00542 <span class="comment">    /// // the block&#39;s lifetime must exceed that of document</span>
<a name="l00543"></a>00543 <span class="comment">    /// char* Buffer = new char[Size];</span>
<a name="l00544"></a>00544 <span class="comment">    /// memcpy(Buffer, Source, Size);</span>
<a name="l00545"></a>00545 <span class="comment">    ///</span>
<a name="l00546"></a>00546 <span class="comment">    /// // The block can be allocated by any method; the block is modified during parsing</span>
<a name="l00547"></a>00547 <span class="comment">    /// Mezzanine::xml::ParseResult Result = doc.LoadBufferInplace(Buffer, Size);</span>
<a name="l00548"></a>00548 <span class="comment">    ///</span>
<a name="l00549"></a>00549 <span class="comment">    /// // You have to destroy the block yourself after the document is no longer used</span>
<a name="l00550"></a>00550 <span class="comment">    /// delete[] Buffer;</span>
<a name="l00551"></a>00551 <span class="comment">    /// @endcode</span>
<a name="l00552"></a>00552 <span class="comment">    /// This is an example of loading XML document from memory using Load and a string literal:</span>
<a name="l00553"></a>00553 <span class="comment">    /// @code</span>
<a name="l00554"></a>00554 <span class="comment">    /// // You can use Load to load document from null-terminated strings, for example literals:</span>
<a name="l00555"></a>00555 <span class="comment">    /// Mezzanine::xml::ParseResult Result = doc.Load(&quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;);</span>
<a name="l00556"></a>00556 <span class="comment">    /// @endcode</span>
<a name="l00557"></a>00557 <span class="comment">    /// @subsection XMLLoadingStreams Loading document from C++ IOstreams</span>
<a name="l00558"></a>00558 <span class="comment">    /// To enhance interoperability, Mezzanine::xml provides functions for loading document from any object which implements C++ std::istream interface. This allows you to load documents</span>
<a name="l00559"></a>00559 <span class="comment">    /// from any standard C++ stream (i.e. file stream) or any third-party compliant implementation (i.e. Boost Iostreams). There are two functions, one works with narrow character</span>
<a name="l00560"></a>00560 <span class="comment">    /// streams, another handles wide character ones:</span>
<a name="l00561"></a>00561 <span class="comment">    /// @code</span>
<a name="l00562"></a>00562 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::Load (std::basic_istream&lt; char, std::char_traits&lt; char &gt; &gt; &amp;stream, unsigned int options=ParseDefault, Encoding DocumentEncoding=EncodingAuto);</span>
<a name="l00563"></a>00563 <span class="comment">    /// Mezzanine::xml::ParseResult Mezzanine::xml::Document::Load (std::basic_istream&lt; wchar_t, std::char_traits&lt; wchar_t &gt; &gt; &amp;stream, unsigned int options=ParseDefault);</span>
<a name="l00564"></a>00564 <span class="comment">    /// @endcode</span>
<a name="l00565"></a>00565 <span class="comment">    /// Mezzanine::xml::Document::Load with std::istream argument loads the document from stream from the current read position to the end, treating the stream contents as a byte stream</span>
<a name="l00566"></a>00566 <span class="comment">    /// of the specified encoding (with encoding autodetection as necessary). Thus calling Mezzanine::xml::Document::Load on an opened std::ifstream object is equivalent to calling</span>
<a name="l00567"></a>00567 <span class="comment">    /// Mezzanine::xml::Document::LoadFile.</span>
<a name="l00568"></a>00568 <span class="comment">    /// \n \n</span>
<a name="l00569"></a>00569 <span class="comment">    /// Mezzanine::xml::Document::Load with std::wstream argument treats the stream contents as a wide character stream ( encoding is always @ref Mezzanine::xml::Encoding &quot;Encoding::Encodingwchar_t&quot; ).</span>
<a name="l00570"></a>00570 <span class="comment">    /// Because of this, using Mezzanine::xml::Document::LoadFile with wide character streams requires careful (usually platform-specific) stream setup (i.e. using the imbue function).</span>
<a name="l00571"></a>00571 <span class="comment">    /// Generally use of wide streams is discouraged, however it provides you the ability to load documents from non-Unicode encodings, i.e. you can load Shift-JIS encoded data if</span>
<a name="l00572"></a>00572 <span class="comment">    /// you set the correct locale.</span>
<a name="l00573"></a>00573 <span class="comment">    /// \n \n</span>
<a name="l00574"></a>00574 <span class="comment">    /// This is a simple example of loading XML document from a file using streams read:</span>
<a name="l00575"></a>00575 <span class="comment">    /// @code</span>
<a name="l00576"></a>00576 <span class="comment">    /// std::ifstream Stream(&quot;weekly-utf-8.xml&quot;);</span>
<a name="l00577"></a>00577 <span class="comment">    /// Mezzanine::xml::ParseResult Result = Doc.Load(Stream);</span>
<a name="l00578"></a>00578 <span class="comment">    /// @endcode</span>
<a name="l00579"></a>00579 <span class="comment">    /// Stream loading requires working seek/tell functions and therefore may fail when used with some stream implementations like gzstream.</span>
<a name="l00580"></a>00580 <span class="comment">    /// \n \n</span>
<a name="l00581"></a>00581 <span class="comment">    /// @subsection XMLLoadingErrors Handling Parsing Errors</span>
<a name="l00582"></a>00582 <span class="comment">    /// All document loading functions return the parsing result via Mezzanine::xml::ParseResult object. It contains parsing status, the offset of last successfully parsed character from</span>
<a name="l00583"></a>00583 <span class="comment">    /// the beginning of the source stream, and the encoding of the source stream.</span>
<a name="l00584"></a>00584 <span class="comment">    /// \n \n</span>
<a name="l00585"></a>00585 <span class="comment">    /// Parsing status is represented as the Mezzanine::xml::ParseStatus enumeration and can be one of the following:</span>
<a name="l00586"></a>00586 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusOk&quot; means that no error was encountered during parsing; the source stream represents the valid XML document which was</span>
<a name="l00587"></a>00587 <span class="comment">    ///     fully parsed and converted to a tree.</span>
<a name="l00588"></a>00588 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusFileNotFound&quot; is only returned by Document::LoadFile function and means that file could not be opened.</span>
<a name="l00589"></a>00589 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusIOError&quot; is returned by Document::LoadFile function and by load functions with std::istream/std::wstream arguments; it</span>
<a name="l00590"></a>00590 <span class="comment">    ///     means that some I/O error has occurred during reading the file/stream.</span>
<a name="l00591"></a>00591 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusOutOfMemory&quot; means that there was not enough memory during some allocation; any allocation failure during parsing results</span>
<a name="l00592"></a>00592 <span class="comment">    ///     in this error.</span>
<a name="l00593"></a>00593 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusInternalError&quot; means that something went horribly wrong; currently this error does not occur.</span>
<a name="l00594"></a>00594 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusUnrecognizedTag&quot; means that parsing stopped due to a tag with either an empty name or a name which starts with incorrect</span>
<a name="l00595"></a>00595 <span class="comment">    ///     character, such as #.</span>
<a name="l00596"></a>00596 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusBadPi&quot; means that parsing stopped due to incorrect document declaration/processing instruction.</span>
<a name="l00597"></a>00597 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusBadComment, StatusBadCdata, StatusBadDocType and StatusBadPcdata&quot; mean that parsing stopped due to the invalid construct</span>
<a name="l00598"></a>00598 <span class="comment">    ///     of the respective type</span>
<a name="l00599"></a>00599 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusBadStartElement&quot; means that parsing stopped because starting tag either had no closing &gt; symbol or contained some incorrect</span>
<a name="l00600"></a>00600 <span class="comment">    ///     symbol</span>
<a name="l00601"></a>00601 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusBadAttribute&quot; means that parsing stopped because there was an incorrect attribute, such as an attribute without value or</span>
<a name="l00602"></a>00602 <span class="comment">    ///     with value that is not quoted (note that &lt;node attr=1&gt; is incorrect in XML)</span>
<a name="l00603"></a>00603 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusBadEndElement&quot; means that parsing stopped because ending tag had incorrect syntax (i.e. extra non-whitespace symbols between</span>
<a name="l00604"></a>00604 <span class="comment">    ///     tag name and &gt;)</span>
<a name="l00605"></a>00605 <span class="comment">    ///     - @ref Mezzanine::xml::ParseStatus &quot;ParseStatus::StatusEndElementMismatch&quot; means that parsing stopped because the closing tag did not match the opening one (i.e. &lt;node&gt;&lt;/nedo&gt;)</span>
<a name="l00606"></a>00606 <span class="comment">    ///     or because some tag was not closed at all.</span>
<a name="l00607"></a>00607 <span class="comment">    ///</span>
<a name="l00608"></a>00608 <span class="comment">    /// Mezzanine::xml::ParseResult::Description member function can be used to convert parsing status to a string; the returned message is always in English, so you&#39;ll have to write your own</span>
<a name="l00609"></a>00609 <span class="comment">    /// function if you need a localized string. However please note that the exact messages returned by the Description() function may change from version to version, so any complex</span>
<a name="l00610"></a>00610 <span class="comment">    /// status handling should be based on the Status value.</span>
<a name="l00611"></a>00611 <span class="comment">    /// \n \n</span>
<a name="l00612"></a>00612 <span class="comment">    /// If parsing failed because the source data was not a valid XML, the resulting tree is not destroyed - despite the fact that load function returns error, you can use the part of the</span>
<a name="l00613"></a>00613 <span class="comment">    /// tree that was successfully parsed. Obviously, the last element may have an unexpected name/value; for example, if the attribute value does not end with the necessary quotation</span>
<a name="l00614"></a>00614 <span class="comment">    /// mark, like in &lt;node attr=&quot;value&gt;some data&lt;/node&gt; example, the value of attribute attr will contain the string &quot;value&gt;some data&lt;/node&gt;&quot;.</span>
<a name="l00615"></a>00615 <span class="comment">    /// \n \n</span>
<a name="l00616"></a>00616 <span class="comment">    /// In addition to the Status code, Mezzanine::xml::ParseResult has an Offset member, which contains the offset of last successfully parsed character if parsing failed because of an error</span>
<a name="l00617"></a>00617 <span class="comment">    /// in source data; otherwise offset is 0. For parsing efficiency reasons, Mezzanine::xml does not track the current line during parsing; this offset is in units of Mezzanine::xml::char_t</span>
<a name="l00618"></a>00618 <span class="comment">    /// (bytes for character mode, wide characters for wide character mode). Many text editors support &#39;Go To Position&#39; feature - you can use it to locate the exact error position.</span>
<a name="l00619"></a>00619 <span class="comment">    /// Alternatively, if you&#39;re loading the document from memory, you can display the error chunk along with the error description.</span>
<a name="l00620"></a>00620 <span class="comment">    /// @warning Offset is calculated in the XML buffer in native encoding; if encoding conversion is performed during parsing, offset can not be used to reliably track the error position.</span>
<a name="l00621"></a>00621 <span class="comment">    ///</span>
<a name="l00622"></a>00622 <span class="comment">    /// Mezzanine::xml::ParseResult also has a DocumentEncoding member, which can be used to check that the source data encoding was correctly guessed. It is equal to the exact encoding used</span>
<a name="l00623"></a>00623 <span class="comment">    /// during parsing (i.e. with the exact endianness); see @ref XMLLoadingEncodings for more information.</span>
<a name="l00624"></a>00624 <span class="comment">    /// \n \n</span>
<a name="l00625"></a>00625 <span class="comment">    /// A Mezzanine::xml::ParseResult object can be implicitly converted to bool; if you do not want to handle parsing errors thoroughly, you can just check the return value of load functions</span>
<a name="l00626"></a>00626 <span class="comment">    /// as if it was a bool: if (doc.load_file(&quot;file.xml&quot;)) { //on Successful parse } else { //on failed parse }. A True is returned if parsing was successful.</span>
<a name="l00627"></a>00627 <span class="comment">    /// \n \n</span>
<a name="l00628"></a>00628 <span class="comment">    /// This is an example of handling loading errors:</span>
<a name="l00629"></a>00629 <span class="comment">    /// @code</span>
<a name="l00630"></a>00630 <span class="comment">    /// const char Source[] = &quot;&lt;mesh name=&#39;sphere&#39;&gt;&lt;bounds&gt;0 0 1 1&lt;/bounds&gt;&lt;/mesh&gt;&quot;;</span>
<a name="l00631"></a>00631 <span class="comment">    /// Mezzanine::xml::Document Doc;</span>
<a name="l00632"></a>00632 <span class="comment">    /// Mezzanine::xml::ParseResult Result = Doc.Load(Source);</span>
<a name="l00633"></a>00633 <span class="comment">    ///</span>
<a name="l00634"></a>00634 <span class="comment">    /// if (Result)</span>
<a name="l00635"></a>00635 <span class="comment">    ///     std::cout &lt;&lt; &quot;XML [&quot; &lt;&lt; Source &lt;&lt; &quot;] parsed without errors\n\n&quot;;</span>
<a name="l00636"></a>00636 <span class="comment">    /// else</span>
<a name="l00637"></a>00637 <span class="comment">    /// {</span>
<a name="l00638"></a>00638 <span class="comment">    ///     std::cout &lt;&lt; &quot;XML [&quot; &lt;&lt; Source &lt;&lt; &quot;] parsed with errors\n&quot;;</span>
<a name="l00639"></a>00639 <span class="comment">    ///     std::cout &lt;&lt; &quot;Error description: &quot; &lt;&lt; Result.Description() &lt;&lt; &quot;\n&quot;;</span>
<a name="l00640"></a>00640 <span class="comment">    ///     std::cout &lt;&lt; &quot;Error offset: &quot; &lt;&lt; Result.Offset &lt;&lt; &quot; (error at [...&quot; &lt;&lt; (Source + Result.Offset) &lt;&lt; &quot;]\n\n&quot;;</span>
<a name="l00641"></a>00641 <span class="comment">    /// }</span>
<a name="l00642"></a>00642 <span class="comment">    /// @endcode</span>
<a name="l00643"></a>00643 <span class="comment">    /// @subsection XMLLoadingParsingOptions Parsing Options</span>
<a name="l00644"></a>00644 <span class="comment">    /// All document loading functions accept the optional parameter options. This is a bitmask that customizes the parsing process: you can select the node types that are parsed and</span>
<a name="l00645"></a>00645 <span class="comment">    /// various transformations that are performed with the XML text. Disabling certain transformations can improve parsing performance for some documents; however, the code for all</span>
<a name="l00646"></a>00646 <span class="comment">    /// transformations is very well optimized, and thus the majority of documents won&#39;t get any performance benefit. As a general rule, only modify parsing flags if you want to get some</span>
<a name="l00647"></a>00647 <span class="comment">    /// nodes in the document that are excluded by default (i.e. declaration or comment nodes).</span>
<a name="l00648"></a>00648 <span class="comment">    /// @note You should use the usual bitwise arithmetic to manipulate the bitmask: to enable a flag, use mask | flag; to disable a flag, use mask &amp; ~flag.</span>
<a name="l00649"></a>00649 <span class="comment">    ///</span>
<a name="l00650"></a>00650 <span class="comment">    /// These flags control the resulting tree contents:</span>
<a name="l00651"></a>00651 <span class="comment">    ///     - @ref Mezzanine::xml::ParseDeclaration determines if XML document declaration (node with type @ref Mezzanine::xml::NodeType &quot;NodeDeclaration&quot; ) is to be put in DOM tree. If this flag</span>
<a name="l00652"></a>00652 <span class="comment">    ///     is off, it is not put in the tree, but is still parsed and checked for correctness. This flag is off by default.</span>
<a name="l00653"></a>00653 <span class="comment">    ///     - @ref Mezzanine::xml::ParseDocType determines if XML document type declaration (node with type @ref Mezzanine::xml::NodeType &quot;NodeDocType&quot; ) is to be put in DOM tree. If this flag is</span>
<a name="l00654"></a>00654 <span class="comment">    ///     off, it is not put in the tree, but is still parsed and checked for correctness. This flag is off by default.</span>
<a name="l00655"></a>00655 <span class="comment">    ///     - @ref Mezzanine::xml::ParsePi determines if processing instructions (nodes with type @ref Mezzanine::xml::NodeType &quot;NodePi&quot; ) are to be put in DOM tree. If this flag is off, they are</span>
<a name="l00656"></a>00656 <span class="comment">    ///     not put in the tree, but are still parsed and checked for correctness. Note that &quot;&lt;?xml ...?&gt;&quot; (document declaration) is not considered to be a PI. This flag is off by default.</span>
<a name="l00657"></a>00657 <span class="comment">    ///     - @ref Mezzanine::xml::ParseComments determines if comments (nodes with type @ref Mezzanine::xml::NodeType &quot;NodeComment&quot; ) are to be put in DOM tree. If this flag is off, they are not</span>
<a name="l00658"></a>00658 <span class="comment">    ///     put in the tree, but are still parsed and checked for correctness. This flag is off by default.</span>
<a name="l00659"></a>00659 <span class="comment">    ///     - @ref Mezzanine::xml::ParseCdata determines if CDATA sections (nodes with type @ref Mezzanine::xml::NodeType &quot;NodeCdata&quot; ) are to be put in DOM tree. If this flag is off, they are not</span>
<a name="l00660"></a>00660 <span class="comment">    ///     put in the tree, but are still parsed and checked for correctness. This flag is on by default.</span>
<a name="l00661"></a>00661 <span class="comment">    ///     - @ref Mezzanine::xml::ParseWsPcdata determines if PCDATA nodes (nodes with type @ref Mezzanine::xml::NodeType &quot;NodePcdata&quot; ) that consist only of whitespace characters are to be put</span>
<a name="l00662"></a>00662 <span class="comment">    ///     in DOM tree. Often whitespace-only data is not significant for the application, and the cost of allocating and storing such nodes (both memory and speed-wise) can be</span>
<a name="l00663"></a>00663 <span class="comment">    ///     significant. For example, after parsing XML string &quot;&lt;node&gt; &lt;a/&gt; &lt;/node&gt;, &lt;node&gt;&quot; element will have three children when Mezzanine::xml::ParseWsPcdata is set (child with type</span>
<a name="l00664"></a>00664 <span class="comment">    ///     @ref Mezzanine::xml::NodeType &quot;NodePcdata&quot; and value &quot; &quot;, child with type @ref Mezzanine::xml::NodeType &quot;NodeElement&quot; and name &quot;a&quot;, and another child with type</span>
<a name="l00665"></a>00665 <span class="comment">    ///     @ref Mezzanine::xml::NodeType &quot;NodePcdata&quot; and value &quot; &quot;), and only one child when Mezzanine::xml::ParseWsPcdata is not set. This flag is off by default.</span>
<a name="l00666"></a>00666 <span class="comment">    ///</span>
<a name="l00667"></a>00667 <span class="comment">    /// These flags control the transformation of tree element contents:</span>
<a name="l00668"></a>00668 <span class="comment">    ///     - @ref Mezzanine::xml::ParseEscapes determines if character and entity references are to be expanded during the parsing process. Character references have the form \&amp;#...; or</span>
<a name="l00669"></a>00669 <span class="comment">    ///     \&amp;#x...; (... is Unicode numeric representation of character in either decimal ( \&amp;#...; ) or hexadecimal ( \&amp;#x...; ) form), entity references are \&amp;lt;, \&amp;gt;, \&amp;amp;,</span>
<a name="l00670"></a>00670 <span class="comment">    ///     \&amp;apos; and \&amp;quot; (note that as Mezzanine::xml does not handle DTD, the only allowed entities are predefined ones). If character/entity reference can not be expanded, it is</span>
<a name="l00671"></a>00671 <span class="comment">    ///     left as is, so you can do additional processing later. Reference expansion is performed on attribute values and PCDATA content. This flag is on by default.</span>
<a name="l00672"></a>00672 <span class="comment">    ///     - @ref Mezzanine::xml::ParseEol determines if EOL handling (that is, replacing sequences 0x0d 0x0a by a single 0x0a character, and replacing all standalone 0x0d characters by</span>
<a name="l00673"></a>00673 <span class="comment">    ///     0x0a) is to be performed on input data (that is, comments contents, PCDATA/CDATA contents and attribute values). If this is set all \\r \\n will replaced with \\n.</span>
<a name="l00674"></a>00674 <span class="comment">    ///     This flag is on by default.</span>
<a name="l00675"></a>00675 <span class="comment">    ///     - @ref Mezzanine::xml::ParseWconvAttribute determines if attribute value normalization should be performed for all attributes. This means, that whitespace characters (new line,</span>
<a name="l00676"></a>00676 <span class="comment">    ///     tab and space) are replaced with space (&#39; &#39;). New line characters are always treated as if Mezzanine::xml::ParseEol is set, i.e. \\r \\n is converted to a single space. This</span>
<a name="l00677"></a>00677 <span class="comment">    ///     flag is on by default.</span>
<a name="l00678"></a>00678 <span class="comment">    ///     - @ref Mezzanine::xml::ParseWnormAttribute determines if extended attribute value normalization should be performed for all attributes. This means, that after attribute values</span>
<a name="l00679"></a>00679 <span class="comment">    ///     are normalized as if Mezzanine::xml::ParseWconvAttribute was set, leading and trailing space characters are removed, and all sequences of space characters are replaced by a</span>
<a name="l00680"></a>00680 <span class="comment">    ///     single space character. The value of Mezzanine::xml::ParseWconvAttribute was set has no effect if this flag is on. This flag is off by default.</span>
<a name="l00681"></a>00681 <span class="comment">    ///</span>
<a name="l00682"></a>00682 <span class="comment">    /// @note Mezzanine::xml::ParseWconvAttribute option performs transformations that are required by W3C specification for attributes that are declared as CDATA; ParseWnormAttribute performs</span>
<a name="l00683"></a>00683 <span class="comment">    /// transformations required for NMTOKENS attributes. In the absence of document type declaration all attributes should behave as if they are declared as CDATA, thus</span>
<a name="l00684"></a>00684 <span class="comment">    /// Mezzanine::xml::ParseWconvAttribute is the default option.</span>
<a name="l00685"></a>00685 <span class="comment">    ///</span>
<a name="l00686"></a>00686 <span class="comment">    /// Additionally there are three predefined option masks:</span>
<a name="l00687"></a>00687 <span class="comment">    ///     - Mezzanine::xml::ParseMinimal has all options turned off. This option mask means that Mezzanine::xml does not add declaration nodes, document type declaration nodes, PI nodes,</span>
<a name="l00688"></a>00688 <span class="comment">    ///     CDATA sections and comments to the resulting tree and does not perform any conversion for input data, so theoretically it is the fastest mode. However, as mentioned above,</span>
<a name="l00689"></a>00689 <span class="comment">    ///     in practice Mezzanine::xml::ParseDefault is usually equally fast.</span>
<a name="l00690"></a>00690 <span class="comment">    ///     - Mezzanine::xml::ParseDefault is the default set of flags, i.e. it has all options set to their default values. It includes parsing CDATA sections (comments/PIs are not parsed),</span>
<a name="l00691"></a>00691 <span class="comment">    ///     performing character and entity reference expansion, replacing whitespace characters with spaces in attribute values and performing EOL handling. Note, that PCDATA sections</span>
<a name="l00692"></a>00692 <span class="comment">    ///     consisting only of whitespace characters are not parsed (by default) for performance reasons.</span>
<a name="l00693"></a>00693 <span class="comment">    ///     - Mezzanine::xml::ParseFull is the set of flags which adds nodes of all types to the resulting tree and performs default conversions for input data. It includes parsing CDATA</span>
<a name="l00694"></a>00694 <span class="comment">    ///     sections, comments, PI nodes, document declaration node and document type declaration node, performing character and entity reference expansion, replacing whitespace</span>
<a name="l00695"></a>00695 <span class="comment">    ///     characters with spaces in attribute values and performing EOL handling. Note, that PCDATA sections consisting only of whitespace characters are not parsed in this mode.</span>
<a name="l00696"></a>00696 <span class="comment">    ///</span>
<a name="l00697"></a>00697 <span class="comment">    /// This is an example of using different parsing options:</span>
<a name="l00698"></a>00698 <span class="comment">    /// @code</span>
<a name="l00699"></a>00699 <span class="comment">    /// const char* Source = &quot;&lt;!--comment--&gt;&lt;node&gt;&amp;lt;&lt;/node&gt;&quot;;</span>
<a name="l00700"></a>00700 <span class="comment">    ///</span>
<a name="l00701"></a>00701 <span class="comment">    ///  // Parsing with default options; note that comment node is not added to the tree, and entity reference &amp;lt; is expanded</span>
<a name="l00702"></a>00702 <span class="comment">    /// Doc.Load(Source);</span>
<a name="l00703"></a>00703 <span class="comment">    /// std::cout &lt;&lt; &quot;First node value: [&quot; &lt;&lt; Doc.GetFirstChild().Value() &lt;&lt; &quot;], node child value: [&quot; &lt;&lt; Doc.ChildValue(&quot;node&quot;) &lt;&lt; &quot;]\n&quot;;</span>
<a name="l00704"></a>00704 <span class="comment">    ///</span>
<a name="l00705"></a>00705 <span class="comment">    /// // Parsing with additional value option; comment node is now added to the tree</span>
<a name="l00706"></a>00706 <span class="comment">    /// Doc.Load(Source, Mezzanine::xml::ParseDefault | Mezzanine::xml::ParseComments);</span>
<a name="l00707"></a>00707 <span class="comment">    /// std::cout &lt;&lt; &quot;First node value: [&quot; &lt;&lt; Doc.GetFirstChild().Value() &lt;&lt; &quot;], node child value: [&quot; &lt;&lt; Doc.ChildValue(&quot;node&quot;) &lt;&lt; &quot;]\n&quot;;</span>
<a name="l00708"></a>00708 <span class="comment">    ///</span>
<a name="l00709"></a>00709 <span class="comment">    /// // Parsing with additional value option and without the (default) parse_escapes option; &amp;lt; is not expanded</span>
<a name="l00710"></a>00710 <span class="comment">    /// Doc.Load(Source, (Mezzanine::xml::ParseDefault | Mezzanine::xml::ParseComments) &amp; ~Mezzanine::xml::ParseEscapes);</span>
<a name="l00711"></a>00711 <span class="comment">    /// std::cout &lt;&lt; &quot;First node value: [&quot; &lt;&lt; Doc.GetFirstChild().Value() &lt;&lt; &quot;], node child value: [&quot; &lt;&lt; Doc.ChildValue(&quot;node&quot;) &lt;&lt; &quot;]\n&quot;;</span>
<a name="l00712"></a>00712 <span class="comment">    ///</span>
<a name="l00713"></a>00713 <span class="comment">    /// // Parsing with minimal option mask; comment node is not added to the tree, and &amp;lt; is not expanded</span>
<a name="l00714"></a>00714 <span class="comment">    /// Doc.Load(Source, Mezzanine::xml::ParseMinimal);</span>
<a name="l00715"></a>00715 <span class="comment">    /// std::cout &lt;&lt; &quot;First node value: [&quot; &lt;&lt; Doc.GetFirstChild().Value() &lt;&lt; &quot;], node child value: [&quot; &lt;&lt; Doc.ChildValue(&quot;node&quot;) &lt;&lt; &quot;]\n&quot;;</span>
<a name="l00716"></a>00716 <span class="comment">    /// @endcode</span>
<a name="l00717"></a>00717 <span class="comment">    /// @subsection XMLLoadingEncodings Encodings</span>
<a name="l00718"></a>00718 <span class="comment">    /// Mezzanine::xml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it&#39;s a strict subset</span>
<a name="l00719"></a>00719 <span class="comment">    /// of UTF-16) and handles all encoding conversions. Most loading functions accept the optional parameter encoding. This is a value of enumeration type Mezzanine::xml::Encoding, that</span>
<a name="l00720"></a>00720 <span class="comment">    /// can have the following values:</span>
<a name="l00721"></a>00721 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingAuto&quot; means that pugixml will try to guess the encoding based on source XML data. The algorithm is a modified version of the</span>
<a name="l00722"></a>00722 <span class="comment">    ///     one presented in Appendix F.1 of XML recommendation; it tries to match the first few bytes of input data with the following patterns in strict order:</span>
<a name="l00723"></a>00723 <span class="comment">    ///             - If first four bytes match UTF-32 BOM (Byte Order Mark), encoding is assumed to be UTF-32 with the endianness equal to that of BOM;</span>
<a name="l00724"></a>00724 <span class="comment">    ///             - If first two bytes match UTF-16 BOM, encoding is assumed to be UTF-16 with the endianness equal to that of BOM;</span>
<a name="l00725"></a>00725 <span class="comment">    ///             - If first three bytes match UTF-8 BOM, encoding is assumed to be UTF-8;</span>
<a name="l00726"></a>00726 <span class="comment">    ///             - If first four bytes match UTF-32 representation of &lt;, encoding is assumed to be UTF-32 with the corresponding endianness;</span>
<a name="l00727"></a>00727 <span class="comment">    ///             - If first four bytes match UTF-16 representation of &lt;?, encoding is assumed to be UTF-16 with the corresponding endianness;</span>
<a name="l00728"></a>00728 <span class="comment">    ///             - If first two bytes match UTF-16 representation of &lt;, encoding is assumed to be UTF-16 with the corresponding endianness (this guess may yield incorrect result,</span>
<a name="l00729"></a>00729 <span class="comment">    ///             but it&#39;s better than UTF-8);</span>
<a name="l00730"></a>00730 <span class="comment">    ///             - Otherwise encoding is assumed to be UTF-8.</span>
<a name="l00731"></a>00731 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingUTF8&quot; corresponds to UTF-8 encoding as defined in the Unicode standard; UTF-8 sequences with length equal to 5 or 6 are not</span>
<a name="l00732"></a>00732 <span class="comment">    ///     standard and are rejected.</span>
<a name="l00733"></a>00733 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingUTF16LE&quot; corresponds to little-endian UTF-16 encoding as defined in the Unicode standard; surrogate pairs are supported.</span>
<a name="l00734"></a>00734 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingUTF16BE&quot; corresponds to big-endian UTF-16 encoding as defined in the Unicode standard; surrogate pairs are supported.</span>
<a name="l00735"></a>00735 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingUTF16&quot; corresponds to UTF-16 encoding as defined in the Unicode standard; the endianness is assumed to be that of the target</span>
<a name="l00736"></a>00736 <span class="comment">    ///     platform.</span>
<a name="l00737"></a>00737 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingUTF32LE&quot; corresponds to little-endian UTF-32 encoding as defined in the Unicode standard.</span>
<a name="l00738"></a>00738 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingUTF32BE&quot; corresponds to big-endian UTF-32 encoding as defined in the Unicode standard.</span>
<a name="l00739"></a>00739 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::EncodingUTF32&quot; corresponds to UTF-32 encoding as defined in the Unicode standard; the endianness is assumed to be that of the target</span>
<a name="l00740"></a>00740 <span class="comment">    ///     platform.</span>
<a name="l00741"></a>00741 <span class="comment">    ///     - @ref Mezzanine::xml::Encoding &quot;Encoding::Encodingwchar_t &quot; corresponds to the encoding of Mezzanine::xml::wchar_t type; it has the same meaning as either</span>
<a name="l00742"></a>00742 <span class="comment">    ///     @ref Mezzanine::xml::Encoding &quot;EncodingUTF16&quot; or @ref Mezzanine::xml::Encoding &quot;EncodingUTF32&quot;, depending on Mezzanine::xml::wchar_t size.</span>
<a name="l00743"></a>00743 <span class="comment">    ///</span>
<a name="l00744"></a>00744 <span class="comment">    /// The algorithm used for @ref Mezzanine::xml::Encoding &quot;EncodingAuto&quot; correctly detects any supported Unicode encoding for all well-formed XML documents (since they start with document</span>
<a name="l00745"></a>00745 <span class="comment">    /// declaration) and for all other XML documents that start with &lt;; if your XML document does not start with &lt; and has encoding that is different from UTF-8, use the specific encoding.</span>
<a name="l00746"></a>00746 <span class="comment">    /// @note The current behavior for Unicode conversion is to skip all invalid UTF sequences during conversion. This behavior should not be relied upon; moreover, in case no encoding</span>
<a name="l00747"></a>00747 <span class="comment">    /// conversion is performed, the invalid sequences are not removed, so you&#39;ll get them as is in node/attribute contents.</span>
<a name="l00748"></a>00748 <span class="comment">    ///</span>
<a name="l00749"></a>00749 <span class="comment">    /// @subsection XMLLoadingStandards Conformance to W3C Specification</span>
<a name="l00750"></a>00750 <span class="comment">    /// Mezzanine::xml is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject invalid</span>
<a name="l00751"></a>00751 <span class="comment">    /// XML documents, some validation is not performed because of performance reasons.</span>
<a name="l00752"></a>00752 <span class="comment">    /// \n \n There is only one non-conformant behavior when dealing with valid XML documents, Mezzanine::xml does not use information supplied in document type declaration for parsing. This</span>
<a name="l00753"></a>00753 <span class="comment">    /// means that entities declared in DOCTYPE are not expanded, and all attribute/PCDATA values are always processed in a uniform way that depends only on parsing options.</span>
<a name="l00754"></a>00754 <span class="comment">    /// \n \n</span>
<a name="l00755"></a>00755 <span class="comment">    /// As for rejecting invalid XML documents, there are a number of incompatibilities with W3C specification, including:</span>
<a name="l00756"></a>00756 <span class="comment">    ///     - Multiple attributes of the same node can have equal names.</span>
<a name="l00757"></a>00757 <span class="comment">    ///     - All non-ASCII characters are treated in the same way as symbols of English alphabet, so some invalid tag names are not rejected.</span>
<a name="l00758"></a>00758 <span class="comment">    ///     - Attribute values which contain &lt; are not rejected.</span>
<a name="l00759"></a>00759 <span class="comment">    ///     - Invalid entity/character references are not rejected and are instead left as is.</span>
<a name="l00760"></a>00760 <span class="comment">    ///     - Comment values can contain --.</span>
<a name="l00761"></a>00761 <span class="comment">    ///     - XML data is not required to begin with document declaration; additionally, document declaration can appear after comments and other nodes.</span>
<a name="l00762"></a>00762 <span class="comment">    ///     - Invalid document type declarations are silently ignored in some cases.</span>
<a name="l00763"></a>00763 <span class="comment">    ///</span>
<a name="l00764"></a>00764 <span class="comment">    /// @section XMLAccessing Accessing Document Data</span>
<a name="l00765"></a>00765 <span class="comment">    ///     - @ref XMLAccessingBasics</span>
<a name="l00766"></a>00766 <span class="comment">    ///     - @ref XMLAccessingNodeData</span>
<a name="l00767"></a>00767 <span class="comment">    ///     - @ref XMLAccessingAttributeData</span>
<a name="l00768"></a>00768 <span class="comment">    ///     - @ref XMLAccessingContentBased</span>
<a name="l00769"></a>00769 <span class="comment">    ///     - @ref XMLAccessingIterators</span>
<a name="l00770"></a>00770 <span class="comment">    ///     - @ref XMLAccessingWalker</span>
<a name="l00771"></a>00771 <span class="comment">    ///     - @ref XMLAccessingPredicates</span>
<a name="l00772"></a>00772 <span class="comment">    ///     - @ref XMLAccessingMisc</span>
<a name="l00773"></a>00773 <span class="comment">    ///</span>
<a name="l00774"></a>00774 <span class="comment">    /// Mezzanine::xml features an extensive interface for getting various types of data from the document and for traversing the document. This section provides documentation for all such</span>
<a name="l00775"></a>00775 <span class="comment">    /// functions that do not modify the tree except for XPath-related functions; see @ref XMLXPath for XPath reference. As discussed in @ref XMLInterface, there are two types of handles</span>
<a name="l00776"></a>00776 <span class="comment">    /// to tree data - Mezzanine::xml::Node and Mezzanine::xml::Attribute. The handles have special null (empty) values which propagate through various functions and thus are useful for writing</span>
<a name="l00777"></a>00777 <span class="comment">    /// more concise code; see @ref XMLInterface for details. The documentation in this section will explicitly state the results of all function in case of null inputs.</span>
<a name="l00778"></a>00778 <span class="comment">    /// @subsection XMLAccessingBasics Basic traversal functions</span>
<a name="l00779"></a>00779 <span class="comment">    /// The internal representation of the document is a tree, where each node has a list of child nodes (the order of children corresponds to their order in the XML representation),</span>
<a name="l00780"></a>00780 <span class="comment">    /// additionally element nodes have a list of attributes, which is also ordered. Several functions are provided in order to let you get from one node in the tree to the other. These</span>
<a name="l00781"></a>00781 <span class="comment">    /// functions roughly correspond to the internal representation, and thus are usually building blocks for other methods of traversing (i.e. XPath traversals are based on these</span>
<a name="l00782"></a>00782 <span class="comment">    /// functions).</span>
<a name="l00783"></a>00783 <span class="comment">    /// @code</span>
<a name="l00784"></a>00784 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetParent() const;</span>
<a name="l00785"></a>00785 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetFirstChild() const;</span>
<a name="l00786"></a>00786 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetLastChild() const;</span>
<a name="l00787"></a>00787 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetNextSibling() const;</span>
<a name="l00788"></a>00788 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetPreviousSibling() const;</span>
<a name="l00789"></a>00789 <span class="comment">    ///</span>
<a name="l00790"></a>00790 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::GetFirstAttribute() const;</span>
<a name="l00791"></a>00791 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::GetLastAttribute() const;</span>
<a name="l00792"></a>00792 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Attribute::GetNextAttribute() const;</span>
<a name="l00793"></a>00793 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Attribute::GetPreviousAttribute() const;</span>
<a name="l00794"></a>00794 <span class="comment">    /// @endcode</span>
<a name="l00795"></a>00795 <span class="comment">    /// The GetParent function returns the node&#39;s parent; all non-null nodes except the document have non-null parent. GetFirstChild and GetLastChild return the first and last child of the</span>
<a name="l00796"></a>00796 <span class="comment">    /// node, respectively; note that only document nodes and element nodes can have non-empty child node list. If node has no children, both functions return null nodes. GetNextSibling</span>
<a name="l00797"></a>00797 <span class="comment">    /// and GetPreviousSibling return the node that&#39;s immediately to the right/left of this node in the children list, respectively - for example, in &lt;a/&gt; &lt;b/&gt; &lt;c/&gt;, calling GetNextSibling</span>
<a name="l00798"></a>00798 <span class="comment">    /// for a handle that points to &lt;b/&gt; results in a handle pointing to &lt;c/&gt;, and calling GetPreviousSibling results in handle pointing to &lt;a/&gt;. If node does not have next/previous sibling</span>
<a name="l00799"></a>00799 <span class="comment">    /// (this happens if it is the last/first node in the list, respectively), the functions return null nodes. GetFirstAttribute, GetLastAttribute, GetNextAttribute and GetPreviousAttribute</span>
<a name="l00800"></a>00800 <span class="comment">    /// functions behave similarly to the corresponding child node functions and allow to iterate through attribute list in the same way.</span>
<a name="l00801"></a>00801 <span class="comment">    /// @note Because of memory consumption reasons, attributes do not have a link to their parent nodes. Thus there is no Mezzanine::xml::attribute::parent() function.</span>
<a name="l00802"></a>00802 <span class="comment">    ///</span>
<a name="l00803"></a>00803 <span class="comment">    /// Calling any of the functions above on the null handle results in a null handle - i.e. node.GetFirstChild().GetNextSibling() returns the second child of node, and null handle if node</span>
<a name="l00804"></a>00804 <span class="comment">    /// is null, has no children at all or if it has only one child node.</span>
<a name="l00805"></a>00805 <span class="comment">    /// \n \n</span>
<a name="l00806"></a>00806 <span class="comment">    /// With these functions, you can iterate through all child nodes and display all attributes like this:</span>
<a name="l00807"></a>00807 <span class="comment">    /// @code</span>
<a name="l00808"></a>00808 <span class="comment">    /// for (Mezzanine::xml::Node tool = tools.GetFirstChild(); tool; tool = tool.GetNextSibling())</span>
<a name="l00809"></a>00809 <span class="comment">    /// {</span>
<a name="l00810"></a>00810 <span class="comment">    ///     std::cout &lt;&lt; &quot;Tool:&quot;;</span>
<a name="l00811"></a>00811 <span class="comment">    ///</span>
<a name="l00812"></a>00812 <span class="comment">    ///     for (Mezzanine::xml::Attribute attr = tool.GetFirstAttribute(); attr; attr = attr.GetNextAttribute())</span>
<a name="l00813"></a>00813 <span class="comment">    ///     {</span>
<a name="l00814"></a>00814 <span class="comment">    ///         std::cout &lt;&lt; &quot; &quot; &lt;&lt; attr.Name() &lt;&lt; &quot;=&quot; &lt;&lt; attr.Value();</span>
<a name="l00815"></a>00815 <span class="comment">    ///     }</span>
<a name="l00816"></a>00816 <span class="comment">    ///</span>
<a name="l00817"></a>00817 <span class="comment">    ///     std::cout &lt;&lt; std::endl;</span>
<a name="l00818"></a>00818 <span class="comment">    /// }</span>
<a name="l00819"></a>00819 <span class="comment">    /// @endcode</span>
<a name="l00820"></a>00820 <span class="comment">    /// @subsection XMLAccessingNodeData Getting Node Data</span>
<a name="l00821"></a>00821 <span class="comment">    /// Apart from structural information (parent, child nodes, attributes), nodes can have name and value, both of which are strings. Depending on node type, name or value may be absent.</span>
<a name="l00822"></a>00822 <span class="comment">    /// @ref Mezzanine::xml::NodeType &quot;NodeDocument&quot; nodes do not have a name or value, @ref Mezzanine::xml::NodeType &quot;NodeElement&quot; and @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDeclaration&quot; nodes</span>
<a name="l00823"></a>00823 <span class="comment">    /// always have a name but never have a value, @ref Mezzanine::xml::NodeType &quot;NodeType::NodePcdata&quot;, @ref Mezzanine::xml::NodeType &quot;NodeType::NodeCdata&quot;,</span>
<a name="l00824"></a>00824 <span class="comment">    /// @ref Mezzanine::xml::NodeType &quot;NodeType::NodeComment&quot; and @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDocType&quot; nodes never have a name but always have a value (it may be empty though),</span>
<a name="l00825"></a>00825 <span class="comment">    /// @ref Mezzanine::xml::NodeType &quot;NodeType::NodePi&quot; nodes always have a name and a value (again, value may be empty). In order to get node&#39;s name or value, you can use the following</span>
<a name="l00826"></a>00826 <span class="comment">    /// functions:</span>
<a name="l00827"></a>00827 <span class="comment">    /// @code</span>
<a name="l00828"></a>00828 <span class="comment">    /// const char_t* Mezzanine::xml::Node::Name() const;</span>
<a name="l00829"></a>00829 <span class="comment">    /// const char_t* Mezzanine::xml::Node::Value() const;</span>
<a name="l00830"></a>00830 <span class="comment">    /// @endcode</span>
<a name="l00831"></a>00831 <span class="comment">    /// In case node does not have a name or value or if the node handle is null, both functions return empty strings - they never return null pointers.</span>
<a name="l00832"></a>00832 <span class="comment">    /// \n \n</span>
<a name="l00833"></a>00833 <span class="comment">    /// It is common to store data as text contents of some node - i.e. &lt;node&gt; &lt;description&gt; This is a node &lt;/description&gt; &lt;/node&gt;. In this case, &lt;description&gt; node does not have</span>
<a name="l00834"></a>00834 <span class="comment">    /// a value, but instead has a child of type @ref Mezzanine::xml::NodeType &quot;NodeType::NodePcdata&quot; with value &quot;This is a node&quot;. Mezzanine::xml provides two helper functions to parse such data:</span>
<a name="l00835"></a>00835 <span class="comment">    /// @code</span>
<a name="l00836"></a>00836 <span class="comment">    /// const char_t* Mezzanine::xml::Node::ChildValue() const;</span>
<a name="l00837"></a>00837 <span class="comment">    /// const char_t* Mezzanine::xml::Node::ChildValue(const char_t* name) const;</span>
<a name="l00838"></a>00838 <span class="comment">    /// @endcode</span>
<a name="l00839"></a>00839 <span class="comment">    /// ChildValue() returns the value of the first child with type @ref Mezzanine::xml::NodeType &quot;NodeType::NodePcdata&quot; or @ref Mezzanine::xml::NodeType &quot;NodeType::NodeCdata&quot;;</span>
<a name="l00840"></a>00840 <span class="comment">    /// ChildValue(Name) is a simple wrapper for Child(Name).ChildValue(). For the above example, calling node.ChildValue(&quot;description&quot;) and description.ChildValue() will both produce</span>
<a name="l00841"></a>00841 <span class="comment">    /// string &quot;This is a node&quot;. If there is no child with relevant type, or if the handle is null, ChildValue functions return empty string.</span>
<a name="l00842"></a>00842 <span class="comment">    /// \n \n</span>
<a name="l00843"></a>00843 <span class="comment">    /// There is an example of using some of these functions @ref XMLAccessingAttributeData &quot;at the end of the next section&quot;.</span>
<a name="l00844"></a>00844 <span class="comment">    /// @subsection XMLAccessingAttributeData Getting attribute data</span>
<a name="l00845"></a>00845 <span class="comment">    /// All attributes have name and value, both of which are strings (value may be empty). There are two corresponding accessors:</span>
<a name="l00846"></a>00846 <span class="comment">    /// @code</span>
<a name="l00847"></a>00847 <span class="comment">    /// const char_t* Mezzanine::xml::Attribute::Name() const;</span>
<a name="l00848"></a>00848 <span class="comment">    /// const char_t* Mezzanine::xml::Attribute::Value() const;</span>
<a name="l00849"></a>00849 <span class="comment">    /// @endcode</span>
<a name="l00850"></a>00850 <span class="comment">    /// In case the attribute handle is null, both functions return empty strings - they never return null pointers.</span>
<a name="l00851"></a>00851 <span class="comment">    /// \n \n</span>
<a name="l00852"></a>00852 <span class="comment">    /// In many cases attribute values have types that are not strings - i.e. an attribute may always contain values that should be treated as integers, despite the fact that they are</span>
<a name="l00853"></a>00853 <span class="comment">    /// represented as strings in XML. Mezzanine::xml provides several accessors that convert attribute value to some other type:</span>
<a name="l00854"></a>00854 <span class="comment">    /// @code</span>
<a name="l00855"></a>00855 <span class="comment">    /// // Native C++ types</span>
<a name="l00856"></a>00856 <span class="comment">    /// bool Mezzanine::xml::Attribute::AsBool() const;</span>
<a name="l00857"></a>00857 <span class="comment">    /// double Mezzanine::xml::Attribute::AsDouble() const;</span>
<a name="l00858"></a>00858 <span class="comment">    /// float Mezzanine::xml::Attribute::AsFloat() const;</span>
<a name="l00859"></a>00859 <span class="comment">    /// int Mezzanine::xml::Attribute::AsInt() const;</span>
<a name="l00860"></a>00860 <span class="comment">    /// unsigned int Mezzanine::xml::Attribute::AsUint() const;</span>
<a name="l00861"></a>00861 <span class="comment">    ///</span>
<a name="l00862"></a>00862 <span class="comment">    /// //Mezzanine abstracted types</span>
<a name="l00863"></a>00863 <span class="comment">    /// Real Mezzanine::xml::Attribute::AsReal() const;</span>
<a name="l00864"></a>00864 <span class="comment">    /// String Mezzanine::xml::Attribute::AsString() const;</span>
<a name="l00865"></a>00865 <span class="comment">    /// Whole Mezzanine::xml::Attribute::AsWhole() const;</span>
<a name="l00866"></a>00866 <span class="comment">    /// @endcode</span>
<a name="l00867"></a>00867 <span class="comment">    /// AsDouble, AsFloat, AsInt, AsUint, AsReal and AsWhole convert attribute values to numbers. If attribute handle is null or attribute value is empty, 0 is returned. Otherwise, all</span>
<a name="l00868"></a>00868 <span class="comment">    /// leading whitespace characters are truncated, and the remaining string is parsed as a decimal number (AsInt, AsUint or AsWhole) or as a floating point number in either decimal</span>
<a name="l00869"></a>00869 <span class="comment">    /// or scientific form (AsDouble, AsFloat or AsReal). Any extra characters are silently discarded, i.e. AsInt will return 1 for string &quot;1abc&quot;.</span>
<a name="l00870"></a>00870 <span class="comment">    /// \n \n</span>
<a name="l00871"></a>00871 <span class="comment">    /// In case the input string contains a number that is out of the target numeric range, the result is undefined.</span>
<a name="l00872"></a>00872 <span class="comment">    /// @warning Some number conversion functions depend on current C locale as set with setlocale, so may return unexpected results if the locale is different from &quot;C&quot;.</span>
<a name="l00873"></a>00873 <span class="comment">    ///</span>
<a name="l00874"></a>00874 <span class="comment">    /// AsBool converts attribute value to boolean as follows: if attribute handle is null or attribute value is empty, false is returned. Otherwise, true is returned if the first</span>
<a name="l00875"></a>00875 <span class="comment">    /// character is one of &#39;1&#39;, &#39;t&#39;, &#39;T&#39;, &#39;y&#39;, &#39;Y&#39;. This means that strings like &quot;true&quot; and &quot;yes&quot; are recognized as true, while strings like &quot;false&quot; and &quot;no&quot; are recognized as false.</span>
<a name="l00876"></a>00876 <span class="comment">    /// For more complex matching you&#39;ll have to write your own function.</span>
<a name="l00877"></a>00877 <span class="comment">    /// @note There are no portable 64-bit types in C++, so there is no corresponding conversion function. If your platform has a 64-bit integer, you can easily write a conversion</span>
<a name="l00878"></a>00878 <span class="comment">    /// function yourself. We are planning on addressing this with a new Mezzanine abstracted type, but we have not done so yet.</span>
<a name="l00879"></a>00879 <span class="comment">    ///</span>
<a name="l00880"></a>00880 <span class="comment">    /// This is an example of using these functions, along with node data retrieval ones:</span>
<a name="l00881"></a>00881 <span class="comment">    /// @code</span>
<a name="l00882"></a>00882 <span class="comment">    /// for (Mezzanine::xml::Node tool = tools.GetChild(&quot;Tool&quot;); tool; tool = tool.GetNextSibling(&quot;Tool&quot;))</span>
<a name="l00883"></a>00883 <span class="comment">    /// {</span>
<a name="l00884"></a>00884 <span class="comment">    ///     std::cout &lt;&lt; &quot;Tool &quot; &lt;&lt; tool.GetAttribute(&quot;Filename&quot;).Value();</span>
<a name="l00885"></a>00885 <span class="comment">    ///     std::cout &lt;&lt; &quot;: AllowRemote &quot; &lt;&lt; tool.GetAttribute(&quot;AllowRemote&quot;).AsBool();</span>
<a name="l00886"></a>00886 <span class="comment">    ///     std::cout &lt;&lt; &quot;, Timeout &quot; &lt;&lt; tool.GetAttribute(&quot;Timeout&quot;).AsInt();</span>
<a name="l00887"></a>00887 <span class="comment">    ///     std::cout &lt;&lt; &quot;, Description &#39;&quot; &lt;&lt; tool.ChildValue(&quot;Description&quot;) &lt;&lt; &quot;&#39;\n&quot;;</span>
<a name="l00888"></a>00888 <span class="comment">    /// }</span>
<a name="l00889"></a>00889 <span class="comment">    /// @endcode</span>
<a name="l00890"></a>00890 <span class="comment">    /// @subsection XMLAccessingContentBased Content Based Traversal Functions</span>
<a name="l00891"></a>00891 <span class="comment">    /// Since a lot of document traversal consists of finding the node/attribute with the correct name, there are special functions for that purpose:</span>
<a name="l00892"></a>00892 <span class="comment">    /// @code</span>
<a name="l00893"></a>00893 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetChild(const char_t* name) const;</span>
<a name="l00894"></a>00894 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::GetAttribute(const char_t* name) const;</span>
<a name="l00895"></a>00895 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetNextSibling(const char_t* name) const;</span>
<a name="l00896"></a>00896 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetPreviousSibling(const char_t* name) const;</span>
<a name="l00897"></a>00897 <span class="comment">    /// @endcode</span>
<a name="l00898"></a>00898 <span class="comment">    /// GetChild and GetAttribute return the first child/attribute with the specified name; GetNextSibling and GetPreviousSibling return the first sibling in the corresponding direction</span>
<a name="l00899"></a>00899 <span class="comment">    /// with the specified name. All string comparisons are case-sensitive. In case the node handle is null or there is no node/attribute with the specified name, null handle is returned.</span>
<a name="l00900"></a>00900 <span class="comment">    /// \n \n</span>
<a name="l00901"></a>00901 <span class="comment">    /// GetChild and GetNextSibling functions can be used together to loop through all child nodes with the desired name like this:</span>
<a name="l00902"></a>00902 <span class="comment">    /// @code</span>
<a name="l00903"></a>00903 <span class="comment">    /// for (Mezzanine::xml::Node tool = tools.GetChild(&quot;Tool&quot;); tool; tool = tool.GetNextSibling(&quot;Tool&quot;))</span>
<a name="l00904"></a>00904 <span class="comment">    ///     {}</span>
<a name="l00905"></a>00905 <span class="comment">    /// @endcode</span>
<a name="l00906"></a>00906 <span class="comment">    /// Occasionally the needed node is specified not by the unique name but instead by the value of some attribute; for example, it is common to have node collections with each node</span>
<a name="l00907"></a>00907 <span class="comment">    /// having a unique id: &lt;group&gt; &lt;item id=&quot;1&quot;/&gt; &lt;item id=&quot;2&quot;/&gt; &lt;/group&gt;. There are two functions for finding child nodes based on the attribute values:</span>
<a name="l00908"></a>00908 <span class="comment">    /// @code</span>
<a name="l00909"></a>00909 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::FindChildbyAttribute(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;</span>
<a name="l00910"></a>00910 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::FindChildbyAttribute(const char_t* attr_name, const char_t* attr_value) const;</span>
<a name="l00911"></a>00911 <span class="comment">    /// @endcode</span>
<a name="l00912"></a>00912 <span class="comment">    /// The three-argument function returns the first child node with the specified name which has an attribute with the specified name/value; the two-argument function skips the name</span>
<a name="l00913"></a>00913 <span class="comment">    /// test for the node, which can be useful for searching in heterogeneous collections. If the node handle is null or if no node is found, null handle is returned. All string</span>
<a name="l00914"></a>00914 <span class="comment">    /// comparisons are case-sensitive.</span>
<a name="l00915"></a>00915 <span class="comment">    /// \n \n</span>
<a name="l00916"></a>00916 <span class="comment">    /// In all of the above functions, all arguments have to be valid strings; passing null pointers results in undefined behavior.</span>
<a name="l00917"></a>00917 <span class="comment">    ///</span>
<a name="l00918"></a>00918 <span class="comment">    /// This is an example of using these functions:</span>
<a name="l00919"></a>00919 <span class="comment">    /// @code</span>
<a name="l00920"></a>00920 <span class="comment">    /// std::cout &lt;&lt; &quot;Tool for *.dae generation: &quot; &lt;&lt; tools.FindChildbyAttribute(&quot;Tool&quot;, &quot;OutputFileMasks&quot;, &quot;*.dae&quot;).GetAttribute(&quot;Filename&quot;).Value() &lt;&lt; &quot;\n&quot;;</span>
<a name="l00921"></a>00921 <span class="comment">    ///</span>
<a name="l00922"></a>00922 <span class="comment">    /// for (Mezzanine::xml::Node tool = tools.GetChild(&quot;Tool&quot;); tool; tool = tool.GetNextSibling(&quot;Tool&quot;))</span>
<a name="l00923"></a>00923 <span class="comment">    /// {</span>
<a name="l00924"></a>00924 <span class="comment">    ///     std::cout &lt;&lt; &quot;Tool &quot; &lt;&lt; tool.GetAttribute(&quot;Filename&quot;).Value() &lt;&lt; &quot;\n&quot;;</span>
<a name="l00925"></a>00925 <span class="comment">    /// }</span>
<a name="l00926"></a>00926 <span class="comment">    /// @endcode</span>
<a name="l00927"></a>00927 <span class="comment">    /// @subsection XMLAccessingIterators Traversing Node/Attribute Lists via Iterators</span>
<a name="l00928"></a>00928 <span class="comment">    /// Child node lists and attribute lists are simply double-linked lists; while you can use GetPreviousSibling/GetNextSibling and other such functions for iteration, Mezzanine::xml</span>
<a name="l00929"></a>00929 <span class="comment">    /// additionally provides node and attribute iterators, so that you can treat nodes as containers of other nodes or attributes:</span>
<a name="l00930"></a>00930 <span class="comment">    /// @code</span>
<a name="l00931"></a>00931 <span class="comment">    /// class Mezzanine::xml::NodeIterator;</span>
<a name="l00932"></a>00932 <span class="comment">    /// class Mezzanine::xml::AttributeIterator;</span>
<a name="l00933"></a>00933 <span class="comment">    ///</span>
<a name="l00934"></a>00934 <span class="comment">    /// typedef Mezzanine::xml::NodeIterator Mezzanine::xml::Node::iterator;</span>
<a name="l00935"></a>00935 <span class="comment">    /// iterator Mezzanine::xml::Node::begin() const;</span>
<a name="l00936"></a>00936 <span class="comment">    /// iterator Mezzanine::xml::Node::end() const;</span>
<a name="l00937"></a>00937 <span class="comment">    ///</span>
<a name="l00938"></a>00938 <span class="comment">    /// typedef Mezzanine::xml::AttributeIterator Mezzanine::xml::Node::attribute_iterator;</span>
<a name="l00939"></a>00939 <span class="comment">    /// attribute_iterator Mezzanine::xml::Node::attributes_begin() const;</span>
<a name="l00940"></a>00940 <span class="comment">    /// attribute_iterator Mezzanine::xml::Node::attributes_end() const;</span>
<a name="l00941"></a>00941 <span class="comment">    /// @endcode</span>
<a name="l00942"></a>00942 <span class="comment">    /// begin and attributes_begin return iterators that point to the first node/attribute, respectively; end and attributes_end return past-the-end iterator for node/attribute list,</span>
<a name="l00943"></a>00943 <span class="comment">    /// respectively - this iterator can&#39;t be dereferenced, but decrementing it results in an iterator pointing to the last element in the list (except for empty lists, where decrementing</span>
<a name="l00944"></a>00944 <span class="comment">    /// past-the-end iterator results in undefined behavior). Past-the-end iterator is commonly used as a termination value for iteration loops (see sample below). If you want to get an</span>
<a name="l00945"></a>00945 <span class="comment">    /// iterator that points to an existing handle, you can construct the iterator with the handle as a single constructor argument, like so: Mezzanine::xml::NodeIterator(node). For</span>
<a name="l00946"></a>00946 <span class="comment">    /// Mezzanine::xml::AttributeIterator, you&#39;ll have to provide both an attribute and its parent node.</span>
<a name="l00947"></a>00947 <span class="comment">    /// \n \n</span>
<a name="l00948"></a>00948 <span class="comment">    /// begin and end return equal iterators if called on null node; such iterators can&#39;t be dereferenced. attributes_begin and attributes_end behave the same way. For correct iterator</span>
<a name="l00949"></a>00949 <span class="comment">    /// usage this means that child node/attribute collections of null nodes appear to be empty.</span>
<a name="l00950"></a>00950 <span class="comment">    /// @note The names begin, end, attribute_begin and attribute_end were chosen for maximum compatibility. Some template functions that act on containers rely on the name begin and end.</span>
<a name="l00951"></a>00951 <span class="comment">    /// We may develop a naming scheme that fits better into the existing API in the future.</span>
<a name="l00952"></a>00952 <span class="comment">    ///</span>
<a name="l00953"></a>00953 <span class="comment">    /// Both types of iterators have bidirectional iterator semantics (i.e. they can be incremented and decremented, but efficient random access is not supported) and support all usual</span>
<a name="l00954"></a>00954 <span class="comment">    /// iterator operations - comparison, dereference, etc. The iterators are invalidated if the node/attribute objects they&#39;re pointing to are removed from the tree; adding</span>
<a name="l00955"></a>00955 <span class="comment">    /// nodes/attributes does not invalidate any iterators.</span>
<a name="l00956"></a>00956 <span class="comment">    /// \n \n</span>
<a name="l00957"></a>00957 <span class="comment">    /// Here is an example of using iterators for document traversal:</span>
<a name="l00958"></a>00958 <span class="comment">    /// @code</span>
<a name="l00959"></a>00959 <span class="comment">    /// for (Mezzanine::xml::NodeIterator it = tools.begin(); it != tools.end(); ++it)</span>
<a name="l00960"></a>00960 <span class="comment">    /// {</span>
<a name="l00961"></a>00961 <span class="comment">    ///     std::cout &lt;&lt; &quot;Tool:&quot;;</span>
<a name="l00962"></a>00962 <span class="comment">    ///</span>
<a name="l00963"></a>00963 <span class="comment">    ///     for (Mezzanine::xml::AttributeIterator ait = it-&gt;attributes_begin(); ait != it-&gt;attributes_end(); ++ait)</span>
<a name="l00964"></a>00964 <span class="comment">    ///     {</span>
<a name="l00965"></a>00965 <span class="comment">    ///         std::cout &lt;&lt; &quot; &quot; &lt;&lt; ait-&gt;Name() &lt;&lt; &quot;=&quot; &lt;&lt; ait-&gt;Value();</span>
<a name="l00966"></a>00966 <span class="comment">    ///     }</span>
<a name="l00967"></a>00967 <span class="comment">    ///</span>
<a name="l00968"></a>00968 <span class="comment">    ///     std::cout &lt;&lt; std::endl;</span>
<a name="l00969"></a>00969 <span class="comment">    /// }</span>
<a name="l00970"></a>00970 <span class="comment">    /// @endcode</span>
<a name="l00971"></a>00971 <span class="comment">    /// @warning Node and attribute iterators are somewhere in the middle between const and non-const iterators. While dereference operation yields a non-constant reference to the object,</span>
<a name="l00972"></a>00972 <span class="comment">    /// so that you can use it for tree modification operations, modifying this reference by assignment - i.e. passing iterators to a function like std::sort - will not give expected results,</span>
<a name="l00973"></a>00973 <span class="comment">    /// as assignment modifies local handle that&#39;s stored in the iterator.</span>
<a name="l00974"></a>00974 <span class="comment">    ///</span>
<a name="l00975"></a>00975 <span class="comment">    /// @subsection XMLAccessingWalker Recursive traversal with Mezzanine::xml::TreeWalker</span>
<a name="l00976"></a>00976 <span class="comment">    /// The methods described above allow traversal of immediate children of some node; if you want to do a deep tree traversal, you&#39;ll have to do it via a recursive function or some</span>
<a name="l00977"></a>00977 <span class="comment">    /// equivalent method. However, pugixml provides a helper for depth-first traversal of a subtree. In order to use it, you have to implement the Mezzanine::xml::TreeWalker interface and to</span>
<a name="l00978"></a>00978 <span class="comment">    /// call the Mezzanine::xml::Node::Traverse function.</span>
<a name="l00979"></a>00979 <span class="comment">    /// @code</span>
<a name="l00980"></a>00980 <span class="comment">    /// bool Mezzanine::xml::Node::Traverse(Mezzanine::xml::TreeWalker&amp; walker);</span>
<a name="l00981"></a>00981 <span class="comment">    /// @endcode</span>
<a name="l00982"></a>00982 <span class="comment">    /// The traversal is launched by calling traverse function on traversal root and proceeds as follows:</span>
<a name="l00983"></a>00983 <span class="comment">    ///     - First, TreeWalker::begin function is called with traversal root as its argument.</span>
<a name="l00984"></a>00984 <span class="comment">    ///     - Then, TreeWalker::for_each function is called for all nodes in the traversal subtree in depth first order, excluding the traversal root. Node is passed as an argument.</span>
<a name="l00985"></a>00985 <span class="comment">    ///     - Finally, TreeWalker::end function is called with traversal root as its argument.</span>
<a name="l00986"></a>00986 <span class="comment">    ///</span>
<a name="l00987"></a>00987 <span class="comment">    /// @warning The Names of the Treewalker could change without notice prior to the initial of the engine.</span>
<a name="l00988"></a>00988 <span class="comment">    ///</span>
<a name="l00989"></a>00989 <span class="comment">    /// If begin, end or any of the for_each calls return false, the traversal is terminated and false is returned as the traversal result; otherwise, the traversal results in true.</span>
<a name="l00990"></a>00990 <span class="comment">    /// Note that you don&#39;t have to override begin or end functions; their default implementations return true.</span>
<a name="l00991"></a>00991 <span class="comment">    /// \n \n</span>
<a name="l00992"></a>00992 <span class="comment">    /// You can get the node&#39;s depth relative to the traversal root at any point by calling TreeWalker::Depth function. It returns -1 if called from begin/end, and returns 0-based depth if</span>
<a name="l00993"></a>00993 <span class="comment">    /// called from TreeWalker::for_each - depth is 0 for all children of the traversal root, 1 for all grandchildren and so on.</span>
<a name="l00994"></a>00994 <span class="comment">    /// \n \n</span>
<a name="l00995"></a>00995 <span class="comment">    /// This is an example of traversing tree hierarchy with Mezzanine::xml::TreeWalker:</span>
<a name="l00996"></a>00996 <span class="comment">    /// @code</span>
<a name="l00997"></a>00997 <span class="comment">    /// struct SimpleWalker: Mezzanine::xml::TreeWalker</span>
<a name="l00998"></a>00998 <span class="comment">    /// {</span>
<a name="l00999"></a>00999 <span class="comment">    ///     virtual bool for_each(Mezzanine::xml::Node&amp; node)</span>
<a name="l01000"></a>01000 <span class="comment">    ///     {</span>
<a name="l01001"></a>01001 <span class="comment">    ///         for (int i = 0; i &lt; Depth(); ++i) std::cout &lt;&lt; &quot;  &quot;; // indentation</span>
<a name="l01002"></a>01002 <span class="comment">    ///</span>
<a name="l01003"></a>01003 <span class="comment">    ///         std::cout &lt;&lt; &quot;: Name=&#39;&quot; &lt;&lt; node.Name() &lt;&lt; &quot;&#39;, Value=&#39;&quot; &lt;&lt; node.Value() &lt;&lt; &quot;&#39;\n&quot;;</span>
<a name="l01004"></a>01004 <span class="comment">    ///</span>
<a name="l01005"></a>01005 <span class="comment">    ///         return true; // continue traversal</span>
<a name="l01006"></a>01006 <span class="comment">    ///     }</span>
<a name="l01007"></a>01007 <span class="comment">    /// };</span>
<a name="l01008"></a>01008 <span class="comment">    /// @endcode</span>
<a name="l01009"></a>01009 <span class="comment">    /// @code</span>
<a name="l01010"></a>01010 <span class="comment">    /// SimpleWalker walker;</span>
<a name="l01011"></a>01011 <span class="comment">    /// Doc.Traverse(walker);</span>
<a name="l01012"></a>01012 <span class="comment">    /// @endcode</span>
<a name="l01013"></a>01013 <span class="comment">    /// @subsection XMLAccessingPredicates Searching for Nodes/Attributes with Predicates</span>
<a name="l01014"></a>01014 <span class="comment">    /// While there are existing functions for getting a node/attribute with known contents, they are often not sufficient for simple queries. As an alternative for manual iteration</span>
<a name="l01015"></a>01015 <span class="comment">    /// through nodes/attributes until the needed one is found, you can make a predicate and call one of Find functions:</span>
<a name="l01016"></a>01016 <span class="comment">    /// @code</span>
<a name="l01017"></a>01017 <span class="comment">    /// template &lt;typename Predicate&gt; Mezzanine::xml::Attribute Mezzanine::xml::Node::FindAttribute(Predicate pred) const;</span>
<a name="l01018"></a>01018 <span class="comment">    /// template &lt;typename Predicate&gt; Mezzanine::xml::Node Mezzanine::xml::Node::FindChild(Predicate pred) const;</span>
<a name="l01019"></a>01019 <span class="comment">    /// template &lt;typename Predicate&gt; Mezzanine::xml::Node Mezzanine::xml::Node::FindNode(Predicate pred) const;</span>
<a name="l01020"></a>01020 <span class="comment">    /// @endcode</span>
<a name="l01021"></a>01021 <span class="comment">    /// The predicate should be either a plain function or a function object which accepts one argument of type Mezzanine::xml::Attribute (for FindAttribute) or Mezzanine::xml::Node (for FindChild</span>
<a name="l01022"></a>01022 <span class="comment">    /// and FindNode), and returns bool. The predicate is never called with null handle as an argument.</span>
<a name="l01023"></a>01023 <span class="comment">    /// \n \n</span>
<a name="l01024"></a>01024 <span class="comment">    /// Mezzanine::xml::Node::FindAttribute function iterates through all attributes of the specified node, and returns the first attribute for which the predicate returned true. If the</span>
<a name="l01025"></a>01025 <span class="comment">    /// predicate returned false for all attributes or if there were no attributes (including the case where the node is null), null attribute is returned.</span>
<a name="l01026"></a>01026 <span class="comment">    /// \n \n</span>
<a name="l01027"></a>01027 <span class="comment">    /// Mezzanine::xml::Node::FindChild function iterates through all child nodes of the specified node, and returns the first node for which the predicate returned true. If the predicate</span>
<a name="l01028"></a>01028 <span class="comment">    /// returned false for all nodes or if there were no child nodes (including the case where the node is null), null node is returned.</span>
<a name="l01029"></a>01029 <span class="comment">    /// \n \n</span>
<a name="l01030"></a>01030 <span class="comment">    /// Mezzanine::xml::Node::FindNode function performs a depth-first traversal through the subtree of the specified node (excluding the node itself), and returns the first node for which</span>
<a name="l01031"></a>01031 <span class="comment">    /// the predicate returned true. If the predicate returned false for all nodes or if subtree was empty, null node is returned.</span>
<a name="l01032"></a>01032 <span class="comment">    /// \n \n</span>
<a name="l01033"></a>01033 <span class="comment">    /// Here are some sample predicates:</span>
<a name="l01034"></a>01034 <span class="comment">    /// @code</span>
<a name="l01035"></a>01035 <span class="comment">    /// bool SmallTimeout(Mezzanine::xml::Node node)</span>
<a name="l01036"></a>01036 <span class="comment">    /// {</span>
<a name="l01037"></a>01037 <span class="comment">    ///     return node.GetAttribute(&quot;Timeout&quot;).AsInt() &lt; 20;</span>
<a name="l01038"></a>01038 <span class="comment">    /// }</span>
<a name="l01039"></a>01039 <span class="comment">    ///</span>
<a name="l01040"></a>01040 <span class="comment">    /// struct AllowRemotePredicate</span>
<a name="l01041"></a>01041 <span class="comment">    /// {</span>
<a name="l01042"></a>01042 <span class="comment">    ///     bool operator()(Mezzanine::xml::Attribute attr) const</span>
<a name="l01043"></a>01043 <span class="comment">    ///     {</span>
<a name="l01044"></a>01044 <span class="comment">    ///         return strcmp(attr.Name(), &quot;AllowRemote&quot;) == 0;</span>
<a name="l01045"></a>01045 <span class="comment">    ///     }</span>
<a name="l01046"></a>01046 <span class="comment">    ///</span>
<a name="l01047"></a>01047 <span class="comment">    ///     bool operator()(Mezzanine::xml::Node node) const</span>
<a name="l01048"></a>01048 <span class="comment">    ///     {</span>
<a name="l01049"></a>01049 <span class="comment">    ///         return node.GetAttribute(&quot;AllowRemote&quot;).AsBool();</span>
<a name="l01050"></a>01050 <span class="comment">    ///     }</span>
<a name="l01051"></a>01051 <span class="comment">    /// };</span>
<a name="l01052"></a>01052 <span class="comment">    /// @endcode</span>
<a name="l01053"></a>01053 <span class="comment">    /// This is an example of using predicate-based functions:</span>
<a name="l01054"></a>01054 <span class="comment">    /// @code</span>
<a name="l01055"></a>01055 <span class="comment">    /// // Find child via predicate (looks for direct children only)</span>
<a name="l01056"></a>01056 <span class="comment">    /// std::cout &lt;&lt; tools.FindChild(AllowRemotePredicate()).GetAttribute(&quot;Filename&quot;).Value() &lt;&lt; std::endl;</span>
<a name="l01057"></a>01057 <span class="comment">    ///</span>
<a name="l01058"></a>01058 <span class="comment">    /// // Find node via predicate (looks for all descendants in depth-first order)</span>
<a name="l01059"></a>01059 <span class="comment">    /// std::cout &lt;&lt; doc.FindNode(AllowRemotePredicate()).GetAttribute(&quot;Filename&quot;).Value() &lt;&lt; std::endl;</span>
<a name="l01060"></a>01060 <span class="comment">    ///</span>
<a name="l01061"></a>01061 <span class="comment">    /// // Find attribute via predicate</span>
<a name="l01062"></a>01062 <span class="comment">    /// std::cout &lt;&lt; tools.LastChild().FindAttribute(AllowRemotePredicate()).Value() &lt;&lt; std::endl;</span>
<a name="l01063"></a>01063 <span class="comment">    ///</span>
<a name="l01064"></a>01064 <span class="comment">    /// // We can use simple functions instead of function objects</span>
<a name="l01065"></a>01065 <span class="comment">    /// std::cout &lt;&lt; tools.FindChild(SmallTimeout).GetAttribute(&quot;Filename&quot;).Value() &lt;&lt; std::endl;</span>
<a name="l01066"></a>01066 <span class="comment">    /// @endcode</span>
<a name="l01067"></a>01067 <span class="comment">    /// @subsection XMLAccessingMisc Miscellaneous functions</span>
<a name="l01068"></a>01068 <span class="comment">    /// If you need to get the document root of some node, you can use the following function:</span>
<a name="l01069"></a>01069 <span class="comment">    /// @code</span>
<a name="l01070"></a>01070 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::GetRoot() const;</span>
<a name="l01071"></a>01071 <span class="comment">    /// @endcode</span>
<a name="l01072"></a>01072 <span class="comment">    /// This function returns the node with type @ref Mezzanine::xml::NodeType &quot;NodeDocument&quot;, which is the root node of the document the node belongs to (unless the node is null, in which</span>
<a name="l01073"></a>01073 <span class="comment">    /// case null node is returned).</span>
<a name="l01074"></a>01074 <span class="comment">    /// \n \n</span>
<a name="l01075"></a>01075 <span class="comment">    /// While Mezzanine::xml supports complex XPath expressions, sometimes a simple path handling facility is needed. There are two functions, for getting node path and for converting path</span>
<a name="l01076"></a>01076 <span class="comment">    /// to a node:</span>
<a name="l01077"></a>01077 <span class="comment">    /// @code</span>
<a name="l01078"></a>01078 <span class="comment">    /// Mezzanine::String Mezzanine::xml::Node::Path(char_t delimiter = &#39;/&#39;) const;</span>
<a name="l01079"></a>01079 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::FirstElementByPath(const char_t* Path, char_t delimiter = &#39;/&#39;) const;</span>
<a name="l01080"></a>01080 <span class="comment">    /// @endcode</span>
<a name="l01081"></a>01081 <span class="comment">    /// Node paths consist of node names, separated with a delimiter (which is / by default); also paths can contain self (.) and parent (..) pseudo-names, so that this is a valid path:</span>
<a name="l01082"></a>01082 <span class="comment">    /// &quot;../../foo/./bar&quot;. path returns the path to the node from the document root, FirstElementByPath looks for a node represented by a given path; a path can be an absolute one</span>
<a name="l01083"></a>01083 <span class="comment">    /// (absolute paths start with the delimiter), in which case the rest of the path is treated as document root relative, and relative to the given node. For example, in the following</span>
<a name="l01084"></a>01084 <span class="comment">    /// document: &lt;a&gt; &lt;b&gt; &lt;c/&gt; &lt;/b&gt; &lt;/a&gt;, node &lt;c/&gt; has path &quot;a/b/c&quot;; calling FirstElementByPath for document with path &quot;a/b&quot; results in node &lt;b/&gt;; calling FirstElementByPath for</span>
<a name="l01085"></a>01085 <span class="comment">    /// node &lt;a/&gt; with path &quot;../a/./b/../.&quot; results in node &lt;a/&gt;; calling FirstElementByPath with path &quot;/a&quot; results in node &lt;a/&gt; for any node.</span>
<a name="l01086"></a>01086 <span class="comment">    /// \n \n</span>
<a name="l01087"></a>01087 <span class="comment">    /// In case path component is ambiguous (if there are two nodes with given name), the first one is selected; paths are not guaranteed to uniquely identify nodes in a document. If any</span>
<a name="l01088"></a>01088 <span class="comment">    /// component of a path is not found, the result of FirstElementByPath is null node; also FirstElementByPath returns null node for null nodes, in which case the path does not matter.</span>
<a name="l01089"></a>01089 <span class="comment">    /// path returns an empty string for null nodes.</span>
<a name="l01090"></a>01090 <span class="comment">    /// @note The Path function returns the result as String which is currently a typedef of std::string, and thus is not available if XML_NO_STL is defined.</span>
<a name="l01091"></a>01091 <span class="comment">    ///</span>
<a name="l01092"></a>01092 <span class="comment">    /// Mezzanine::xml does not record row/column information for nodes upon parsing for efficiency reasons. However, if the node has not changed in a significant way since parsing (the</span>
<a name="l01093"></a>01093 <span class="comment">    /// name/value are not changed, and the node itself is the original one, i.e. it was not deleted from the tree and re-added later), it is possible to get the offset from the</span>
<a name="l01094"></a>01094 <span class="comment">    /// beginning of XML buffer:</span>
<a name="l01095"></a>01095 <span class="comment">    /// @code</span>
<a name="l01096"></a>01096 <span class="comment">    /// ptrdiff_t Mezzanine::xml::node::OffSetDebug() const;</span>
<a name="l01097"></a>01097 <span class="comment">    /// @endcode</span>
<a name="l01098"></a>01098 <span class="comment">    /// If the offset is not available (this happens if the node is null, was not originally parsed from a stream, or has changed in a significant way), the function returns -1. Otherwise</span>
<a name="l01099"></a>01099 <span class="comment">    /// it returns the offset to node&#39;s data from the beginning of XML buffer in Mezzanine::xml::char_t units. For more information on parsing offsets, see parsing error handling documentation.</span>
<a name="l01100"></a>01100 <span class="comment">    /// \n \n</span>
<a name="l01101"></a>01101 <span class="comment">    /// @section XMLModifying Modifiying Documents</span>
<a name="l01102"></a>01102 <span class="comment">    ///     - @ref XMLModifyingNodeData</span>
<a name="l01103"></a>01103 <span class="comment">    ///     - @ref XMLModifyingAttributeData</span>
<a name="l01104"></a>01104 <span class="comment">    ///     - @ref XMLModifyingAdding</span>
<a name="l01105"></a>01105 <span class="comment">    ///     - @ref XMLModifyingRemoving</span>
<a name="l01106"></a>01106 <span class="comment">    ///     - @ref XMLModifyingCloning</span>
<a name="l01107"></a>01107 <span class="comment">    ///</span>
<a name="l01108"></a>01108 <span class="comment">    /// The document in Mezzanine::xml is fully mutable: you can completely change the document structure and modify the data of nodes/attributes. This section provides documentation for the</span>
<a name="l01109"></a>01109 <span class="comment">    /// relevant functions. All functions take care of memory management and structural integrity themselves, so they always result in structurally valid tree - however, it is possible to</span>
<a name="l01110"></a>01110 <span class="comment">    /// create an invalid XML tree (for example, by adding two attributes with the same name or by setting attribute/node name to empty/invalid string). Tree modification is optimized for</span>
<a name="l01111"></a>01111 <span class="comment">    /// performance and for memory consumption, so if you have enough memory you can create documents from scratch with Mezzanine::xml and later save them to file/stream instead of relying on</span>
<a name="l01112"></a>01112 <span class="comment">    /// error-prone manual text writing and without too much overhead.</span>
<a name="l01113"></a>01113 <span class="comment">    /// \n \n</span>
<a name="l01114"></a>01114 <span class="comment">    /// All member functions that change node/attribute data or structure are non-constant and thus can not be called on constant handles. However, you can easily convert constant handle</span>
<a name="l01115"></a>01115 <span class="comment">    /// to non-constant one by simple assignment: void foo(const Mezzanine::xml::Node&amp; n) { Mezzanine::xml::Node nc = n; }, so const-correctness here mainly provides additional documentation.</span>
<a name="l01116"></a>01116 <span class="comment">    /// \n \n</span>
<a name="l01117"></a>01117 <span class="comment">    /// @subsection XMLModifyingNodeData Setting Node Data</span>
<a name="l01118"></a>01118 <span class="comment">    ///As discussed before, nodes can have name and value, both of which are c-strings. Depending on node type, name or value may be absent. @ref Mezzanine::xml::NodeType &quot;NodeDocument&quot; nodes</span>
<a name="l01119"></a>01119 <span class="comment">    /// do not have a name or value, @ref Mezzanine::xml::NodeType &quot;NodeElement&quot; and @ref Mezzanine::xml::NodeType &quot;NodeDeclaration&quot; nodes always have a name but never have a value,</span>
<a name="l01120"></a>01120 <span class="comment">    /// @ref Mezzanine::xml::NodeType &quot;NodePcdata&quot;, @ref Mezzanine::xml::NodeType &quot;NodeCdata&quot;, @ref Mezzanine::xml::NodeType &quot;NodeComment&quot; and @ref Mezzanine::xml::NodeType &quot;NodeDocType&quot; nodes never have a</span>
<a name="l01121"></a>01121 <span class="comment">    /// name but always have a value (it may be empty though), @ref Mezzanine::xml::NodeType &quot;NodePi&quot; nodes always have a name and a value (again, value may be empty). In order to set node&#39;s</span>
<a name="l01122"></a>01122 <span class="comment">    /// name or value, you can use the following functions:</span>
<a name="l01123"></a>01123 <span class="comment">    /// @code</span>
<a name="l01124"></a>01124 <span class="comment">    /// bool Mezzanine::xml::Node::SetName(const char_t* rhs);</span>
<a name="l01125"></a>01125 <span class="comment">    /// bool Mezzanine::xml::Node::SetName(const String&amp; rhs);</span>
<a name="l01126"></a>01126 <span class="comment">    /// bool Mezzanine::xml::Node::SetValue(const char_t* rhs);</span>
<a name="l01127"></a>01127 <span class="comment">    /// @endcode</span>
<a name="l01128"></a>01128 <span class="comment">    /// Both functions try to set the name/value to the specified string, and return the operation result. The operation fails if the node can not have name or value (for instance, when</span>
<a name="l01129"></a>01129 <span class="comment">    /// trying to call SetName on a @ref Mezzanine::xml::NodeType &quot;NodePcdata&quot; node), if the node handle is null, or if there is insufficient memory to handle the request. The provided string</span>
<a name="l01130"></a>01130 <span class="comment">    /// is copied into document managed memory and can be destroyed after the function returns (for example, you can safely pass stack-allocated buffers to these functions). The name/value</span>
<a name="l01131"></a>01131 <span class="comment">    /// content is not verified, so take care to use only valid XML names, or the document may become malformed.</span>
<a name="l01132"></a>01132 <span class="comment">    /// \n \n</span>
<a name="l01133"></a>01133 <span class="comment">    /// There is no equivalent of ChildValue function for modifying text children of the node.</span>
<a name="l01134"></a>01134 <span class="comment">    /// \n \n</span>
<a name="l01135"></a>01135 <span class="comment">    /// This is an example of setting node name and value:</span>
<a name="l01136"></a>01136 <span class="comment">    /// @code</span>
<a name="l01137"></a>01137 <span class="comment">    /// Mezzanine::xml::Node node = doc.GetChild(&quot;node&quot;);</span>
<a name="l01138"></a>01138 <span class="comment">    ///</span>
<a name="l01139"></a>01139 <span class="comment">    /// // change node name</span>
<a name="l01140"></a>01140 <span class="comment">    /// std::cout &lt;&lt; node.SetName(&quot;notnode&quot;);</span>
<a name="l01141"></a>01141 <span class="comment">    /// std::cout &lt;&lt; &quot;, new node name: &quot; &lt;&lt; node.Name() &lt;&lt; std::endl;</span>
<a name="l01142"></a>01142 <span class="comment">    ///</span>
<a name="l01143"></a>01143 <span class="comment">    /// // change comment text</span>
<a name="l01144"></a>01144 <span class="comment">    /// std::cout &lt;&lt; doc.GetLastChild().SetValue(&quot;useless comment&quot;);</span>
<a name="l01145"></a>01145 <span class="comment">    /// std::cout &lt;&lt; &quot;, new comment text: &quot; &lt;&lt; doc.LastChild().Value() &lt;&lt; std::endl;</span>
<a name="l01146"></a>01146 <span class="comment">    ///</span>
<a name="l01147"></a>01147 <span class="comment">    /// // we can&#39;t change value of the element or name of the comment</span>
<a name="l01148"></a>01148 <span class="comment">    /// std::cout &lt;&lt; node.SetValue(&quot;1&quot;) &lt;&lt; &quot;, &quot; &lt;&lt; doc.LastChild().SetName(&quot;2&quot;) &lt;&lt; std::endl;</span>
<a name="l01149"></a>01149 <span class="comment">    /// @endcode</span>
<a name="l01150"></a>01150 <span class="comment">    /// @subsection XMLModifyingAttributeData Setting Attribute Data</span>
<a name="l01151"></a>01151 <span class="comment">    /// All attributes have name and value, both of which are strings (value may be empty). You can set them with the following functions:</span>
<a name="l01152"></a>01152 <span class="comment">    /// @code</span>
<a name="l01153"></a>01153 <span class="comment">    /// bool Mezzanine::xml::Attribute::SetName(const char_t* rhs);</span>
<a name="l01154"></a>01154 <span class="comment">    /// bool Mezzanine::xml::Attribute::SetValue(const char_t* rhs);</span>
<a name="l01155"></a>01155 <span class="comment">    /// @endcode</span>
<a name="l01156"></a>01156 <span class="comment">    /// Both functions try to set the name/value to the specified string, and return the operation result. The operation fails if the attribute handle is null, or if there is insufficient</span>
<a name="l01157"></a>01157 <span class="comment">    /// memory to handle the request. The provided string is copied into document managed memory and can be destroyed after the function returns (for example, you can safely pass</span>
<a name="l01158"></a>01158 <span class="comment">    /// stack-allocated buffers to these functions). The name/value content is not verified, so take care to use only valid XML names, or the document may become malformed.</span>
<a name="l01159"></a>01159 <span class="comment">    /// \n \n</span>
<a name="l01160"></a>01160 <span class="comment">    /// In addition to string functions, several functions are provided for handling attributes with numbers and booleans as values:</span>
<a name="l01161"></a>01161 <span class="comment">    /// @code</span>
<a name="l01162"></a>01162 <span class="comment">    /// bool Mezzanine::xml::Attribute::SetValue(int rhs);</span>
<a name="l01163"></a>01163 <span class="comment">    /// bool Mezzanine::xml::Attribute::SetValue(unsigned int rhs);</span>
<a name="l01164"></a>01164 <span class="comment">    /// bool Mezzanine::xml::Attribute::SetValue(double rhs);</span>
<a name="l01165"></a>01165 <span class="comment">    /// bool Mezzanine::xml::Attribute::SetValue(bool rhs);</span>
<a name="l01166"></a>01166 <span class="comment">    /// @endcode</span>
<a name="l01167"></a>01167 <span class="comment">    /// The above functions convert the argument to string and then call the base SetValue function. Integers are converted to a decimal form, floating-point numbers are converted to either</span>
<a name="l01168"></a>01168 <span class="comment">    /// decimal or scientific form, depending on the number magnitude, boolean values are converted to either &quot;true&quot; or &quot;false&quot;.</span>
<a name="l01169"></a>01169 <span class="comment">    /// @warning Number conversion functions depend on current C locale as set with setlocale, so may generate unexpected results if the locale is different from &quot;C&quot;.</span>
<a name="l01170"></a>01170 <span class="comment">    ///</span>
<a name="l01171"></a>01171 <span class="comment">    /// @note There are no portable 64-bit types in C++, so there is no corresponding SetValue function. If your platform has a 64-bit integer, you can easily write such a function yourself.</span>
<a name="l01172"></a>01172 <span class="comment">    ///</span>
<a name="l01173"></a>01173 <span class="comment">    /// For convenience, all set_value functions have the corresponding assignment operators:</span>
<a name="l01174"></a>01174 <span class="comment">    /// @code</span>
<a name="l01175"></a>01175 <span class="comment">    /// Mezzanine::xml::Attribute&amp; Mezzanine::xml::Attribute::operator=(const char_t* rhs);</span>
<a name="l01176"></a>01176 <span class="comment">    /// Mezzanine::xml::Attribute&amp; Mezzanine::xml::Attribute::operator=(int rhs);</span>
<a name="l01177"></a>01177 <span class="comment">    /// Mezzanine::xml::Attribute&amp; Mezzanine::xml::Attribute::operator=(unsigned int rhs);</span>
<a name="l01178"></a>01178 <span class="comment">    /// Mezzanine::xml::Attribute&amp; Mezzanine::xml::Attribute::operator=(double rhs);</span>
<a name="l01179"></a>01179 <span class="comment">    /// Mezzanine::xml::Attribute&amp; Mezzanine::xml::Attribute::operator=(bool rhs);</span>
<a name="l01180"></a>01180 <span class="comment">    /// @endcode</span>
<a name="l01181"></a>01181 <span class="comment">    /// These operators simply call the right SetValue function and return the attribute they&#39;re called on; the return value of SetValue is ignored, so errors are ignored.</span>
<a name="l01182"></a>01182 <span class="comment">    /// \n \n</span>
<a name="l01183"></a>01183 <span class="comment">    /// This is an example of setting attribute name and value:</span>
<a name="l01184"></a>01184 <span class="comment">    /// @code</span>
<a name="l01185"></a>01185 <span class="comment">    /// Mezzanine::xml::Attribute attr = node.GetAttribute(&quot;id&quot;);</span>
<a name="l01186"></a>01186 <span class="comment">    ///</span>
<a name="l01187"></a>01187 <span class="comment">    /// // change attribute name/value</span>
<a name="l01188"></a>01188 <span class="comment">    /// std::cout &lt;&lt; attr.SetName(&quot;key&quot;) &lt;&lt; &quot;, &quot; &lt;&lt; attr.SetValue(&quot;345&quot;);</span>
<a name="l01189"></a>01189 <span class="comment">    /// std::cout &lt;&lt; &quot;, new attribute: &quot; &lt;&lt; attr.name() &lt;&lt; &quot;=&quot; &lt;&lt; attr.value() &lt;&lt; std::endl;</span>
<a name="l01190"></a>01190 <span class="comment">    ///</span>
<a name="l01191"></a>01191 <span class="comment">    /// // we can use numbers or booleans</span>
<a name="l01192"></a>01192 <span class="comment">    /// attr.SetValue(1.234);</span>
<a name="l01193"></a>01193 <span class="comment">    /// std::cout &lt;&lt; &quot;new attribute value: &quot; &lt;&lt; attr.Value() &lt;&lt; std::endl;</span>
<a name="l01194"></a>01194 <span class="comment">    ///</span>
<a name="l01195"></a>01195 <span class="comment">    /// // we can also use assignment operators for more concise code</span>
<a name="l01196"></a>01196 <span class="comment">    /// attr = true;</span>
<a name="l01197"></a>01197 <span class="comment">    /// std::cout &lt;&lt; &quot;final attribute value: &quot; &lt;&lt; attr.value() &lt;&lt; std::endl;</span>
<a name="l01198"></a>01198 <span class="comment">    /// @endcode</span>
<a name="l01199"></a>01199 <span class="comment">    /// @subsection XMLModifyingAdding Adding Nodes/Attributes</span>
<a name="l01200"></a>01200 <span class="comment">    /// Nodes and attributes do not exist without a document tree, so you can&#39;t create them without adding them to some document. A node or attribute can be created at the end of</span>
<a name="l01201"></a>01201 <span class="comment">    /// node/attribute list or before/after some other node:</span>
<a name="l01202"></a>01202 <span class="comment">    /// @code</span>
<a name="l01203"></a>01203 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::AppendAttribute(const char_t* Name);</span>
<a name="l01204"></a>01204 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::AppendAttribute(const String&amp; Name);</span>
<a name="l01205"></a>01205 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::PrependAttribute(const char_t* Name);</span>
<a name="l01206"></a>01206 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::InsertAttributeAfter(const char_t* Name, const Mezzanine::xml::Attribute&amp; attr);</span>
<a name="l01207"></a>01207 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::InsertAttributeBefore(const char_t* Name, const Mezzanine::xml::Attribute&amp; attr);</span>
<a name="l01208"></a>01208 <span class="comment">    ///</span>
<a name="l01209"></a>01209 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::AppendChild(Mezzanine::xml::NodeType type = NodeElement);</span>
<a name="l01210"></a>01210 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::PrependChild(Mezzanine::xml::NodeType type = NodeElement);</span>
<a name="l01211"></a>01211 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::InsertChildAfter(Mezzanine::xml::NodeType type, const Mezzanine::xml::Node&amp; node);</span>
<a name="l01212"></a>01212 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::InsertChildBefore(Mezzanine::xml::NodeType type, const Mezzanine::xml::Node&amp; node);</span>
<a name="l01213"></a>01213 <span class="comment">    ///</span>
<a name="l01214"></a>01214 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::AppendChild(const char_t* Name);</span>
<a name="l01215"></a>01215 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::AppendChild(const String&amp; Name);</span>
<a name="l01216"></a>01216 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::PrependChild(const char_t* Name);</span>
<a name="l01217"></a>01217 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::PrependChild(const String&amp; Name);</span>
<a name="l01218"></a>01218 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::InsertChildAfter(const char_t* Name, const Mezzanine::xml::Node&amp; node);</span>
<a name="l01219"></a>01219 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::InsertChildBefore(const char_t* Name, const Mezzanine::xml::Node&amp; node);</span>
<a name="l01220"></a>01220 <span class="comment">    /// @endcode</span>
<a name="l01221"></a>01221 <span class="comment">    /// AppendAttribute and AppendChild create a new node/attribute at the end of the corresponding list of the node the method is called on; PrependAttribute and PrependChild create a new</span>
<a name="l01222"></a>01222 <span class="comment">    /// node/attribute at the beginning of the list; InsertAttributeAfter, InsertAttributeBefore, InsertChildAfter and InsertAttributeBefore add the node/attribute before or after the</span>
<a name="l01223"></a>01223 <span class="comment">    /// specified node/attribute.</span>
<a name="l01224"></a>01224 <span class="comment">    /// \n \n</span>
<a name="l01225"></a>01225 <span class="comment">    /// The overloads of AppendChild and PrependChild that accept Mezzanine::String references convert it to a string, then call the version of the function that accepts a c-style string.</span>
<a name="l01226"></a>01226 <span class="comment">    /// \n \n</span>
<a name="l01227"></a>01227 <span class="comment">    /// Attribute functions create an attribute with the specified name; you can specify the empty name and change the name later if you want to. Node functions with the type argument</span>
<a name="l01228"></a>01228 <span class="comment">    /// create the node with the specified type; since node type can&#39;t be changed, you have to know the desired type beforehand. Also note that not all types can be added as children; see</span>
<a name="l01229"></a>01229 <span class="comment">    /// below for clarification. Node functions with the name argument create the element node (NodeElement) with the specified name.</span>
<a name="l01230"></a>01230 <span class="comment">    /// \n \n</span>
<a name="l01231"></a>01231 <span class="comment">    /// All functions return the handle to the created object on success, and null handle on failure. There are several reasons for failure:</span>
<a name="l01232"></a>01232 <span class="comment">    ///     - Adding fails if the target node is null;</span>
<a name="l01233"></a>01233 <span class="comment">    ///     - Only @ref Mezzanine::xml::NodeType &quot;NodeType::NodeElement&quot; nodes can contain attributes, so attribute adding fails if node is not an element;</span>
<a name="l01234"></a>01234 <span class="comment">    ///     - Only @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDocument&quot; and @ref Mezzanine::xml::NodeType &quot;NodeType::NodeElement&quot; nodes can contain children, so child node adding fails if the</span>
<a name="l01235"></a>01235 <span class="comment">    ///     target node is not an element or a document;</span>
<a name="l01236"></a>01236 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDocument&quot; and @ref Mezzanine::xml::NodeType &quot;NodeType::NodeNull&quot; nodes can not be inserted as children, so passing</span>
<a name="l01237"></a>01237 <span class="comment">    ///     @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDocument&quot; or @ref Mezzanine::xml::NodeType &quot;NodeType::NodeNull value as type results in operation failure;</span>
<a name="l01238"></a>01238 <span class="comment">    ///     - @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDeclaration&quot; nodes can only be added as children of the document node; attempt to insert declaration node as a child of an element node fails;</span>
<a name="l01239"></a>01239 <span class="comment">    ///     - Adding node/attribute results in memory allocation, which may fail;</span>
<a name="l01240"></a>01240 <span class="comment">    ///     - Insertion functions fail if the specified node or attribute is null or is not in the target node&#39;s children/attribute list.</span>
<a name="l01241"></a>01241 <span class="comment">    ///</span>
<a name="l01242"></a>01242 <span class="comment">    /// Even if the operation fails, the document remains in consistent state, but the requested node/attribute is not added.</span>
<a name="l01243"></a>01243 <span class="comment">    /// @warning GetAttribute() and GetChild() functions do not add attributes or nodes to the tree, so code like node.GetAttribute(&quot;id&quot;) = 123; will not do anything if node does not</span>
<a name="l01244"></a>01244 <span class="comment">    /// have an attribute with name &quot;id&quot;. Make sure you&#39;re operating with existing attributes/nodes by adding them if necessary.</span>
<a name="l01245"></a>01245 <span class="comment">    ///</span>
<a name="l01246"></a>01246 <span class="comment">    /// This is an example of adding new attributes/nodes to the document:</span>
<a name="l01247"></a>01247 <span class="comment">    /// @code</span>
<a name="l01248"></a>01248 <span class="comment">    /// // add node with some name</span>
<a name="l01249"></a>01249 <span class="comment">    /// Mezzanine::xml::Node node = doc.AppendChild(&quot;node&quot;);</span>
<a name="l01250"></a>01250 <span class="comment">    ///</span>
<a name="l01251"></a>01251 <span class="comment">    /// // add description node with text child</span>
<a name="l01252"></a>01252 <span class="comment">    /// Mezzanine::xml::Node descr = node.AppendChild(&quot;description&quot;);</span>
<a name="l01253"></a>01253 <span class="comment">    /// descr.AppendChild(Mezzanine::xml::NodePcdata).SetValue(&quot;Simple node&quot;);</span>
<a name="l01254"></a>01254 <span class="comment">    ///</span>
<a name="l01255"></a>01255 <span class="comment">    /// // add param node before the description</span>
<a name="l01256"></a>01256 <span class="comment">    /// Mezzanine::xml::Node param = node.InsertChildBefore(&quot;param&quot;, descr);</span>
<a name="l01257"></a>01257 <span class="comment">    ///</span>
<a name="l01258"></a>01258 <span class="comment">    /// // add attributes to param node</span>
<a name="l01259"></a>01259 <span class="comment">    /// param.AppendAttribute(&quot;name&quot;) = &quot;version&quot;;</span>
<a name="l01260"></a>01260 <span class="comment">    /// param.AppendAttribute(&quot;value&quot;) = 1.1;</span>
<a name="l01261"></a>01261 <span class="comment">    /// param.InsertAttributeAfter(&quot;type&quot;, param.GetAttribute(&quot;name&quot;)) = &quot;float&quot;;</span>
<a name="l01262"></a>01262 <span class="comment">    /// @endcode</span>
<a name="l01263"></a>01263 <span class="comment">    /// @subsection XMLModifyingRemoving Removing Nodes/Attributes</span>
<a name="l01264"></a>01264 <span class="comment">    /// If you do not want your document to contain some node or attribute, you can remove it with one of the following functions:</span>
<a name="l01265"></a>01265 <span class="comment">    /// @code</span>
<a name="l01266"></a>01266 <span class="comment">    /// bool Mezzanine::xml::Node::RemoveAttribute(const Mezzanine::xml::Attribute&amp; a);</span>
<a name="l01267"></a>01267 <span class="comment">    /// bool Mezzanine::xml::Node::RemoveChild(const Mezzanine::xml::Node&amp; n);</span>
<a name="l01268"></a>01268 <span class="comment">    /// @endcode</span>
<a name="l01269"></a>01269 <span class="comment">    /// RemoveAttribute removes the attribute from the attribute list of the node, and returns the operation result. RemoveChild removes the child node with the entire subtree (including</span>
<a name="l01270"></a>01270 <span class="comment">    /// all descendant nodes and attributes) from the document, and returns the operation result. Removing fails if one of the following is true:</span>
<a name="l01271"></a>01271 <span class="comment">    ///     - The node the function is called on is null;</span>
<a name="l01272"></a>01272 <span class="comment">    ///     - The attribute/node to be removed is null;</span>
<a name="l01273"></a>01273 <span class="comment">    ///     - The attribute/node to be removed is not in the node&#39;s attribute/child list.</span>
<a name="l01274"></a>01274 <span class="comment">    ///</span>
<a name="l01275"></a>01275 <span class="comment">    /// Removing the attribute or node invalidates all handles to the same underlying object, and also invalidates all iterators pointing to the same object. Removing node also invalidates</span>
<a name="l01276"></a>01276 <span class="comment">    /// all past-the-end iterators to its attribute or child node list. Be careful to ensure that all such handles and iterators either do not exist or are not used after the attribute/node</span>
<a name="l01277"></a>01277 <span class="comment">    /// is removed.</span>
<a name="l01278"></a>01278 <span class="comment">    /// \n \n</span>
<a name="l01279"></a>01279 <span class="comment">    /// If you want to remove the attribute or child node by its name, two additional helper functions are available:</span>
<a name="l01280"></a>01280 <span class="comment">    /// @code</span>
<a name="l01281"></a>01281 <span class="comment">    /// bool Mezzanine::xml::Node::RemoveAttribute(const char_t* Name);</span>
<a name="l01282"></a>01282 <span class="comment">    /// bool Mezzanine::xml::Node::RemoveChild(const char_t* Name);</span>
<a name="l01283"></a>01283 <span class="comment">    /// @endcode</span>
<a name="l01284"></a>01284 <span class="comment">    /// These functions look for the first attribute or child with the specified name, and then remove it, returning the result. If there is no attribute or child with such name, the</span>
<a name="l01285"></a>01285 <span class="comment">    /// function returns false; if there are two nodes with the given name, only the first node is deleted. If you want to delete all nodes with the specified name, you can use code</span>
<a name="l01286"></a>01286 <span class="comment">    /// like this: while (node.RemoveChild(&quot;tool&quot;)) ;.</span>
<a name="l01287"></a>01287 <span class="comment">    /// \n \n</span>
<a name="l01288"></a>01288 <span class="comment">    /// This is an example of removing attributes/nodes from the document:</span>
<a name="l01289"></a>01289 <span class="comment">    /// @code</span>
<a name="l01290"></a>01290 <span class="comment">    /// // remove description node with the whole subtree</span>
<a name="l01291"></a>01291 <span class="comment">    /// Mezzanine::xml::Node node = doc.GetChild(&quot;node&quot;);</span>
<a name="l01292"></a>01292 <span class="comment">    /// node.RemoveChild(&quot;description&quot;);</span>
<a name="l01293"></a>01293 <span class="comment">    ///</span>
<a name="l01294"></a>01294 <span class="comment">    /// // remove id attribute</span>
<a name="l01295"></a>01295 <span class="comment">    /// Mezzanine::xml::Node param = node.GetChild(&quot;param&quot;);</span>
<a name="l01296"></a>01296 <span class="comment">    /// param.RemoveAttribute(&quot;value&quot;);</span>
<a name="l01297"></a>01297 <span class="comment">    ///</span>
<a name="l01298"></a>01298 <span class="comment">    /// // we can also remove nodes/attributes by handles</span>
<a name="l01299"></a>01299 <span class="comment">    /// Mezzanine::xml::Attribute id = param.GetAttribute(&quot;name&quot;);</span>
<a name="l01300"></a>01300 <span class="comment">    /// param.RemoveAttribute(id);</span>
<a name="l01301"></a>01301 <span class="comment">    /// @endcode</span>
<a name="l01302"></a>01302 <span class="comment">    /// @subsection XMLModifyingCloning Cloning Nodes/Attributes</span>
<a name="l01303"></a>01303 <span class="comment">    /// With the help of previously described functions, it is possible to create trees with any contents and structure, including cloning the existing data. However since this is an often</span>
<a name="l01304"></a>01304 <span class="comment">    /// needed operation, Mezzanine::xml provides built-in node/attribute cloning facilities. Since nodes and attributes do not exist without a document tree, you can&#39;t create a standalone copy</span>
<a name="l01305"></a>01305 <span class="comment">    /// - you have to immediately insert it somewhere in the tree. For this, you can use one of the following functions:</span>
<a name="l01306"></a>01306 <span class="comment">    /// @code</span>
<a name="l01307"></a>01307 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::AppendCopy(const Mezzanine::xml::Attribute&amp; proto);</span>
<a name="l01308"></a>01308 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::PrependCopy(const Mezzanine::xml::Attribute&amp; proto);</span>
<a name="l01309"></a>01309 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::InsertCopyAfter(const Mezzanine::xml::Attribute&amp; proto, const Mezzanine::xml::Attribute&amp; attr);</span>
<a name="l01310"></a>01310 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::Node::InsertCopyAfter(const Mezzanine::xml::Attribute&amp; proto, const Mezzanine::xml::Attribute&amp; attr);</span>
<a name="l01311"></a>01311 <span class="comment">    ///</span>
<a name="l01312"></a>01312 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::AppendCopy(const Mezzanine::xml::Node&amp; proto);</span>
<a name="l01313"></a>01313 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::PrependCopy(const Mezzanine::xml::Node&amp; proto);</span>
<a name="l01314"></a>01314 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::InsertCopyAfter(const Mezzanine::xml::Node&amp; proto, const Mezzanine::xml::Node&amp; node);</span>
<a name="l01315"></a>01315 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::Node::InsertCopyAfter(const Mezzanine::xml::Node&amp; proto, const Mezzanine::xml::Node&amp; node);</span>
<a name="l01316"></a>01316 <span class="comment">    /// @endcode</span>
<a name="l01317"></a>01317 <span class="comment">    ///</span>
<a name="l01318"></a>01318 <span class="comment">    /// These functions mirror the structure of AppendChild, PrependChild, InsertChildBefore and related functions - they take the handle to the prototype object, which is to be cloned,</span>
<a name="l01319"></a>01319 <span class="comment">    /// insert a new attribute/node at the appropriate place, and then copy the attribute data or the whole node subtree to the new object. The functions return the handle to the resulting</span>
<a name="l01320"></a>01320 <span class="comment">    /// duplicate object, or null handle on failure.</span>
<a name="l01321"></a>01321 <span class="comment">    /// \n \n</span>
<a name="l01322"></a>01322 <span class="comment">    /// The attribute is copied along with the name and value; the node is copied along with its type, name and value; additionally attribute list and all children are recursively cloned,</span>
<a name="l01323"></a>01323 <span class="comment">    /// resulting in the deep subtree clone. The prototype object can be a part of the same document, or a part of any other document.</span>
<a name="l01324"></a>01324 <span class="comment">    /// \n \n</span>
<a name="l01325"></a>01325 <span class="comment">    /// The failure conditions resemble those of AppendChild, InsertChild_before and related functions, consult their documentation for more information. There are additional caveats</span>
<a name="l01326"></a>01326 <span class="comment">    /// specific to cloning functions:</span>
<a name="l01327"></a>01327 <span class="comment">    ///     - Cloning null handles results in operation failure;</span>
<a name="l01328"></a>01328 <span class="comment">    ///     - Node cloning starts with insertion of the node of the same type as that of the prototype; for this reason, cloning functions can not be directly used to clone entire</span>
<a name="l01329"></a>01329 <span class="comment">    ///     documents, since @ref Mezzanine::xml::NodeType &quot;NodeType::NodeDocument&quot; is not a valid insertion type. The example below provides a workaround.</span>
<a name="l01330"></a>01330 <span class="comment">    ///     - It is possible to copy a subtree as a child of some node inside this subtree, i.e. node.AppendCopy(node.GetParent().GetParent());. This is a valid operation, and it results</span>
<a name="l01331"></a>01331 <span class="comment">    ///     in a clone of the subtree in the state before cloning started, i.e. no infinite recursion takes place.</span>
<a name="l01332"></a>01332 <span class="comment">    ///</span>
<a name="l01333"></a>01333 <span class="comment">    /// This is an example with one possible implementation of include tags in XML. It illustrates node cloning and usage of other document modification functions:</span>
<a name="l01334"></a>01334 <span class="comment">    /// @code</span>
<a name="l01335"></a>01335 <span class="comment">    /// bool LoadPreprocess(Mezzanine::xml::Document&amp; doc, const char* path);</span>
<a name="l01336"></a>01336 <span class="comment">    ///</span>
<a name="l01337"></a>01337 <span class="comment">    /// bool PreProcess(Mezzanine::xml::Node node)</span>
<a name="l01338"></a>01338 <span class="comment">    /// {</span>
<a name="l01339"></a>01339 <span class="comment">    ///     for (Mezzanine::xml::Node child = node.GetFirstChild(); child; )</span>
<a name="l01340"></a>01340 <span class="comment">    ///     {</span>
<a name="l01341"></a>01341 <span class="comment">    ///         if (child.Type() == Mezzanine::xml::NodePi &amp;&amp; strcmp(child.Name(), &quot;include&quot;) == 0)</span>
<a name="l01342"></a>01342 <span class="comment">    ///         {</span>
<a name="l01343"></a>01343 <span class="comment">    ///             Mezzanine::xml::Node include = child;</span>
<a name="l01344"></a>01344 <span class="comment">    ///</span>
<a name="l01345"></a>01345 <span class="comment">    ///             // load new preprocessed document (note: ideally this should handle relative paths)</span>
<a name="l01346"></a>01346 <span class="comment">    ///             const char* path = include.Value();</span>
<a name="l01347"></a>01347 <span class="comment">    ///</span>
<a name="l01348"></a>01348 <span class="comment">    ///             Mezzanine::xml::Document doc;</span>
<a name="l01349"></a>01349 <span class="comment">    ///             if (!LoadPreprocess(doc, path)) return false;</span>
<a name="l01350"></a>01350 <span class="comment">    ///</span>
<a name="l01351"></a>01351 <span class="comment">    ///             // insert the comment marker above include directive</span>
<a name="l01352"></a>01352 <span class="comment">    ///             node.InsertChildBefore(pugi::NodeComment, include).SetValue(path);</span>
<a name="l01353"></a>01353 <span class="comment">    ///</span>
<a name="l01354"></a>01354 <span class="comment">    ///             // copy the document above the include directive (this retains the original order!)</span>
<a name="l01355"></a>01355 <span class="comment">    ///             for (Mezzanine::xml::Node ic = doc.FirstChild(); ic; ic = ic.NextSibling())</span>
<a name="l01356"></a>01356 <span class="comment">    ///             {</span>
<a name="l01357"></a>01357 <span class="comment">    ///                 node.InsertCopyAfter(ic, include);</span>
<a name="l01358"></a>01358 <span class="comment">    ///             }</span>
<a name="l01359"></a>01359 <span class="comment">    ///</span>
<a name="l01360"></a>01360 <span class="comment">    ///             // remove the include node and move to the next child</span>
<a name="l01361"></a>01361 <span class="comment">    ///             child = child.NextSibling();</span>
<a name="l01362"></a>01362 <span class="comment">    ///</span>
<a name="l01363"></a>01363 <span class="comment">    ///             node.RemoveChild(include);</span>
<a name="l01364"></a>01364 <span class="comment">    ///         }</span>
<a name="l01365"></a>01365 <span class="comment">    ///         else</span>
<a name="l01366"></a>01366 <span class="comment">    ///         {</span>
<a name="l01367"></a>01367 <span class="comment">    ///             if (!PreProcess(child)) return false;</span>
<a name="l01368"></a>01368 <span class="comment">    ///</span>
<a name="l01369"></a>01369 <span class="comment">    ///             child = child.NextSibling();</span>
<a name="l01370"></a>01370 <span class="comment">    ///         }</span>
<a name="l01371"></a>01371 <span class="comment">    ///     }</span>
<a name="l01372"></a>01372 <span class="comment">    ///</span>
<a name="l01373"></a>01373 <span class="comment">    ///     return true;</span>
<a name="l01374"></a>01374 <span class="comment">    /// }</span>
<a name="l01375"></a>01375 <span class="comment">    ///</span>
<a name="l01376"></a>01376 <span class="comment">    /// bool LoadPreprocess(Mezzanine::xml::Document&amp; doc, const char* path)</span>
<a name="l01377"></a>01377 <span class="comment">    /// {</span>
<a name="l01378"></a>01378 <span class="comment">    ///     Mezzanine::xml::ParseResult result = doc.LoadFile(path, Mezzanine::xml::ParseDefault | Mezzanine::xml::ParsePi); // for &lt;?include?&gt;</span>
<a name="l01379"></a>01379 <span class="comment">    ///</span>
<a name="l01380"></a>01380 <span class="comment">    ///     return result ? PreProcess(doc) : false;</span>
<a name="l01381"></a>01381 <span class="comment">    /// }</span>
<a name="l01382"></a>01382 <span class="comment">    /// @endcode</span>
<a name="l01383"></a>01383 <span class="comment">    /// @section XMLSaving Saving Documents</span>
<a name="l01384"></a>01384 <span class="comment">    ///     - @ref XMLSavingFile</span>
<a name="l01385"></a>01385 <span class="comment">    ///     - @ref XMLSavingStreams</span>
<a name="l01386"></a>01386 <span class="comment">    ///     - @ref XMLSavingWriter</span>
<a name="l01387"></a>01387 <span class="comment">    ///     - @ref XMLSavingSubtree</span>
<a name="l01388"></a>01388 <span class="comment">    ///     - @ref XMLSavingOptions</span>
<a name="l01389"></a>01389 <span class="comment">    ///     - @ref XMLSavingEncodings</span>
<a name="l01390"></a>01390 <span class="comment">    ///</span>
<a name="l01391"></a>01391 <span class="comment">    /// Often after creating a new document or loading the existing one and processing it, it is necessary to save the result back to file. Also it is occasionally useful to output the</span>
<a name="l01392"></a>01392 <span class="comment">    /// whole document or a subtree to some stream; use cases include debug printing, serialization via network or other text-oriented medium, etc. Mezzanine::xml provides several functions</span>
<a name="l01393"></a>01393 <span class="comment">    /// to output any subtree of the document to a file, stream or another generic transport interface; these functions allow one to customize the output format ( see @ref XMLSavingOptions ), and</span>
<a name="l01394"></a>01394 <span class="comment">    /// also perform necessary encoding conversions ( see @ref XMLSavingEncodings ). This section documents the relevant functionality.</span>
<a name="l01395"></a>01395 <span class="comment">    /// \n \n</span>
<a name="l01396"></a>01396 <span class="comment">    /// Before writing to the destination the node/attribute data is properly formatted according to the node type; all special XML symbols, such as &lt; and \&amp;, are properly escaped. In</span>
<a name="l01397"></a>01397 <span class="comment">    /// order to guard against forgotten node/attribute names, empty node/attribute names are printed as &quot;:anonymous&quot;. For well-formed output, make sure all node and attribute names are</span>
<a name="l01398"></a>01398 <span class="comment">    /// set to meaningful values.</span>
<a name="l01399"></a>01399 <span class="comment">    /// \n \n</span>
<a name="l01400"></a>01400 <span class="comment">    /// CDATA sections with values that contain &quot;]]&gt;&quot; are split into several sections as follows: section with value &quot;pre]]&gt;post&quot; is written as &lt;![CDATA[pre]]]]&gt;&lt;![CDATA[&gt;post]]&gt;. While</span>
<a name="l01401"></a>01401 <span class="comment">    /// this alters the structure of the document (if you load the document after saving it, there will be two CDATA sections instead of one), this is the only way to escape CDATA contents.</span>
<a name="l01402"></a>01402 <span class="comment">    /// @subsection XMLSavingFile Saving Documents to Files</span>
<a name="l01403"></a>01403 <span class="comment">    /// If you want to save the whole document to a file, you can use one of the following functions:</span>
<a name="l01404"></a>01404 <span class="comment">    /// @code</span>
<a name="l01405"></a>01405 <span class="comment">    /// bool Mezzanine::xml::Document::SaveFile(const char* Path, const Mezzanine::xml::char_t* indent = &quot;\t&quot;, unsigned int flags = Mezzanine::xml::FormatDefault, Mezzanine::xml::Encoding encoding = EncodingAuto) const;</span>
<a name="l01406"></a>01406 <span class="comment">    /// bool Mezzanine::xml::Document::SaveFile(const wchar_t* Path, const Mezzanine::xml::char_t* indent = &quot;\t&quot;, unsigned int flags = Mezzanine::xml::FormatDefault, Mezzanine::xml::Encoding encoding = EncodingAuto) const;</span>
<a name="l01407"></a>01407 <span class="comment">    /// @endcode</span>
<a name="l01408"></a>01408 <span class="comment">    /// These functions accept file path as its first argument, and also three optional arguments, which specify indentation and other output options (see Output options) and output data</span>
<a name="l01409"></a>01409 <span class="comment">    /// encoding ( see @ ref XMLSavingEncodings ). The Path has the target operating system format, so it can be a relative or absolute one, it should have the delimiters of the target</span>
<a name="l01410"></a>01410 <span class="comment">    /// system, it should have the exact case if the target file system is case-sensitive, etc.</span>
<a name="l01411"></a>01411 <span class="comment">    /// \n \n</span>
<a name="l01412"></a>01412 <span class="comment">    /// File path is passed to the system file opening function as is in case of the first function (which accepts const char* Path); the second function either uses a special file opening</span>
<a name="l01413"></a>01413 <span class="comment">    /// function if it is provided by the runtime library or converts the path to UTF-8 and uses the system file opening function.</span>
<a name="l01414"></a>01414 <span class="comment">    /// \n \n</span>
<a name="l01415"></a>01415 <span class="comment">    /// SaveFile opens the target file for writing, outputs the requested header (by default a document declaration is output, unless the document already has one), and then saves the</span>
<a name="l01416"></a>01416 <span class="comment">    /// document contents. If the file could not be opened, the function returns false. Calling SaveFile is equivalent to creating an Mezzanine::xml::WriterFile object with FILE* handle as the</span>
<a name="l01417"></a>01417 <span class="comment">    /// only constructor argument and then calling save; see @ref XMLSavingWriter for writer interface details.</span>
<a name="l01418"></a>01418 <span class="comment">    /// \n \n</span>
<a name="l01419"></a>01419 <span class="comment">    /// This is a simple example of saving XML document to a file :</span>
<a name="l01420"></a>01420 <span class="comment">    /// @code</span>
<a name="l01421"></a>01421 <span class="comment">    /// // save document to file</span>
<a name="l01422"></a>01422 <span class="comment">    /// std::cout &lt;&lt; &quot;Saving result: &quot; &lt;&lt; doc.SaveFile(&quot;save_file_output.xml&quot;) &lt;&lt; std::endl;</span>
<a name="l01423"></a>01423 <span class="comment">    /// @endcode</span>
<a name="l01424"></a>01424 <span class="comment">    /// @subsection XMLSavingStreams Saving Documents to C++ IOstreams</span>
<a name="l01425"></a>01425 <span class="comment">    /// To enhance interoperability Mezzanine::xml provides functions for saving document to any object which implements C++ std::ostream interface. This allows you to save documents to any</span>
<a name="l01426"></a>01426 <span class="comment">    /// standard C++ stream (i.e. file stream) or any third-party compliant implementation (i.e. Boost Iostreams). Most notably, this allows for easy debug output, since you can use</span>
<a name="l01427"></a>01427 <span class="comment">    /// std::cout stream as saving target. There are two functions, one works with narrow character streams, another handles wide character ones:</span>
<a name="l01428"></a>01428 <span class="comment">    /// @code</span>
<a name="l01429"></a>01429 <span class="comment">    /// void Mezzanine::xml::Document::Save(std::ostream&amp; stream, const char_t* indent = &quot;\t&quot;, unsigned int flags = Mezzanine::xml::FormatDefault, Mezzanine::xml::Encoding encoding = EncodingAuto) const;</span>
<a name="l01430"></a>01430 <span class="comment">    /// void Mezzanine::xml::Document::Save(std::wostream&amp; stream, const char_t* indent = &quot;\t&quot;, unsigned int flags = Mezzanine::xml::FormatDefault) const;</span>
<a name="l01431"></a>01431 <span class="comment">    /// @endcode</span>
<a name="l01432"></a>01432 <span class="comment">    /// Calling Save with an std::ostream argument saves the document to the stream in the same way as SaveFile (i.e. with requested header and with encoding conversions). On the other</span>
<a name="l01433"></a>01433 <span class="comment">    /// hand, save with std::wstream argument saves the document to the wide stream with @ref Mezzanine::xml::Encoding &quot;Encoding::Encodingwchar_t&quot; encoding. Because of this, using save with wide</span>
<a name="l01434"></a>01434 <span class="comment">    /// character streams requires careful (usually platform-specific) stream setup (i.e. using the imbue function). Generally use of wide streams is discouraged, however it provides you</span>
<a name="l01435"></a>01435 <span class="comment">    /// with the ability to save documents to non-Unicode encodings, i.e. you can save Shift-JIS encoded data if you set the correct locale.</span>
<a name="l01436"></a>01436 <span class="comment">    /// \n \n</span>
<a name="l01437"></a>01437 <span class="comment">    /// Calling Save with stream target is equivalent to creating an Mezzanine::xml::WriterStream object with stream as the only constructor argument and then calling save; see</span>
<a name="l01438"></a>01438 <span class="comment">    /// @ref XMLSavingWriter for writer interface details.</span>
<a name="l01439"></a>01439 <span class="comment">    /// \n \n</span>
<a name="l01440"></a>01440 <span class="comment">    /// This is a simple example of saving XML document to standard output:</span>
<a name="l01441"></a>01441 <span class="comment">    /// @code</span>
<a name="l01442"></a>01442 <span class="comment">    /// // save document to standard output</span>
<a name="l01443"></a>01443 <span class="comment">    /// std::cout &lt;&lt; &quot;Document:\n&quot;;</span>
<a name="l01444"></a>01444 <span class="comment">    /// doc.Save(std::cout);</span>
<a name="l01445"></a>01445 <span class="comment">    /// @endcode</span>
<a name="l01446"></a>01446 <span class="comment">    /// @subsection XMLSavingWriter Saving Document via Writer Interface</span>
<a name="l01447"></a>01447 <span class="comment">    /// All of the above saving functions are implemented in terms of the Mezzanine::xml::Writer interface. This is a simple interface with a single function, which is called several times</span>
<a name="l01448"></a>01448 <span class="comment">    /// during output process with chunks of document data as input.</span>
<a name="l01449"></a>01449 <span class="comment">    /// @code</span>
<a name="l01450"></a>01450 <span class="comment">    /// class Writer</span>
<a name="l01451"></a>01451 <span class="comment">    /// {</span>
<a name="l01452"></a>01452 <span class="comment">    /// public:</span>
<a name="l01453"></a>01453 <span class="comment">    ///     virtual void Write(const void* data, size_t size) = 0;</span>
<a name="l01454"></a>01454 <span class="comment">    /// };</span>
<a name="l01455"></a>01455 <span class="comment">    ///</span>
<a name="l01456"></a>01456 <span class="comment">    /// void Mezzanine::xml::Document::Save (Writer &amp;WriterInstance, const char_t *indent=XML_TEXT(&quot;\t&quot;), unsigned int flags=FormatDefault, Encoding DocumentEncoding=EncodingAuto) const;</span>
<a name="l01457"></a>01457 <span class="comment">    /// @endcode</span>
<a name="l01458"></a>01458 <span class="comment">    /// In order to output the document via some custom transport, for example sockets, you should create an object which implements Mezzanine::xml::Writer interface and pass it to save function.</span>
<a name="l01459"></a>01459 <span class="comment">    /// Mezzanine::xml::Writer::Write function is called with a buffer as an input, where data points to buffer start, and size is equal to the buffer size in bytes. The Write implementation must</span>
<a name="l01460"></a>01460 <span class="comment">    /// write the buffer to the transport; it can not save the passed buffer pointer, as the buffer contents will change after write returns. The buffer contains the chunk of document data</span>
<a name="l01461"></a>01461 <span class="comment">    /// in the desired encoding.</span>
<a name="l01462"></a>01462 <span class="comment">    /// \n \n</span>
<a name="l01463"></a>01463 <span class="comment">    /// The Write function is called with relatively large blocks (size is usually several kilobytes, except for the first block with BOM, which is output only if Mezzanine::xml::FormatWriteBom</span>
<a name="l01464"></a>01464 <span class="comment">    /// is set, and last block, which may be small), so there is often no need for additional buffering in the implementation.</span>
<a name="l01465"></a>01465 <span class="comment">    /// \n \n</span>
<a name="l01466"></a>01466 <span class="comment">    /// This is a simple example of custom writer for saving document data to STL string:</span>
<a name="l01467"></a>01467 <span class="comment">    /// @code</span>
<a name="l01468"></a>01468 <span class="comment">    /// struct StringWriter: Mezzanine::xml::Writer</span>
<a name="l01469"></a>01469 <span class="comment">    /// {</span>
<a name="l01470"></a>01470 <span class="comment">    ///     std::string Result;</span>
<a name="l01471"></a>01471 <span class="comment">    ///</span>
<a name="l01472"></a>01472 <span class="comment">    ///     virtual void Write(const void* data, size_t size)</span>
<a name="l01473"></a>01473 <span class="comment">    ///     {</span>
<a name="l01474"></a>01474 <span class="comment">    ///         Result += std::string(static_cast&lt;const char*&gt;(data), size);</span>
<a name="l01475"></a>01475 <span class="comment">    ///     }</span>
<a name="l01476"></a>01476 <span class="comment">    /// };</span>
<a name="l01477"></a>01477 <span class="comment">    /// @endcode</span>
<a name="l01478"></a>01478 <span class="comment">    /// @subsection XMLSavingSubtree Saving a Single Subtree</span>
<a name="l01479"></a>01479 <span class="comment">    /// While the previously described functions save the whole document to the destination, it is easy to save a single subtree. The following functions are provided:</span>
<a name="l01480"></a>01480 <span class="comment">    /// @code</span>
<a name="l01481"></a>01481 <span class="comment">    /// void Mezzanine::xml::Node::Print(std::basic_ostream&lt; char, std::char_traits&lt; char &gt; &gt; &amp;os, const char_t *indent=XML_TEXT(&quot;\t&quot;), unsigned int flags=FormatDefault, Encoding DocumentEncoding=EncodingAuto, unsigned int Depth=0) const ;</span>
<a name="l01482"></a>01482 <span class="comment">    /// void Mezzanine::xml::Node::Print(std::basic_ostream&lt; wchar_t, std::char_traits&lt; wchar_t &gt; &gt; &amp;os, const char_t *indent=XML_TEXT(&quot;\t&quot;), unsigned int flags=FormatDefault, unsigned int Depth=0) const ) const;</span>
<a name="l01483"></a>01483 <span class="comment">    /// void Mezzanine::xml::Node::Print(Mezzanine::xml::Writer &amp;WriterInstance, const char_t *indent=XML_TEXT(&quot;\t&quot;), unsigned int flags=FormatDefault, Encoding DocumentEncoding=EncodingAuto, unsigned int Depth=0) const;</span>
<a name="l01484"></a>01484 <span class="comment">    /// @endcode</span>
<a name="l01485"></a>01485 <span class="comment">    /// These functions have the same arguments with the same meaning as the corresponding Mezzanine::xml::Document::Save functions, and allow you to save the subtree to either a C++ IOstream</span>
<a name="l01486"></a>01486 <span class="comment">    /// or to any object that implements Mezzanine::xml::Writer interface.</span>
<a name="l01487"></a>01487 <span class="comment">    /// \n \n</span>
<a name="l01488"></a>01488 <span class="comment">    /// Saving a subtree differs from saving the whole document: the process behaves as if Mezzanine::xml::FormatWriteBom is off, and Mezzanine::xml::FormatNoDeclaration is on, even if actual values</span>
<a name="l01489"></a>01489 <span class="comment">    /// of the flags are different. This means that BOM is not written to the destination, and document declaration is only written if it is the node itself or is one of node&#39;s children.</span>
<a name="l01490"></a>01490 <span class="comment">    /// Note that this also holds if you&#39;re saving a document; this example illustrates the difference:</span>
<a name="l01491"></a>01491 <span class="comment">    /// @code</span>
<a name="l01492"></a>01492 <span class="comment">    /// // get a test document</span>
<a name="l01493"></a>01493 <span class="comment">    /// Mezzanine::xml::Document doc;</span>
<a name="l01494"></a>01494 <span class="comment">    /// doc.Load(&quot;&lt;foo bar=&#39;baz&#39;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;&quot;);</span>
<a name="l01495"></a>01495 <span class="comment">    ///</span>
<a name="l01496"></a>01496 <span class="comment">    /// // print document to standard output (prints &lt;?xml version=&quot;1.0&quot;?&gt;&lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span>
<a name="l01497"></a>01497 <span class="comment">    /// doc.Save(std::cout, &quot;&quot;, Mezzanine::xml::FormatRaw);</span>
<a name="l01498"></a>01498 <span class="comment">    /// std::cout &lt;&lt; std::endl;</span>
<a name="l01499"></a>01499 <span class="comment">    ///</span>
<a name="l01500"></a>01500 <span class="comment">    /// // print document to standard output as a regular node (prints &lt;foo bar=&quot;baz&quot;&gt;&lt;call&gt;hey&lt;/call&gt;&lt;/foo&gt;)</span>
<a name="l01501"></a>01501 <span class="comment">    /// doc.Print(std::cout, &quot;&quot;, Mezzanine::xml::FormatRaw);</span>
<a name="l01502"></a>01502 <span class="comment">    /// std::cout &lt;&lt; std::endl;</span>
<a name="l01503"></a>01503 <span class="comment">    ///</span>
<a name="l01504"></a>01504 <span class="comment">    /// // print a subtree to standard output (prints &lt;call&gt;hey&lt;/call&gt;)</span>
<a name="l01505"></a>01505 <span class="comment">    /// doc.GetChild(&quot;foo&quot;).GetChild(&quot;call&quot;).Print(std::cout, &quot;&quot;, Mezzanine::xml::FormatRaw);</span>
<a name="l01506"></a>01506 <span class="comment">    /// std::cout &lt;&lt; std::endl;</span>
<a name="l01507"></a>01507 <span class="comment">    /// @endcode</span>
<a name="l01508"></a>01508 <span class="comment">    /// @subsection XMLSavingOptions Output Options</span>
<a name="l01509"></a>01509 <span class="comment">    /// All saving functions accept the optional parameter flags. This is a bitmask that customizes the output format; you can select the way the document nodes are printed and select the</span>
<a name="l01510"></a>01510 <span class="comment">    /// needed additional information that is output before the document contents.</span>
<a name="l01511"></a>01511 <span class="comment">    /// @note You should use the usual bitwise arithmetics to manipulate the bitmask: to enable a flag, use mask | flag; to disable a flag, use mask &amp; ~flag.</span>
<a name="l01512"></a>01512 <span class="comment">    ///</span>
<a name="l01513"></a>01513 <span class="comment">    /// These flags control the resulting tree contents:</span>
<a name="l01514"></a>01514 <span class="comment">    ///     - Mezzanine::xml::FormatIndent determines if all nodes should be indented with the indentation string (this is an additional parameter for all saving functions, and is &quot;\t&quot; by - default).</span>
<a name="l01515"></a>01515 <span class="comment">    ///     If this flag is on, before every node the indentation string is output several times, where the amount of indentation depends on the node&#39;s depth relative to the</span>
<a name="l01516"></a>01516 <span class="comment">    ///     output subtree. This flag has no effect if Mezzanine::xml::FormatRaw is enabled. This flag is off by default.</span>
<a name="l01517"></a>01517 <span class="comment">    ///     - Mezzanine::xml::FormatRaw switches between formatted and raw output. If this flag is on, the nodes are not indented in any way, and also no newlines that are not part of</span>
<a name="l01518"></a>01518 <span class="comment">    ///     document text are printed. Raw mode can be used for serialization where the result is not intended to be read by humans; also it can be useful if the document was parsed</span>
<a name="l01519"></a>01519 <span class="comment">    ///     with Mezzanine::xml::ParseWsPcdata flag, to preserve the original document formatting as much as possible. This flag is on by default.</span>
<a name="l01520"></a>01520 <span class="comment">    ///</span>
<a name="l01521"></a>01521 <span class="comment">    ///These flags control the additional output information:</span>
<a name="l01522"></a>01522 <span class="comment">    ///     - Mezzanine::xml::FormatNoDeclaration disables default node declaration output. By default, if the document is saved via save or SaveFile function, and it does not have any</span>
<a name="l01523"></a>01523 <span class="comment">    ///     document declaration, a default declaration is output before the document contents. Enabling this flag disables this declaration. This flag has no effect in</span>
<a name="l01524"></a>01524 <span class="comment">    ///     Mezzanine::xml::Node::Print functions: they never output the default declaration. This flag is off by default.</span>
<a name="l01525"></a>01525 <span class="comment">    ///     - Mezzanine::xml::FormatWriteBom enables Byte Order Mark (BOM) output. By default, no BOM is output, so in case of non UTF-8 encodings the resulting document&#39;s encoding may not</span>
<a name="l01526"></a>01526 <span class="comment">    ///     be recognized by some parsers and text editors, if they do not implement sophisticated encoding detection. Enabling this flag adds an encoding-specific BOM to the output. This</span>
<a name="l01527"></a>01527 <span class="comment">    ///     flag has no effect in Mezzanine::xml::Node::Print functions: they never output the BOM. This flag is off by default.</span>
<a name="l01528"></a>01528 <span class="comment">    ///</span>
<a name="l01529"></a>01529 <span class="comment">    /// Additionally, there is one predefined option mask:</span>
<a name="l01530"></a>01530 <span class="comment">    ///     - Mezzanine::xml::FormatDefault is the default set of flags, i.e. it has all options set to their default values. This differs from the default pugixml settings and only sets</span>
<a name="l01531"></a>01531 <span class="comment">    ///     Mezzanine::xml::FormatRaw . This is to minimize output size, and optimize for computer consumption of xml.</span>
<a name="l01532"></a>01532 <span class="comment">    ///</span>
<a name="l01533"></a>01533 <span class="comment">    /// @subsection XMLSavingEncodings Encodings</span>
<a name="l01534"></a>01534 <span class="comment">    /// Mezzanine::xml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it&#39;s a strict subset</span>
<a name="l01535"></a>01535 <span class="comment">    /// of UTF-16) and handles all encoding conversions during output. The output encoding is set via the encoding parameter of saving functions, which is of type xml_encoding. The</span>
<a name="l01536"></a>01536 <span class="comment">    /// possible values for the encoding are documented in Encodings; the only flag that has a different meaning is EncodingAuto.</span>
<a name="l01537"></a>01537 <span class="comment">    /// \n \n</span>
<a name="l01538"></a>01538 <span class="comment">    /// While all other flags set the exact encoding, EncodingAuto is meant for automatic encoding detection. The automatic detection does not make sense for output encoding, since there</span>
<a name="l01539"></a>01539 <span class="comment">    /// is usually nothing to infer the actual encoding from, so here @ref Mezzanine::xml::Encoding &quot;EncodingAuto&quot; means UTF-8 encoding, which is the most popular encoding for XML data storage. This is also the default</span>
<a name="l01540"></a>01540 <span class="comment">    /// value of output encoding; specify another value if you do not want UTF-8 encoded output.</span>
<a name="l01541"></a>01541 <span class="comment">    /// \n \n</span>
<a name="l01542"></a>01542 <span class="comment">    /// Also note that wide stream saving functions do not have encoding argument and always assume @ref Mezzanine::xml::Encoding &quot;Encodingwchar_t&quot; encoding.</span>
<a name="l01543"></a>01543 <span class="comment">    /// @note The current behavior for Unicode conversion is to skip all invalid UTF sequences during conversion. This behavior should not be relied upon; if your node/attribute names do</span>
<a name="l01544"></a>01544 <span class="comment">    /// not contain any valid UTF sequences, they may be output as if they are empty, which will result in malformed XML document.</span>
<a name="l01545"></a>01545 <span class="comment">    /// @section XMLXPath XPath</span>
<a name="l01546"></a>01546 <span class="comment">    ///     - @ref XMLXPathTypes</span>
<a name="l01547"></a>01547 <span class="comment">    ///     - @ref XMLXPathSelecting</span>
<a name="l01548"></a>01548 <span class="comment">    ///     - @ref XMLXPathQuery</span>
<a name="l01549"></a>01549 <span class="comment">    ///     - @ref XMLXPathVariables</span>
<a name="l01550"></a>01550 <span class="comment">    ///     - @ref XMLXPathError</span>
<a name="l01551"></a>01551 <span class="comment">    ///     - @ref XMLXPathStandards</span>
<a name="l01552"></a>01552 <span class="comment">    ///</span>
<a name="l01553"></a>01553 <span class="comment">    /// If the task at hand is to select a subset of document nodes that match some criteria, it is possible to code a function using the existing traversal functionality for any practical</span>
<a name="l01554"></a>01554 <span class="comment">    /// criteria. However, often either a data-driven approach is desirable, in case the criteria are not predefined and come from a file, or it is inconvenient to use traversal interfaces</span>
<a name="l01555"></a>01555 <span class="comment">    /// and a higher-level Domain Specific Language is required. There is a standard language for XML processing, XPath, that can be useful for these cases. Mezzanine::xml implements an almost</span>
<a name="l01556"></a>01556 <span class="comment">    /// complete subset of XPath 1.0. Because of differences in document object model and some performance implications, there are minor violations of the official specifications, which</span>
<a name="l01557"></a>01557 <span class="comment">    /// can be found in @ref XMLXPathStandards . The rest of this section describes the interface for XPath functionality. Please note that if you wish to learn to use XPath language, you</span>
<a name="l01558"></a>01558 <span class="comment">    /// have to look for other tutorials or manuals.</span>
<a name="l01559"></a>01559 <span class="comment">    /// \n \n</span>
<a name="l01560"></a>01560 <span class="comment">    /// @subsection XMLXPathTypes XPath Types</span>
<a name="l01561"></a>01561 <span class="comment">    /// Each XPath expression can have one of the following types: boolean, number, string or node set. Boolean type corresponds to bool type, number type corresponds to double type, string</span>
<a name="l01562"></a>01562 <span class="comment">    /// type corresponds to either std::string or std::wstring, depending on whether wide character interface is enabled, and node set corresponds to Mezzanine::xml::XPathNodeSet type. There is</span>
<a name="l01563"></a>01563 <span class="comment">    /// an enumeration, Mezzanine::xml::XPathValueType, which can take the values @ref Mezzanine::xml::XPathValueType &quot;XPathTypeBoolean&quot;, @ref Mezzanine::xml::XPathValueType &quot;XPathTypeNumber&quot;,</span>
<a name="l01564"></a>01564 <span class="comment">    /// @ref Mezzanine::xml::XPathValueType XPathTypeString or @ref Mezzanine::xml::XPathValueType XPathTypeNodeSet, accordingly.</span>
<a name="l01565"></a>01565 <span class="comment">    /// \n \n</span>
<a name="l01566"></a>01566 <span class="comment">    /// Because an XPath node can be either a node or an attribute, there is a special type, Mezzanine::xml::XPathNode, which is a discriminated union of these types. A value of this type</span>
<a name="l01567"></a>01567 <span class="comment">    /// contains two node handles, one of Mezzanine::xml::Node type, and another one of Mezzanine::xml::Attribute type; at most one of them can be non-null. The accessors to get these handles are</span>
<a name="l01568"></a>01568 <span class="comment">    /// available:</span>
<a name="l01569"></a>01569 <span class="comment">    /// @code</span>
<a name="l01570"></a>01570 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::XPathNode::GetNode() const;</span>
<a name="l01571"></a>01571 <span class="comment">    /// Mezzanine::xml::Attribute Mezzanine::xml::XPathNode::GetAttribute() const;</span>
<a name="l01572"></a>01572 <span class="comment">    /// @endcode</span>
<a name="l01573"></a>01573 <span class="comment">    /// XPath nodes can be null, in which case both accessors return null handles.</span>
<a name="l01574"></a>01574 <span class="comment">    /// \n \n</span>
<a name="l01575"></a>01575 <span class="comment">    /// Note that as per XPath specification, each XPath node has a parent, which can be retrieved via this function:</span>
<a name="l01576"></a>01576 <span class="comment">    /// @code</span>
<a name="l01577"></a>01577 <span class="comment">    /// Mezzanine::xml::Node Mezzanine::xml::XPathNode::GetParent() const;</span>
<a name="l01578"></a>01578 <span class="comment">    /// @endcode</span>
<a name="l01579"></a>01579 <span class="comment">    /// The GetParent function returns the node&#39;s parent if the XPath node corresponds to Mezzanine::xml::Node handle (equivalent to GetNode().GetParent()), or the node to which the attribute</span>
<a name="l01580"></a>01580 <span class="comment">    /// belongs to, if the XPath node corresponds to Mezzanine::xml::Attribute handle. For null nodes, parent returns null handle.</span>
<a name="l01581"></a>01581 <span class="comment">    /// \n \n</span>
<a name="l01582"></a>01582 <span class="comment">    /// Like node and attribute handles, XPath node handles can be implicitly cast to boolean-like object to check if it is a null node, and also can be compared for equality with</span>
<a name="l01583"></a>01583 <span class="comment">    /// each other.</span>
<a name="l01584"></a>01584 <span class="comment">    /// \n \n</span>
<a name="l01585"></a>01585 <span class="comment">    /// You can also create XPath nodes with one of the three constructors: the default constructor, the constructor that takes node argument, and the constructor that takes an attribute</span>
<a name="l01586"></a>01586 <span class="comment">    /// and a node argument (in which case the attribute must belong to the attribute list of the node). The constructor from Mezzanine::xml::Node is implicit, so you can usually pass</span>
<a name="l01587"></a>01587 <span class="comment">    /// Mezzanine::xml::Node to functions that expect Mezzanine::xml::XPathNode. Apart from that you usually don&#39;t need to create your own XPath node objects, since they are returned to you via</span>
<a name="l01588"></a>01588 <span class="comment">    /// selection functions.</span>
<a name="l01589"></a>01589 <span class="comment">    /// \n \n</span>
<a name="l01590"></a>01590 <span class="comment">    /// XPath expressions operate not on single nodes, but instead on node sets. A node set is a collection of nodes, which can be optionally ordered in either a forward document order</span>
<a name="l01591"></a>01591 <span class="comment">    /// or a reverse one. Document order is defined in XPath specification; an XPath node is before another node in document order if it appears before it in XML representation of the</span>
<a name="l01592"></a>01592 <span class="comment">    /// corresponding document.</span>
<a name="l01593"></a>01593 <span class="comment">    /// \n \n</span>
<a name="l01594"></a>01594 <span class="comment">    /// Node sets are represented by Mezzanine::xml::XPathNodeSet object, which has an interface that resembles one of sequential random-access containers. It has an iterator type along with</span>
<a name="l01595"></a>01595 <span class="comment">    /// usual begin/past-the-end iterator accessors:</span>
<a name="l01596"></a>01596 <span class="comment">    /// @code</span>
<a name="l01597"></a>01597 <span class="comment">    /// typedef const Mezzanine::xml::XPathNode* Mezzanine::xml::XPathNodeSet::const_iterator;</span>
<a name="l01598"></a>01598 <span class="comment">    /// const_iterator Mezzanine::xml::XPathNodeSet::begin() const;</span>
<a name="l01599"></a>01599 <span class="comment">    /// const_iterator Mezzanine::xml::XPathNodeSet::end() const;</span>
<a name="l01600"></a>01600 <span class="comment">    /// @endcode</span>
<a name="l01601"></a>01601 <span class="comment">    /// And it also can be iterated via indices, just like std::vector:</span>
<a name="l01602"></a>01602 <span class="comment">    /// @code</span>
<a name="l01603"></a>01603 <span class="comment">    /// const Mezzanine::xml::XPathNode&amp; Mezzanine::xml::XPathNodeSet::operator[](size_t index) const;</span>
<a name="l01604"></a>01604 <span class="comment">    /// size_t Mezzanine::xml::XPathNodeSet::size() const;</span>
<a name="l01605"></a>01605 <span class="comment">    /// bool Mezzanine::xml::XPathNodeSet::empty() const;</span>
<a name="l01606"></a>01606 <span class="comment">    /// @endcode</span>
<a name="l01607"></a>01607 <span class="comment">    /// All of the above operations have the same semantics as that of std::vector: the iterators are random-access, all of the above operations are constant time, and accessing the element</span>
<a name="l01608"></a>01608 <span class="comment">    /// at index that is greater or equal than the set size results in undefined behavior. You can use both iterator-based and index-based access for iteration, however the iterator-based</span>
<a name="l01609"></a>01609 <span class="comment">    /// one can be faster.</span>
<a name="l01610"></a>01610 <span class="comment">    /// \n \n</span>
<a name="l01611"></a>01611 <span class="comment">    /// The order of iteration depends on the order of nodes inside the set; the order can be queried via the following function:</span>
<a name="l01612"></a>01612 <span class="comment">    /// @code</span>
<a name="l01613"></a>01613 <span class="comment">    /// enum Mezzanine::xml::XPathNodeSet::CollectionType { TypeUnsorted, TypeSorted, TypeSortedReverse };</span>
<a name="l01614"></a>01614 <span class="comment">    /// CollectionType Mezzanine::xml::XPathNodeSet::Type() const;</span>
<a name="l01615"></a>01615 <span class="comment">    /// @endcode</span>
<a name="l01616"></a>01616 <span class="comment">    /// The Type function returns the current order of nodes; TypeSorted means that the nodes are in forward document order, TypeSortedReverse means that the nodes are in reverse document</span>
<a name="l01617"></a>01617 <span class="comment">    /// order, and TypeUnsorted means that neither order is guaranteed (nodes can accidentally be in a sorted order even if Type() returns TypeUnsorted). If you require a specific order of</span>
<a name="l01618"></a>01618 <span class="comment">    /// iteration, you can change it via sort function:</span>
<a name="l01619"></a>01619 <span class="comment">    /// void Mezzanine::xml::XPathNodeSet::sort(bool reverse = false);</span>
<a name="l01620"></a>01620 <span class="comment">    /// @warning When converted from the pugixml naming scheme, changes were made to this class conservatively. Once it is determine what the new names should be. this could be changed.</span>
<a name="l01621"></a>01621 <span class="comment">    ///</span>
<a name="l01622"></a>01622 <span class="comment">    /// Calling sort sorts the nodes in either forward or reverse document order, depending on the argument; after this call Type() will return TypeSorted or TypeSortedReverse.</span>
<a name="l01623"></a>01623 <span class="comment">    /// \n \n</span>
<a name="l01624"></a>01624 <span class="comment">    /// Often the actual iteration is not needed; instead, only the first element in document order is required. For this, a special accessor is provided:</span>
<a name="l01625"></a>01625 <span class="comment">    /// @code</span>
<a name="l01626"></a>01626 <span class="comment">    /// Mezzanine::xml::XPathNode Mezzanine::xml::XPathNodeSet::first() const;</span>
<a name="l01627"></a>01627 <span class="comment">    /// @endcode</span>
<a name="l01628"></a>01628 <span class="comment">    /// This function returns the first node in forward document order from the set, or null node if the set is empty. Note that while the result of the node does not depend on the order of</span>
<a name="l01629"></a>01629 <span class="comment">    /// nodes in the set (i.e. on the result of Type()), the complexity does - if the set is sorted, the complexity is constant, otherwise it is linear in the number of elements or worse.</span>
<a name="l01630"></a>01630 <span class="comment">    /// \n \n</span>
<a name="l01631"></a>01631 <span class="comment">    /// While in the majority of cases the node set is returned by XPath functions, sometimes there is a need to manually construct a node set. For such cases, a constructor is provided</span>
<a name="l01632"></a>01632 <span class="comment">    /// which takes an iterator range (const_iterator is a typedef for const Mezzanine::xml::XPathNode*), and an optional type:</span>
<a name="l01633"></a>01633 <span class="comment">    /// @code</span>
<a name="l01634"></a>01634 <span class="comment">    /// Mezzanine::xml::XPathNodeSet::XPathNodeSet(const_iterator begin, const_iterator end, CollectionType Type=TypeUnsorted);</span>
<a name="l01635"></a>01635 <span class="comment">    /// @endcode</span>
<a name="l01636"></a>01636 <span class="comment">    /// The constructor copies the specified range and sets the specified type. The objects in the range are not checked in any way; you&#39;ll have to ensure that the range contains no</span>
<a name="l01637"></a>01637 <span class="comment">    /// duplicates, and that the objects are sorted according to the type parameter. Otherwise XPath operations with this set may produce unexpected results.</span>
<a name="l01638"></a>01638 <span class="comment">    /// \n \n</span>
<a name="l01639"></a>01639 <span class="comment">    /// @subsection XMLXPathSelecting Selecting Nodes via XPath Expression</span>
<a name="l01640"></a>01640 <span class="comment">    /// If you want to select nodes that match some XPath expression, you can do it with the following functions:</span>
<a name="l01641"></a>01641 <span class="comment">    /// @code</span>
<a name="l01642"></a>01642 <span class="comment">    /// Mezzanine::xml::XPathNode Mezzanine::xml::Node::FindSingleNode(const char_t* query, XPathVariableSet* variables = 0) const;</span>
<a name="l01643"></a>01643 <span class="comment">    /// Mezzanine::xml::XPathNodeSet Mezzanine::xml::Node::FindNodes(const char_t* query, XPathVariableSet* variables = 0) const;</span>
<a name="l01644"></a>01644 <span class="comment">    /// @endcode</span>
<a name="l01645"></a>01645 <span class="comment">    /// The FindNodes function compiles the expression and then executes it with the node as a context node, and returns the resulting node set. FindSingleNode returns only the first node</span>
<a name="l01646"></a>01646 <span class="comment">    /// in document order from the result, and is equivalent to calling FindNodes(query).first(). If the XPath expression does not match anything, or the node handle is null, FindNodes</span>
<a name="l01647"></a>01647 <span class="comment">    /// returns an empty set, and FindSingleNode returns null XPath node.</span>
<a name="l01648"></a>01648 <span class="comment">    /// \n \n</span>
<a name="l01649"></a>01649 <span class="comment">    /// If exception handling is not disabled, both functions throw Mezzanine::xml::XPathException if the query can not be compiled or if it returns a value with type other than node set; see</span>
<a name="l01650"></a>01650 <span class="comment">    /// Error handling for details.</span>
<a name="l01651"></a>01651 <span class="comment">    /// \n \n</span>
<a name="l01652"></a>01652 <span class="comment">    /// While compiling expressions is fast, the compilation time can introduce a significant overhead if the same expression is used many times on small subtrees. If you&#39;re doing many</span>
<a name="l01653"></a>01653 <span class="comment">    /// similar queries, consider compiling them into query objects (see @ref XMLXPathQuery for further reference). Once you get a compiled query object, you can pass it to Find functions</span>
<a name="l01654"></a>01654 <span class="comment">    /// instead of an expression string:</span>
<a name="l01655"></a>01655 <span class="comment">    /// @code</span>
<a name="l01656"></a>01656 <span class="comment">    /// Mezzanine::xml::XPathNode Mezzanine::xml::Node::FindSingleNode(const Mezzanine::xml::XPathQuery&amp; query) const;</span>
<a name="l01657"></a>01657 <span class="comment">    /// Mezzanine::xml::XPathNodeSet Mezzanine::xml::Node::FindNodes(const Mezzanine::xml::XPathQuery&amp; query) const;</span>
<a name="l01658"></a>01658 <span class="comment">    /// @endcode</span>
<a name="l01659"></a>01659 <span class="comment">    /// If exception handling is not disabled, both functions throw Mezzanine::xml::XPathException if the query returns a value with type other than node set.</span>
<a name="l01660"></a>01660 <span class="comment">    /// \n \n</span>
<a name="l01661"></a>01661 <span class="comment">    /// This is an example of selecting nodes using XPath expressions:</span>
<a name="l01662"></a>01662 <span class="comment">    /// @code</span>
<a name="l01663"></a>01663 <span class="comment">    /// Mezzanine::xml::XPathNodeSet tools = doc.FindNodes(&quot;/Profile/Tools/Tool[@AllowRemote=&#39;true&#39; and @DeriveCaptionFrom=&#39;lastparam&#39;]&quot;);</span>
<a name="l01664"></a>01664 <span class="comment">    ///</span>
<a name="l01665"></a>01665 <span class="comment">    /// std::cout &lt;&lt; &quot;Tools:&quot;;</span>
<a name="l01666"></a>01666 <span class="comment">    ///</span>
<a name="l01667"></a>01667 <span class="comment">    /// for (Mezzanine::xml::XPathNodeSet::const_iterator it = tools.begin(); it != tools.end(); ++it)</span>
<a name="l01668"></a>01668 <span class="comment">    /// {</span>
<a name="l01669"></a>01669 <span class="comment">    ///     Mezzanine::xml::XPathNode node = *it;</span>
<a name="l01670"></a>01670 <span class="comment">    ///     std::cout &lt;&lt; &quot; &quot; &lt;&lt; node.GetNode().GetAttribute(&quot;Filename&quot;).Value();</span>
<a name="l01671"></a>01671 <span class="comment">    /// }</span>
<a name="l01672"></a>01672 <span class="comment">    ///</span>
<a name="l01673"></a>01673 <span class="comment">    /// Mezzanine::xml::XPathNode BuildTool = doc.FindSingleNode(&quot;//Tool[contains(Description, &#39;build system&#39;)]&quot;);</span>
<a name="l01674"></a>01674 <span class="comment">    ///</span>
<a name="l01675"></a>01675 <span class="comment">    /// std::cout &lt;&lt; &quot;\nBuild tool: &quot; &lt;&lt; BuildTool.GetNode().GetAttribute(&quot;Filename&quot;).Value() &lt;&lt; &quot;\n&quot;;</span>
<a name="l01676"></a>01676 <span class="comment">    /// @endcode</span>
<a name="l01677"></a>01677 <span class="comment">    /// @subsection XMLXPathQuery Using Query Objects</span>
<a name="l01678"></a>01678 <span class="comment">    /// When you call FindNodes with an expression string as an argument, a query object is created behind the scenes. A query object represents a compiled XPath expression. Query objects</span>
<a name="l01679"></a>01679 <span class="comment">    /// can be useful in the following circumstances:</span>
<a name="l01680"></a>01680 <span class="comment">    ///     - You can precompile expressions to query objects to save compilation time if it becomes an issue;</span>
<a name="l01681"></a>01681 <span class="comment">    ///     - You can use query objects to evaluate XPath expressions which result in booleans, numbers or strings;</span>
<a name="l01682"></a>01682 <span class="comment">    ///     - You can get the type of expression value via query object.</span>
<a name="l01683"></a>01683 <span class="comment">    ///</span>
<a name="l01684"></a>01684 <span class="comment">    /// Query objects correspond to Mezzanine::xml::XPathQuery type. They are immutable and non-copyable: they are bound to the expression at creation time and can not be cloned. If you want to</span>
<a name="l01685"></a>01685 <span class="comment">    /// put query objects in a container, allocate them on heap via new operator and store pointers to Mezzanine::xml::XPathQuery in the container.</span>
<a name="l01686"></a>01686 <span class="comment">    /// \n \n</span>
<a name="l01687"></a>01687 <span class="comment">    /// You can create a query object with the constructor that takes XPath expression as an argument:</span>
<a name="l01688"></a>01688 <span class="comment">    /// @code</span>
<a name="l01689"></a>01689 <span class="comment">    /// explicit Mezzanine::xml::XPathQuery::XPathQuery(const char_t* query, XPathVariableSet* variables = 0);</span>
<a name="l01690"></a>01690 <span class="comment">    /// @endcode</span>
<a name="l01691"></a>01691 <span class="comment">    /// The expression is compiled and the compiled representation is stored in the new query object. If compilation fails, XPathException is thrown if exception handling is not disabled</span>
<a name="l01692"></a>01692 <span class="comment">    /// (see @ref XMLXPathError for details). After the query is created, you can query the type of the evaluation result using the following function:</span>
<a name="l01693"></a>01693 <span class="comment">    /// @code</span>
<a name="l01694"></a>01694 <span class="comment">    /// Mezzanine::xml::XPathValueType Mezzanine::xml::XPathQuery::ReturnType() const;</span>
<a name="l01695"></a>01695 <span class="comment">    /// @endcode</span>
<a name="l01696"></a>01696 <span class="comment">    /// You can evaluate the query using one of the following functions:</span>
<a name="l01697"></a>01697 <span class="comment">    /// @code</span>
<a name="l01698"></a>01698 <span class="comment">    /// bool Mezzanine::xml::XPathQuery::EvaluateBoolean(const Mezzanine::xml::XPathNode&amp; n) const;</span>
<a name="l01699"></a>01699 <span class="comment">    /// double Mezzanine::xml::XPathQuery::EvaluateNumber(const Mezzanine::xml::XPathNode&amp; n) const;</span>
<a name="l01700"></a>01700 <span class="comment">    /// Mezzanine::String Mezzanine::xml::XPathQuery::EvaluateString(const Mezzanine::xml::XPathNode&amp; n) const;</span>
<a name="l01701"></a>01701 <span class="comment">    /// Mezzanine::xml::XPathNodeSet Mezzanine::xml::XPathQuery::EvaluateNodeSet(const Mezzanine::xml::XPathNode&amp; n) const;</span>
<a name="l01702"></a>01702 <span class="comment">    /// @endcode</span>
<a name="l01703"></a>01703 <span class="comment">    /// All functions take the context node as an argument, compute the expression and return the result, converted to the requested type. According to XPath specification, value of any</span>
<a name="l01704"></a>01704 <span class="comment">    /// type can be converted to boolean, number or string value, but no type other than node set can be converted to node set. Because of this, EvaluateBoolean, EvaluateNumber and</span>
<a name="l01705"></a>01705 <span class="comment">    /// EvaluateString always return a result, but EvaluateNodeSet results in an error if the return type is not node set ( see @ref XMLXPathError ).</span>
<a name="l01706"></a>01706 <span class="comment">    /// @note Calling node.FindNodes(&quot;query&quot;) is equivalent to calling Mezzanine::xml::XPathQuery(&quot;query&quot;).EvaluateNodeSet(node).</span>
<a name="l01707"></a>01707 <span class="comment">    ///</span>
<a name="l01708"></a>01708 <span class="comment">    /// Note that EvaluateString function returns the STL string; as such, it&#39;s not available in XML_NO_STL mode and also usually allocates memory. There is another string evaluation</span>
<a name="l01709"></a>01709 <span class="comment">    /// function:</span>
<a name="l01710"></a>01710 <span class="comment">    /// @code</span>
<a name="l01711"></a>01711 <span class="comment">    /// size_t Mezzanine::xml::XPathQuery::EvaluateString(char_t* buffer, size_t capacity, const Mezzanine::xml::XPathNode&amp; n) const;</span>
<a name="l01712"></a>01712 <span class="comment">    /// @endcode</span>
<a name="l01713"></a>01713 <span class="comment">    /// This function evaluates the string, and then writes the result to buffer (but at most capacity characters); then it returns the full size of the result in characters, including</span>
<a name="l01714"></a>01714 <span class="comment">    /// the terminating zero. If capacity is not 0, the resulting buffer is always zero-terminated. You can use this function as follows:</span>
<a name="l01715"></a>01715 <span class="comment">    ///     - First call the function with buffer = 0 and capacity = 0; then allocate the returned amount of characters, and call the function again, passing the allocated storage and the</span>
<a name="l01716"></a>01716 <span class="comment">    ///     amount of characters;</span>
<a name="l01717"></a>01717 <span class="comment">    ///     - First call the function with small buffer and buffer capacity; then, if the result is larger than the capacity, the output has been trimmed, so allocate a larger buffer and</span>
<a name="l01718"></a>01718 <span class="comment">    ///     call the function again.</span>
<a name="l01719"></a>01719 <span class="comment">    ///</span>
<a name="l01720"></a>01720 <span class="comment">    /// This is an example of using query objects:</span>
<a name="l01721"></a>01721 <span class="comment">    /// @code</span>
<a name="l01722"></a>01722 <span class="comment">    /// // Select nodes via compiled query</span>
<a name="l01723"></a>01723 <span class="comment">    /// Mezzanine::xml::XPathQuery QueryRemoteTools(&quot;/Profile/Tools/Tool[@AllowRemote=&#39;true&#39;]&quot;);</span>
<a name="l01724"></a>01724 <span class="comment">    ///</span>
<a name="l01725"></a>01725 <span class="comment">    /// Mezzanine::xml::XPathNodeSet tools = QueryRemoteTools.EvaluateNodeSet(doc);</span>
<a name="l01726"></a>01726 <span class="comment">    /// std::cout &lt;&lt; &quot;Remote tool: &quot;;</span>
<a name="l01727"></a>01727 <span class="comment">    /// tools[2].node().print(std::cout);</span>
<a name="l01728"></a>01728 <span class="comment">    ///</span>
<a name="l01729"></a>01729 <span class="comment">    /// // Evaluate numbers via compiled query</span>
<a name="l01730"></a>01730 <span class="comment">    /// Mezzanine::xml::XPathQuery QueryTimeouts(&quot;sum(//Tool/@Timeout)&quot;);</span>
<a name="l01731"></a>01731 <span class="comment">    /// std::cout &lt;&lt; QueryTimeouts.EvaluateNumber(doc) &lt;&lt; std::endl;</span>
<a name="l01732"></a>01732 <span class="comment">    ///</span>
<a name="l01733"></a>01733 <span class="comment">    /// // Evaluate strings via compiled query for different context nodes</span>
<a name="l01734"></a>01734 <span class="comment">    /// Mezzanine::xml::XPathQuery QueryNameValid(&quot;string-length(substring-before(@Filename, &#39;_&#39;)) &gt; 0 and @OutputFileMasks&quot;);</span>
<a name="l01735"></a>01735 <span class="comment">    /// Mezzanine::xml::XPathQuery QueryName(&quot;concat(substring-before(@Filename, &#39;_&#39;), &#39; produces &#39;, @OutputFileMasks)&quot;);</span>
<a name="l01736"></a>01736 <span class="comment">    ///</span>
<a name="l01737"></a>01737 <span class="comment">    /// for (Mezzanine::xml::Node tool = doc.FirstElementByPath(&quot;Profile/Tools/Tool&quot;); tool; tool = tool.NextSibling())</span>
<a name="l01738"></a>01738 <span class="comment">    /// {</span>
<a name="l01739"></a>01739 <span class="comment">    ///     std::string s = QueryName.EvaluateString(tool);</span>
<a name="l01740"></a>01740 <span class="comment">    ///</span>
<a name="l01741"></a>01741 <span class="comment">    ///     if (QueryNameValid.EvaluateBoolean(tool)) std::cout &lt;&lt; s &lt;&lt; std::endl;</span>
<a name="l01742"></a>01742 <span class="comment">    /// }</span>
<a name="l01743"></a>01743 <span class="comment">    /// @endcode</span>
<a name="l01744"></a>01744 <span class="comment">    /// @subsection XMLXPathVariables Using Variables</span>
<a name="l01745"></a>01745 <span class="comment">    /// XPath queries may contain references to variables; this is useful if you want to use queries that depend on some dynamic parameter without manually preparing the complete query</span>
<a name="l01746"></a>01746 <span class="comment">    /// string, or if you want to reuse the same query object for similar queries.</span>
<a name="l01747"></a>01747 <span class="comment">    /// \n \n</span>
<a name="l01748"></a>01748 <span class="comment">    /// Variable references have the form $name; in order to use them, you have to provide a variable set, which includes all variables present in the query with correct types. This set</span>
<a name="l01749"></a>01749 <span class="comment">    /// is passed to Mezzanine::xml::XPathQuery constructor or to FindNodes/FindNode functions:</span>
<a name="l01750"></a>01750 <span class="comment">    /// @code</span>
<a name="l01751"></a>01751 <span class="comment">    /// explicit Mezzanine::xml::XPathQuery::Mezzanine::xml::XPathQuery(const char_t* query, XPathVariableSet* variables = 0);</span>
<a name="l01752"></a>01752 <span class="comment">    /// Mezzanine::xml::XPathNode xml_node::FindNode(const char_t* query, XPathVariableSet* variables = 0) const;</span>
<a name="l01753"></a>01753 <span class="comment">    /// XPathNodeSet xml_node::FindNodes(const char_t* query, XPathVariableSet* variables = 0) const;</span>
<a name="l01754"></a>01754 <span class="comment">    /// @endcode</span>
<a name="l01755"></a>01755 <span class="comment">    /// If you&#39;re using query objects, you can change the variable values before evaluate/select calls to change the query behavior.</span>
<a name="l01756"></a>01756 <span class="comment">    /// @note The variable set pointer is stored in the query object; you have to ensure that the lifetime of the set exceeds that of query object.</span>
<a name="l01757"></a>01757 <span class="comment">    ///</span>
<a name="l01758"></a>01758 <span class="comment">    /// Variable sets correspond to XPathVariableSet type, which is essentially a variable container.</span>
<a name="l01759"></a>01759 <span class="comment">    /// \n \n</span>
<a name="l01760"></a>01760 <span class="comment">    /// You can add new variables with the following function:</span>
<a name="l01761"></a>01761 <span class="comment">    /// @code</span>
<a name="l01762"></a>01762 <span class="comment">    /// Mezzanine::xml::XPathVariable* Mezzanine::xml::XPathVariableSet::Add(const char_t* Name, Mezzanine::xml::XPathValueType type);</span>
<a name="l01763"></a>01763 <span class="comment">    /// @endcode</span>
<a name="l01764"></a>01764 <span class="comment">    /// The function tries to add a new variable with the specified name and type; if the variable with such name does not exist in the set, the function adds a new variable and returns</span>
<a name="l01765"></a>01765 <span class="comment">    /// the variable handle; if there is already a variable with the specified name, the function returns the variable handle if variable has the specified type. Otherwise the function</span>
<a name="l01766"></a>01766 <span class="comment">    /// returns null pointer; it also returns null pointer on allocation failure.</span>
<a name="l01767"></a>01767 <span class="comment">    /// \n \n</span>
<a name="l01768"></a>01768 <span class="comment">    /// New variables are assigned the default value which depends on the type: 0 for numbers, false for booleans, empty string for strings and empty set for node sets.</span>
<a name="l01769"></a>01769 <span class="comment">    /// \n \n</span>
<a name="l01770"></a>01770 <span class="comment">    /// You can get the existing variables with the following functions:</span>
<a name="l01771"></a>01771 <span class="comment">    /// @code</span>
<a name="l01772"></a>01772 <span class="comment">    /// XPathVariable* XPathVariableSet::Get(const char_t* Name);</span>
<a name="l01773"></a>01773 <span class="comment">    /// const XPathVariable* XPathVariableSet::Get(const char_t* Name) const;</span>
<a name="l01774"></a>01774 <span class="comment">    /// @endcode</span>
<a name="l01775"></a>01775 <span class="comment">    /// The functions return the variable handle, or null pointer if the variable with the specified name is not found.</span>
<a name="l01776"></a>01776 <span class="comment">    /// \n \n</span>
<a name="l01777"></a>01777 <span class="comment">    /// Additionally, there are the helper functions for setting the variable value by name; they try to add the variable with the corresponding type, if it does not exist, and to set the</span>
<a name="l01778"></a>01778 <span class="comment">    /// value. If the variable with the same name but with different type is already present, they return false; they also return false on allocation failure. Note that these functions do</span>
<a name="l01779"></a>01779 <span class="comment">    /// not perform any type conversions.</span>
<a name="l01780"></a>01780 <span class="comment">    /// @code</span>
<a name="l01781"></a>01781 <span class="comment">    /// bool XPathVariableSet::Set(const char_t* Name, bool Value);</span>
<a name="l01782"></a>01782 <span class="comment">    /// bool XPathVariableSet::Set(const char_t* Name, double Value);</span>
<a name="l01783"></a>01783 <span class="comment">    /// bool XPathVariableSet::Set(const char_t* Name, const char_t* Value);</span>
<a name="l01784"></a>01784 <span class="comment">    /// bool XPathVariableSet::Set(const char_t* Name, const XPathNodeSet&amp; Value);</span>
<a name="l01785"></a>01785 <span class="comment">    /// @endcode</span>
<a name="l01786"></a>01786 <span class="comment">    /// The variable values are copied to the internal variable storage, so you can modify or destroy them after the functions return.</span>
<a name="l01787"></a>01787 <span class="comment">    /// \n \n</span>
<a name="l01788"></a>01788 <span class="comment">    /// If setting variables by name is not efficient enough, or if you have to inspect variable information or get variable values, you can use variable handles. A variable corresponds to</span>
<a name="l01789"></a>01789 <span class="comment">    /// the XPathVariable type, and a variable handle is simply a pointer to XPathVariable.</span>
<a name="l01790"></a>01790 <span class="comment">    /// \n \n</span>
<a name="l01791"></a>01791 <span class="comment">    /// In order to get variable information, you can use one of the following functions:</span>
<a name="l01792"></a>01792 <span class="comment">    /// @code</span>
<a name="l01793"></a>01793 <span class="comment">    /// const char_t* Mezzanine::xml::XPathVariable::Name() const;</span>
<a name="l01794"></a>01794 <span class="comment">    /// Mezzanine::xml::XPathValueType Mezzanine::xml::XPathVariable::Type() const;</span>
<a name="l01795"></a>01795 <span class="comment">    /// @endcode</span>
<a name="l01796"></a>01796 <span class="comment">    /// Note that each variable has a distinct type which is specified upon variable creation and can not be changed later.</span>
<a name="l01797"></a>01797 <span class="comment">    /// \n \n</span>
<a name="l01798"></a>01798 <span class="comment">    /// In order to get variable value, you should use one of the following functions, depending on the variable type:</span>
<a name="l01799"></a>01799 <span class="comment">    /// @code</span>
<a name="l01800"></a>01800 <span class="comment">    /// bool Mezzanine::xml::XPathVariable::GetBoolean() const;</span>
<a name="l01801"></a>01801 <span class="comment">    /// double Mezzanine::xml::XPathVariable::GetNumber() const;</span>
<a name="l01802"></a>01802 <span class="comment">    /// const char_t* Mezzanine::xml::XPathVariable::GetString() const;</span>
<a name="l01803"></a>01803 <span class="comment">    /// const Mezzanine::xml::XPathNodeSet&amp; Mezzanine::xml::XPathVariable::GetNodeSet() const;</span>
<a name="l01804"></a>01804 <span class="comment">    /// @endcode</span>
<a name="l01805"></a>01805 <span class="comment">    /// These functions return the value of the variable. Note that no type conversions are performed; if the type mismatch occurs, a dummy value is returned (false for booleans, NaN for</span>
<a name="l01806"></a>01806 <span class="comment">    /// numbers, empty string for strings and empty set for node sets).</span>
<a name="l01807"></a>01807 <span class="comment">    /// \n \n</span>
<a name="l01808"></a>01808 <span class="comment">    /// In order to set variable value, you should use one of the following functions, depending on the variable type:</span>
<a name="l01809"></a>01809 <span class="comment">    /// @code</span>
<a name="l01810"></a>01810 <span class="comment">    /// bool XPathVariable::Set(bool Value);</span>
<a name="l01811"></a>01811 <span class="comment">    /// bool XPathVariable::Set(double Value);</span>
<a name="l01812"></a>01812 <span class="comment">    /// bool XPathVariable::Set(const char_t* Value);</span>
<a name="l01813"></a>01813 <span class="comment">    /// bool XPathVariable::Set(const XPathNodeSet&amp; Value);</span>
<a name="l01814"></a>01814 <span class="comment">    /// @endcode</span>
<a name="l01815"></a>01815 <span class="comment">    /// These functions modify the variable value. Note that no type conversions are performed; if the type mismatch occurs, the functions return false; they also return false on allocation</span>
<a name="l01816"></a>01816 <span class="comment">    /// failure. The variable values are copied to the internal variable storage, so you can modify or destroy them after the functions return.</span>
<a name="l01817"></a>01817 <span class="comment">    /// \n \n</span>
<a name="l01818"></a>01818 <span class="comment">    /// This is an example of using variables in XPath queries:</span>
<a name="l01819"></a>01819 <span class="comment">    /// @code</span>
<a name="l01820"></a>01820 <span class="comment">    /// // Select nodes via compiled query</span>
<a name="l01821"></a>01821 <span class="comment">    /// Mezzanine::xml::XPathVariableSet vars;</span>
<a name="l01822"></a>01822 <span class="comment">    /// vars.Add(&quot;remote&quot;, Mezzanine::xml::XPathTypeBoolean);</span>
<a name="l01823"></a>01823 <span class="comment">    ///</span>
<a name="l01824"></a>01824 <span class="comment">    /// Mezzanine::xml::XPathQuery QueryRemoteTools(&quot;/Profile/Tools/Tool[@AllowRemote = string($remote)]&quot;, &amp;vars);</span>
<a name="l01825"></a>01825 <span class="comment">    ///</span>
<a name="l01826"></a>01826 <span class="comment">    /// vars.Set(&quot;remote&quot;, true);</span>
<a name="l01827"></a>01827 <span class="comment">    /// XPathNodeSet ToolsRemote = QueryRemoteTools.EvaluateNodeSet(doc);</span>
<a name="l01828"></a>01828 <span class="comment">    ///</span>
<a name="l01829"></a>01829 <span class="comment">    /// vars.Set(&quot;remote&quot;, false);</span>
<a name="l01830"></a>01830 <span class="comment">    /// Mezzanine::xml::XPathNodeSet ToolsLocal = QueryRemoteTools.EvaluateNodeSet(doc);</span>
<a name="l01831"></a>01831 <span class="comment">    ///</span>
<a name="l01832"></a>01832 <span class="comment">    /// std::cout &lt;&lt; &quot;Remote tool: &quot;;</span>
<a name="l01833"></a>01833 <span class="comment">    /// ToolsRemote[2].GetNode().Print(std::cout);</span>
<a name="l01834"></a>01834 <span class="comment">    ///</span>
<a name="l01835"></a>01835 <span class="comment">    /// std::cout &lt;&lt; &quot;Local tool: &quot;;</span>
<a name="l01836"></a>01836 <span class="comment">    /// ToolsLocal[0].GetNode().Print(std::cout);</span>
<a name="l01837"></a>01837 <span class="comment">    ///</span>
<a name="l01838"></a>01838 <span class="comment">    /// // You can pass the context directly to FindNodes/FindNode</span>
<a name="l01839"></a>01839 <span class="comment">    /// Mezzanine::xml::XPathNodeSet ToolsLocalImm = doc.FindNodes(&quot;/Profile/Tools/Tool[@AllowRemote = string($remote)]&quot;, &amp;vars);</span>
<a name="l01840"></a>01840 <span class="comment">    ///</span>
<a name="l01841"></a>01841 <span class="comment">    /// std::cout &lt;&lt; &quot;Local tool imm: &quot;;</span>
<a name="l01842"></a>01842 <span class="comment">    /// ToolsLocalImm[0].GetNode().Print(std::cout);</span>
<a name="l01843"></a>01843 <span class="comment">    /// @endcode</span>
<a name="l01844"></a>01844 <span class="comment">    /// @subsection XMLXPathError Error Handling</span>
<a name="l01845"></a>01845 <span class="comment">    /// There are two different mechanisms for error handling in XPath implementation; the mechanism used depends on whether exception support is disabled (this is controlled with</span>
<a name="l01846"></a>01846 <span class="comment">    /// XML_NO_EXCEPTIONS define).</span>
<a name="l01847"></a>01847 <span class="comment">    /// \n \n</span>
<a name="l01848"></a>01848 <span class="comment">    /// By default, XPath functions throw Mezzanine::xml::XPathException object in case of errors; additionally, in the event any memory allocation fails, an std::bad_alloc exception is thrown. Also</span>
<a name="l01849"></a>01849 <span class="comment">    /// Mezzanine::xml::XPathException is thrown if the query is evaluated to a node set, but the return type is not node set. If the query constructor succeeds (i.e. no exception is thrown), the query</span>
<a name="l01850"></a>01850 <span class="comment">    /// object is valid. Otherwise you can get the error details via one of the following functions:</span>
<a name="l01851"></a>01851 <span class="comment">    /// @code</span>
<a name="l01852"></a>01852 <span class="comment">    /// virtual const char* Mezzanine::xml::XPathException::what() const throw();</span>
<a name="l01853"></a>01853 <span class="comment">    /// const Mezzanine::xml::XPathParseResult&amp; Mezzanine::xml::XPathException::Result() const;</span>
<a name="l01854"></a>01854 <span class="comment">    /// @endcode</span>
<a name="l01855"></a>01855 <span class="comment">    /// If exceptions are disabled, then in the event of parsing failure the query is initialized to invalid state; you can test if the query object is valid by using it in a boolean</span>
<a name="l01856"></a>01856 <span class="comment">    /// expression: if (query) { ... }. Additionally, you can get parsing result via the Result() accessor:</span>
<a name="l01857"></a>01857 <span class="comment">    /// @code</span>
<a name="l01858"></a>01858 <span class="comment">    /// const XPathParseResult&amp; XPathQuery::Result() const;</span>
<a name="l01859"></a>01859 <span class="comment">    /// @endcode</span>
<a name="l01860"></a>01860 <span class="comment">    /// Without exceptions, evaluating invalid query results in false, empty string, NaN or an empty node set, depending on the type; evaluating a query as a node set results in an empty</span>
<a name="l01861"></a>01861 <span class="comment">    /// node set if the return type is not node set.</span>
<a name="l01862"></a>01862 <span class="comment">    /// \n \n</span>
<a name="l01863"></a>01863 <span class="comment">    /// The information about parsing result is returned via Mezzanine::xml::XPathParseResult object. It contains parsing status and the offset of last successfully parsed character from the</span>
<a name="l01864"></a>01864 <span class="comment">    /// beginning of the source stream.</span>
<a name="l01865"></a>01865 <span class="comment">    /// \n \n</span>
<a name="l01866"></a>01866 <span class="comment">    /// Parsing result is represented as the error message; it is either a null pointer, in case there is no error, or the error message in the form of ASCII zero-terminated string.</span>
<a name="l01867"></a>01867 <span class="comment">    /// \n \n</span>
<a name="l01868"></a>01868 <span class="comment">    /// The Description() member function can be used to get the error message; it never returns the null pointer, so you can safely use Description() even if query parsing succeeded.</span>
<a name="l01869"></a>01869 <span class="comment">    /// \n \n</span>
<a name="l01870"></a>01870 <span class="comment">    /// In addition to the error message, parsing result has an OffSet member, which contains the offset of last successfully parsed character. This offset is in units of Mezzanine::xml::char_t</span>
<a name="l01871"></a>01871 <span class="comment">    /// (bytes for character mode, wide characters for wide character mode).</span>
<a name="l01872"></a>01872 <span class="comment">    /// \n \n</span>
<a name="l01873"></a>01873 <span class="comment">    /// Parsing result object can be implicitly converted to bool like this: if (result) { ... } else { ... }.</span>
<a name="l01874"></a>01874 <span class="comment">    /// \n \n</span>
<a name="l01875"></a>01875 <span class="comment">    /// This is an example of XPath error handling:</span>
<a name="l01876"></a>01876 <span class="comment">    /// @code</span>
<a name="l01877"></a>01877 <span class="comment">    /// // Exception is thrown for incorrect query syntax</span>
<a name="l01878"></a>01878 <span class="comment">    /// try</span>
<a name="l01879"></a>01879 <span class="comment">    /// {</span>
<a name="l01880"></a>01880 <span class="comment">    ///     doc.FindNodes(&quot;//nodes[#true()]&quot;);</span>
<a name="l01881"></a>01881 <span class="comment">    /// }</span>
<a name="l01882"></a>01882 <span class="comment">    /// catch (const Mezzanine::xml::XPathException&amp; e)</span>
<a name="l01883"></a>01883 <span class="comment">    /// {</span>
<a name="l01884"></a>01884 <span class="comment">    ///     std::cout &lt;&lt; &quot;Select failed: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span>
<a name="l01885"></a>01885 <span class="comment">    /// }</span>
<a name="l01886"></a>01886 <span class="comment">    ///</span>
<a name="l01887"></a>01887 <span class="comment">    /// // Exception is thrown for incorrect query semantics</span>
<a name="l01888"></a>01888 <span class="comment">    /// try</span>
<a name="l01889"></a>01889 <span class="comment">    /// {</span>
<a name="l01890"></a>01890 <span class="comment">    /// doc.FindNodes(&quot;(123)/next&quot;);</span>
<a name="l01891"></a>01891 <span class="comment">    /// }</span>
<a name="l01892"></a>01892 <span class="comment">    /// catch (const Mezzanine::xml::XPathException&amp; e)</span>
<a name="l01893"></a>01893 <span class="comment">    /// {</span>
<a name="l01894"></a>01894 <span class="comment">    ///     std::cout &lt;&lt; &quot;Select failed: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span>
<a name="l01895"></a>01895 <span class="comment">    /// }</span>
<a name="l01896"></a>01896 <span class="comment">    ///</span>
<a name="l01897"></a>01897 <span class="comment">    /// // Exception is thrown for query with incorrect return type</span>
<a name="l01898"></a>01898 <span class="comment">    /// try</span>
<a name="l01899"></a>01899 <span class="comment">    /// {</span>
<a name="l01900"></a>01900 <span class="comment">    ///     doc.FindNodes(&quot;123&quot;);</span>
<a name="l01901"></a>01901 <span class="comment">    /// }</span>
<a name="l01902"></a>01902 <span class="comment">    /// catch (const Mezzanine::xml::XPathException&amp; e)</span>
<a name="l01903"></a>01903 <span class="comment">    /// {</span>
<a name="l01904"></a>01904 <span class="comment">    ///     std::cout &lt;&lt; &quot;Select failed: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span>
<a name="l01905"></a>01905 <span class="comment">    /// }</span>
<a name="l01906"></a>01906 <span class="comment">    /// @endcode</span>
<a name="l01907"></a>01907 <span class="comment">    /// @subsection XMLXPathStandards Conformance to W3C Specification</span>
<a name="l01908"></a>01908 <span class="comment">    /// Because of the differences in document object models, performance considerations and implementation complexity, pugixml does not provide a fully conformant XPath 1.0 implementation.</span>
<a name="l01909"></a>01909 <span class="comment">    /// This is the current list of incompatibilities:</span>
<a name="l01910"></a>01910 <span class="comment">    ///     - Consecutive text nodes sharing the same parent are not merged, i.e. in &lt;node&gt;text1 &lt;![CDATA[data]]&gt; text2 &lt;/node&gt; node should have one text node children, but instead has</span>
<a name="l01911"></a>01911 <span class="comment">    ///     three.</span>
<a name="l01912"></a>01912 <span class="comment">    ///     - Since the document type declaration is not used for parsing, id() function always returns an empty node set.</span>
<a name="l01913"></a>01913 <span class="comment">    ///     - Namespace nodes are not supported (affects namespace:: axis).</span>
<a name="l01914"></a>01914 <span class="comment">    ///     - Name tests are performed on QNames in XML document instead of expanded names; for &lt;foo xmlns:ns1=&#39;uri&#39; xmlns:ns2=&#39;uri&#39;&gt; &lt;ns1:child/&gt; &lt;ns2:child/&gt; &lt;/foo&gt;, query foo/ns1:*</span>
<a name="l01915"></a>01915 <span class="comment">    ///     will return only the first child, not both of them. Compliant XPath implementations can return both nodes if the user provides appropriate namespace declarations.</span>
<a name="l01916"></a>01916 <span class="comment">    ///     - String functions consider a character to be either a single char value or a single wchar_t value, depending on the library configuration; this means that some string functions</span>
<a name="l01917"></a>01917 <span class="comment">    ///     are not fully Unicode-aware. This affects substring(), string-length() and translate() functions.</span>
<a name="l01918"></a>01918 <span class="comment"></span>
<a name="l01919"></a>01919 
<a name="l01920"></a>01920 <span class="comment"></span>
<a name="l01921"></a>01921 <span class="comment">    /**</span>
<a name="l01922"></a>01922 <span class="comment">    @page OriginalpugixmlLicense Original pugixml License</span>
<a name="l01923"></a>01923 <span class="comment">    The original pugixml software had the following license text:</span>
<a name="l01924"></a>01924 <span class="comment">    @section pugixmloriginallicense Original Text</span>
<a name="l01925"></a>01925 <span class="comment">    @verbatim</span>
<a name="l01926"></a>01926 <span class="comment">    The pugixml library is distributed under the MIT license:</span>
<a name="l01927"></a>01927 <span class="comment"></span>
<a name="l01928"></a>01928 <span class="comment">         Copyright (c) 2006-2010 Arseny Kapoulkine</span>
<a name="l01929"></a>01929 <span class="comment"></span>
<a name="l01930"></a>01930 <span class="comment">         Permission is hereby granted, free of charge, to any person obtaining a copy of this software</span>
<a name="l01931"></a>01931 <span class="comment">         and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<a name="l01932"></a>01932 <span class="comment">         including without limitation the rights to use, copy, modify, merge, publish, distribute,</span>
<a name="l01933"></a>01933 <span class="comment">         sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is</span>
<a name="l01934"></a>01934 <span class="comment">         furnished to do so, subject to the following conditions:</span>
<a name="l01935"></a>01935 <span class="comment"></span>
<a name="l01936"></a>01936 <span class="comment">         The above copyright notice and this permission notice shall be included in all copies or</span>
<a name="l01937"></a>01937 <span class="comment">         substantial portions of the Software.</span>
<a name="l01938"></a>01938 <span class="comment"></span>
<a name="l01939"></a>01939 <span class="comment">         THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING</span>
<a name="l01940"></a>01940 <span class="comment">         BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<a name="l01941"></a>01941 <span class="comment">         NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<a name="l01942"></a>01942 <span class="comment">         DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a name="l01943"></a>01943 <span class="comment">         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l01944"></a>01944 <span class="comment"></span>
<a name="l01945"></a>01945 <span class="comment">    This means that you can freely use pugixml in your applications, both open-source and proprietary.</span>
<a name="l01946"></a>01946 <span class="comment">    If you use pugixml in a product, it is sufficient to add an acknowledgment like this to the product</span>
<a name="l01947"></a>01947 <span class="comment">    distribution:</span>
<a name="l01948"></a>01948 <span class="comment"></span>
<a name="l01949"></a>01949 <span class="comment">         This software is based on pugixml library (http://pugixml.org).</span>
<a name="l01950"></a>01950 <span class="comment">         pugixml is Copyright (C) 2006-2010 Arseny Kapoulkine.</span>
<a name="l01951"></a>01951 <span class="comment">    @endverbatim</span>
<a name="l01952"></a>01952 <span class="comment">    \n \n</span>
<a name="l01953"></a>01953 <span class="comment">    The documentation was copied with permission per the copyright notice near the bottom of Table of contents and several other pages as follows:</span>
<a name="l01954"></a>01954 <span class="comment">    \n \n</span>
<a name="l01955"></a>01955 <span class="comment">    @verbatim</span>
<a name="l01956"></a>01956 <span class="comment">    Copyright © 2010 Arseny Kapoulkine</span>
<a name="l01957"></a>01957 <span class="comment">    Distributed under the MIT License</span>
<a name="l01958"></a>01958 <span class="comment">    @endverbatim</span>
<a name="l01959"></a>01959 <span class="comment">    */</span>
<a name="l01960"></a>01960 <span class="comment"></span>
<a name="l01961"></a>01961 <span class="comment">    ///////////////////////////////////////</span>
<a name="l01962"></a>01962 <span class="comment"></span>    <span class="keyword">namespace </span>xml
<a name="l01963"></a>01963     {
<a name="l01964"></a>01964 
<a name="l01965"></a>01965         <span class="keyword">class </span>Document;
<a name="l01966"></a>01966 <span class="comment"></span>
<a name="l01967"></a>01967 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l01968"></a>01968 <span class="comment">        /// @file xmldoc.h</span>
<a name="l01969"></a>01969 <span class="comment">        /// @brief The Doxygen documentation and minor tools to assist with the XML system</span>
<a name="l01970"></a>01970 <span class="comment">        /// @details The integration process for PugiXML requires that our changes all be stored in shell script.</span>
<a name="l01971"></a>01971 <span class="comment">        /// This is not condusive to good clean documentation  and is why the doxygen documention for the XML parser exist here</span>
<a name="l01972"></a>01972 <span class="comment">        /// instead of xml.h.</span>
<a name="l01973"></a>01973 <span class="comment">        ///////////////////////////////////////</span>
<a name="l01974"></a>01974 <span class="comment"></span><span class="comment"></span>
<a name="l01975"></a>01975 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l01976"></a>01976 <span class="comment">        /// @file xml.h</span>
<a name="l01977"></a>01977 <span class="comment">        /// @brief This is where bulk of the XML subsystem is declare, there are numerous class that are all tighlty integrated so one file seemed appropriate.</span>
<a name="l01978"></a>01978 <span class="comment">        /// @details See xmldoc.h for additional details.</span>
<a name="l01979"></a>01979 <span class="comment">        ///////////////////////////////////////</span>
<a name="l01980"></a>01980 <span class="comment"></span><span class="comment"></span>
<a name="l01981"></a>01981 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l01982"></a>01982 <span class="comment">        /// @enum ParseStatus</span>
<a name="l01983"></a>01983 <span class="comment">        /// @brief These statuses are used to help determine what issues, if any the parser had. the XML parser had.</span>
<a name="l01984"></a>01984 <span class="comment"></span><span class="comment"></span>
<a name="l01985"></a>01985 <span class="comment">        /// @var StatusOk</span>
<a name="l01986"></a>01986 <span class="comment">        /// @brief This is returned to indicated there where no issues parsing the XML document</span>
<a name="l01987"></a>01987 <span class="comment"></span><span class="comment"></span>
<a name="l01988"></a>01988 <span class="comment">        /// @var StatusFileNotFound</span>
<a name="l01989"></a>01989 <span class="comment">        /// @brief File was not found during a loading from filename attempt.</span>
<a name="l01990"></a>01990 <span class="comment"></span><span class="comment"></span>
<a name="l01991"></a>01991 <span class="comment">        /// @var StatusIOError</span>
<a name="l01992"></a>01992 <span class="comment">        /// @brief Error reading from file or stream.</span>
<a name="l01993"></a>01993 <span class="comment"></span><span class="comment"></span>
<a name="l01994"></a>01994 <span class="comment">        /// @var StatusOutOfMemory</span>
<a name="l01995"></a>01995 <span class="comment">        /// @brief Could not allocate memory.</span>
<a name="l01996"></a>01996 <span class="comment"></span><span class="comment"></span>
<a name="l01997"></a>01997 <span class="comment">        /// @var StatusInternalError</span>
<a name="l01998"></a>01998 <span class="comment">        /// @brief An unkown error, currently nothing should be able to return this status</span>
<a name="l01999"></a>01999 <span class="comment"></span><span class="comment"></span>
<a name="l02000"></a>02000 <span class="comment">        /// @var StatusUnrecognizedTag</span>
<a name="l02001"></a>02001 <span class="comment">        /// @brief The parser could not determine type of tag.</span>
<a name="l02002"></a>02002 <span class="comment"></span><span class="comment"></span>
<a name="l02003"></a>02003 <span class="comment">        /// @var StatusBadPi</span>
<a name="l02004"></a>02004 <span class="comment">        /// @brief Parsing error occurred while parsing document declaration/processing instruction.</span>
<a name="l02005"></a>02005 <span class="comment"></span><span class="comment"></span>
<a name="l02006"></a>02006 <span class="comment">        /// @var StatusBadComment</span>
<a name="l02007"></a>02007 <span class="comment">        /// @brief Parsing error occurred while parsing comment.</span>
<a name="l02008"></a>02008 <span class="comment"></span><span class="comment"></span>
<a name="l02009"></a>02009 <span class="comment">        /// @var StatusBadCdata</span>
<a name="l02010"></a>02010 <span class="comment">        /// @brief Parsing error occurred while parsing CDATA section.</span>
<a name="l02011"></a>02011 <span class="comment"></span><span class="comment"></span>
<a name="l02012"></a>02012 <span class="comment">        /// @var StatusBadDocType</span>
<a name="l02013"></a>02013 <span class="comment">        /// @brief Parsing error occurred while parsing document type declaration.</span>
<a name="l02014"></a>02014 <span class="comment"></span><span class="comment"></span>
<a name="l02015"></a>02015 <span class="comment">        /// @var StatusBadPcdata</span>
<a name="l02016"></a>02016 <span class="comment">        /// @brief Parsing error occurred while parsing PCDATA section.</span>
<a name="l02017"></a>02017 <span class="comment"></span><span class="comment"></span>
<a name="l02018"></a>02018 <span class="comment">        /// @var StatusBadStartElement</span>
<a name="l02019"></a>02019 <span class="comment">        /// @brief Parsing error occurred while parsing start element tag .</span>
<a name="l02020"></a>02020 <span class="comment"></span><span class="comment"></span>
<a name="l02021"></a>02021 <span class="comment">        /// @var StatusBadAttribute</span>
<a name="l02022"></a>02022 <span class="comment">        /// @brief Parsing error occurred while parsing element attribute.</span>
<a name="l02023"></a>02023 <span class="comment"></span><span class="comment"></span>
<a name="l02024"></a>02024 <span class="comment">        /// @var StatusBadEndElement</span>
<a name="l02025"></a>02025 <span class="comment">        /// @brief Parsing error occurred while parsing end element tag.</span>
<a name="l02026"></a>02026 <span class="comment"></span><span class="comment"></span>
<a name="l02027"></a>02027 <span class="comment">        /// @var StatusEndElementMismatch</span>
<a name="l02028"></a>02028 <span class="comment">        /// @brief There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or there was an excessive closing tag).</span>
<a name="l02029"></a>02029 <span class="comment"></span><span class="comment"></span>
<a name="l02030"></a>02030 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02031"></a>02031 <span class="comment">        /// @struct ParseResult</span>
<a name="l02032"></a>02032 <span class="comment">        /// @brief All the information needed to troubleshoot a Parsing error.</span>
<a name="l02033"></a>02033 <span class="comment"></span><span class="comment"></span>
<a name="l02034"></a>02034 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02035"></a>02035 <span class="comment">        /// @enum Encoding</span>
<a name="l02036"></a>02036 <span class="comment">        /// @brief These flags determine the encoding of input data for an XML document.</span>
<a name="l02037"></a>02037 <span class="comment"></span><span class="comment"></span>
<a name="l02038"></a>02038 <span class="comment">        /// @var EncodingAuto</span>
<a name="l02039"></a>02039 <span class="comment">        /// @brief Auto-detect input document encoding using Byte Order Mark (BOM) or &lt; / &lt;? detection; use UTF8 if BOM is not found .</span>
<a name="l02040"></a>02040 <span class="comment"></span><span class="comment"></span>
<a name="l02041"></a>02041 <span class="comment">        /// @var EncodingUTF8</span>
<a name="l02042"></a>02042 <span class="comment">        /// @brief UTF8 document encoding</span>
<a name="l02043"></a>02043 <span class="comment"></span><span class="comment"></span>
<a name="l02044"></a>02044 <span class="comment">        /// @var EncodingUTF16LE</span>
<a name="l02045"></a>02045 <span class="comment">        /// @brief Little-endian UTF16</span>
<a name="l02046"></a>02046 <span class="comment"></span><span class="comment"></span>
<a name="l02047"></a>02047 <span class="comment">        /// @var EncodingUTF16BE</span>
<a name="l02048"></a>02048 <span class="comment">        /// @brief Big-endian UTF16</span>
<a name="l02049"></a>02049 <span class="comment"></span><span class="comment"></span>
<a name="l02050"></a>02050 <span class="comment">        /// @var EncodingUTF16</span>
<a name="l02051"></a>02051 <span class="comment">        /// @brief UTF16 with native endianness</span>
<a name="l02052"></a>02052 <span class="comment"></span><span class="comment"></span>
<a name="l02053"></a>02053 <span class="comment">        /// @var EncodingUTF32LE</span>
<a name="l02054"></a>02054 <span class="comment">        /// @brief Little-endian UTF32</span>
<a name="l02055"></a>02055 <span class="comment"></span><span class="comment"></span>
<a name="l02056"></a>02056 <span class="comment">        /// @var EncodingUTF32BE</span>
<a name="l02057"></a>02057 <span class="comment">        /// @brief Big-endian UTF32</span>
<a name="l02058"></a>02058 <span class="comment"></span><span class="comment"></span>
<a name="l02059"></a>02059 <span class="comment">        /// @var EncodingUTF32</span>
<a name="l02060"></a>02060 <span class="comment">        /// @brief UTF32 with native endianness</span>
<a name="l02061"></a>02061 <span class="comment"></span><span class="comment"></span>
<a name="l02062"></a>02062 <span class="comment">        /// @var Encodingwchar_t</span>
<a name="l02063"></a>02063 <span class="comment">        /// @brief The same document encoding wchar_t has (usually either UTF16 or UTF32)</span>
<a name="l02064"></a>02064 <span class="comment"></span><span class="comment"></span>
<a name="l02065"></a>02065 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02066"></a>02066 <span class="comment">        /// @enum NodeType</span>
<a name="l02067"></a>02067 <span class="comment">        /// @brief The types of nodes.</span>
<a name="l02068"></a>02068 <span class="comment"></span><span class="comment"></span>
<a name="l02069"></a>02069 <span class="comment">        /// @var NodeNull</span>
<a name="l02070"></a>02070 <span class="comment">        /// @brief Empty (null) node handle.</span>
<a name="l02071"></a>02071 <span class="comment"></span><span class="comment"></span>
<a name="l02072"></a>02072 <span class="comment">        /// @var NodeDocument</span>
<a name="l02073"></a>02073 <span class="comment">        /// @brief A document tree&#39;s absolute root.</span>
<a name="l02074"></a>02074 <span class="comment"></span><span class="comment"></span>
<a name="l02075"></a>02075 <span class="comment">        /// @var NodeElement</span>
<a name="l02076"></a>02076 <span class="comment">        /// @brief Element tag, i.e. &#39;&lt;node/&gt;&#39;.</span>
<a name="l02077"></a>02077 <span class="comment"></span><span class="comment"></span>
<a name="l02078"></a>02078 <span class="comment">        /// @var NodePcdata</span>
<a name="l02079"></a>02079 <span class="comment">        /// @brief Plain character data, i.e. &#39;text&#39;.</span>
<a name="l02080"></a>02080 <span class="comment"></span><span class="comment"></span>
<a name="l02081"></a>02081 <span class="comment">        /// @var NodeCdata</span>
<a name="l02082"></a>02082 <span class="comment">        /// @brief Character data, i.e. &#39;&lt;![CDATA[text]]&gt;&#39;.</span>
<a name="l02083"></a>02083 <span class="comment"></span><span class="comment"></span>
<a name="l02084"></a>02084 <span class="comment">        /// @var NodeComment</span>
<a name="l02085"></a>02085 <span class="comment">        /// @brief Comment tag, i.e. &#39;&lt;!-- text --&gt;&#39;.</span>
<a name="l02086"></a>02086 <span class="comment"></span><span class="comment"></span>
<a name="l02087"></a>02087 <span class="comment">        /// @var NodePi</span>
<a name="l02088"></a>02088 <span class="comment">        /// @brief Processing instructions to the XML parser, i.e. &#39;&lt;?name?&gt;&#39;.</span>
<a name="l02089"></a>02089 <span class="comment"></span><span class="comment"></span>
<a name="l02090"></a>02090 <span class="comment">        /// @var NodeDeclaration</span>
<a name="l02091"></a>02091 <span class="comment">        /// @brief Document declaration, i.e. &#39;&lt;?xml version=&quot;1.0&quot;?&gt;&#39;.</span>
<a name="l02092"></a>02092 <span class="comment"></span><span class="comment"></span>
<a name="l02093"></a>02093 <span class="comment">        /// @var NodeDocType</span>
<a name="l02094"></a>02094 <span class="comment">        /// @brief Document type declaration, i.e. &#39;&lt;!DOCTYPE doc&gt;&#39;.</span>
<a name="l02095"></a>02095 <span class="comment"></span><span class="comment"></span>
<a name="l02096"></a>02096 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02097"></a>02097 <span class="comment">        /// @var Mezzanine::xml::ParseMinimal</span>
<a name="l02098"></a>02098 <span class="comment">        /// @brief Minimal parsing mode (equivalent to turning all other flags off).</span>
<a name="l02099"></a>02099 <span class="comment">        /// @details Only elements and PCDATA sections are added to the DOM tree, no text conversions are performed.</span>
<a name="l02100"></a>02100 <span class="comment"></span><span class="comment"></span>
<a name="l02101"></a>02101 <span class="comment">        /// @var ParsePi</span>
<a name="l02102"></a>02102 <span class="comment">        /// @brief This flag determines if processing instructions (NodePi) are added to the DOM tree. This flag is off by default.</span>
<a name="l02103"></a>02103 <span class="comment"></span><span class="comment"></span>
<a name="l02104"></a>02104 <span class="comment">        /// @var ParseComments</span>
<a name="l02105"></a>02105 <span class="comment">        /// @brief This flag determines if comments (NodeComment) are added to the DOM tree. This flag is off by default.</span>
<a name="l02106"></a>02106 <span class="comment"></span><span class="comment"></span>
<a name="l02107"></a>02107 <span class="comment">        /// @var ParseCdata</span>
<a name="l02108"></a>02108 <span class="comment">        /// @brief This flag determines if CDATA sections (NodeCdata) are added to the DOM tree. This flag is on by default.</span>
<a name="l02109"></a>02109 <span class="comment"></span><span class="comment"></span>
<a name="l02110"></a>02110 <span class="comment">        /// @var ParseWsPcdata</span>
<a name="l02111"></a>02111 <span class="comment">        /// @brief This flag determines if plain character data (NodePcdata) that consist only of whitespace are added to the DOM tree.</span>
<a name="l02112"></a>02112 <span class="comment">        /// @details This flag is off by default; turning it on usually results in slower parsing and more memory consumption.</span>
<a name="l02113"></a>02113 <span class="comment"></span><span class="comment"></span>
<a name="l02114"></a>02114 <span class="comment">        /// @var ParseEscapes</span>
<a name="l02115"></a>02115 <span class="comment">        /// @brief This flag determines if character and entity references are expanded during parsing. This flag is on by default.</span>
<a name="l02116"></a>02116 <span class="comment"></span><span class="comment"></span>
<a name="l02117"></a>02117 <span class="comment">        /// @var ParseEol</span>
<a name="l02118"></a>02118 <span class="comment">        /// @brief This flag determines if EOL characters are normalized (converted to \#xA) during parsing. This flag is on by default.</span>
<a name="l02119"></a>02119 <span class="comment"></span><span class="comment"></span>
<a name="l02120"></a>02120 <span class="comment">        /// @var ParseWconvAttribute</span>
<a name="l02121"></a>02121 <span class="comment">        /// @brief This flag determines if attribute values are normalized using CDATA normalization rules during parsing. This flag is on by default.</span>
<a name="l02122"></a>02122 <span class="comment"></span><span class="comment"></span>
<a name="l02123"></a>02123 <span class="comment">        /// @var ParseWnormAttribute</span>
<a name="l02124"></a>02124 <span class="comment">        /// @brief This flag determines if attribute values are normalized using NMTOKENS normalization rules during parsing. This flag is off by default.</span>
<a name="l02125"></a>02125 <span class="comment"></span><span class="comment"></span>
<a name="l02126"></a>02126 <span class="comment">        /// @var ParseDeclaration</span>
<a name="l02127"></a>02127 <span class="comment">        /// @brief This flag determines if document declaration (NodeDeclaration) is added to the DOM tree. This flag is off by default.</span>
<a name="l02128"></a>02128 <span class="comment"></span><span class="comment"></span>
<a name="l02129"></a>02129 <span class="comment">        /// @var ParseDocType</span>
<a name="l02130"></a>02130 <span class="comment">        /// @brief This flag determines if document type declaration (NodeDoctype) is added to the DOM tree. This flag is off by default.</span>
<a name="l02131"></a>02131 <span class="comment"></span><span class="comment"></span>
<a name="l02132"></a>02132 <span class="comment">        /// @var ParseDefault</span>
<a name="l02133"></a>02133 <span class="comment">        /// @brief The default parsing mode.</span>
<a name="l02134"></a>02134 <span class="comment">        /// @details Elements, PCDATA and CDATA sections are added to the DOM tree, character/reference entities are expanded,</span>
<a name="l02135"></a>02135 <span class="comment">        /// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.</span>
<a name="l02136"></a>02136 <span class="comment"></span><span class="comment"></span>
<a name="l02137"></a>02137 <span class="comment">        /// @var ParseFull</span>
<a name="l02138"></a>02138 <span class="comment">        /// @brief The full parsing mode.</span>
<a name="l02139"></a>02139 <span class="comment">        /// @details Nodes of all types are added to the DOM tree, character/reference entities are expanded,</span>
<a name="l02140"></a>02140 <span class="comment">        /// End-of-Line characters are normalized, attribute values are normalized using CDATA normalization rules.</span>
<a name="l02141"></a>02141 <span class="comment"></span><span class="comment"></span>
<a name="l02142"></a>02142 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02143"></a>02143 <span class="comment"></span>        <span class="comment">// @typedef string_t</span>
<a name="l02144"></a>02144         <span class="comment">// @brief A string class used internally to store data in the XML parser.</span>
<a name="l02145"></a>02145 <span class="comment"></span>
<a name="l02146"></a>02146 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02147"></a>02147 <span class="comment">        /// @var FormatIndent</span>
<a name="l02148"></a>02148 <span class="comment">        /// @brief Indent the nodes that are written to output stream with as many indentation strings as deep the node is in DOM tree. This flag is off by default.</span>
<a name="l02149"></a>02149 <span class="comment"></span><span class="comment"></span>
<a name="l02150"></a>02150 <span class="comment">        /// @var FormatWriteBom</span>
<a name="l02151"></a>02151 <span class="comment">        /// @brief Write encoding-specific Byte Order Mark (BOM) to the output stream. This flag is off by default.</span>
<a name="l02152"></a>02152 <span class="comment"></span><span class="comment"></span>
<a name="l02153"></a>02153 <span class="comment">        /// @var FormatRaw</span>
<a name="l02154"></a>02154 <span class="comment">        /// @brief Use raw output mode (no indentation and no line breaks are written). This flag is on by default.</span>
<a name="l02155"></a>02155 <span class="comment"></span><span class="comment"></span>
<a name="l02156"></a>02156 <span class="comment">        /// @var FormatNoDeclaration</span>
<a name="l02157"></a>02157 <span class="comment">        /// @brief Omit default XML declaration even if there is no declaration in the document. This flag is off by default.</span>
<a name="l02158"></a>02158 <span class="comment"></span><span class="comment"></span>
<a name="l02159"></a>02159 <span class="comment">        /// @var FormatDefault</span>
<a name="l02160"></a>02160 <span class="comment">        /// @brief The default set of formatting flags. Only FormatRaw is enabled.</span>
<a name="l02161"></a>02161 <span class="comment"></span><span class="comment"></span>
<a name="l02162"></a>02162 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02163"></a>02163 <span class="comment">        /// @class Writer</span>
<a name="l02164"></a>02164 <span class="comment">        /// @brief Interface for node printing (see @ref Node::Print)</span>
<a name="l02165"></a>02165 <span class="comment"></span><span class="comment"></span>
<a name="l02166"></a>02166 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02167"></a>02167 <span class="comment">        /// @class WriterFile</span>
<a name="l02168"></a>02168 <span class="comment">        /// @brief An implementation of @ref Writer intended for writing to FILEs as defined in stdio</span>
<a name="l02169"></a>02169 <span class="comment"></span><span class="comment"></span>
<a name="l02170"></a>02170 <span class="comment">        /// @var WriterFile::file</span>
<a name="l02171"></a>02171 <span class="comment">        /// @internal</span>
<a name="l02172"></a>02172 <span class="comment">        /// @brief A pointer to a FILE as defined in stdio</span>
<a name="l02173"></a>02173 <span class="comment"></span><span class="comment"></span>
<a name="l02174"></a>02174 <span class="comment">        /// @fn WriterFile::WriterFile(void* file)</span>
<a name="l02175"></a>02175 <span class="comment">        /// @brief Construct a Writer from a FILE* object.</span>
<a name="l02176"></a>02176 <span class="comment">        /// @param file The FILE to be written to. The FILE can be a File handle as per stdio or the standard input, output or even error. The use of void* was intended to avoid a depedency on the stdio header, in the original PugiXML. After a review for compatibility this may change to promote better type safety.</span>
<a name="l02177"></a>02177 <span class="comment"></span><span class="comment"></span>
<a name="l02178"></a>02178 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02179"></a>02179 <span class="comment">        /// @class WriterStream</span>
<a name="l02180"></a>02180 <span class="comment">        /// @brief An implementation of @ref Writer intended for writing std::ostreams</span>
<a name="l02181"></a>02181 <span class="comment"></span><span class="comment"></span>
<a name="l02182"></a>02182 <span class="comment">                /// @var WriterStream::narrow_stream</span>
<a name="l02183"></a>02183 <span class="comment">                /// @internal</span>
<a name="l02184"></a>02184 <span class="comment"></span><span class="comment"></span>
<a name="l02185"></a>02185 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02186"></a>02186 <span class="comment">        /// @def XML_DEPRECATED</span>
<a name="l02187"></a>02187 <span class="comment">        /// @brief Used to mark XML internals as deprecated at the compiler level.</span>
<a name="l02188"></a>02188 <span class="comment"></span><span class="comment"></span>
<a name="l02189"></a>02189 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02190"></a>02190 <span class="comment">        /// @def _XML_H</span>
<a name="l02191"></a>02191 <span class="comment">        /// @internal</span>
<a name="l02192"></a>02192 <span class="comment">        /// @brief Prevents accidental loading of the file xml.h multiple times.</span>
<a name="l02193"></a>02193 <span class="comment"></span><span class="comment"></span>
<a name="l02194"></a>02194 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02195"></a>02195 <span class="comment">        /// @def XML_TEXT</span>
<a name="l02196"></a>02196 <span class="comment">        /// @internal</span>
<a name="l02197"></a>02197 <span class="comment">        /// @brief Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the character type at compile time.</span>
<a name="l02198"></a>02198 <span class="comment"></span><span class="comment"></span>
<a name="l02199"></a>02199 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02200"></a>02200 <span class="comment">        /// @def XML_CHAR</span>
<a name="l02201"></a>02201 <span class="comment">        /// @internal</span>
<a name="l02202"></a>02202 <span class="comment">        /// @brief Links the  Pugi character datatype to match the Mezzanine Mezzanine::Characterdatatype</span>
<a name="l02203"></a>02203 <span class="comment"></span><span class="comment"></span>
<a name="l02204"></a>02204 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02205"></a>02205 <span class="comment">        /// @class Attribute</span>
<a name="l02206"></a>02206 <span class="comment">        /// @brief A light-weight handle for manipulating attributes in DOM tree</span>
<a name="l02207"></a>02207 <span class="comment"></span><span class="comment"></span>
<a name="l02208"></a>02208 <span class="comment">        /// @var Attribute::_attr</span>
<a name="l02209"></a>02209 <span class="comment">        /// @internal</span>
<a name="l02210"></a>02210 <span class="comment">        /// @brief Stores pointers to the attribute data and some metadata about the attribute.</span>
<a name="l02211"></a>02211 <span class="comment"></span><span class="comment"></span>
<a name="l02212"></a>02212 <span class="comment">        /// @fn Attribute::Attribute()</span>
<a name="l02213"></a>02213 <span class="comment">        /// @brief Constructs an empty Attribute.</span>
<a name="l02214"></a>02214 <span class="comment"></span><span class="comment"></span>
<a name="l02215"></a>02215 <span class="comment">        /// @fn Attribute::Attribute(AttributeStruct* attr)</span>
<a name="l02216"></a>02216 <span class="comment">        /// @brief Constructs attribute from internal pointer.</span>
<a name="l02217"></a>02217 <span class="comment">        /// @param attr An internal AttributeStruct pointer containing all the data to create an attribute.</span>
<a name="l02218"></a>02218 <span class="comment"></span><span class="comment"></span>
<a name="l02219"></a>02219 <span class="comment">        /// @fn Attribute::operator!() const</span>
<a name="l02220"></a>02220 <span class="comment">        /// @brief Used to convert this attribute the opposite of it&#39;s normal boolean value</span>
<a name="l02221"></a>02221 <span class="comment">        /// @details This is described in the PugiXML source a a workaround for a borland c++ issue.</span>
<a name="l02222"></a>02222 <span class="comment">        /// @return Returns false if the internal pointer AttributeStruct is set and true otherwise.</span>
<a name="l02223"></a>02223 <span class="comment"></span><span class="comment"></span>
<a name="l02224"></a>02224 <span class="comment">        /// @fn Attribute::operator==(const Attribute&amp; r) const;</span>
<a name="l02225"></a>02225 <span class="comment">        /// @brief Compares the internal values to check equality.</span>
<a name="l02226"></a>02226 <span class="comment">        /// @param r The other @ref Attribute this is being compared to.</span>
<a name="l02227"></a>02227 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02228"></a>02228 <span class="comment">        /// @return Returns true if all the internal values match between this and the other Attribute.</span>
<a name="l02229"></a>02229 <span class="comment"></span><span class="comment"></span>
<a name="l02230"></a>02230 <span class="comment">        /// @fn Attribute::operator!=(const Attribute&amp; r) const;</span>
<a name="l02231"></a>02231 <span class="comment">        /// @brief Compares the internal values to check inequality.</span>
<a name="l02232"></a>02232 <span class="comment">        /// @param r The other @ref Attribute this is being compared to.</span>
<a name="l02233"></a>02233 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02234"></a>02234 <span class="comment">        /// @return Returns true if any of the internal values don&#39;t match between this and the other @ref Attribute.</span>
<a name="l02235"></a>02235 <span class="comment"></span><span class="comment"></span>
<a name="l02236"></a>02236 <span class="comment">        /// @fn Attribute::operator&lt;(const Attribute&amp; r) const;</span>
<a name="l02237"></a>02237 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02238"></a>02238 <span class="comment">        /// @param r The other @ref Attribute this is being compared to.</span>
<a name="l02239"></a>02239 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02240"></a>02240 <span class="comment">        /// @return Returns True if the other @ref Attribute is greater than this one as per sequential comparison of internal pointers.</span>
<a name="l02241"></a>02241 <span class="comment"></span><span class="comment"></span>
<a name="l02242"></a>02242 <span class="comment">        /// @fn Attribute::operator&gt;(const Attribute&amp; r) const;</span>
<a name="l02243"></a>02243 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02244"></a>02244 <span class="comment">        /// @param r The other @ref Attribute this is being compared to.</span>
<a name="l02245"></a>02245 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02246"></a>02246 <span class="comment">        /// @return Returns True if the other @ref Attribute is less than this one as per sequential comparison of internal pointers.</span>
<a name="l02247"></a>02247 <span class="comment"></span><span class="comment"></span>
<a name="l02248"></a>02248 <span class="comment">        /// @fn Attribute::operator&lt;=(const Attribute&amp; r) const;</span>
<a name="l02249"></a>02249 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02250"></a>02250 <span class="comment">        /// @param r The other @ref Attribute this is being compared to.</span>
<a name="l02251"></a>02251 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02252"></a>02252 <span class="comment">        /// @return Returns True if the other @ref Attribute is greater than or equal to this one as per sequential comparison of internal pointers.</span>
<a name="l02253"></a>02253 <span class="comment"></span><span class="comment"></span>
<a name="l02254"></a>02254 <span class="comment">        /// @fn Attribute::operator&gt;=(const Attribute&amp; r) const;</span>
<a name="l02255"></a>02255 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02256"></a>02256 <span class="comment">        /// @param r The other @ref Attribute this is being compared to.</span>
<a name="l02257"></a>02257 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02258"></a>02258 <span class="comment">        /// @return Returns True if the other @ref Attribute is less than or equal to this one as per sequential comparison of internal pointers.</span>
<a name="l02259"></a>02259 <span class="comment"></span><span class="comment"></span>
<a name="l02260"></a>02260 <span class="comment">        /// @fn Attribute::Empty() const;</span>
<a name="l02261"></a>02261 <span class="comment">        /// @brief Is this storing anything at all?</span>
<a name="l02262"></a>02262 <span class="comment">        /// @return Returns True if this @ref Attribute is storing nothing. False if it is storing anything.</span>
<a name="l02263"></a>02263 <span class="comment"></span><span class="comment"></span>
<a name="l02264"></a>02264 <span class="comment">        /// @fn Attribute::Name() const;</span>
<a name="l02265"></a>02265 <span class="comment">        /// @brief Get the name of this @ref Attribute.</span>
<a name="l02266"></a>02266 <span class="comment">        /// @return Returns A pointer to a const c-style array of the the character type (usually char or wchar_t) containing the name.</span>
<a name="l02267"></a>02267 <span class="comment">        /// @warning returns &quot;&quot; if attribute is empty.</span>
<a name="l02268"></a>02268 <span class="comment"></span><span class="comment"></span>
<a name="l02269"></a>02269 <span class="comment">        /// @fn Attribute::Value() const;</span>
<a name="l02270"></a>02270 <span class="comment">        /// @brief Get the Value of this @ref Attribute.</span>
<a name="l02271"></a>02271 <span class="comment">        /// @return Returns A pointer to a const c-style array of the the character type (usually char or wchar_t) containing the value.</span>
<a name="l02272"></a>02272 <span class="comment">        /// @warning returns &quot;&quot; if attribute is empty.</span>
<a name="l02273"></a>02273 <span class="comment"></span><span class="comment"></span>
<a name="l02274"></a>02274 <span class="comment">        /// @fn Attribute::AsInt() const;</span>
<a name="l02275"></a>02275 <span class="comment">        /// @brief Attempts to convert the value of the attribute to an int and returns the results.</span>
<a name="l02276"></a>02276 <span class="comment">        /// @return If the value of this attribute can be convert to an int by reading the character and interpretting them a number, that numberis returned. Returns 0 on failure.</span>
<a name="l02277"></a>02277 <span class="comment">        /// @todo Update Attribute::AsInt() to check errno and throw exceptions were appropriate, and throw a exception on failure instead of producing a valid return value.</span>
<a name="l02278"></a>02278 <span class="comment">        /// @warning This may silently fail if the value of the attribute exceeds the maximum value that can be stored in and int. Check &quot;errno&quot; and see if it is set to &quot;ERANGE&quot; to test for this condition.</span>
<a name="l02279"></a>02279 <span class="comment"></span><span class="comment"></span>
<a name="l02280"></a>02280 <span class="comment">        /// @fn Attribute::AsUint() const;</span>
<a name="l02281"></a>02281 <span class="comment">        /// @brief Attempts to convert the value of the attribute to an unsigned int and returns the results.</span>
<a name="l02282"></a>02282 <span class="comment">        /// @return If the value of this attribute can be convert to an unsigned int by reading the character and interpretting them a number, that numberis returned. Returns 0 on failure.</span>
<a name="l02283"></a>02283 <span class="comment">        /// @todo Update Attribute::AsUint() to check errno and throw exceptions were appropriate, and throw a exception on failure instead of producing a valid return value.</span>
<a name="l02284"></a>02284 <span class="comment">        /// @warning This may silently fail if the value of the attribute exceeds the maximum value that can be stored in and int. Check &quot;errno&quot; and see if it is set to &quot;ERANGE&quot; to test for this condition.</span>
<a name="l02285"></a>02285 <span class="comment"></span><span class="comment"></span>
<a name="l02286"></a>02286 <span class="comment">        /// @fn Attribute::AsDouble() const;</span>
<a name="l02287"></a>02287 <span class="comment">        /// @brief Attempts to convert the value of the attribute to a double and returns the results.</span>
<a name="l02288"></a>02288 <span class="comment">        /// @return If the value of this attribute can be convert to a double by reading the character and interpretting them a number, that numberis returned. Returns 0 on failure.</span>
<a name="l02289"></a>02289 <span class="comment">        /// @todo Update Attribute::AsDouble() to check errno and throw exceptions were appropriate, and throw a exception on failure instead of producing a valid return value.</span>
<a name="l02290"></a>02290 <span class="comment">        /// @warning This may silently fail if the value of the attribute exceeds the maximum value that can be stored in and double. Check &quot;errno&quot; and see if it is set to &quot;ERANGE&quot; to test for this condition.</span>
<a name="l02291"></a>02291 <span class="comment"></span><span class="comment"></span>
<a name="l02292"></a>02292 <span class="comment">        /// @fn Attribute::AsFloat() const;</span>
<a name="l02293"></a>02293 <span class="comment">        /// @brief Attempts to convert the value of the attribute to a float and returns the results.</span>
<a name="l02294"></a>02294 <span class="comment">        /// @return If the value of this attribute can be convert to a float by reading the character and interpretting them a number, that numberis returned. Returns 0 on failure.</span>
<a name="l02295"></a>02295 <span class="comment">        /// @todo Update Attribute::AsFloat() to check errno and throw exceptions were appropriate, and throw a exception on failure instead of producing a valid return value.</span>
<a name="l02296"></a>02296 <span class="comment">        /// @warning This may silently fail if the value of the attribute exceeds the maximum value that can be stored in and float. Check &quot;errno&quot; and see if it is set to &quot;ERANGE&quot; to test for this condition.</span>
<a name="l02297"></a>02297 <span class="comment"></span><span class="comment"></span>
<a name="l02298"></a>02298 <span class="comment">        /// @fn Attribute::AsReal() const;</span>
<a name="l02299"></a>02299 <span class="comment">        /// @brief Attempts to convert the value of the attribute to a Real and returns the results.</span>
<a name="l02300"></a>02300 <span class="comment">        /// @return If the value of this attribute can be converted to a Real by reading the character</span>
<a name="l02301"></a>02301 <span class="comment">        /// and interpretting them a number, that number is returned. Returns 0 on failure.</span>
<a name="l02302"></a>02302 <span class="comment">        /// @exception This can throw exception in certain overflow conditions</span>
<a name="l02303"></a>02303 <span class="comment"></span><span class="comment"></span>
<a name="l02304"></a>02304 <span class="comment">        /// @fn Attribute::AsWhole() const;</span>
<a name="l02305"></a>02305 <span class="comment">        /// @brief Attempts to convert the value of the attribute to a Whole and returns the results.</span>
<a name="l02306"></a>02306 <span class="comment">        /// @return If the value of this attribute can be converted to a Whole by reading the character</span>
<a name="l02307"></a>02307 <span class="comment">        /// and interpretting them a number, that number is returned. Returns 0 on failure.</span>
<a name="l02308"></a>02308 <span class="comment">        /// @exception This can throw exception in certain overflow conditions</span>
<a name="l02309"></a>02309 <span class="comment"></span><span class="comment"></span>
<a name="l02310"></a>02310 <span class="comment">        /// @fn Attribute::AsInteger() const;</span>
<a name="l02311"></a>02311 <span class="comment">        /// @brief Attempts to convert the value of the attribute to a Integer and returns the results.</span>
<a name="l02312"></a>02312 <span class="comment">        /// @return If the value of this attribute can be converted to a Integer by reading the character</span>
<a name="l02313"></a>02313 <span class="comment">        /// and interpretting them a number, that number is returned. Returns 0 on failure.</span>
<a name="l02314"></a>02314 <span class="comment">        /// @exception This can throw exception in certain overflow conditions</span>
<a name="l02315"></a>02315 <span class="comment"></span><span class="comment"></span>
<a name="l02316"></a>02316 <span class="comment">        /// @fn Attribute::AsString() const;</span>
<a name="l02317"></a>02317 <span class="comment">        /// @brief Attempts to convert the value of the attribute to a String and returns the results.</span>
<a name="l02318"></a>02318 <span class="comment">        /// @return If the value of this attribute can be converted to a Real by reading the character</span>
<a name="l02319"></a>02319 <span class="comment">        /// and interpretting them a number, that number is returned. Returns 0 on failure.</span>
<a name="l02320"></a>02320 <span class="comment">        /// @exception This can throw exception in certain overflow conditions</span>
<a name="l02321"></a>02321 <span class="comment"></span><span class="comment"></span>
<a name="l02322"></a>02322 <span class="comment">        /// @fn Attribute::AsBool() const;</span>
<a name="l02323"></a>02323 <span class="comment">        /// @brief Attempts to convert the value of the attribute to a float and returns the results.</span>
<a name="l02324"></a>02324 <span class="comment">        /// @return Value as bool (returns true if first character is in &#39;1tTyY&#39; set), or false if attribute is empty</span>
<a name="l02325"></a>02325 <span class="comment"></span><span class="comment"></span>
<a name="l02326"></a>02326 <span class="comment">                /// @fn Attribute::operator=(const char_t* rhs);</span>
<a name="l02327"></a>02327 <span class="comment">                /// @param rhs The new value as an c-style string.</span>
<a name="l02328"></a>02328 <span class="comment">                /// @brief The same as @ref Attribute::SetValue(const char_t* rhs); without the error return</span>
<a name="l02329"></a>02329 <span class="comment">                /// @return An reference to this attribute.</span>
<a name="l02330"></a>02330 <span class="comment"></span><span class="comment"></span>
<a name="l02331"></a>02331 <span class="comment">                /// @fn Attribute::operator=(int rhs);</span>
<a name="l02332"></a>02332 <span class="comment">                /// @param rhs The new value as an int.</span>
<a name="l02333"></a>02333 <span class="comment">                /// @brief The same as @ref Attribute::SetValue(); without the error return.</span>
<a name="l02334"></a>02334 <span class="comment">                /// @return An reference to this attribute.</span>
<a name="l02335"></a>02335 <span class="comment"></span><span class="comment"></span>
<a name="l02336"></a>02336 <span class="comment">                /// @fn Attribute::operator=(unsigned int rhs);</span>
<a name="l02337"></a>02337 <span class="comment">                /// @param rhs The new value as an unsigned int.</span>
<a name="l02338"></a>02338 <span class="comment">                /// @brief The same as @ref Attribute::SetValue(); without the error return.</span>
<a name="l02339"></a>02339 <span class="comment">                /// @return An reference to this attribute.</span>
<a name="l02340"></a>02340 <span class="comment"></span><span class="comment"></span>
<a name="l02341"></a>02341 <span class="comment">                /// @fn Attribute::operator=(double rhs);</span>
<a name="l02342"></a>02342 <span class="comment">                /// @brief The same as @ref Attribute::SetValue(); without the error return.</span>
<a name="l02343"></a>02343 <span class="comment">                /// @param rhs The new value as a double.</span>
<a name="l02344"></a>02344 <span class="comment">                /// @return An reference to this attribute.</span>
<a name="l02345"></a>02345 <span class="comment"></span><span class="comment"></span>
<a name="l02346"></a>02346 <span class="comment">                /// @fn Attribute::operator=(bool rhs);</span>
<a name="l02347"></a>02347 <span class="comment">                /// @brief The same as @ref Attribute::SetValue(); without the error return.</span>
<a name="l02348"></a>02348 <span class="comment">                /// @param rhs This with be interpretted, then converted to &quot;true&quot; or &quot;false&quot; and used as the new value.</span>
<a name="l02349"></a>02349 <span class="comment">                /// @return An reference to this attribute.</span>
<a name="l02350"></a>02350 <span class="comment"></span><span class="comment"></span>
<a name="l02351"></a>02351 <span class="comment">                /// @fn Attribute::GetNextAttribute() const;</span>
<a name="l02352"></a>02352 <span class="comment">                /// @brief Get the next attribute.</span>
<a name="l02353"></a>02353 <span class="comment">                /// @details This will get the next sibling attribute. That is, another Attribute on the same node as this attribute. This is internally a circular linked list, so once you reach the end, you simply be given the first node. If this attribute is empty this will return a empty attribute.</span>
<a name="l02354"></a>02354 <span class="comment">                /// @return Either the next attribute or if this attribute is empty an empty attribute.</span>
<a name="l02355"></a>02355 <span class="comment"></span><span class="comment"></span>
<a name="l02356"></a>02356 <span class="comment">                /// @fn Attribute::GetPreviousAttribute() const;</span>
<a name="l02357"></a>02357 <span class="comment">                /// @brief Get the previous attribute.</span>
<a name="l02358"></a>02358 <span class="comment">                /// @details This will get the previous sibling attribute. That is, another Attribute on the same node as this attribute. This is internally a circular linked list, so once you reach the beginning, you simply be given the last node. If this attribute is empty this will return a empty attribute.</span>
<a name="l02359"></a>02359 <span class="comment">                /// @return Either the previous attribute or if this attribute is empty an empty attribute.</span>
<a name="l02360"></a>02360 <span class="comment"></span>
<a name="l02361"></a>02361                 <span class="comment">// Get hash Value (unique for handles to the same object)</span><span class="comment"></span>
<a name="l02362"></a>02362 <span class="comment">                /// @fn Attribute::HashValue() const;</span>
<a name="l02363"></a>02363 <span class="comment">                /// @brief Get a unique identifying value for the Attribute this represents</span>
<a name="l02364"></a>02364 <span class="comment">                /// @return A size_t that is unique per Attribute that an attribute could represent.</span>
<a name="l02365"></a>02365 <span class="comment"></span><span class="comment"></span>
<a name="l02366"></a>02366 <span class="comment">                /// @fn Attribute::InternalObject() const;</span>
<a name="l02367"></a>02367 <span class="comment">                /// @brief Retrieve a pointer to the internal data.</span>
<a name="l02368"></a>02368 <span class="comment">                /// @return A void pointer to the internal data.</span>
<a name="l02369"></a>02369 <span class="comment">                /// @internal</span>
<a name="l02370"></a>02370 <span class="comment"></span><span class="preprocessor">#ifdef __BORLANDC__</span>
<a name="l02371"></a>02371 <span class="preprocessor"></span><span class="comment">        /// @fn operator&amp;&amp;(const Attribute&amp; lhs, bool rhs);</span>
<a name="l02372"></a>02372 <span class="comment"></span><span class="comment">        /// @brief Used to work around a Borland c++ issue casting @ref Attribute class instances to boolean values.</span>
<a name="l02373"></a>02373 <span class="comment"></span><span class="comment">        /// @param lhs Left Hand Side of the operator.</span>
<a name="l02374"></a>02374 <span class="comment"></span><span class="comment">        /// @param rhs Right Hand Side of the operator.</span>
<a name="l02375"></a>02375 <span class="comment"></span><span class="comment">        /// @return A bool that has the correct value for a &amp;&amp; operation.</span>
<a name="l02376"></a>02376 <span class="comment"></span><span class="comment"></span>
<a name="l02377"></a>02377 <span class="comment">        /// @fn operator||(const Attribute&amp; lhs, bool rhs);</span>
<a name="l02378"></a>02378 <span class="comment">        /// @brief Used to work around a Borland c++ issue casting @ref Attribute class instances to boolean values.</span>
<a name="l02379"></a>02379 <span class="comment">        /// @param lhs Left Hand Side of the operator.</span>
<a name="l02380"></a>02380 <span class="comment">        /// @param rhs Right Hand Side of the operator.</span>
<a name="l02381"></a>02381 <span class="comment">        /// @return A bool that has the correct value for a || operation.</span>
<a name="l02382"></a>02382 <span class="comment"></span><span class="preprocessor">#endif</span>
<a name="l02383"></a>02383 <span class="preprocessor"></span>
<a name="l02384"></a>02384 <span class="comment"></span>
<a name="l02385"></a>02385 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02386"></a>02386 <span class="comment">        /// @class Node</span>
<a name="l02387"></a>02387 <span class="comment">        /// @brief A light-weight handle for manipulating nodes in DOM tree</span>
<a name="l02388"></a>02388 <span class="comment"></span><span class="comment"></span>
<a name="l02389"></a>02389 <span class="comment">        /// @var Node::_GetRoot</span>
<a name="l02390"></a>02390 <span class="comment">        /// @internal</span>
<a name="l02391"></a>02391 <span class="comment">        /// @brief Stores pointers to the Node data and some metadata.</span>
<a name="l02392"></a>02392 <span class="comment"></span><span class="comment"></span>
<a name="l02393"></a>02393 <span class="comment">        /// @fn Node::Node()</span>
<a name="l02394"></a>02394 <span class="comment">        /// @brief Default constructor. Constructs an empty node.</span>
<a name="l02395"></a>02395 <span class="comment"></span><span class="comment"></span>
<a name="l02396"></a>02396 <span class="comment">        /// @fn Node::operator!() const</span>
<a name="l02397"></a>02397 <span class="comment">        /// @brief Used to convert this node the opposite of it&#39;s normal boolean value</span>
<a name="l02398"></a>02398 <span class="comment">        /// @details This is described in the PugiXML source a a workaround for a borland c++ issue.</span>
<a name="l02399"></a>02399 <span class="comment">        /// @return Returns false if the internal pointer NodeStruct is set and true otherwise.</span>
<a name="l02400"></a>02400 <span class="comment"></span><span class="comment"></span>
<a name="l02401"></a>02401 <span class="comment">        /// @fn Node::operator==(const Node&amp; r) const;</span>
<a name="l02402"></a>02402 <span class="comment">        /// @brief Compares the internal values to check equality.</span>
<a name="l02403"></a>02403 <span class="comment">        /// @param r The other @ref Node this is being compared to.</span>
<a name="l02404"></a>02404 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02405"></a>02405 <span class="comment">        /// @return Returns true if all the internal values match between this and the other Node.</span>
<a name="l02406"></a>02406 <span class="comment"></span><span class="comment"></span>
<a name="l02407"></a>02407 <span class="comment">        /// @fn Node::operator!=(const Node&amp; r) const;</span>
<a name="l02408"></a>02408 <span class="comment">        /// @brief Compares the internal values to check inequality.</span>
<a name="l02409"></a>02409 <span class="comment">        /// @param r The other @ref Node this is being compared to.</span>
<a name="l02410"></a>02410 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02411"></a>02411 <span class="comment">        /// @return Returns true if any of the internal values don&#39;t match between this and the other @ref Node.</span>
<a name="l02412"></a>02412 <span class="comment"></span><span class="comment"></span>
<a name="l02413"></a>02413 <span class="comment">        /// @fn Node::operator&lt;(const Node&amp; r) const;</span>
<a name="l02414"></a>02414 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02415"></a>02415 <span class="comment">        /// @param r The other @ref Node this is being compared to.</span>
<a name="l02416"></a>02416 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02417"></a>02417 <span class="comment">        /// @return Returns True if the other @ref Node is greater than this one as per sequential comparison of internal pointers.</span>
<a name="l02418"></a>02418 <span class="comment"></span><span class="comment"></span>
<a name="l02419"></a>02419 <span class="comment">        /// @fn Node::operator&gt;(const Node&amp; r) const;</span>
<a name="l02420"></a>02420 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02421"></a>02421 <span class="comment">        /// @param r The other @ref Node this is being compared to.</span>
<a name="l02422"></a>02422 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02423"></a>02423 <span class="comment">        /// @return Returns True if the other @ref Node is less than this one as per sequential comparison of internal pointers.</span>
<a name="l02424"></a>02424 <span class="comment"></span><span class="comment"></span>
<a name="l02425"></a>02425 <span class="comment">        /// @fn Node::operator&lt;=(const Node&amp; r) const;</span>
<a name="l02426"></a>02426 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02427"></a>02427 <span class="comment">        /// @param r The other @ref Node this is being compared to.</span>
<a name="l02428"></a>02428 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02429"></a>02429 <span class="comment">        /// @return Returns True if the other @ref Node is greater than or equal to this one as per sequential comparison of internal pointers.</span>
<a name="l02430"></a>02430 <span class="comment"></span><span class="comment"></span>
<a name="l02431"></a>02431 <span class="comment">        /// @fn Node::operator&gt;=(const Node&amp; r) const;</span>
<a name="l02432"></a>02432 <span class="comment">        /// @brief Compares the internal values to check for inequality.</span>
<a name="l02433"></a>02433 <span class="comment">        /// @param r The other @ref Node this is being compared to.</span>
<a name="l02434"></a>02434 <span class="comment">        /// @details Many of the internal values are pointers, and it is the addresses of these that are being compared.</span>
<a name="l02435"></a>02435 <span class="comment">        /// @return Returns True if the other @ref Node is less than or equal to this one as per sequential comparison of internal pointers.</span>
<a name="l02436"></a>02436 <span class="comment"></span><span class="comment"></span>
<a name="l02437"></a>02437 <span class="comment">        /// @fn Node::Empty() const;</span>
<a name="l02438"></a>02438 <span class="comment">        /// @brief Is this storing anything at all?</span>
<a name="l02439"></a>02439 <span class="comment">        /// @return Returns True if this @ref Node is storing nothing. False if it is storing anything.</span>
<a name="l02440"></a>02440 <span class="comment"></span><span class="comment"></span>
<a name="l02441"></a>02441 <span class="comment">        /// @fn Node::Type() const;</span>
<a name="l02442"></a>02442 <span class="comment">        /// @brief Identify what kind of Node this is.</span>
<a name="l02443"></a>02443 <span class="comment">        /// @return A @ref NodeType identifying this Node, or o/NULL if this Node is empty.</span>
<a name="l02444"></a>02444 <span class="comment"></span><span class="comment"></span>
<a name="l02445"></a>02445 <span class="comment">        /// @fn Node::Name() const;</span>
<a name="l02446"></a>02446 <span class="comment">        /// @brief Get the name of this @ref Node.</span>
<a name="l02447"></a>02447 <span class="comment">        /// @return Returns A pointer to a const c-style array of the the character type (usually char or wchar_t) containing the name.</span>
<a name="l02448"></a>02448 <span class="comment">        /// @warning returns &quot;&quot; if Node is empty.</span>
<a name="l02449"></a>02449 <span class="comment"></span><span class="comment"></span>
<a name="l02450"></a>02450 <span class="comment">        /// @fn Node::Value() const;</span>
<a name="l02451"></a>02451 <span class="comment">        /// @brief Get the Value of this @ref Node.</span>
<a name="l02452"></a>02452 <span class="comment">        /// @return Returns A pointer to a const c-style array of the the character type (usually char or wchar_t) containing the value.</span>
<a name="l02453"></a>02453 <span class="comment">        /// @warning returns &quot;&quot; if Node is empty.</span>
<a name="l02454"></a>02454 <span class="comment"></span><span class="comment"></span>
<a name="l02455"></a>02455 <span class="comment">                /// @fn Node::GetFirstAttribute() const;</span>
<a name="l02456"></a>02456 <span class="comment">                /// @brief Get the First Attribute in this Node.</span>
<a name="l02457"></a>02457 <span class="comment">                /// @return This attempts to return the First @ref Attribute in this node, if it cannot it returns an empty @ref Attribute.</span>
<a name="l02458"></a>02458 <span class="comment"></span><span class="comment"></span>
<a name="l02459"></a>02459 <span class="comment">        /// @fn Node::GetLastAttribute() const;</span>
<a name="l02460"></a>02460 <span class="comment">        /// @brief Get the Last Attribute in this Node.</span>
<a name="l02461"></a>02461 <span class="comment">        /// @return This attempts to return the Last @ref Attribute in this node, if it cannot it returns an empty @ref Attribute.</span>
<a name="l02462"></a>02462 <span class="comment"></span><span class="comment"></span>
<a name="l02463"></a>02463 <span class="comment">                /// @fn Node::GetFirstChild() const;</span>
<a name="l02464"></a>02464 <span class="comment">                /// @brief Get the first child Node of this Node.</span>
<a name="l02465"></a>02465 <span class="comment">                /// @return Returns the First child node if it exists, otherwise it return an empty node.</span>
<a name="l02466"></a>02466 <span class="comment"></span><span class="comment"></span>
<a name="l02467"></a>02467 <span class="comment">                /// @fn Node::GetLastChild() const;</span>
<a name="l02468"></a>02468 <span class="comment">                /// @brief Get the last child Node of this Node.</span>
<a name="l02469"></a>02469 <span class="comment">                /// @return Returns the last child node if it exists, otherwise it return an empty node.</span>
<a name="l02470"></a>02470 <span class="comment"></span><span class="comment"></span>
<a name="l02471"></a>02471 <span class="comment">        /// @fn Node::GetNextSibling() const;</span>
<a name="l02472"></a>02472 <span class="comment">        /// @brief Attempt to retrieve the next sibling of this Node.</span>
<a name="l02473"></a>02473 <span class="comment">        /// @details A sibling of a Node is another Node that shares the same parent. If this is and the sibling nodes are valid, this retrieves that Node, otherwise this return an empty Node.</span>
<a name="l02474"></a>02474 <span class="comment">        /// @return A Node that represents a sibling, or an empty Node on failure.</span>
<a name="l02475"></a>02475 <span class="comment"></span><span class="comment"></span>
<a name="l02476"></a>02476 <span class="comment">        /// @fn Node::GetParent() const;</span>
<a name="l02477"></a>02477 <span class="comment">        /// @brief Attempt to retrieve the parent of this Node.</span>
<a name="l02478"></a>02478 <span class="comment">        /// @return A Node that represents the parent Node, or an empty Node on failure.</span>
<a name="l02479"></a>02479 <span class="comment"></span><span class="comment"></span>
<a name="l02480"></a>02480 <span class="comment">        /// @fn Node::GetRoot() const;</span>
<a name="l02481"></a>02481 <span class="comment">        /// @brief Attempt to retrieve the root Node, or the most base Node containing this Node.</span>
<a name="l02482"></a>02482 <span class="comment">        /// @return A Node that represents the root of the XML document, or an empty Node on failure. If there are multiple roots this attempts to retrieve the appropriate one.</span>
<a name="l02483"></a>02483 <span class="comment"></span><span class="comment"></span>
<a name="l02484"></a>02484 <span class="comment">        /// @fn Node::GetAttribute(const char_t* Name) const;</span>
<a name="l02485"></a>02485 <span class="comment">        /// @brief Attempt to get an Attribute on this Node with a given name.</span>
<a name="l02486"></a>02486 <span class="comment">        /// @param Name The name of the desired Attribute.</span>
<a name="l02487"></a>02487 <span class="comment">        /// @return An Attribute that represents the first matching Attribute, or an empty Attribute on failure.</span>
<a name="l02488"></a>02488 <span class="comment"></span><span class="comment"></span>
<a name="l02489"></a>02489 <span class="comment">        /// @fn Node::ChildValue() const;</span>
<a name="l02490"></a>02490 <span class="comment">        /// @brief Retrieve the value of this(or a child&#39;s) Nodes PCDATA child Node</span>
<a name="l02491"></a>02491 <span class="comment">        /// @details If this node represents &quot;&lt;node&gt;Some text in the PCDATA field, that is actually represent by a node&lt;/node&gt;&quot;, then this would return &quot;Some text in the PCDATA field, that is actually represent by a node&quot;. This will iterate through child Nodes from until it finds a PCDATA node or fails</span>
<a name="l02492"></a>02492 <span class="comment">        /// @return This will return the Value of the first available PCDATA node.</span>
<a name="l02493"></a>02493 <span class="comment"></span><span class="comment"></span>
<a name="l02494"></a>02494 <span class="comment">        /// @fn Node::ChildValue(const char_t* Name) const;</span>
<a name="l02495"></a>02495 <span class="comment">        /// @brief Get the PCDATA of a given child. The same a calling &quot;GetChild(Name).ChildValue()&quot;.</span>
<a name="l02496"></a>02496 <span class="comment">        /// @param Name The Name of the desired child node.</span>
<a name="l02497"></a>02497 <span class="comment">        /// @return This will return the Value of the first available matching PCDATA node.</span>
<a name="l02498"></a>02498 <span class="comment"></span><span class="comment"></span>
<a name="l02499"></a>02499 <span class="comment">        /// @fn Node::PrependAttribute(const char_t* Name);</span>
<a name="l02500"></a>02500 <span class="comment">        /// @brief Creates an Attribute and puts it at the begining of this Nodes attributes</span>
<a name="l02501"></a>02501 <span class="comment">        /// @param Name The name of the New attribute to be created</span>
<a name="l02502"></a>02502 <span class="comment">        /// @details This attempts to create an Attribute and stick it at the beginning of the list of attributes on the current</span>
<a name="l02503"></a>02503 <span class="comment">        /// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will</span>
<a name="l02504"></a>02504 <span class="comment">        /// fail and return an empty attribute if this Node is empty.</span>
<a name="l02505"></a>02505 <span class="comment">        /// @return The created Attribute or an empty Attribute on Failure.</span>
<a name="l02506"></a>02506 <span class="comment"></span><span class="comment"></span>
<a name="l02507"></a>02507 <span class="comment">        /// @fn Node::InsertAttributeAfter(const char_t* Name, const Attribute&amp; attr);</span>
<a name="l02508"></a>02508 <span class="comment">        /// @brief Creates an Attribute and puts it into the list of this Nodes attributes.</span>
<a name="l02509"></a>02509 <span class="comment">        /// @param Name The name of the New attribute to be created</span>
<a name="l02510"></a>02510 <span class="comment">        /// @param attr An Attribute that represents an Attribute on this Node, and is just before where you want the new Attribute.</span>
<a name="l02511"></a>02511 <span class="comment">        /// @details This attempts to create an Attribute and stick it in the list of attributes, Just after another Attribute, on the current</span>
<a name="l02512"></a>02512 <span class="comment">        /// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will</span>
<a name="l02513"></a>02513 <span class="comment">        /// fail and return an empty attribute if this Node is empty.</span>
<a name="l02514"></a>02514 <span class="comment">        /// @return The created Attribute or an empty Attribute on Failure.</span>
<a name="l02515"></a>02515 <span class="comment"></span><span class="comment"></span>
<a name="l02516"></a>02516 <span class="comment">        /// @fn Node::InsertAttributeBefore(const char_t* Name, const Attribute&amp; attr);</span>
<a name="l02517"></a>02517 <span class="comment">        /// @brief Creates an Attribute and puts it into the list of this Nodes attributes.</span>
<a name="l02518"></a>02518 <span class="comment">        /// @param Name The name of the New attribute to be created</span>
<a name="l02519"></a>02519 <span class="comment">        /// @param attr An Attribute that represents an Attribute on this Node, and is just after where you want the new Attribute.</span>
<a name="l02520"></a>02520 <span class="comment">        /// @details This attempts to create an Attribute and stick it in the list of attributes, Just before another Attribute, on the current</span>
<a name="l02521"></a>02521 <span class="comment">        /// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will</span>
<a name="l02522"></a>02522 <span class="comment">        /// fail and return an empty attribute if this Node is empty.</span>
<a name="l02523"></a>02523 <span class="comment">        /// @return The created Attribute or an empty Attribute on Failure.</span>
<a name="l02524"></a>02524 <span class="comment"></span><span class="comment"></span>
<a name="l02525"></a>02525 <span class="comment">        /// @fn Node::InsertCopyBefore(const Attribute&amp; proto, const Attribute&amp; attr);</span>
<a name="l02526"></a>02526 <span class="comment">        /// @brief Copies an Attribute and puts the copy into the list of this Nodes attributes.</span>
<a name="l02527"></a>02527 <span class="comment">        /// @param proto The attribute to be copied.</span>
<a name="l02528"></a>02528 <span class="comment">        /// @param attr An Attribute that represents an Attribute on this Node, and is just after where you want the new copy of proto.</span>
<a name="l02529"></a>02529 <span class="comment">        /// @details This attempts to create a copy of an attribute Attribute and stick it in the middle of the list of attributes, just before a selected attribute, on the current</span>
<a name="l02530"></a>02530 <span class="comment">        /// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will</span>
<a name="l02531"></a>02531 <span class="comment">        /// fail and return an empty attribute if this Node is empty.</span>
<a name="l02532"></a>02532 <span class="comment">        /// @return The created Attribute or an empty Attribute on Failure.</span>
<a name="l02533"></a>02533 <span class="comment"></span><span class="comment"></span>
<a name="l02534"></a>02534 <span class="comment">        /// @fn Node::PrependChild(NodeType Type = NodeElement);</span>
<a name="l02535"></a>02535 <span class="comment">        /// @brief Creates a Node and makes it a child of this one, and puts at the beginning of the Child Nodes.</span>
<a name="l02536"></a>02536 <span class="comment">        /// @param Type The NodeType of the Node to be added to the beginning list of child Nodes.</span>
<a name="l02537"></a>02537 <span class="comment">        /// @return A Node representing the freshly added Node, or an empty Node if there was an error.</span>
<a name="l02538"></a>02538 <span class="comment">                /// @todo Not all nodes can be added to other nodes, we need to figure it out and put it here.</span>
<a name="l02539"></a>02539 <span class="comment"></span><span class="comment"></span>
<a name="l02540"></a>02540 <span class="comment">        /// @fn Node::InsertChildAfter(NodeType Type, const Node&amp; node);</span>
<a name="l02541"></a>02541 <span class="comment">        /// @brief Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes.</span>
<a name="l02542"></a>02542 <span class="comment">        /// @param Type The NodeType of the Node to be added, just after another specific node.</span>
<a name="l02543"></a>02543 <span class="comment">        /// @param node The specific node to add the new one after.</span>
<a name="l02544"></a>02544 <span class="comment">        /// @todo Not all nodes can be added to other nodes, we need to figure it out and put it here.</span>
<a name="l02545"></a>02545 <span class="comment">        /// @return A Node representing the freshly added Node, or an empty Node if there was an error.</span>
<a name="l02546"></a>02546 <span class="comment"></span><span class="comment"></span>
<a name="l02547"></a>02547 <span class="comment">                /// @fn Node::RemoveAttribute(const Attribute&amp; a);</span>
<a name="l02548"></a>02548 <span class="comment">                /// @brief Remove specified Attribute.</span>
<a name="l02549"></a>02549 <span class="comment">                /// @param a The Attribute to look for. If the given Attribute doesn&#39;t belong to this Node then this will fail</span>
<a name="l02550"></a>02550 <span class="comment">                /// @return True if the removal was successful, false otherwise</span>
<a name="l02551"></a>02551 <span class="comment"></span><span class="comment"></span>
<a name="l02552"></a>02552 <span class="comment">                /// @fn Node::RemoveAttribute(const char_t* Name);</span>
<a name="l02553"></a>02553 <span class="comment">                /// @brief Remove Attribute as specified by name.</span>
<a name="l02554"></a>02554 <span class="comment">                /// @param Name The name of the Attribute to remove.</span>
<a name="l02555"></a>02555 <span class="comment">                /// @return True if the removal was successful, false otherwise.</span>
<a name="l02556"></a>02556 <span class="comment"></span><span class="comment"></span>
<a name="l02557"></a>02557 <span class="comment">                /// @fn Node::RemoveChild(const Node&amp; n);</span>
<a name="l02558"></a>02558 <span class="comment">                /// @brief Remove specified child element.</span>
<a name="l02559"></a>02559 <span class="comment">                /// @param n The Node to look for. If the given Attribute doesn&#39;t belong to this Node then this will fail</span>
<a name="l02560"></a>02560 <span class="comment">                /// @return True if the removal was successful, false otherwise</span>
<a name="l02561"></a>02561 <span class="comment"></span><span class="comment"></span>
<a name="l02562"></a>02562 <span class="comment">        /// @fn Node::FindChildbyAttribute(const char_t* Name, const char_t* AttrName, const char_t* AttrValue) const;</span>
<a name="l02563"></a>02563 <span class="comment">        /// @brief Find a Node by an Attribute it has.</span>
<a name="l02564"></a>02564 <span class="comment">        /// @param Name The name of the matching Node.</span>
<a name="l02565"></a>02565 <span class="comment">        /// @param AttrName The name of the matching Attribute.</span>
<a name="l02566"></a>02566 <span class="comment">        /// @param AttrValue The value of the matching Attribute.</span>
<a name="l02567"></a>02567 <span class="comment">        /// @details Any Null pointers instead of character arrays passed in will cause undefined behavior. All Matching is Case sensitive.</span>
<a name="l02568"></a>02568 <span class="comment">        /// @return The First matching xml::Node</span>
<a name="l02569"></a>02569 <span class="comment"></span><span class="comment"></span>
<a name="l02570"></a>02570 <span class="comment">        /// @fn Node::Path(char_t delimiter = &#39;/&#39;) const;</span>
<a name="l02571"></a>02571 <span class="comment">        /// @brief Get the absolute path to this Node</span>
<a name="l02572"></a>02572 <span class="comment">        /// @param delimiter The character to use as a pathname separator, this defaults to &#39;/&#39;.</span>
<a name="l02573"></a>02573 <span class="comment">        /// @return A String containing an path</span>
<a name="l02574"></a>02574 <span class="comment"></span><span class="comment"></span>
<a name="l02575"></a>02575 <span class="comment">        /// @fn Node::FirstElementByPath(const char_t* Path, char_t delimiter = &#39;/&#39;) const;</span>
<a name="l02576"></a>02576 <span class="comment">        /// @brief Search for a node by Path consisting of node names and . or .. elements.</span>
<a name="l02577"></a>02577 <span class="comment">        /// @todo Investigate this more deeply.</span>
<a name="l02578"></a>02578 <span class="comment">        /// @param Path The path to search for.</span>
<a name="l02579"></a>02579 <span class="comment">        /// @param delimiter The character to use as a pathname separator, this defaults to &#39;/&#39;.</span>
<a name="l02580"></a>02580 <span class="comment">        /// @return The matching Node, of an empty Node on failure.</span>
<a name="l02581"></a>02581 <span class="comment"></span><span class="comment"></span>
<a name="l02582"></a>02582 <span class="comment">        /// @fn Node::Traverse(TreeWalker&amp; walker);</span>
<a name="l02583"></a>02583 <span class="comment">        /// @brief Perform sophisticated (or whatever) algorithms on this and all descendant Nodes in the XML tree.</span>
<a name="l02584"></a>02584 <span class="comment">        /// @param walker Any class that fully implement xml::Treewalker. This is where the algorithm to be run is located.</span>
<a name="l02585"></a>02585 <span class="comment">        /// @return True if every descendant Node of this Node was iterated through, false if it didn&#39;t go through every Node.</span>
<a name="l02586"></a>02586 <span class="comment">        /// @see xml::TreeWalker</span>
<a name="l02587"></a>02587 <span class="comment"></span><span class="comment"></span>
<a name="l02588"></a>02588 <span class="comment">        /// @fn Node::FindSingleNode(const char_t* query, XPathVariableSet* variables = 0) const;</span>
<a name="l02589"></a>02589 <span class="comment">        /// @brief Select single node by evaluating an XPath query. Returns first node from the resulting node set.</span>
<a name="l02590"></a>02590 <span class="comment">        /// @param query The XPath query as a c-string to be evaluated.</span>
<a name="l02591"></a>02591 <span class="comment">        /// @param variables undocumented.</span>
<a name="l02592"></a>02592 <span class="comment">        /// @return XPathNode The first matching XPath node.</span>
<a name="l02593"></a>02593 <span class="comment"></span><span class="comment"></span>
<a name="l02594"></a>02594 <span class="comment">        /// @fn Node::FindSingleNode(const XPathQuery&amp; query) const;</span>
<a name="l02595"></a>02595 <span class="comment">        /// @brief Select single node by evaluating an XPath query. Returns first node from the resulting node set.</span>
<a name="l02596"></a>02596 <span class="comment">        /// @param query The XPath query XPathQuery class instance.</span>
<a name="l02597"></a>02597 <span class="comment">        /// @return XPathNode The first matching XPath node.</span>
<a name="l02598"></a>02598 <span class="comment"></span><span class="comment"></span>
<a name="l02599"></a>02599 <span class="comment">        /// @typedef Node::iterator</span>
<a name="l02600"></a>02600 <span class="comment">        /// @brief An iterator for child Nodes</span>
<a name="l02601"></a>02601 <span class="comment"></span><span class="comment"></span>
<a name="l02602"></a>02602 <span class="comment">        /// @fn Node::begin() const;</span>
<a name="l02603"></a>02603 <span class="comment">        /// @brief Get a Child node iterator that references the first child Node.</span>
<a name="l02604"></a>02604 <span class="comment">        /// @return A Node::Iterator that reference the first child Node.</span>
<a name="l02605"></a>02605 <span class="comment"></span><span class="comment"></span>
<a name="l02606"></a>02606 <span class="comment">        /// @fn Node::end() const;</span>
<a name="l02607"></a>02607 <span class="comment">        /// @brief Get a Child node iterator that references one past the last child Node.</span>
<a name="l02608"></a>02608 <span class="comment">        /// @return A Node::Iterator that reference the last child Node.</span>
<a name="l02609"></a>02609 <span class="comment"></span><span class="comment"></span>
<a name="l02610"></a>02610 <span class="comment">        /// @typedef Node::attribute_iterator</span>
<a name="l02611"></a>02611 <span class="comment">        /// @brief An iterator for Attribute members on this Node</span>
<a name="l02612"></a>02612 <span class="comment"></span><span class="comment"></span>
<a name="l02613"></a>02613 <span class="comment">        /// @fn Node::attributes_begin() const;</span>
<a name="l02614"></a>02614 <span class="comment">        /// @brief Get an Attribute iterator that references the first Attribute on this Node.</span>
<a name="l02615"></a>02615 <span class="comment">        /// @return A Node::Iterator that reference the first child node.</span>
<a name="l02616"></a>02616 <span class="comment"></span><span class="comment"></span>
<a name="l02617"></a>02617 <span class="comment">        /// @fn Node::attributes_end() const;</span>
<a name="l02618"></a>02618 <span class="comment">        /// @brief Get an Attribute iterator that references the one past the last Attribute on this Node.</span>
<a name="l02619"></a>02619 <span class="comment">        /// @return A Node::Iterator that reference the last Attribute on this Node.</span>
<a name="l02620"></a>02620 <span class="comment"></span><span class="comment"></span>
<a name="l02621"></a>02621 <span class="comment">                /// @fn Node::OffSetDebug() const;</span>
<a name="l02622"></a>02622 <span class="comment">                /// @internal</span>
<a name="l02623"></a>02623 <span class="comment">                /// @brief Get node Offset in parsed file/string (in char_t units) for debugging purposes</span>
<a name="l02624"></a>02624 <span class="comment">        /// @return ptrdiff_t</span>
<a name="l02625"></a>02625 <span class="comment"></span><span class="comment"></span>
<a name="l02626"></a>02626 <span class="comment">                /// @fn Node::HashValue() const;</span>
<a name="l02627"></a>02627 <span class="comment">                /// @internal</span>
<a name="l02628"></a>02628 <span class="comment">                /// @brief Get hash Value (unique for handles to the same object)</span>
<a name="l02629"></a>02629 <span class="comment">                /// @return A size_t that uniquely identifies this node.</span>
<a name="l02630"></a>02630 <span class="comment"></span><span class="comment"></span>
<a name="l02631"></a>02631 <span class="comment">                /// @fn Node::InternalObject() const;</span>
<a name="l02632"></a>02632 <span class="comment">                /// @internal</span>
<a name="l02633"></a>02633 <span class="comment">                /// @brief Get internal pointer</span>
<a name="l02634"></a>02634 <span class="comment">                /// @return A NodeStruct* that points to the internal data of this Node</span>
<a name="l02635"></a>02635 <span class="comment"></span><span class="comment"></span>
<a name="l02636"></a>02636 <span class="comment">        //////////////////////////////////////////////////////////////////////////////</span>
<a name="l02637"></a>02637 <span class="comment">        /// @class NodeStruct</span>
<a name="l02638"></a>02638 <span class="comment">        /// @internal</span>
<a name="l02639"></a>02639 <span class="comment">        /// @brief The internal data storage structure used in a Node.</span>
<a name="l02640"></a>02640 <span class="comment">        /// @warning Not part of the API, subject to change without warning.</span>
<a name="l02641"></a>02641 <span class="comment"></span><span class="comment"></span>
<a name="l02642"></a>02642 <span class="comment">        //////////////////////////////////////////////////////////////////////////////</span>
<a name="l02643"></a>02643 <span class="comment">        /// @class AttributeStruct</span>
<a name="l02644"></a>02644 <span class="comment">        /// @internal</span>
<a name="l02645"></a>02645 <span class="comment">        /// @brief The internal data storage structure used in an Attribute.</span>
<a name="l02646"></a>02646 <span class="comment">        /// @warning Not part of the API, subject to change without warning.</span>
<a name="l02647"></a>02647 <span class="comment"></span><span class="comment"></span>
<a name="l02648"></a>02648 <span class="comment">        //////////////////////////////////////////////////////////////////////////////</span>
<a name="l02649"></a>02649 <span class="comment">        /// @class NodeIterator</span>
<a name="l02650"></a>02650 <span class="comment">        /// @brief Child node iterator (a bidirectional iterator over a collection of Node)</span>
<a name="l02651"></a>02651 <span class="comment">        /// @details Node::begin() and Node::attributes_begin() return iterators that point to the first node/attribute, respectively; Node::end() and Node::attributes_end() return past-the-end iterator for node/attribute list, respectively - this iterator can&#39;t be dereferenced, but decrementing it results in an iterator pointing to the last element in the list (except for empty lists, where decrementing past-the-end iterator results in undefined behavior). Past-the-end iterator is commonly used as a termination value for iteration loops. If you want to get an iterator that points to an existing handle, you can construct the iterator with the handle as a single constructor argument, like so: xml_node_iterator(node). For xml_attribute_iterator, you&#39;ll have to provide both an attribute and its parent node.\n\n</span>
<a name="l02652"></a>02652 <span class="comment">        /// Node::begin() and Node::end() return equal iterators if called on null Node; such iterators can&#39;t be dereferenced. Node::attributes_begin() and Node::attributes_end() behave the same way. For correct iterator usage this means that child node/attribute collections of null nodes appear to be empty.\n\n</span>
<a name="l02653"></a>02653 <span class="comment">        /// Both types of iterators have bidirectional iterator semantics (i.e. they can be incremented and decremented, but efficient random access is not supported) and support all usual iterator operations - comparison, dereference, etc. The iterators are invalidated if the node/attribute objects they&#39;re pointing to are removed from the tree; adding nodes/attributes does not invalidate any iterators.</span>
<a name="l02654"></a>02654 <span class="comment"></span><span class="comment"></span>
<a name="l02655"></a>02655 <span class="comment">                /// @typedef NodeIterator::difference_type;</span>
<a name="l02656"></a>02656 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02657"></a>02657 <span class="comment"></span><span class="comment"></span>
<a name="l02658"></a>02658 <span class="comment">                /// @typedef NodeIterator::value_type;</span>
<a name="l02659"></a>02659 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02660"></a>02660 <span class="comment"></span><span class="comment"></span>
<a name="l02661"></a>02661 <span class="comment">                /// @typedef NodeIterator::pointer;</span>
<a name="l02662"></a>02662 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02663"></a>02663 <span class="comment"></span><span class="comment"></span>
<a name="l02664"></a>02664 <span class="comment">                /// @typedef NodeIterator::reference;</span>
<a name="l02665"></a>02665 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02666"></a>02666 <span class="comment"></span><span class="comment"></span>
<a name="l02667"></a>02667 <span class="comment">                /// @typedef NodeIterator::iterator_category;</span>
<a name="l02668"></a>02668 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02669"></a>02669 <span class="comment"></span><span class="comment"></span>
<a name="l02670"></a>02670 <span class="comment">        /// @fn NodeIterator::NodeIterator();</span>
<a name="l02671"></a>02671 <span class="comment">        /// @brief Default Constructor, makes a blank iterator</span>
<a name="l02672"></a>02672 <span class="comment"></span><span class="comment"></span>
<a name="l02673"></a>02673 <span class="comment">        /// @fn NodeIterator::NodeIterator(const Node&amp; node);</span>
<a name="l02674"></a>02674 <span class="comment">        /// @brief Construct an iterator which points to the specified node</span>
<a name="l02675"></a>02675 <span class="comment">        /// @param node A Node that this iterator will point to.</span>
<a name="l02676"></a>02676 <span class="comment"></span><span class="comment"></span>
<a name="l02677"></a>02677 <span class="comment">        /// @fn NodeIterator::operator==(const NodeIterator&amp; rhs) const;</span>
<a name="l02678"></a>02678 <span class="comment">        /// @brief Compares this NodeIterator to another NodeIterator for equality</span>
<a name="l02679"></a>02679 <span class="comment">        /// @param rhs The Right Hand Side NodeIterator</span>
<a name="l02680"></a>02680 <span class="comment">        /// @return True if the internal data stored in Node this NodeIterator refers to is the same as the metadata in the other NodeIterator&#39;s Node, false otherwise.</span>
<a name="l02681"></a>02681 <span class="comment"></span><span class="comment"></span>
<a name="l02682"></a>02682 <span class="comment">        /// @fn NodeIterator::operator!=(const NodeIterator&amp; rhs) const;</span>
<a name="l02683"></a>02683 <span class="comment">        /// @brief Compares this NodeIterator to another NodeIterator for inequality</span>
<a name="l02684"></a>02684 <span class="comment">        /// @param rhs The Right Hand Side NodeIterator.</span>
<a name="l02685"></a>02685 <span class="comment">        /// @return False if the internal data stored in Node this NodeIterator refers to is the same as the metadata in the other NodeIterator&#39;s Node, True otherwise.</span>
<a name="l02686"></a>02686 <span class="comment"></span><span class="comment"></span>
<a name="l02687"></a>02687 <span class="comment">        /// @fn NodeIterator::operator*();</span>
<a name="l02688"></a>02688 <span class="comment">        /// @brief Deferences this Iterator</span>
<a name="l02689"></a>02689 <span class="comment">        /// @return a Node reference to the node pointed at by this NodeIterator.</span>
<a name="l02690"></a>02690 <span class="comment"></span><span class="comment"></span>
<a name="l02691"></a>02691 <span class="comment">        /// @fn NodeIterator::operator-&gt;();</span>
<a name="l02692"></a>02692 <span class="comment">        /// @brief Get the pointer the Node this points to.</span>
<a name="l02693"></a>02693 <span class="comment">        /// @return A pointer to the Node this NodeIterator references.</span>
<a name="l02694"></a>02694 <span class="comment"></span><span class="comment"></span>
<a name="l02695"></a>02695 <span class="comment">                /// @fn NodeIterator::operator++();</span>
<a name="l02696"></a>02696 <span class="comment">                /// @brief Increment the iterator to the next member of the container.</span>
<a name="l02697"></a>02697 <span class="comment">        /// @return Returns a const NodeIterator.</span>
<a name="l02698"></a>02698 <span class="comment"></span><span class="comment"></span>
<a name="l02699"></a>02699 <span class="comment">                /// @fn NodeIterator::operator++(int);</span>
<a name="l02700"></a>02700 <span class="comment">                /// @brief Increment the iterator to the next member of the container.</span>
<a name="l02701"></a>02701 <span class="comment">        /// @return Returns a NodeIterator.</span>
<a name="l02702"></a>02702 <span class="comment"></span><span class="comment"></span>
<a name="l02703"></a>02703 <span class="comment">                /// @fn NodeIterator::operator--();</span>
<a name="l02704"></a>02704 <span class="comment">                /// @brief Decrement the iterator to the next member of the container.</span>
<a name="l02705"></a>02705 <span class="comment">        /// @return Returns a const NodeIterator.</span>
<a name="l02706"></a>02706 <span class="comment"></span><span class="comment"></span>
<a name="l02707"></a>02707 <span class="comment">                /// @fn NodeIterator::operator--(int);</span>
<a name="l02708"></a>02708 <span class="comment">                /// @brief Decrement the iterator to the next member of the container.</span>
<a name="l02709"></a>02709 <span class="comment">        /// @return Returns a NodeIterator.</span>
<a name="l02710"></a>02710 <span class="comment"></span><span class="comment"></span>
<a name="l02711"></a>02711 <span class="comment">        //////////////////////////////////////////////////////////////////////////////</span>
<a name="l02712"></a>02712 <span class="comment">        /// @class AttributeIterator</span>
<a name="l02713"></a>02713 <span class="comment">        /// @brief Attribute iterator (a bidirectional iterator over a collection of Attribute).</span>
<a name="l02714"></a>02714 <span class="comment">        /// @see This behaves very similar to xml::NodeIterator</span>
<a name="l02715"></a>02715 <span class="comment"></span><span class="comment"></span>
<a name="l02716"></a>02716 <span class="comment">                /// @typedef AttributeIterator::difference_type;</span>
<a name="l02717"></a>02717 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02718"></a>02718 <span class="comment"></span><span class="comment"></span>
<a name="l02719"></a>02719 <span class="comment">                /// @typedef AttributeIterator::value_type;</span>
<a name="l02720"></a>02720 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02721"></a>02721 <span class="comment"></span><span class="comment"></span>
<a name="l02722"></a>02722 <span class="comment">                /// @typedef AttributeIterator::pointer;</span>
<a name="l02723"></a>02723 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02724"></a>02724 <span class="comment"></span><span class="comment"></span>
<a name="l02725"></a>02725 <span class="comment">                /// @typedef AttributeIterator::reference;</span>
<a name="l02726"></a>02726 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02727"></a>02727 <span class="comment"></span><span class="comment"></span>
<a name="l02728"></a>02728 <span class="comment">                /// @typedef AttributeIterator::iterator_category;</span>
<a name="l02729"></a>02729 <span class="comment">                /// @brief An Iterator trait</span>
<a name="l02730"></a>02730 <span class="comment"></span><span class="comment"></span>
<a name="l02731"></a>02731 <span class="comment">        /// @fn AttributeIterator::AttributeIterator();</span>
<a name="l02732"></a>02732 <span class="comment">        /// @brief Default Constructor, makes a blank iterator</span>
<a name="l02733"></a>02733 <span class="comment"></span><span class="comment"></span>
<a name="l02734"></a>02734 <span class="comment">        /// @fn AttributeIterator::AttributeIterator(const Attribute&amp; attr, const Node&amp; GetParent);</span>
<a name="l02735"></a>02735 <span class="comment">        /// @brief Construct an iterator which points to the specified node</span>
<a name="l02736"></a>02736 <span class="comment">        /// @param GetParent A Node that contains the Attribute this iterator will point to.</span>
<a name="l02737"></a>02737 <span class="comment">        /// @param attr The Attribute this iterator points to.</span>
<a name="l02738"></a>02738 <span class="comment"></span><span class="comment"></span>
<a name="l02739"></a>02739 <span class="comment">        /// @fn AttributeIterator::operator==(const AttributeIterator&amp; rhs) const;</span>
<a name="l02740"></a>02740 <span class="comment">        /// @brief Compares this AttributeIterator to another AttributeIterator for equality</span>
<a name="l02741"></a>02741 <span class="comment">        /// @param rhs The Right Hand Side AttributeIterator</span>
<a name="l02742"></a>02742 <span class="comment">        /// @return True if the internal data stored in the Attribute this AttributeIterator refers to is the same as the metadata in the other AttributeIterator&#39;s Attribute, false otherwise.</span>
<a name="l02743"></a>02743 <span class="comment"></span><span class="comment"></span>
<a name="l02744"></a>02744 <span class="comment">        /// @fn AttributeIterator::operator!=(const AttributeIterator&amp; rhs) const;</span>
<a name="l02745"></a>02745 <span class="comment">        /// @brief Compares this AttributeIterator to another AttributeIterator for inequality</span>
<a name="l02746"></a>02746 <span class="comment">        /// @param rhs The Right Hand Side AttributeIterator.</span>
<a name="l02747"></a>02747 <span class="comment">        /// @return False if the internal data stored in Node this AttributeIterator refers to is the same as the metadata in the other AttributeIterator&#39;s Attribute, True otherwise.</span>
<a name="l02748"></a>02748 <span class="comment"></span><span class="comment"></span>
<a name="l02749"></a>02749 <span class="comment">        /// @fn AttributeIterator::operator*();</span>
<a name="l02750"></a>02750 <span class="comment">        /// @brief Deferences this Iterator</span>
<a name="l02751"></a>02751 <span class="comment">        /// @return a Attribute reference to the Attribute pointed at by this AttributeIterator.</span>
<a name="l02752"></a>02752 <span class="comment"></span><span class="comment"></span>
<a name="l02753"></a>02753 <span class="comment">        /// @fn AttributeIterator::operator-&gt;();</span>
<a name="l02754"></a>02754 <span class="comment">        /// @brief Get the pointer the Attribute this points to.</span>
<a name="l02755"></a>02755 <span class="comment">        /// @return A pointer to the Attribute this AttributeIterator references.</span>
<a name="l02756"></a>02756 <span class="comment"></span><span class="comment"></span>
<a name="l02757"></a>02757 <span class="comment">                /// @fn AttributeIterator::operator++();</span>
<a name="l02758"></a>02758 <span class="comment">                /// @brief Increment the iterator to the next member of the container.</span>
<a name="l02759"></a>02759 <span class="comment">        /// @return Returns a const AttributeIterator.</span>
<a name="l02760"></a>02760 <span class="comment"></span><span class="comment"></span>
<a name="l02761"></a>02761 <span class="comment">                /// @fn AttributeIterator::operator++(int);</span>
<a name="l02762"></a>02762 <span class="comment">                /// @brief Increment the iterator to the next member of the container.</span>
<a name="l02763"></a>02763 <span class="comment">        /// @return Returns a AttributeIterator.</span>
<a name="l02764"></a>02764 <span class="comment"></span><span class="comment"></span>
<a name="l02765"></a>02765 <span class="comment">                /// @fn AttributeIterator::operator--();</span>
<a name="l02766"></a>02766 <span class="comment">                /// @brief Decrement the iterator to the next member of the container.</span>
<a name="l02767"></a>02767 <span class="comment">        /// @return Returns a const AttributeIterator.</span>
<a name="l02768"></a>02768 <span class="comment"></span><span class="comment"></span>
<a name="l02769"></a>02769 <span class="comment">                /// @fn AttributeIterator::operator--(int);</span>
<a name="l02770"></a>02770 <span class="comment">                /// @brief Decrement the iterator to the next member of the container.</span>
<a name="l02771"></a>02771 <span class="comment">        /// @return Returns a AttributeIterator.</span>
<a name="l02772"></a>02772 <span class="comment"></span><span class="comment"></span>
<a name="l02773"></a>02773 <span class="comment">        //////////////////////////////////////////////////////////////////////////////</span>
<a name="l02774"></a>02774 <span class="comment">        /// @class TreeWalker</span>
<a name="l02775"></a>02775 <span class="comment">        /// @brief Used to call a function for_each member of the subtree of nodes descended from a specific node.</span>
<a name="l02776"></a>02776 <span class="comment">        /// @details If you want to do a deep tree traversal, you&#39;ll either have to do it via a recursive function or some</span>
<a name="l02777"></a>02777 <span class="comment">        /// equivalent method or use a TreeWalker. This provides a helper for depth-first traversal of a subtree. In order</span>
<a name="l02778"></a>02778 <span class="comment">        /// to use it, you have to implement xml::TreeWalker interface and call xml::Node::Traverse() function. \n\n</span>
<a name="l02779"></a>02779 <span class="comment">        ///  * First, TreeWalker::begin() is called with traversal root as its argument.\n</span>
<a name="l02780"></a>02780 <span class="comment">        ///  * Then, TreeWalker::for_each() function is called for all nodes in the traversal subtree in depth first order, excluding the traversal root. Each Node is passed as an argument.\n</span>
<a name="l02781"></a>02781 <span class="comment">        ///  * Finally, TreeWalker::end() function is called with traversal root as its argument.\n\n</span>
<a name="l02782"></a>02782 <span class="comment">        /// If TreeWalker::begin(), TreeWalker::end() or any of the TreeWalker::for_each() calls return false, the traversal</span>
<a name="l02783"></a>02783 <span class="comment">        /// is terminated and false is returned as the traversal result; otherwise, the traversal results in true. Note that</span>
<a name="l02784"></a>02784 <span class="comment">        /// you don&#39;t have to override begin or end functions; their default implementations return true.\n\n</span>
<a name="l02785"></a>02785 <span class="comment">        /// You can get the node&#39;s depth relative to the traversal root at any point by calling TreeWalker::Depth() function.</span>
<a name="l02786"></a>02786 <span class="comment"></span><span class="comment"></span>
<a name="l02787"></a>02787 <span class="comment">        /// @fn TreeWalker::Depth() const;</span>
<a name="l02788"></a>02788 <span class="comment">        /// @brief How many descendants deep are we during traversal.</span>
<a name="l02789"></a>02789 <span class="comment">        /// @return This returns -1 if called from TreeWalker::begin() or TreeWalker::end(), and returns 0-based depth if called from for_each - depth is 0 for all children of the traversal root, 1 for all grandchildren, 2 for great-grandchildren and so on.</span>
<a name="l02790"></a>02790 <span class="comment"></span><span class="comment"></span>
<a name="l02791"></a>02791 <span class="comment">        /// @fn TreeWalker::TreeWalker();</span>
<a name="l02792"></a>02792 <span class="comment">        /// @brief Default constructor, initializes depth, and can do little else without a fully implemented treewalker.</span>
<a name="l02793"></a>02793 <span class="comment"></span><span class="comment"></span>
<a name="l02794"></a>02794 <span class="comment">        /// @fn TreeWalker::~TreeWalker();</span>
<a name="l02795"></a>02795 <span class="comment">        /// @brief Virtual deconstructor. Tears down a TreeWalker</span>
<a name="l02796"></a>02796 <span class="comment"></span><span class="comment"></span>
<a name="l02797"></a>02797 <span class="comment">        /// @fn TreeWalker::begin(Node&amp; node);</span>
<a name="l02798"></a>02798 <span class="comment">        /// @brief Called by the root Node of the xml subtree when traversal begins.</span>
<a name="l02799"></a>02799 <span class="comment">        /// @param node The first node the Tree to traverse</span>
<a name="l02800"></a>02800 <span class="comment">        /// @details By default this simply returns true, but is expected to be overridden with any desired behavior</span>
<a name="l02801"></a>02801 <span class="comment">        /// @return True by default. If it returns false, then traversal ends and the Node::Traverse() that was called is expected to return false.</span>
<a name="l02802"></a>02802 <span class="comment"></span><span class="comment"></span>
<a name="l02803"></a>02803 <span class="comment">        /// @fn TreeWalker::for_each(Node&amp; node);</span>
<a name="l02804"></a>02804 <span class="comment">        /// @brief A Pure Virtual function that is expected to be implemented to create the desired behavior.</span>
<a name="l02805"></a>02805 <span class="comment">        /// @param node The curren node being trraversed.</span>
<a name="l02806"></a>02806 <span class="comment">        /// @details This is called on every Node that is traversed except the root node of the traversed subtree. Can be used to perform sophisticated searches</span>
<a name="l02807"></a>02807 <span class="comment">        /// of a portion of the xml document, alter the document on a large scale, gather statistics, or just about any other behavior that requires touching</span>
<a name="l02808"></a>02808 <span class="comment">        /// many nodes.</span>
<a name="l02809"></a>02809 <span class="comment">        /// @return if true Traversal is expected to continue, if false, then traversal ends and the Node::Traverse() that was called is expected to return false.</span>
<a name="l02810"></a>02810 <span class="comment"></span><span class="comment"></span>
<a name="l02811"></a>02811 <span class="comment">        /// @fn TreeWalker::end(Node&amp; node);</span>
<a name="l02812"></a>02812 <span class="comment">        /// @brief Called on the root Node of the xml subtree when traversal ends.</span>
<a name="l02813"></a>02813 <span class="comment">        /// @param node The last node the Tree to traverse</span>
<a name="l02814"></a>02814 <span class="comment">        /// @details By default this simply returns true, but is expected to be overridden with any desired behavior</span>
<a name="l02815"></a>02815 <span class="comment">        /// @return True by default. If it returns false, then traversal ends and the Node::Traverse() that was called is expected to return false.</span>
<a name="l02816"></a>02816 <span class="comment"></span><span class="comment"></span>
<a name="l02817"></a>02817 <span class="comment">        //////////////////////////////////////////////////////////////////////////////</span>
<a name="l02818"></a>02818 <span class="comment">        /// @class Document</span>
<a name="l02819"></a>02819 <span class="comment">        /// @brief The root node of any xml hierarchy is a Document Node</span>
<a name="l02820"></a>02820 <span class="comment">        /// @details This has all the same features as a Node and include a few features for saving, loading, streaming</span>
<a name="l02821"></a>02821 <span class="comment">        /// and to a limited degree managing the document declaration.</span>
<a name="l02822"></a>02822 <span class="comment"></span><span class="comment"></span>
<a name="l02823"></a>02823 <span class="comment">        /// @fn Document::Document();</span>
<a name="l02824"></a>02824 <span class="comment">        /// @brief Creates an empty document with just a root Node</span>
<a name="l02825"></a>02825 <span class="comment"></span><span class="comment"></span>
<a name="l02826"></a>02826 <span class="comment">        /// @fn Document::~Document()</span>
<a name="l02827"></a>02827 <span class="comment">        /// @brief Tears down a document, and incidentally invalidates all Node and Attribute handles to this document.</span>
<a name="l02828"></a>02828 <span class="comment"></span><span class="comment"></span>
<a name="l02829"></a>02829 <span class="comment">        /// @fn Document::Reset();</span>
<a name="l02830"></a>02830 <span class="comment">        /// @brief Removes all nodes, leaving the empty document.</span>
<a name="l02831"></a>02831 <span class="comment"></span><span class="comment"></span>
<a name="l02832"></a>02832 <span class="comment">        /// @fn Document::Reset(const Document&amp; proto);</span>
<a name="l02833"></a>02833 <span class="comment">        /// @brief Removes all nodes, then copies the entire contents of the specified document</span>
<a name="l02834"></a>02834 <span class="comment">        /// @param proto The Document to copy.</span>
<a name="l02835"></a>02835 <span class="comment"></span><span class="comment"></span>
<a name="l02836"></a>02836 <span class="comment">        /// @fn Document::Load(std::basic_istream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; stream, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto);</span>
<a name="l02837"></a>02837 <span class="comment">        /// @brief Load XML from a stream.</span>
<a name="l02838"></a>02838 <span class="comment">        /// @param stream An std::istream which has xml text in it.</span>
<a name="l02839"></a>02839 <span class="comment">        /// @param options A bitset of parse options that should be set using the Parse variables. This Defaults to ParseDefault.</span>
<a name="l02840"></a>02840 <span class="comment">        /// @param DocumentEncoding What kind of text is in the stream, this defaults to Encoding::EncodingAuto</span>
<a name="l02841"></a>02841 <span class="comment">        /// @return A ParseResult that stores the the outcome of attempting to load the document.</span>
<a name="l02842"></a>02842 <span class="comment"></span><span class="comment"></span>
<a name="l02843"></a>02843 <span class="comment">        /// @fn Document::Load(std::basic_istream&lt;wchar_t, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream, unsigned int options = ParseDefault);</span>
<a name="l02844"></a>02844 <span class="comment">        /// @brief Load XML from a wide stream.</span>
<a name="l02845"></a>02845 <span class="comment">        /// @param stream An std::basic_istream which has xml wide character text in it.</span>
<a name="l02846"></a>02846 <span class="comment">        /// @param options A bitset of parse options that should be set using the Parse variables. This Defaults to ParseDefault.</span>
<a name="l02847"></a>02847 <span class="comment">        /// @return A ParseResult that stores the the outcome of attempting to load the document.</span>
<a name="l02848"></a>02848 <span class="comment"></span><span class="comment"></span>
<a name="l02849"></a>02849 <span class="comment">        /// @fn Document::Load(const char_t* contents, unsigned int options = ParseDefault);</span>
<a name="l02850"></a>02850 <span class="comment">        /// @brief Load XML from a Character array.</span>
<a name="l02851"></a>02851 <span class="comment">        /// @param contents A pointer to the Null terminated array of Characters.</span>
<a name="l02852"></a>02852 <span class="comment">        /// @param options A bitset of parse options that should be set using the Parse variables. This Defaults to ParseDefault.</span>
<a name="l02853"></a>02853 <span class="comment">        /// @return A ParseResult that stores the the outcome of attempting to load the document.</span>
<a name="l02854"></a>02854 <span class="comment"></span><span class="comment"></span>
<a name="l02855"></a>02855 <span class="comment">        /// @fn Document::LoadBuffer(const void* contents, size_t size, unsigned int options = ParseDefault, Encoding DocumentEncoding = EncodingAuto);</span>
<a name="l02856"></a>02856 <span class="comment">        /// @brief Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the function returns.</span>
<a name="l02857"></a>02857 <span class="comment">        /// @param contents A pointer to buffer containing the xml document to be parsed, that will remain unchanged.</span>
<a name="l02858"></a>02858 <span class="comment">        /// @param size The size of the buffer.</span>
<a name="l02859"></a>02859 <span class="comment">        /// @param options A bitset of parse options that should be set using the Parse variables. This Defaults to ParseDefault.</span>
<a name="l02860"></a>02860 <span class="comment">        /// @param DocumentEncoding What kind of text is in the stream, this defaults to Encoding::EncodingAuto</span>
<a name="l02861"></a>02861 <span class="comment">        /// @return A ParseResult that stores the the outcome of attempting to load the document.</span>
<a name="l02862"></a>02862 <span class="comment"></span><span class="comment"></span>
<a name="l02863"></a>02863 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02864"></a>02864 <span class="comment">        /// @enum XPathValueType</span>
<a name="l02865"></a>02865 <span class="comment">        /// @brief XPathQuery return type</span>
<a name="l02866"></a>02866 <span class="comment"></span><span class="comment"></span>
<a name="l02867"></a>02867 <span class="comment">                /// @var XPathTypeNone</span>
<a name="l02868"></a>02868 <span class="comment">                /// @brief Unknown Type (query failed to compile)</span>
<a name="l02869"></a>02869 <span class="comment"></span><span class="comment"></span>
<a name="l02870"></a>02870 <span class="comment">                /// @var XPathTypeNodeSet</span>
<a name="l02871"></a>02871 <span class="comment">                /// @brief Node set (XPathNodeSet)</span>
<a name="l02872"></a>02872 <span class="comment"></span><span class="comment"></span>
<a name="l02873"></a>02873 <span class="comment">                /// @var XPathTypeNumber</span>
<a name="l02874"></a>02874 <span class="comment">                /// @brief Number This corresponds to a double or Real.</span>
<a name="l02875"></a>02875 <span class="comment"></span><span class="comment"></span>
<a name="l02876"></a>02876 <span class="comment">                /// @var XPathTypeString</span>
<a name="l02877"></a>02877 <span class="comment">                /// @brief Corresponds to the String type.</span>
<a name="l02878"></a>02878 <span class="comment"></span><span class="comment"></span>
<a name="l02879"></a>02879 <span class="comment">                /// @var XPathTypeBoolean</span>
<a name="l02880"></a>02880 <span class="comment">                /// @brief A Boolean value.</span>
<a name="l02881"></a>02881 <span class="comment"></span><span class="comment"></span>
<a name="l02882"></a>02882 <span class="comment">                ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02883"></a>02883 <span class="comment">        /// @struct XPathParseResult</span>
<a name="l02884"></a>02884 <span class="comment">        /// @brief XPath parsing result</span>
<a name="l02885"></a>02885 <span class="comment"></span><span class="comment"></span>
<a name="l02886"></a>02886 <span class="comment">        /// @var XPathParseResult::Offset</span>
<a name="l02887"></a>02887 <span class="comment">        /// @brief Last parsed Offset (in Character units from string start)</span>
<a name="l02888"></a>02888 <span class="comment"></span><span class="comment"></span>
<a name="l02889"></a>02889 <span class="comment">        /// @var XPathParseResult::error</span>
<a name="l02890"></a>02890 <span class="comment">        /// @brief Error message (0 if no error).</span>
<a name="l02891"></a>02891 <span class="comment"></span><span class="comment"></span>
<a name="l02892"></a>02892 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02893"></a>02893 <span class="comment">        /// @class XPathVariable</span>
<a name="l02894"></a>02894 <span class="comment">        /// @brief A single XPath variable</span>
<a name="l02895"></a>02895 <span class="comment">        /// @details This is intended to be used as a single member of an XPathVariableSet, and for moving data into and out of XPathQueries.</span>
<a name="l02896"></a>02896 <span class="comment"></span><span class="comment"></span>
<a name="l02897"></a>02897 <span class="comment">        /// @fn XPathVariable::XPathVariable();</span>
<a name="l02898"></a>02898 <span class="comment">        /// @brief Protected Default constructor.</span>
<a name="l02899"></a>02899 <span class="comment"></span><span class="comment"></span>
<a name="l02900"></a>02900 <span class="comment">        /// @var XPathVariable::_type</span>
<a name="l02901"></a>02901 <span class="comment">        /// @brief What kind of data does this variable store</span>
<a name="l02902"></a>02902 <span class="comment"></span><span class="comment"></span>
<a name="l02903"></a>02903 <span class="comment">        /// @var XPathVariable::_next</span>
<a name="l02904"></a>02904 <span class="comment">        /// @brief The next variable in the variable set. I think, and I am not certain, that this is a circularly linked list.</span>
<a name="l02905"></a>02905 <span class="comment"></span><span class="comment"></span>
<a name="l02906"></a>02906 <span class="comment">        /// @fn XPathVariable::XPathVariable(const XPathVariable&amp;);</span>
<a name="l02907"></a>02907 <span class="comment">        /// @brief Protected Copy Constructor, used to force noncopyable semantics</span>
<a name="l02908"></a>02908 <span class="comment"></span><span class="comment"></span>
<a name="l02909"></a>02909 <span class="comment">        /// @fn XPathVariable::operator=(const XPathVariable&amp;);</span>
<a name="l02910"></a>02910 <span class="comment">        /// @brief Protected assignment operator, used to force noncopyable semantics</span>
<a name="l02911"></a>02911 <span class="comment">        /// @return Shouldn&#39;t be used, not implemented.</span>
<a name="l02912"></a>02912 <span class="comment"></span><span class="comment"></span>
<a name="l02913"></a>02913 <span class="comment">        /// @fn XPathVariable::Set(bool Value);</span>
<a name="l02914"></a>02914 <span class="comment">        /// @brief Set variable Value; no Type conversion is performed.</span>
<a name="l02915"></a>02915 <span class="comment">        /// @return True is returned on Success, false is returned on Type mismatch error.</span>
<a name="l02916"></a>02916 <span class="comment">        /// @param Value The value to attempt to put into this.</span>
<a name="l02917"></a>02917 <span class="comment"></span><span class="comment"></span>
<a name="l02918"></a>02918 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02919"></a>02919 <span class="comment">        /// @class XPathVariableSet</span>
<a name="l02920"></a>02920 <span class="comment">        /// @brief A set of XPath variables.</span>
<a name="l02921"></a>02921 <span class="comment"></span><span class="comment"></span>
<a name="l02922"></a>02922 <span class="comment">        /// @fn XPathVariableSet::XPathVariableSet();</span>
<a name="l02923"></a>02923 <span class="comment">        /// @brief Default Constructor, Blanks any XPathVariable it contains.</span>
<a name="l02924"></a>02924 <span class="comment"></span><span class="comment"></span>
<a name="l02925"></a>02925 <span class="comment">        /// @fn XPathVariableSet::~XPathVariableSet();</span>
<a name="l02926"></a>02926 <span class="comment">        /// @brief Default Deconstructor, Deletes any XPathVariable it contains.</span>
<a name="l02927"></a>02927 <span class="comment"></span><span class="comment"></span>
<a name="l02928"></a>02928 <span class="comment">        /// @fn XPathVariableSet::Add(const char_t* Name, XPathValueType Type);</span>
<a name="l02929"></a>02929 <span class="comment">        /// @brief Add a new variable or get the existing one, if the Types match</span>
<a name="l02930"></a>02930 <span class="comment">        /// @return A pointer to the XPathVariable you referenced or just created.</span>
<a name="l02931"></a>02931 <span class="comment">        /// @param Name The name of variable to add.</span>
<a name="l02932"></a>02932 <span class="comment">        /// @param Type The Type of the new value to add as an XPathValueType.</span>
<a name="l02933"></a>02933 <span class="comment"></span><span class="comment"></span>
<a name="l02934"></a>02934 <span class="comment">                /// @fn XPathVariableSet::Get(const char_t* Name);</span>
<a name="l02935"></a>02935 <span class="comment">                /// @brief Get the named XPathVariable.</span>
<a name="l02936"></a>02936 <span class="comment">        /// @return A pointer to the specified XPathVariable.</span>
<a name="l02937"></a>02937 <span class="comment">                /// @param Name The name of the XPathVariable you want.</span>
<a name="l02938"></a>02938 <span class="comment"></span><span class="comment"></span>
<a name="l02939"></a>02939 <span class="comment">                /// @fn XPathVariableSet::Get(const char_t* Name) const;</span>
<a name="l02940"></a>02940 <span class="comment">                /// @brief Get the named XPathVariable.</span>
<a name="l02941"></a>02941 <span class="comment">                /// @param Name The name of the XPathVariable you want.</span>
<a name="l02942"></a>02942 <span class="comment">        /// @return A pointer to the specified XPathVariable.</span>
<a name="l02943"></a>02943 <span class="comment"></span><span class="comment"></span>
<a name="l02944"></a>02944 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02945"></a>02945 <span class="comment">        /// @class XPathQuery</span>
<a name="l02946"></a>02946 <span class="comment">        /// @brief A compiled XPath query object</span>
<a name="l02947"></a>02947 <span class="comment">        /// @details When you call select_nodes with an expression string as an argument, a query object is created behind the scenes. A query object represents a compiled XPath expression. Query objects can be needed in the following circumstances: \n</span>
<a name="l02948"></a>02948 <span class="comment">        /// - You can precompile expressions to query objects to save compilation time if it becomes an issue; \n</span>
<a name="l02949"></a>02949 <span class="comment">        /// - You can use query objects to evaluate XPath expressions which result in booleans, numbers or strings; \n</span>
<a name="l02950"></a>02950 <span class="comment">        /// - You can get the type of expression value via query object. \n \n</span>
<a name="l02951"></a>02951 <span class="comment">        /// Query objects correspond to xml::XPathQuery type. They are immutable and non-copyable: they are bound to the expression at creation time and can not be cloned. If you want to put query objects in a container, allocate them on heap via new operator and store pointers to xml::XPathQuery in the container. \n \n</span>
<a name="l02952"></a>02952 <span class="comment">        /// To evaluate an XPath expression there are a few EvaluatedType functions. According to XPath specification, value of any type can be converted to boolean, number or string value, but no type other than node set can be converted to node set. Because of this, XPathQuery::EvaluateBoolean(), XPathQuery::EvaluateNumber() and XPathQuery::EvaluateString() always return a result, but EvaluateNodeSet results in an error if the return type is not node set.</span>
<a name="l02953"></a>02953 <span class="comment"></span><span class="comment"></span>
<a name="l02954"></a>02954 <span class="comment">        /// @fn XPathQuery::ReturnType() const;</span>
<a name="l02955"></a>02955 <span class="comment">        /// @brief Get query expression return Type.</span>
<a name="l02956"></a>02956 <span class="comment">        /// @return A XPathValueType.</span>
<a name="l02957"></a>02957 <span class="comment"></span><span class="comment"></span>
<a name="l02958"></a>02958 <span class="comment">        /// @fn XPathQuery::EvaluateBoolean(const XPathNode&amp; n) const;</span>
<a name="l02959"></a>02959 <span class="comment">        /// @brief Evaluate expression as boolean value in the specified context; performs Type conversion if necessary.</span>
<a name="l02960"></a>02960 <span class="comment">        /// @return A bool result of evaluating the expression.</span>
<a name="l02961"></a>02961 <span class="comment">        /// @throw If XML_NO_EXCEPTIONS is not defined (by default it is not defined), throws std::bad_alloc on out of memory errors.</span>
<a name="l02962"></a>02962 <span class="comment">        /// @param n The XPathNode that will serve as the context for the query.</span>
<a name="l02963"></a>02963 <span class="comment"></span><span class="comment"></span>
<a name="l02964"></a>02964 <span class="comment">        /// @fn XPathQuery::Result() const;</span>
<a name="l02965"></a>02965 <span class="comment">        /// @brief Get parsing Result (used to get compilation errors when XML_NO_EXCEPTIONS is enabled)</span>
<a name="l02966"></a>02966 <span class="comment">                /// @return A const reference to an XPathParseResult.</span>
<a name="l02967"></a>02967 <span class="comment"></span><span class="comment"></span>
<a name="l02968"></a>02968 <span class="comment">        /// @fn XPathQuery::operator!() const;</span>
<a name="l02969"></a>02969 <span class="comment">        /// @brief Logical not operator, used a workaround for borland compiler.</span>
<a name="l02970"></a>02970 <span class="comment">        /// @return A bool that is the opposite of evaluatig this as a bool normally.</span>
<a name="l02971"></a>02971 <span class="comment"></span><span class="comment"></span>
<a name="l02972"></a>02972 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02973"></a>02973 <span class="comment">        /// @class XPathException</span>
<a name="l02974"></a>02974 <span class="comment">        /// @brief Thrown in a variety of XPath only situations, to indicate type mismatch or other issues.</span>
<a name="l02975"></a>02975 <span class="comment"></span><span class="comment"></span>
<a name="l02976"></a>02976 <span class="comment">                /// @fn XPathException::what() const throw();</span>
<a name="l02977"></a>02977 <span class="comment">                /// @brief Get error message.</span>
<a name="l02978"></a>02978 <span class="comment">                /// @return A description of the error message as a c-style string.</span>
<a name="l02979"></a>02979 <span class="comment"></span><span class="comment"></span>
<a name="l02980"></a>02980 <span class="comment">                /// @fn XPathException::Result() const;</span>
<a name="l02981"></a>02981 <span class="comment">                /// @brief Get parse Result.</span>
<a name="l02982"></a>02982 <span class="comment">                /// @return The XPathParseResult used to create this exception.</span>
<a name="l02983"></a>02983 <span class="comment"></span><span class="comment"></span>
<a name="l02984"></a>02984 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l02985"></a>02985 <span class="comment">        /// @class XPathNode</span>
<a name="l02986"></a>02986 <span class="comment">        /// @brief An XPath node which can store handles to a xml::Node or an xml::Attribute.</span>
<a name="l02987"></a>02987 <span class="comment">        /// @details Because an XPath node can be either a xml::Node or an xml::Attribute, there is a special type, XPathNode,</span>
<a name="l02988"></a>02988 <span class="comment">        /// which is a discriminated union of these types. A value of this type contains two node handles, one of xml::Node type,</span>
<a name="l02989"></a>02989 <span class="comment">        /// and another one of xml::Attribute type; at most one of them can be non-null. The accessors to get these handles are</span>
<a name="l02990"></a>02990 <span class="comment">        /// available: XPathNode::GetNode() an XPathNode::GetAttribute() . \n \n</span>
<a name="l02991"></a>02991 <span class="comment">        /// XPath nodes can be null, in which case both accessors return null handles.</span>
<a name="l02992"></a>02992 <span class="comment"></span><span class="comment"></span>
<a name="l02993"></a>02993 <span class="comment">        /// @fn XPathNode::XPathNode(const Node&amp; node);</span>
<a name="l02994"></a>02994 <span class="comment">        /// @brief Construct From a xml::Node.</span>
<a name="l02995"></a>02995 <span class="comment">        /// @param node The xml::Node this handle should reference.</span>
<a name="l02996"></a>02996 <span class="comment"></span><span class="comment"></span>
<a name="l02997"></a>02997 <span class="comment">                /// @fn XPathNode::GetNode() const;</span>
<a name="l02998"></a>02998 <span class="comment">                /// @brief Get the xml::Node this is referencing</span>
<a name="l02999"></a>02999 <span class="comment">                /// @return A valid xml::Node, or a null node if this doesn&#39;t reference a an xml::Node.</span>
<a name="l03000"></a>03000 <span class="comment"></span><span class="comment"></span>
<a name="l03001"></a>03001 <span class="comment">                /// @fn XPathNode::GetAttribute() const;</span>
<a name="l03002"></a>03002 <span class="comment">                /// @brief Get the xml::Attribute this is referencing</span>
<a name="l03003"></a>03003 <span class="comment">        /// @return A valid xml::Attribute, or a null node if this doesn&#39;t reference a an xml::Attribute.</span>
<a name="l03004"></a>03004 <span class="comment"></span><span class="comment"></span>
<a name="l03005"></a>03005 <span class="comment">                /// @fn XPathNode::GetParent() const;</span>
<a name="l03006"></a>03006 <span class="comment">                /// @brief Get the parent of the xml::Node or xml::Attribute this refers to.</span>
<a name="l03007"></a>03007 <span class="comment">        /// @return A valid xml::Node, or a null node if this doesn&#39;t reference a an xml::Node.</span>
<a name="l03008"></a>03008 <span class="comment"></span><span class="comment"></span>
<a name="l03009"></a>03009 <span class="comment">        /// @fn XPathNode::operator!() const;</span>
<a name="l03010"></a>03010 <span class="comment">        /// @brief Logical not operator, used a workaround for borland compiler.</span>
<a name="l03011"></a>03011 <span class="comment">        /// @return A bool that is the opposite of evaluatig this as a bool normally.</span>
<a name="l03012"></a>03012 <span class="comment"></span><span class="comment"></span>
<a name="l03013"></a>03013 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l03014"></a>03014 <span class="comment">        /// @class XPathNodeSet</span>
<a name="l03015"></a>03015 <span class="comment">        /// @brief A collection of nodes that an XPathQuery can work on.</span>
<a name="l03016"></a>03016 <span class="comment"></span><span class="comment"></span>
<a name="l03017"></a>03017 <span class="comment">        /// @enum XPathNodeSet::CollectionType</span>
<a name="l03018"></a>03018 <span class="comment">        /// @brief The different ways a collection may or may not be ordered.</span>
<a name="l03019"></a>03019 <span class="comment"></span><span class="comment"></span>
<a name="l03020"></a>03020 <span class="comment">        /// @var XPathNodeSet::TypeUnsorted</span>
<a name="l03021"></a>03021 <span class="comment">        /// @brief Not Ordered.</span>
<a name="l03022"></a>03022 <span class="comment"></span><span class="comment"></span>
<a name="l03023"></a>03023 <span class="comment">        /// @var XPathNodeSet::TypeSorted</span>
<a name="l03024"></a>03024 <span class="comment">        /// @brief In document Order.</span>
<a name="l03025"></a>03025 <span class="comment"></span><span class="comment"></span>
<a name="l03026"></a>03026 <span class="comment">        /// @var XPathNodeSet::TypeSortedReverse</span>
<a name="l03027"></a>03027 <span class="comment">        /// @brief In reverse document Order.</span>
<a name="l03028"></a>03028 <span class="comment"></span><span class="comment"></span>
<a name="l03029"></a>03029 <span class="comment">        /// @typedef XPathNodeSet::const_iterator;</span>
<a name="l03030"></a>03030 <span class="comment">        /// @brief An iterator trait. Const iterator for XPathNodes.</span>
<a name="l03031"></a>03031 <span class="comment"></span><span class="comment"></span>
<a name="l03032"></a>03032 <span class="comment">        /// @fn XPathNodeSet::XPathNodeSet();</span>
<a name="l03033"></a>03033 <span class="comment">        /// @brief Default constructor. Constructs empty set.</span>
<a name="l03034"></a>03034 <span class="comment"></span><span class="comment"></span>
<a name="l03035"></a>03035 <span class="comment">        /// @fn XPathNodeSet::XPathNodeSet(const_iterator begin, const_iterator end, CollectionType Type = TypeUnsorted);</span>
<a name="l03036"></a>03036 <span class="comment">        /// @param begin A const XPathNode iterator at the beginning of the set of nodes.</span>
<a name="l03037"></a>03037 <span class="comment">        /// @param end A const XPathNode iterator at the end of the set of nodes.</span>
<a name="l03038"></a>03038 <span class="comment">        /// @param Type What XPathNodeSet::CollectionType is being used, this defaults to XPathNodeSet::TypeUnsorted</span>
<a name="l03039"></a>03039 <span class="comment">        /// @brief Constructs a set from iterator range.</span>
<a name="l03040"></a>03040 <span class="comment">        /// @details Data is not checked for duplicates and is not sorted according to provided Type, so be careful.</span>
<a name="l03041"></a>03041 <span class="comment"></span><span class="comment"></span>
<a name="l03042"></a>03042 <span class="comment">                /// @fn XPathNodeSet::operator=(const XPathNodeSet&amp; ns);</span>
<a name="l03043"></a>03043 <span class="comment">                /// @brief Assignment Operator.</span>
<a name="l03044"></a>03044 <span class="comment">                /// @return A reference to the freshly assigned XPathNodeSet.</span>
<a name="l03045"></a>03045 <span class="comment">                /// @param ns The XPathNodeSet to copy.</span>
<a name="l03046"></a>03046 <span class="comment"></span><span class="comment"></span>
<a name="l03047"></a>03047 <span class="comment">                /// @fn XPathNodeSet::Type() const;</span>
<a name="l03048"></a>03048 <span class="comment">                /// @brief Get collection Type.</span>
<a name="l03049"></a>03049 <span class="comment">                /// @return CollectionType</span>
<a name="l03050"></a>03050 <span class="comment"></span><span class="comment"></span>
<a name="l03051"></a>03051 <span class="comment">        /// @fn XPathNodeSet::operator[](size_t index) const;</span>
<a name="l03052"></a>03052 <span class="comment">        /// @brief Indexing operator.</span>
<a name="l03053"></a>03053 <span class="comment">        /// @param index A size_t indicating which XPathNode you would like to retrieve</span>
<a name="l03054"></a>03054 <span class="comment">        /// @return A const reference to the XPathNode you requested.</span>
<a name="l03055"></a>03055 <span class="comment">        /// @warning Out of bounds errors are checked using assert. Exceptions will not be thrown, during debugging out of bounds access will abort the termination and in production code out of bounds accesses will cause undefined behavior.</span>
<a name="l03056"></a>03056 <span class="comment"></span><span class="comment"></span>
<a name="l03057"></a>03057 <span class="comment">                /// @fn XPathNodeSet::begin() const;</span>
<a name="l03058"></a>03058 <span class="comment">                /// @brief Get Beginning iterator.</span>
<a name="l03059"></a>03059 <span class="comment">                /// @return A XPathNodeSet::const_iterator to the beginning of the collection.</span>
<a name="l03060"></a>03060 <span class="comment"></span><span class="comment"></span>
<a name="l03061"></a>03061 <span class="comment">                /// @fn XPathNodeSet::end() const;</span>
<a name="l03062"></a>03062 <span class="comment">                /// @brief Get Ending iterator.</span>
<a name="l03063"></a>03063 <span class="comment">        /// @return A XPathNodeSet::const_iterator to the end of the collection.</span>
<a name="l03064"></a>03064 <span class="comment"></span><span class="comment"></span>
<a name="l03065"></a>03065 <span class="comment">        /// @fn XPathNodeSet::sort(bool reverse = false);</span>
<a name="l03066"></a>03066 <span class="comment">        /// @brief Sort the collection in ascending/descending order by document order.</span>
<a name="l03067"></a>03067 <span class="comment">        /// @param reverse If true this sorts the collection in the opposite of document order.</span>
<a name="l03068"></a>03068 <span class="comment"></span><span class="comment"></span>
<a name="l03069"></a>03069 <span class="comment">        /// @fn XPathNodeSet::first() const;</span>
<a name="l03070"></a>03070 <span class="comment">        /// @brief Get first node in the collection by document order.</span>
<a name="l03071"></a>03071 <span class="comment">        /// @return The first node of the, in document order as an XPathNode.</span>
<a name="l03072"></a>03072 <span class="comment"></span><span class="comment"></span>
<a name="l03073"></a>03073 <span class="comment">        /// @fn XPathNodeSet::Empty() const;</span>
<a name="l03074"></a>03074 <span class="comment">        /// @brief Check if collection is empty.</span>
<a name="l03075"></a>03075 <span class="comment">        /// @return True if the document is empty, false otherwise.</span>
<a name="l03076"></a>03076 <span class="comment"></span><span class="comment"></span>
<a name="l03077"></a>03077 <span class="comment">        ///////////////////////////////////////////////////////////////////////////////</span>
<a name="l03078"></a>03078 <span class="comment"></span>        <span class="comment">// floaters</span>
<a name="l03079"></a>03079 <span class="comment"></span>
<a name="l03080"></a>03080 <span class="comment">        /// @internal</span>
<a name="l03081"></a>03081 <span class="comment">        /// @fn AsUtf8(const wchar_t* str);</span>
<a name="l03082"></a>03082 <span class="comment">        /// @brief Convert a c-style string of wchar_t to std::string containing UTF8.</span>
<a name="l03083"></a>03083 <span class="comment">        /// @param str The string to convert</span>
<a name="l03084"></a>03084 <span class="comment">        /// @return A std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; containing the converted data</span>
<a name="l03085"></a>03085 <span class="comment"></span><span class="comment"></span>
<a name="l03086"></a>03086 <span class="comment">        /// @internal</span>
<a name="l03087"></a>03087 <span class="comment">        /// @fn AsUtf8(const std::basic_string&lt;wchar_t, std::char_traits&lt;wchar_t&gt;, std::allocator&lt;wchar_t&gt; &gt;&amp; str);</span>
<a name="l03088"></a>03088 <span class="comment">        /// @brief Convert a std::wstring to a UTF8 std::string</span>
<a name="l03089"></a>03089 <span class="comment">        /// @param str The string to convert.</span>
<a name="l03090"></a>03090 <span class="comment">        /// @return A std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; containing the converted data</span>
<a name="l03091"></a>03091 <span class="comment"></span><span class="comment"></span>
<a name="l03092"></a>03092 <span class="comment">        /// @internal</span>
<a name="l03093"></a>03093 <span class="comment">        /// @fn AsWide(const char* str);</span>
<a name="l03094"></a>03094 <span class="comment">        /// @brief Convert a Convert a c-style string to std::wstring containing native encoding (Usually UCS2 on windows and UTF32 on Linux/Mac).</span>
<a name="l03095"></a>03095 <span class="comment">        /// @param str The string to convert.</span>
<a name="l03096"></a>03096 <span class="comment">        /// @return A std::basic_string&lt;wchar_t, std::char_traits&lt;wchar_t&gt;, std::allocator&lt;wchar_t&gt; &gt; containing the converted data</span>
<a name="l03097"></a>03097 <span class="comment"></span><span class="comment"></span>
<a name="l03098"></a>03098 <span class="comment">        /// @internal</span>
<a name="l03099"></a>03099 <span class="comment">        /// @fn AsWide(const std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp; str);</span>
<a name="l03100"></a>03100 <span class="comment">        /// @brief Convert a Convert a std::string to std::wstring containing native encoding (Usually UCS2 on windows and UTF32 on Linux/Mac).</span>
<a name="l03101"></a>03101 <span class="comment">        /// @param str The string to convert.</span>
<a name="l03102"></a>03102 <span class="comment">        /// @return A std::basic_string&lt;wchar_t, std::char_traits&lt;wchar_t&gt;, std::allocator&lt;wchar_t&gt; &gt; containing the converted data</span>
<a name="l03103"></a>03103 <span class="comment"></span><span class="comment"></span>
<a name="l03104"></a>03104 <span class="comment">        /// @typedef AllocationFunction</span>
<a name="l03105"></a>03105 <span class="comment">        /// @brief Memory allocation function interface; returns pointer to allocated memory or NULL on failure</span>
<a name="l03106"></a>03106 <span class="comment"></span><span class="comment"></span>
<a name="l03107"></a>03107 <span class="comment">        /// @typedef deAllocationFunction</span>
<a name="l03108"></a>03108 <span class="comment">        /// @brief Memory deallocation function interface</span>
<a name="l03109"></a>03109 <span class="comment"></span><span class="comment"></span>
<a name="l03110"></a>03110 <span class="comment">        /// @internal</span>
<a name="l03111"></a>03111 <span class="comment">        /// @fn SetMemory_management_functions(AllocationFunction allocate, deAllocationFunction deallocate);</span>
<a name="l03112"></a>03112 <span class="comment">        /// @brief Override default memory management functions. All subsequent allocations/deallocations will be performed via supplied functions.</span>
<a name="l03113"></a>03113 <span class="comment">        /// @param allocate The new memory allocator</span>
<a name="l03114"></a>03114 <span class="comment">        /// @param deallocate The new memory deallocator</span>
<a name="l03115"></a>03115 <span class="comment"></span><span class="comment"></span>
<a name="l03116"></a>03116 <span class="comment">        /// @internal</span>
<a name="l03117"></a>03117 <span class="comment">        /// @fn GetMemoryAllocationFunction();</span>
<a name="l03118"></a>03118 <span class="comment">        /// @brief Get the current allocation funciton</span>
<a name="l03119"></a>03119 <span class="comment">        /// @return A function to the current allocation function</span>
<a name="l03120"></a>03120 <span class="comment"></span><span class="comment"></span>
<a name="l03121"></a>03121 <span class="comment">        /// @internal</span>
<a name="l03122"></a>03122 <span class="comment">        /// @fn GetMemoryDeallocationFunction();</span>
<a name="l03123"></a>03123 <span class="comment">        /// @brief Get the current allocation funciton</span>
<a name="l03124"></a>03124 <span class="comment">        /// @return A function to the current allocation function</span>
<a name="l03125"></a>03125 <span class="comment"></span><span class="comment"></span>
<a name="l03126"></a>03126 <span class="comment">        /// @brief Gets the first tag out of the Stream and returns it as a String</span>
<a name="l03127"></a>03127 <span class="comment">        /// @param stream An std::ostream that contains atleast one xml tag</span>
<a name="l03128"></a>03128 <span class="comment">        /// @return This gets one XML tag, its closing tage, and all subtags.</span>
<a name="l03129"></a>03129 <span class="comment"></span>        <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a> MEZZ_LIB GetOneTag(std::istream&amp; stream);
<a name="l03130"></a>03130 <span class="comment"></span>
<a name="l03131"></a>03131 <span class="comment">        /// @internal</span>
<a name="l03132"></a>03132 <span class="comment">        /// @brief Perform a basic series of checks for extracting meaning from a single xml tag.</span>
<a name="l03133"></a>03133 <span class="comment">        /// @param NameSpace Used when throwing exceptions, this is a string containing the namespace and colons of a class to be deserialized for example &quot;Mezzanine::&quot;</span>
<a name="l03134"></a>03134 <span class="comment">        /// @param ClassName This will be used to identify the main xml element/tag you are attempting to deserialize. This will also be used in error messages.</span>
<a name="l03135"></a>03135 <span class="comment">        /// @param OneTag One XML tag/elements worth of text to deserialize.</span>
<a name="l03136"></a>03136 <span class="comment">        /// @return A pointer to xml::Document that you are now the owner of and must delete, that has the data parse and ready to access.</span>
<a name="l03137"></a>03137 <span class="comment">        /// @throw This can throw a Mezzanine::exception in the event that the xml cannot be parsed.</span>
<a name="l03138"></a>03138 <span class="comment"></span>        Document* MEZZ_LIB PreParseClassFromSingleTag(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a>&amp; NameSpace, <span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a>&amp; ClassName, <span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a>&amp; OneTag);
<a name="l03139"></a>03139 <span class="comment"></span>
<a name="l03140"></a>03140 <span class="comment">        /// @internal</span>
<a name="l03141"></a>03141 <span class="comment">        /// @brief Calls PreParseClassFromSingleTag passing a &quot;&quot; as the Namespace</span>
<a name="l03142"></a>03142 <span class="comment">        /// @param ClassName This will be used to identify the main xml element/tag you are attempting to deserialize. This will also be used in error messages.</span>
<a name="l03143"></a>03143 <span class="comment">        /// @param OneTag One XML tag/elements worth of text to deserialize.</span>
<a name="l03144"></a>03144 <span class="comment">        /// @return A pointer to xml::Document that you are now the owner of and must delete, that has the data parse and ready to access.</span>
<a name="l03145"></a>03145 <span class="comment">        /// @throw This can throw a Mezzanine::exception in the event that the xml cannot be parsed.</span>
<a name="l03146"></a>03146 <span class="comment"></span>        Document* MEZZ_LIB PreParseClassFromSingleTag(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a>&amp; ClassName, <span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a>&amp; OneTag);
<a name="l03147"></a>03147 <span class="comment"></span>
<a name="l03148"></a>03148 <span class="comment">        /// @brief Convert &lt; &gt; \&amp; and &quot; in text to \&amp;lt;, \&amp;gt;, \&amp;amp; and \&amp;quote so text can safely be stored in XML</span>
<a name="l03149"></a>03149 <span class="comment">        /// @details Usually this is not required. Entering text into an xml::Attribute or and xml::Node will correctly escape it.</span>
<a name="l03150"></a>03150 <span class="comment">        /// Use this when you will be creating raw xml want to safely escape these characters.</span>
<a name="l03151"></a>03151 <span class="comment">        /// @param XMLText The Text to convert to xml safe text</span>
<a name="l03152"></a>03152 <span class="comment">        /// @return a String containing the escaped version of XMLText</span>
<a name="l03153"></a>03153 <span class="comment"></span>        <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a> MEZZ_LIB EscapeXML(<span class="keyword">const</span> <a class="code" href="namespaceMezzanine.html#acf9fcc130e6ebf08e3d8491aebcf1c86" title="A Datatype used to a series of characters.">String</a>&amp; XMLText);
<a name="l03154"></a>03154 
<a name="l03155"></a>03155     }
<a name="l03156"></a>03156 }
<a name="l03157"></a>03157 <span class="preprocessor">#endif</span>
<a name="l03158"></a>03158 <span class="preprocessor"></span>
<a name="l03159"></a>03159 <span class="preprocessor">#endif // \MEZZXML</span>
<a name="l03160"></a>03160 <span class="preprocessor"></span>
<a name="l03161"></a>03161 <span class="comment">/*</span>
<a name="l03162"></a>03162 <span class="comment"> *</span>
<a name="l03163"></a>03163 <span class="comment"> * Software, Files, Libraries and all other items referenced in this clause refers only</span>
<a name="l03164"></a>03164 <span class="comment"> * to the contents of this file and associated documentation.</span>
<a name="l03165"></a>03165 <span class="comment"> *</span>
<a name="l03166"></a>03166 <span class="comment"> * Copyright © 2006-2010 Arseny Kapoulkine</span>
<a name="l03167"></a>03167 <span class="comment"> *</span>
<a name="l03168"></a>03168 <span class="comment"> * Permission is hereby granted, free of charge, to any person</span>
<a name="l03169"></a>03169 <span class="comment"> * obtaining a copy of this software and associated documentation</span>
<a name="l03170"></a>03170 <span class="comment"> * files (the &quot;Software&quot;), to deal in the Software without</span>
<a name="l03171"></a>03171 <span class="comment"> * restriction, including without limitation the rights to use,</span>
<a name="l03172"></a>03172 <span class="comment"> * copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<a name="l03173"></a>03173 <span class="comment"> * copies of the Software, and to permit persons to whom the</span>
<a name="l03174"></a>03174 <span class="comment"> * Software is furnished to do so, subject to the following</span>
<a name="l03175"></a>03175 <span class="comment"> * conditions:</span>
<a name="l03176"></a>03176 <span class="comment"> *</span>
<a name="l03177"></a>03177 <span class="comment"> * The above copyright notice and this permission notice shall be</span>
<a name="l03178"></a>03178 <span class="comment"> * included in all copies or substantial portions of the Software.</span>
<a name="l03179"></a>03179 <span class="comment"> *</span>
<a name="l03180"></a>03180 <span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<a name="l03181"></a>03181 <span class="comment"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES</span>
<a name="l03182"></a>03182 <span class="comment"> * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<a name="l03183"></a>03183 <span class="comment"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT</span>
<a name="l03184"></a>03184 <span class="comment"> * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,</span>
<a name="l03185"></a>03185 <span class="comment"> * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<a name="l03186"></a>03186 <span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR</span>
<a name="l03187"></a>03187 <span class="comment"> * OTHER DEALINGS IN THE SOFTWARE.</span>
<a name="l03188"></a>03188 <span class="comment"> */</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 28 2011 12:21:34 for MezzanineEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3</small></address>
</body>
</html>
