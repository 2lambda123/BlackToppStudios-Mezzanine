<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mezzanine::UI Manual</title>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script> 
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"/></a>MezzanineEngine&#160;<span id="projectnumber"></span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This will describe the use and purpose of the UI components of the <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a>. </p>
<h1><a class="anchor" id="UITOC"></a>
Table Of Contents</h1>
<ul>
<li><a class="el" href="UIManual.html#UIOverview">Overview</a><ul>
<li><a class="el" href="UIManual.html#UIIntroduction">Introduction</a></li>
<li><a class="el" href="UIManual.html#UIFeedback">Feedback</a></li>
<li><a class="el" href="UIManual.html#UIAcknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li><a class="el" href="UIManual.html#UICore">The Core Classes</a><ul>
<li><a class="el" href="UIManual.html#UIClassUIManager">UIManager</a></li>
<li><a class="el" href="UIManual.html#UIClassScreen">Screen</a></li>
<li><a class="el" href="UIManual.html#UIClassQuadRenderable">QuadRenderable</a></li>
<li><a class="el" href="UIManual.html#UIClassWidget">Widget</a></li>
</ul>
</li>
<li><a class="el" href="UIManual.html#UIRender">The Render Classes</a><ul>
<li><a class="el" href="UIManual.html#UILayers">Render Layers</a><ul>
<li><a class="el" href="UIManual.html#UIImageLayer">SingleImageLayer and MultiImageLayer</a></li>
<li><a class="el" href="UIManual.html#UITextLayer">SingleLineTextLayer and MultiLineTextLayer</a></li>
</ul>
</li>
<li><a class="el" href="UIManual.html#UILayerGroups">Render Layer Groups</a></li>
<li><a class="el" href="UIManual.html#UICaching">Local Vertex Caching</a></li>
</ul>
</li>
<li><a class="el" href="UIManual.html#UIInputLife">The Lifetime of an Input</a></li>
<li><a class="el" href="UIManual.html#UIConfig">Configuring and Expanding</a><ul>
<li><a class="el" href="UIManual.html#UISizePos">Sizing and Positioning</a></li>
<li><a class="el" href="UIManual.html#UILayout">Layout Strategies</a></li>
<li><a class="el" href="UIManual.html#UIFactories">Widget Factories</a></li>
<li><a class="el" href="UIManual.html#UIMarkup">Markup Parsers</a></li>
</ul>
</li>
<li><a class="el" href="UIManual.html#UIContainer">Container Widgets</a><ul>
<li><a class="el" href="UIManual.html#UIPaged">Paged Containers and Providers</a></li>
<li><a class="el" href="UIManual.html#UIStacked">Stacked Containers and Buttons</a></li>
</ul>
</li>
</ul>
<p><br/>
</p>
<h1><a class="anchor" id="UIOverview"></a>
Overview</h1>
<ul>
<li><a class="el" href="UIManual.html#UIIntroduction">Introduction</a></li>
<li><a class="el" href="UIManual.html#UIFeedback">Feedback</a></li>
<li><a class="el" href="UIManual.html#UIAcknowledgments">Acknowledgments</a></li>
</ul>
<h2><a class="anchor" id="UIIntroduction"></a>
Introduction</h2>
<p>The <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> User Interface (UI) subsystem is designed to be a powerful and feature rich Graphical User Interface system that can be used to power all the UI needs of a given game. <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> attempts to assemble render operations in as few batches as possible for maximum performance. <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> also provides a default set of Widgets to use when assembling an in-game UI that should meet most basic needs, and can be extended if the needs of a game are not met. <br/>
 <br/>
</p>
<h2><a class="anchor" id="UIFeedback"></a>
Feedback</h2>
<p>If you believe you've found a bug in <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> (bugs include compilation problems (errors/warnings), crashes, performance degradation or incorrect behavior), please contact Blacktopp Studios Inc ( <a href="http://www.blacktoppstudios.com/">http://www.blacktoppstudios.com/</a> ) . We check the the Forums ( <a href="http://www.blacktoppstudios.com/?page_id=753">http://www.blacktoppstudios.com/?page_id=753</a> ) and items sent by our contact form ( <a href="http://www.blacktoppstudios.com/?page_id=33">http://www.blacktoppstudios.com/?page_id=33</a> ) regularly. Be sure to include the relevant information so that the bug can be reproduced: the version of <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a>, compiler version and target architecture, the code that uses <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> and exhibits the bug, etc. <br/>
 <br/>
Feature requests can be reported the same way as bugs, so if you're missing some functionality in <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> or if the API is rough in some places and you can suggest an improvement, please let us know. However, please note that there are many factors when considering API changes (compatibility with previous versions, API redundancy, etc.). <br/>
 <br/>
If you have a contribution to <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a>, such as build script for some build system/IDE, a well-designed set of helper functions, or a binding to some language other than C++, please let us know. You can include the relevant patches as issue attachments. We will have to communicate on the Licensing terms of your contribution though. <br/>
 <br/>
</p>
<h2><a class="anchor" id="UIAcknowledgments"></a>
Acknowledgments</h2>
<p>By no means does the author of <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> consider themselves an expert on UI systems nor claims all of the concepts used in <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> are completely original. In fact the first iteration of <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> was a paper thin wrapper around Gorilla ( <a href="http://www.ogre3d.org/tikiwiki/Gorilla">http://www.ogre3d.org/tikiwiki/Gorilla</a> ); a simple UI rendering library written for Ogre3D. This wrapper was expanded with an early attempt to add typical behaviors such as detecting key presses and mouse hovers was made and something resembling a working system came out of it. But that early system was still severely limited and did not have much in the way of forward thinking applied to it. It was as much an academic exercise as it was a hack. Maintaining it was impractical. <br/>
 <br/>
So actual planning was put forth to create a sane system the core of which could stand the test of time without the need for additional extensive refactors. To do this an extensive amount of research was done to better understand how others resolved the issues I had encountered, as well as the issues they encountered from thier early choices, and issues they completely dodged. As a result, there are concepts from a large number of other sources/libraries. Core input handling was inspired by Torque3D. Event handling was inspired by CEGUI. RenderLayer was inspired by Unity3D 4. LayoutStrategy was inspired by Qt. TextLayer, TextLine, and TextCursor was inspired by QuickGui. The RenderData dirty/caching system was inspired by Gorilla. <br/>
 <br/>
Thank you to everyone responsible for the creation and ongoing existence of these libraries and sharing their thought process for the benefit of others. Without them <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> could not exist in it's current form, instead being left as a poorly thought out hack.</p>
<p><br/>
</p>
<h1><a class="anchor" id="UICore"></a>
The Core Classes</h1>
<ul>
<li><a class="el" href="UIManual.html#UIClassUIManager">UIManager</a></li>
<li><a class="el" href="UIManual.html#UIClassScreen">Screen</a></li>
<li><a class="el" href="UIManual.html#UIClassQuadRenderable">QuadRenderable</a></li>
<li><a class="el" href="UIManual.html#UIClassWidget">Widget</a></li>
</ul>
<h2><a class="anchor" id="UIClassUIManager"></a>
UIManager</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html">Mezzanine::UI::UIManager</a> is the core class at the top of the hierarchy for the UI subsystem. The UIManagers primary responsibilities are the storage of UI Screens, initial input handling, and Button activation code auto registration. The UIManager does not require any special parameters to initialize in code or XML. It does however expect the GraphicsManager to have been initialized prior to a UI Screen being constructed. Further details on the initialization and use of Screens can be found in the subsection below: UIClassSCreen . <br/>
 <br/>
The UIManager only stores a single WorkUnit for the updating of every visible Screen and the Widgets it contains. This UI WorkUnit depends upon the Input System/WorkUnit and then when it runs automatically injects all of the new inputs detected since the last frame update into itself. Inputs may also be injected manually (see <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#aacb361620fdc4810031ac35c0f5b1792">Mezzanine::UI::UIManager::InjectInput(const Input::MetaCode&amp;)</a> ) at any time the WidgetUpdateWorkUnit isn't executing to simulate any input a MetaCode can represent. More information on the lifetime of an Input in the UI system can be found here: <a class="el" href="UIManual.html#UIInputLife">The Lifetime of an Input</a> . <br/>
 <br/>
The UI::Button class has a concept of Activation and Deactivation, however there is no default input for this. On the UI::Button you can set whatever code for Activation and Deactivation you need for your game or application. Although, usually for the sake of user experience you will want to set the same activation code or codes for each UI::Button in your configuration. There are a set of methods on the UIManager to facilitate this. The methods controlling the Auto Register behavior are as follows: <br/>
</p>
<ul>
<li><a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#a3e426db3d7a77c80c2bdddaec48b8305">Mezzanine::UI::UIManager::EnableButtonAutoRegister(Boole)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#a7873b03f14b7a46cc72de92282a3819c">Mezzanine::UI::UIManager::ButtonAutoRegisterEnabled() const </a><br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#aa8c610e73954524b71c6726d6e094b3e">Mezzanine::UI::UIManager::AddAutoRegisterCode(const Input::MetaCode&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#a6616e375862e47786d6f89d040176682">Mezzanine::UI::UIManager::RemoveAutoRegisterCode(const Input::MetaCode&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#a014b9aec6f646919866bd5bd9e3943aa">Mezzanine::UI::UIManager::RemoveAllAutoRegisterCodes()</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#a32330435bdf9ab64ed9a28c3a8d73610">Mezzanine::UI::UIManager::GetAutoRegisteredCodes() const </a><br/>
 <br/>
It is important to note that these methods are not retroactive in any way. Adding or removing an Auto-Register code will not update all of the created buttons. Any change to the configuration you need to do will need to be done manually. Ideally you should set the Button Auto-Register codes shortly after the construction of the UIManager and before construction of any UI Screens to ensure they all get the same codes. <br/>
 <br/>
Throughout the entire UI system there can only be a single widget that is being focused and is given input priority. That widget is evaluated, stored, and can be accessed through the UIManager using the <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#a5fafcbd96be2cf5e8f97d8ba9631879a" title="Gets the current widget being controlled. ">Mezzanine::UI::UIManager::GetWidgetFocus() const </a>method. The focus widget and the hovered widget may not be the same widget, and you may want to access them separately. To retrieve the hovered widget use the <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#aa91adb7c42a330d5d485cf20561245e1" title="Gets the Widget the mouse is hovering over. ">Mezzanine::UI::UIManager::GetHoveredWidget() const </a>method. Both the focus and hovered widget (be them separate widgets or not) are in part evaluated from hover checks. Hover checks are primarily performed by UI Screens, however a system-wide hover check can be called on using the <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#aa2f224e648ef7be571a72f0ec3a077c9" title="Searches all visable screens and layers to see if a Widget is under the given point. ">Mezzanine::UI::UIManager::CheckWidgetUnderPoint(Graphics::Viewport*, const Vector2&amp;)</a> method. Note that this method is already called on once per update with the appropriate parameters IF the mouse is determined to have moved since the last update. As such you shouldn't need to call on this method manually, but can if the need arises. Calling <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#aa2f224e648ef7be571a72f0ec3a077c9" title="Searches all visable screens and layers to see if a Widget is under the given point. ">Mezzanine::UI::UIManager::CheckWidgetUnderPoint(Graphics::Viewport*, const Vector2&amp;)</a> will not update the stored focus or hovered widgets. Screens on the specified viewport will be checked based on ZOrder, with the highest order Screens checked first.</li>
</ul>
<p><br/>
</p>
<h2><a class="anchor" id="UIClassScreen"></a>
Screen</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1Screen.html" title="This class is a helper class for creating UI&#39;s. It is responsible for storing and keeping track of al...">Mezzanine::UI::Screen</a> class is the top of the Widget hierarchy and the primary class responsible for the rendering of Widgets. The UI Screen is created from the UIManager, and requires an .mta (<a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> Texture Atlas) file to have already been loaded. MTA files can be loaded from the UIManager using the <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#adcafbb8efb553f3960b7239498f4f617" title="Loads a Mezzanine Texture Atlas file for use with Screens. ">Mezzanine::UI::UIManager::LoadMTA(const String&amp;,const String&amp;)</a> method. Additionally a viewport needs to be specified and will be where all of the Widgets belonging to that screen will be rendered to. Lastly, a unique name must be specified to create a UI Screen. If a name already in use is specified, an exception will be thrown. If the specified texture atlas isn't available, an exception will be thrown. If an invalid viewport is provided, a segmentation fault will (likely) occur. <br/>
 <br/>
You can place multiple screens on the same viewport, but you cannot specify multiple viewports for the same screen. Screens can be given a ZOrder to resolve render behavior of overlapping Screens. The highest ZOrder will appear at the top, unobstructed, with the lower screens appearing beneath it as transparency permits. This feature could be used to enable things like stat displays where you want them to always be visible across multiple HUDs but would otherwise require duplicate widgets on each Screen/HUD. <br/>
 <br/>
The primary responsibilities of the UI Screen class are the creation and storage of Widgets and their factories, performing hover checks, and collecting of render data from child Widgets to be passed to the graphics subsystem. Additional in depth information about Widgets and their factories can be found in the following sections: <a class="el" href="UIManual.html#UIClassWidget">Widget</a> and/or <a class="el" href="UIManual.html#UIFactories">Widget Factories</a> . <br/>
 <br/>
Hover checks performed by the UI Screen class is somewhat modular and multiple strategies can be deployed using the <a class="el" href="classMezzanine_1_1UI_1_1MouseHoverStrategy.html" title="This is the base class for a method of finding which quad the mouse is hovered over. ">Mezzanine::UI::MouseHoverStrategy</a> class. There is a single pure virtual method ( <a class="el" href="classMezzanine_1_1UI_1_1MouseHoverStrategy.html#a02f3cb6176a163a8a9c3022549ddc86f" title="Finds the hovered quad for the parent screen. ">Mezzanine::UI::MouseHoverStrategy::FindHoveredWidget(const Vector2&amp;)</a> ) that must be defined in a derived class for it to operate. MouseHoverStrategies can be set and retrieved on a given Screen using the <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#ace913ff7bf02f19567ca9d2b8944a5de" title="Sets the strategy to use when detect which object the mouse is hovered over. ">Mezzanine::UI::Screen::SetMouseHoverStrategy(MouseHoverStrategy*)</a> and <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a235fe772a7fcbc67ac3ceee72042ab71" title="Gets the MouseHoverStrategy currently being used by this screen. ">Mezzanine::UI::Screen::GetMouseHoverStrategy() const</a> , respectively. Manual hover checks for a single Screen can be done using the <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a5d7cc04aae7a70967d35ab2b6682000e" title="Gets the quad the mouse is over if any. ">Mezzanine::UI::Screen::FindHoveredWidget(const Vector2&amp;)</a> method, which accepts an arbitrary point, and calls the FindHoveredWidget method on the currently set MouseHoverStrategy. This is the same method that is called on when a system-wide Hover check is performed from the UIManager so it will be called automatically when the mouse has been moved. Manual calling should only be used for usual setups where a check is desired even if the mouse hasn't moved or if multiple checks in a single frame are required. Only a single MouseHoverStrategy can be applied to a screen at a time. <br/>
 <br/>
There are 2 MouseHoverStrategy classes that have already been made and are available for use in <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a>: <a class="el" href="classMezzanine_1_1UI_1_1BruteStrategy.html">Mezzanine::UI::BruteStrategy</a> and <a class="el" href="classMezzanine_1_1UI_1_1NineBoxStrategy.html">Mezzanine::UI::NineBoxStrategy</a> . The BruteStrategy class is extremely simple and simply performs a check on all child Widgets of the Screen from the highest ZOrder to the lowest ZOrder, stopping only when it finds a valid result or exhausts all the children to be searched. The NineBoxStrategy is a little more sophisticated and attempts to divide the screen up into 9 partitions in the form of a 3x3 grid. On either the first run or whenever the Screen is updated it will remove it's old cache and iterate over all Widgets in the screen, putting each Widget in the appropriate partitions. Each paritition is checked against the Widget, so if a Widget overlaps with multiple partitions it will be added to each. Then when a hover check is performed it will determine the partition the mouse is located it, and only check the Widgets within that partition. Due to the costs involved in updating the cache for the NineBoxStrategy, it is only recommended to use it when you have a large and mostly static UI with infrequent updates. By default, all Screens create and use the BruteStrategy class for hover checks. <br/>
 <br/>
"Render Data" collected by a UI Screen pertains to any data that is necessary for the Screen to be rendered. As of the time of this writing, it is a std::vector of procedurally generated vertices. However this is subject to change. See issues #96 and #97 on the <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> issue tracker ( <a href="https://github.com/BlackToppStudios/Mezzanine/issues">https://github.com/BlackToppStudios/Mezzanine/issues</a> ) for more information on these potential changes. To collect these vertices the <a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#ae9f09352c600e2971efe247dc18be1a9">Mezzanine::UI::QuadRenderable::_AppendRenderDataCascading(ScreenRenderData&amp;)</a> method is used. This method iterates over every Widget in the hierarchy starting with the lowest ZOrder child of the screen. For each Widget checked, it will first append any vertices that belong to that Widget, and then pass along the render data container to that Widgets children, once again starting with the lowest ZOrder. This causes every Widget to get checked and any valid RenderData to be appended with the higher ZOrder Widgets overlapping the lower ZOrder Widgets. More information on logic specific to QuadRenderables appending render data can be found in the section below: <a class="el" href="UIManual.html#UIClassQuadRenderable">QuadRenderable</a> . <br/>
 <br/>
Once all of the RenderData has been collected from every Widget in the hierarchy the first thing that is done is the converting of Screen coordinates on each verticy to coordinates that can be read by and used by the video card. Video devices use a coordinate system the top left corner is (-1,-1), the center is (0,0), and the bottom right is (1,1). After the vertices are transformed they are assembled into a render operation that will get passed into the internal graphics subsystem. Collecting render data is not done during any widget updates. Instead it is a part of a callback that gets called during the graphics rendering work unit (which is a monopoly work unit). <br/>
 <br/>
The UI Screen class also comes with a small set of templated utility methods that can be used to perform tasks on all Widgets in the Widget hierarchy. The methods are as follows: <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#ae0f8976f7fc329b52f8d1e9b02f266c8">Mezzanine::UI::Screen::_ProcessAllChildren(Callback*)</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a1f9078b58d0bf3cfdc81b1d280f664f9">Mezzanine::UI::Screen::_ReverseProcessAllChildren(Callback*)</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a7b78a076ef65211a5ff7ea8729e92858">Mezzanine::UI::Screen::_ProcessAllChildren(Widget*,Callback*)</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#af93238ed436c9c213f9f0dc06ef523fe">Mezzanine::UI::Screen::_ReverseProcessAllChildren(Widget*,Callback*)</a> <br/>
<br/>
The "normal" (as in not labeled with "Reverse") processing methods will check child Widgets based on their ZOrder, from lowest to highest. The "Reverse" processing methods will also check child Widgets based on their ZOrder, but from highest to lowest. The overloads where you specify a Widget will only check the specified Widget and it's children. The two overloads that don't allow you to specify a Widget will assume you want to process the entire hierarchy. In all methods the Callback can be either a C-Function or a functor that accepts a pointer to the QuadRenderable to be processed.</p>
<p><br/>
 <br/>
</p>
<h2><a class="anchor" id="UIClassQuadRenderable"></a>
QuadRenderable</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html">Mezzanine::UI::QuadRenderable</a> class is the base class for Screens and Widgets, and as such both of those classes contain all of the functionality mentioned in this section. The QuadRenderable has pure virtual methods, and thus cannot be initialized as is. The primary responsibilities of the QuadRenderable class are the management of rendering related classes and data, storage of transform classes, and management of child Widgets. The QuadRenderable and Widget classes were separated in an effort to separate the rendering and input response functionality in Widgets from each other. The QuadRenderable focuses on rendering. <br/>
 <br/>
The rendering related classes used by the QuadRenderable are the <a class="el" href="classMezzanine_1_1UI_1_1RenderLayer.html">Mezzanine::UI::RenderLayer</a> and it's derived classes as well as the <a class="el" href="classMezzanine_1_1UI_1_1RenderLayerGroup.html">Mezzanine::UI::RenderLayerGroup</a> . RenderLayer classes that are responsible for rendering a type of quad, which could be a sprite/image or text. Multiple renderlayers can be stacked together to achieve different effects, for example: an image layer can be placed at the lowest ZOrder, a border image with a transparent center can be placed at the center ZOrder, and a text layer can be placed at the highest ZOrder to give the appearance of styled and bordered button that is labeled "Start". In order to stack these RenderLayers the way described (and for them to get rendered at all), they must be added to a RenderLayerGroup. RenderLayers belonging to a QuadRenderable can be added to an abitrary number of RenderLayerGroups also belonging to that QuadRenderable, and their ZOrder can be set per RenderLayerGroup. Not all RenderLayer groups can be rendered at the same time. In fact only one can render at a given time, that one being the Active Group. The Active Group can be set manually, or can be configured to be set automatically based on a Widget state (if you are working with a Widget, not a Screen). More on Widget States is covered in the <a class="el" href="UIManual.html#UIClassWidget">Widget</a> section. More details covering the initialization and configuration of RenderLayers is covered in their respective subsections here: <a class="el" href="UIManual.html#UIRender">The Render Classes</a> . <br/>
 <br/>
The position and size of a QuadRenderable/Widget is expressed as a UnifiedDim(Unified Dimension) for each relevant axis. A UnifiedDim is simple a class that stores both Absolute (pixel) and Relative (to the parent) components that could express it's size. When a position or size is evaluated, the Relative component is calculated first (again, based on it's parent) and then has the Absolute component added to it. Relative values are generally between 0 and 1, but nothing locks them into that range. The values can be positive or negative. The Screens position and size are more or less locked, with the position always being (0,0) and it's size matching the pixel size of the Graphics::Viewport that it is attached to. In some cases individual axes on the position or size of a QuadRenderable/Widget can be generated based on other values, rather than specifying their Unified Dimensions. The exact array of possible configurations is large, and is covered in greater detail here: <a class="el" href="UIManual.html#UIConfig">Configuring and Expanding</a> . <br/>
 <br/>
All QuadRenderables have the ability to have Widgets added to them as children. Child Widgets are stored and sorted based on their ZOrder from lowest to highest. Widgets that aren't in a hierarchy with a UI Screen at the top will not be rendered or have their dimensions properly evaluated if they define more than just absolute components of their dimensions. Child Widgets can be added or removed at any time to update the hierarchy. When a QuadRenderable is destroyed, all of it's Widget children are automatically destroyed along with it. So if you wish to preserve a child Widget of a QuadRenderable being destroyed you can remove it from the QuadRenderable, then destroy it, and add it to another QuadRenderable. The exception to this is if you attempt to move a Widget from one Screen to another Screen, as Widgets cannot change Screen ownership. There are no checks in place to prevent adding a Widget as a child to a Screen it doesn't belong to, so it may appear to work, but when it updates it will send those updates to the wrong screen and could generate rendering artifacts. Additionally on destruction this could lead to segmentation faults. Don't do this. <br/>
 <br/>
There are a few additional utilities that the QuadRenderable provides. A QuadRenderable can be made exempt from mouse hover checks using the <a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a467b207ee1db1e360eec4ce2382a9cd2">Mezzanine::UI::QuadRenderable::SetMousePassthrough(Boole)</a> method. This does not prevent it's children from being checked however. Additionally when a QuadRenderable has it's dimensions updated by it's parent, you can make a QuadRenderable become exempt from the auto update using the <a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a107d4b5cd1b7bdf00d6dd0c85389cc05">Mezzanine::UI::QuadRenderable::SetManualTransformUpdates(Boole)</a> method. Typically you will only want to do this if you are creating a Widget where positions are determined by some other Widget specific metadata. For example the Scrollbar classes manually update the Scroller absolute position based on the current Scroll value after the other child Buttons have been updated.</p>
<p><br/>
 <br/>
</p>
<h2><a class="anchor" id="UIClassWidget"></a>
Widget</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1Widget.html">Mezzanine::UI::Widget</a> class is the base class for the entire UI Widget set and contains the core functionality for input response. Widgets can be created using their respective method on the UI Screen if it is among the default Widget set. If it is not among the default Widget set then a factory for that Widget will need to be registered. Once it is a Widget of that type can be constructed under the Screen the factory is registered to using one of three polymorphic construction methods. Those methods are as follows: <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a6e924c2413938e77b31fac1115df09d8">Mezzanine::UI::Screen::CreateWidget(const XML::Node&amp;)</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a7ec259e5da49af23b63539f1fb119a4c">Mezzanine::UI::Screen::CreateWidget(const String&amp;, const String&amp;, const NameValuePairMap&amp;)</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#ad6c62263a08824e8213c753f76bc0881">Mezzanine::UI::Screen::CreateWidget(const String&amp;, const String&amp;, const UnifiedRect&amp;, const NameValuePairMap&amp;)</a> <br/>
<br/>
The first method listed is an XML constructor used primarily for serialization/deserialization. It will read the name of the XML tag passed in to look up the appropriate factory, and will then pass it into a deserializing constructor. The other two methods force you to specify the typename of the Widget to be constructed. The name and additional parameters are also necessary. Widget names must be unique among the Widgets on the screen, otherwise an exception will be thrown. This is universal among all Widgets constructed from the Screen. The additional parameters container must be provided, but can be empty. Some Widgets require additional parameters, and some do not. All Widgets should provide sane defaults in the absence of additional parameters being defined. Optionally a UnifiedRect can also be specified and set to the Widget being constructed. The base Widget class does not have any undefined virtual methods, and can be initialized as is if you only need the basic Widget functionality to achieve a certain effect. The methods to do this are as follows: <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a9606e92736bf7fb88b6fec814a520dd6">Mezzanine::UI::Screen::CreateWidget(const String&amp;)</a> <br/>
 Mezzanine::UI::Screen::CreateWidget(const String&amp;,const String&amp;) <br/>
<br/>
Widgets do have a "WidgetState" that is used to help determine their behavior and interactions between them and the UI system. The <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#ab00340aa24912818ba78ebde061ae897">Mezzanine::UI::Widget::WidgetState</a> enum is a bitfield that defines a set of core states (Untouched, Hovered, Focused, and Dragged), a range of reserved states to be used by derived classes, and a range of values safe for end users to use for any additional configuration that may be needed. The "Untouched" state means nothing is applied to it. No real state of any kind. The "Hovered" state means the mouse is currently hovered over the Widget. The "Focused" state means the Widget is the current focus for the UI system and is being given input priority. The "Dragged" state means that the mouse is being dragged over the Widget, NOT that the Widget itself is being dragged. It is up to a given Widget to decide what a mouse drag means, be it highlighting text, or dragging and dropping child Widgets. The core states are set by the UI manager, and the reserved states are typically set by the derived class(but never the UI Manager). More information on how the UI manager sets the core states can be found here: <a class="el" href="UIManual.html#UIInputLife">The Lifetime of an Input</a> . <br/>
 <br/>
Widget states can have RenderLayerGroups bound to them using the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a2598074c91f3b0ce3a80ce800f34b94f">Mezzanine::UI::Widget::BindGroupToState(const UInt32, RenderLayerGroup*)</a> method. An explicit combination of WidgetState enum values must be used, such as ( WS_Hovered | WS_Focused ), to bind a Widget state to a RenderLayerGroup. Once a state is set the Widget will check if a RenderLayerGroup is bound to that state and make it the Active Group if one is found. To facilitate this, two RenderLayerGroups are automatically created based on some of the core WidgetState values. Here is the relevant initialization code: </p>
<div class="fragment"><div class="line">RenderLayerGroup* NormalGroup = this-&gt;CreateRenderLayerGroup(<span class="stringliteral">&quot;Normal&quot;</span>);</div>
<div class="line">RenderLayerGroup* HoveredGroup = this-&gt;CreateRenderLayerGroup(<span class="stringliteral">&quot;Hovered&quot;</span>);</div>
<div class="line"></div>
<div class="line">this-&gt;BindGroupToState( WS_Untouched, NormalGroup);</div>
<div class="line">this-&gt;BindGroupToState( WS_Hovered, HoveredGroup);</div>
<div class="line">this-&gt;BindGroupToState( WS_Focused, NormalGroup);</div>
<div class="line">this-&gt;BindGroupToState( WS_Dragged, NormalGroup);</div>
<div class="line">this-&gt;BindGroupToState( WS_Hovered | WS_Focused, HoveredGroup);</div>
<div class="line">this-&gt;BindGroupToState( WS_Hovered | WS_Dragged, HoveredGroup);</div>
<div class="line">this-&gt;BindGroupToState( WS_Focused | WS_Dragged, NormalGroup);</div>
<div class="line">this-&gt;BindGroupToState( WS_Hovered | WS_Focused | WS_Dragged, HoveredGroup);</div>
</div><!-- fragment --><p> In general, if the state includes "WS_Hovered", it applies the "Hovered" RenderLayerGroup. Otherwise it applies the "Normal" RenderLayerGroup. These two RenderLayerGroups are created for ALL Widgets, unless explicitly overridden in a derived class (none of the default widgets override this). However no Widget is locked into needing these RenderLayerGroups or these bindings. This configuration can be altered after construction however is needed. It is important to note that while no specific binding or RenderLayerGroup needs to exist, there does need to be an Active Group for a Widget to pass along it's render data to the Screen when it is collected. So if there is no RenderLayerGroup for a particular state(s), when it enters that state it will set NULL to the Active Group and the Widget will become invisible. In some cases this may be desirable, but probably not. <br/>
 <br/>
When a new state is set on a Widget, parent Widgets in the hierarchy are notified using the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a8d4632a1e9dd45da416a1511f551ba3d">Mezzanine::UI::Widget::_NotifyChildStateChange(Widget*, const UInt32&amp;, const UInt32&amp;)</a> method, which internally calls the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a08d9b567352a9ab0f45dc50c5344d711">Mezzanine::UI::Widget::HandleChildStateChangeImpl(Widget*, const UInt32&amp;, const UInt32&amp;)</a> method. The provided implementation for "HandleChildStateChangeImpl" on the Widget class is empty and intended to be overridden if a derived class intends to make use of the information passed into it. In addition to calling "HandleChildStateChangeImpl", the "_NotifyChildStateChange" has logic for checking and invoking the same method if appropriate on the parent Widget. So that logic doesn't need to be included when overriding "HandleChildStateChangeImpl". Currently this functionality is used by the PagedContainer and it's derived classes to fire events when their children have gained focus which is useful when reacting to a Widget in a container has been "selected". <br/>
 <br/>
The UI Widget class inherits from <a class="el" href="classMezzanine_1_1EventPublisher.html">Mezzanine::EventPublisher</a> , which gives it the ability to fire events based on changes made to it. Most of the events present on the Widget that get fired are based on changes being made to the Widgets state. The two exceptions to this are the events that fire based on it's visibility. Checks are made carefully to ensure the events are only fired when a change is actually made. If you find an event is being fired when a change isn't made, it's a bug and please report it on our issue tracker. To subscribe to a given event you need a publisher, a subscriber, and an event name. All default Widget classes will have Strings that are static members of the class containing the name of the event. The names of these members are prefixed with "Event". Simply call <a class="el" href="classMezzanine_1_1EventPublisher.html#a27d4fc1b76bbf49a8f966d8d90a8aa70">Mezzanine::EventPublisher::Subscribe</a> passing in one of those event names and a subscriber and it will become notified when that event occurs. The Strings containing the names of the events fired by the Widget class are as follows: <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a34562fef4e0c46bb7cb157a3f0cdfdf5">Mezzanine::UI::Widget::EventMouseEnter</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a3edf54f69c5171359bebdcedb1e751f7">Mezzanine::UI::Widget::EventMouseExit</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a319dcbe1b0bce0c8ed11463456226409">Mezzanine::UI::Widget::EventMouseDragStart</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a6e79d01165bc57417f11e07fd1379ca7">Mezzanine::UI::Widget::EventMouseDragEnd</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a3c7843de3004c4758d9698d25de12cc2">Mezzanine::UI::Widget::EventFocusGained</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a3e4c309c44e027bf271dbc7c010814f0">Mezzanine::UI::Widget::EventFocusLost</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a9818d9613bcdd3b65c39af17539884fa">Mezzanine::UI::Widget::EventFocusLocked</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#ae8944098cbb987f74ca5121d7918703f">Mezzanine::UI::Widget::EventFocusUnlocked</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#adb711c8968a93e455f7db9120e712b94">Mezzanine::UI::Widget::EventVisibilityShown</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#aa5c260343a9b6035abf5a1b4cbbf486f">Mezzanine::UI::Widget::EventVisibilityHidden</a> <br/>
 <br/>
In addition to being a <a class="el" href="classMezzanine_1_1EventPublisher.html">Mezzanine::EventPublisher</a> , the Widget class is also a <a class="el" href="classMezzanine_1_1EventSubscriber.html">Mezzanine::EventSubscriber</a> . The default implementation of the "_HandleInput(const Input::MetaCode&amp;)" method is empty, and must be overridden by a derived class if a Widget needs to subscribe to events belonging to another Widget. <br/>
 <br/>
Aside from managing its own Widget state, the Widget class is designed to receive and respond to inputs. The method it does this with is the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a78d0eba1976512a72e971fde9cddae85">Mezzanine::UI::Widget::_HandleInput(const Input::MetaCode&amp;)</a> method. Inside this method it calls <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a4fc489f70065926d9a58b0a330e65076">Mezzanine::UI::Widget::HandleInputImpl(const Input::MetaCode&amp;)</a> , which is intended to be overridden by derived classes and have class specific logic that will check if it is the type of input the Widget responds to, process the input if it is, and then return true or false based on whether or not the input was "used". The default implementation on the Widget base class always returns false. If the input was not used (if the method returns false) then the input will be passed upwards in the Widget hierarchy until it is consumed or reaches the Screen. The UI manager may do additional processing if no Widget "uses" the input. More detailed information on how inputs are handled by the Widget class can be found here: <a class="el" href="UIManual.html#UIInputLife">The Lifetime of an Input</a> . <br/>
 <br/>
In addition to the core functionality, the Widget also comes with a few utility methods relating to hovered child Widgets and setting the state. There are a couple of convenient methods that will check whether a child of a Widget is hovered. The <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a99615938f31dd6b5c6d8fa9d9dc96d3d">method</a> will return either a pointer to an immediate child that the mouse is hovered over, or NULL if the mouse is not hovered over any immediate children. For a deeper check, you can use the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#ab01ea99fe7504de6107dc558dbe30ab6">Mezzanine::UI::Widget::GetBottomMostHoveredWidget()</a> method which will search all children, and children of children, etc.. The return is the same, NULL if none are hovered, or a pointer to the hovered child. <br/>
The Widget state can also be forced using the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a742eeb8e4e9d48c5ebd45133fe15b3dd">Mezzanine::UI::Widget::ForceState(const UInt32)</a> method. This method will assign the the provided bitfield to the widget, set the ActiveGroup assigned to that state, pass the notification of the state change upwards in the Widget hierarchy. However, it will not fire any events associated with that state(s). Wherever possible altering bits that belong to the core states should be avoided. The intended use case for this method is to change/update the presence of a user defined state.</p>
<p><br/>
 <br/>
</p>
<h1><a class="anchor" id="UIRender"></a>
The Render Classes</h1>
<ul>
<li><a class="el" href="UIManual.html#UILayers">Render Layers</a><ul>
<li>UISingleImage SingleImageLayer</li>
<li>UIMultiImage MultiImageLayer</li>
<li>UISingleLineText SingleLineTextLayer</li>
<li>UIMultiLineText MultiLineTextLayer</li>
</ul>
</li>
<li><a class="el" href="UIManual.html#UILayerGroups">Render Layer Groups</a></li>
<li><a class="el" href="UIManual.html#UICaching">Local Vertex Caching</a></li>
</ul>
<h2><a class="anchor" id="UILayers"></a>
Render Layers</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1RenderLayer.html">Mezzanine::UI::RenderLayer</a> is the base class for classes that proceadurally generate vertices for quads to be rendered. RenderLayers lack an explicit size and position of their own, instead using the dimensions of the parent QuadRenderable to determine their bounds. The bounds of a RenderLayer can be further manipulated by applying Scaling or Rotation. The methods to do this are: <a class="el" href="classMezzanine_1_1UI_1_1RenderLayer.html#a64b2b8f54ca52ae239c4efc7891e4edf">Mezzanine::UI::RenderLayer::SetRotationDegrees(const Real&amp;)</a> or <a class="el" href="classMezzanine_1_1UI_1_1RenderLayer.html#a1eabfea673bcd75d283cf692edd2c567">Mezzanine::UI::RenderLayer::SetRotationRadians(const Real&amp;)</a> and <a class="el" href="classMezzanine_1_1UI_1_1RenderLayer.html#aeff156a6a52f7c61bd1d1bf104a98717">Mezzanine::UI::RenderLayer::SetScale(const Vector2&amp;)</a> . Depending on the RenderLayer, multiple quads or a single quad can be generated. The available set of RenderLayers are: <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1MultiImageLayer.html">Mezzanine::UI::MultiImageLayer</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1MultiLineTextLayer.html">Mezzanine::UI::MultiLineTextLayer</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1SingleImageLayer.html">Mezzanine::UI::SingleImageLayer</a> <br/>
 <a class="el" href="classMezzanine_1_1UI_1_1SingleLineTextLayer.html">Mezzanine::UI::SingleLineTextLayer</a> <br/>
<br/>
</p>
<h3><a class="anchor" id="UIImageLayer"></a>
SingleImageLayer and MultiImageLayer</h3>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1SingleImageLayer.html">Mezzanine::UI::SingleImageLayer</a> class is designed to present simple colours and/or a single sprite to be stretched across the bounds of the layer. A sprite can be set via pointer or name, from the primary atlas of the parent Screen or any other atlas. However care should be taken when adding an image from an atlas that isn't the parent Screens primary atlas. Doing so will cause the batch count to increase when rendering the UI, which will adversely affect the performance of rendering the UI. Using the <a class="el" href="namespaceMezzanine_1_1UI.html#a61a42a62e4838bc93b194886a363fe36">Mezzanine::UI::QuadCorner</a> enum you can also set colours for each corner of the layers bounds. A convenience method for setting a gradient between two colours is also available, which will set the colour as appropriate for each corner of the layer. <br/>
 <br/>
The <a class="el" href="classMezzanine_1_1UI_1_1MultiImageLayer.html">Mezzanine::UI::MultiImageLayer</a> class has a number of similar concepts to the <a class="el" href="classMezzanine_1_1UI_1_1SingleImageLayer.html">Mezzanine::UI::SingleImageLayer</a> class. It can take a sprite from an atlas to be rendered. Colours can be set for corners and even a gradient can be set. However it is a little more complicated to allow for multiple images to be rendered in the same layer space. This class exists for the cases where otherwise setting multiple images in the same area would require multiple QuadRenderables, and may change in a way that would make each possible look prohibitive to put into the atlas. A lot of the methods to set the sprite or colour have similar counterparts on the MultiImageLayer, with one additional parameter that is the index of the <a class="el" href="classMezzanine_1_1UI_1_1MultiImageData.html">Mezzanine::UI::MultiImageData</a> that is to be altered. Instances of <a class="el" href="classMezzanine_1_1UI_1_1MultiImageData.html">Mezzanine::UI::MultiImageData</a> are not allocated on the fly, and should be created in advance using the <a class="el" href="classMezzanine_1_1UI_1_1MultiImageLayer.html#a355c0ccd89a64689fee3eb65a1a69494">Mezzanine::UI::MultiImageLayer::ReserveMultiImageData(const Whole)</a> method. In addition to the normal things that can be set for a SingleImageLayer there are some additional parameters that be set on a <a class="el" href="classMezzanine_1_1UI_1_1MultiImageData.html">Mezzanine::UI::MultiImageData</a> , in the form of a size and position that can be set for that particular sprite/image. The size and position are set using <a class="el" href="classMezzanine_1_1UI_1_1UnifiedVec2.html">Mezzanine::UI::UnifiedVec2</a> , which uses the scaled bounds for the layer as the relative component to determine it's size and position. Like the other parameters, the getters and setters for the size and position of an image require a valid index of the image to work with. For more information on how the <a class="el" href="classMezzanine_1_1UI_1_1UnifiedVec2.html">Mezzanine::UI::UnifiedVec2</a> class is used to set the size and position of an image, see the <a class="el" href="UIManual.html#UISizePos">Sizing and Positioning</a> section. <br/>
 <br/>
</p>
<h3><a class="anchor" id="UITextLayer"></a>
SingleLineTextLayer and MultiLineTextLayer</h3>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html">Mezzanine::UI::TextLayer</a> class is the base class for the text layer classes in the UI system and is designed to generate a single quad for each renderable character in a UTF-8 encoded string. TextLayers are designed to partition the characters into the lines, and support limited markup that can be customized. Basic renderable properties of the characters to be rendered can be easily altered per-character. Before text can be added to any text layer a default font must be set using the following constructor or methods: <br/>
</p>
<ul>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a4516a564c73a7c359a800a3325ecfa88">Mezzanine::UI::TextLayer::TextLayer(const String&amp; FontName, QuadRenderable*)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a42b76cb4e4d8f33f6c1a92664b77f304">Mezzanine::UI::TextLayer::SetDefaultFont(FontData*)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a9957e86dc4fec612400b464535fd7eb2">Mezzanine::UI::TextLayer::SetDefaultFont(const String&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a145ad34eda26809114f0699f9253c1b5">Mezzanine::UI::TextLayer::SetDefaultFont(const String&amp;,const String&amp;)</a> <br/>
 <br/>
Note that the constructor listed here should not be called directly. Instead the appropriate create method should be called on the QuadRenderable that takes a Font or FontName as a parameter. In addition to a default font, text layers also use a default text colour to decide what colour text should be when one isn't specified in Markup. This value defaults to white, but can be set using the <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a25a1c5ece1b5c3f90c0fa658229a3a01">Mezzanine::UI::TextLayer::SetTextColour(const ColourValue&amp;)</a> method. <br/>
 <br/>
Text passed into a TextLayer is converted into a series of <a class="el" href="classMezzanine_1_1UI_1_1Character.html">Mezzanine::UI::Character</a> instances. The Character class exists to provide an abstraction for both Glyphs and Sprites to be rendered within a TextLayer. Characters can be individually highlighted, coloured, or have a custom size set using the following methods: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1Character.html#a7ca330d2b10c4c1d38329e118ce06aac">Mezzanine::UI::Character::SetHighlighted(Boole)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1Character.html#a397037717ea6eb1e4b08601390c63d0e">Mezzanine::UI::Character::SetCharacterColour(const ColourValue&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1Character.html#af21a8e89f62923bdc7c72292d93a118e">Mezzanine::UI::Character::SetCustomSize(const Vector2&amp;)</a> <br/>
<br/>
Characters are also subject to scaling based on the configuration of their parent TextLayer. The custom size you can set is subject to scaling. Outside of very specific configurations, the Character class shouldn't need to be manipulated directly via code. Most of it's data is set and used by TextLines and TextLayers. In most cases the data that is safe to alter or isn't likely to get wiped the next time the TextLayer is updated is data that can changed via Markup. More information on Markup and the <a class="el" href="classMezzanine_1_1UI_1_1DefaultMarkupParser.html">Mezzanine::UI::DefaultMarkupParser</a> is available below. <br/>
 <br/>
After all of the appropriate <a class="el" href="classMezzanine_1_1UI_1_1Character.html">Mezzanine::UI::Character</a> instances are created, they are placed into TextLines that are stacked vertically within the bounds of the TextLayer. Rather than having a number of explicitly stated positions, positions for both Characters and TextLines are stored as offsets. TextLines have a vertical offset from the top of the TextLayer. TextLines are assumed to fill the complete horizontal space of a TextLayer, so Characters store a horizontal offset from the left of the TextLine/TextLayer. Offsets for TextLines are regenerated any time a new TextLine is created and offsets for Characters within a given TextLine are regenerated any time a Character is inserted. Both offsets are regenerated any time the TextLayer changes its horizontal bounds. When Characters are inserted into TextLines, only horizontal space is checked to determine if they can be inserted. The vertical size of a TextLine is equal to the Character in that TextLine with the largest vertical size. Characters within a TextLine can have their horizontal alignment within that TextLine using the <a class="el" href="classMezzanine_1_1UI_1_1TextLine.html#aa173db25cba98b7e2bd12e3a1c8a368b">Mezzanine::UI::TextLine::SetAlignment(const UI::LinearAlignment)</a> method. The <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a1a39c77898216e1ea37952bf4942f35c">Mezzanine::UI::TextLayer::SetTextLineHorizontalAlignment(const UI::LinearAlignment)</a> method is also available on the TextLayer class to set the horizontal alignment of all TextLines it is storing. <br/>
 <br/>
When a UTF-8 encoded string is passed into a TextLayer and converted into a series of Character instances, the string will be tokenized with the tokens stored in a <a class="el" href="classMezzanine_1_1UI_1_1TokenString.html">Mezzanine::UI::TokenString</a> and then run through the <a class="el" href="classMezzanine_1_1UI_1_1MarkupParser.html">Mezzanine::UI::MarkupParser</a> set for that TextLayer. In order to avoid data duplication and have a minor optimization for inserting characters, TextLayers do not cache the String passed into it as is. Instead the String passed into it is cached as a <a class="el" href="classMezzanine_1_1UI_1_1TokenString.html">Mezzanine::UI::TokenString</a> . Calls to <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a092ae4c9039f8e217a4559b7a8d5d7a8">Mezzanine::UI::TextLayer::SetText(const String&amp;)</a> will destroy the old TokenString and tokenize/parse the new String. Calls to <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#ab6fc11ff655590ecd8dc7c3fae0a9757">will</a> collect the raw characters from each token and concatenate each into a single String that will be returned. When a markup tag is detected by the set MarkupParser it will enable a feature that will change the look or behavior of all render characters that are generated until the terminating tag is detected. If a start tag or end tag is created and doesn't have a corresponding tag to define it's range, then all the text in that tag that would have been hidden is instead rendered, and has no effect on rendered characters in that String. As such, the MarkupParsers in <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> support a form of tag soup where tags can overlap with each other partially. Like most markup, the end tag for a range needs to use the "/" character to let the Parser know it is ending a range of it's type. Not all Markup tags need to define a range, however. An example of a non-range tag is available below. <br/>
 <br/>
The <a class="el" href="classMezzanine_1_1UI_1_1DefaultMarkupParser.html">Mezzanine::UI::DefaultMarkupParser</a> class defines 3 basic tags that can be used to manipulate text. The tags available can change the Font or Colour of a Glyph, or insert a Sprite. Here are some examples of text that could be passed into a TextLayer using the DefaultMarkupParser: <div class="fragment"><div class="line"><span class="stringliteral">&quot;This is a [Colour Value=ff0000]Markup[/Colour] Test.&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;This is [Font Name=Ubuntu]another[/Font] test of the Markup.&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;This is a bird: [Sprite Name=BirdSprite Size=10x5]&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;This is a [Colour Value=ff0000]test of [Font Name=Ubuntu]different[/Colour] overlapping[/Font] tags.&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;This is a [Colour Value=ff0000]test of [Colour Value=00ff00]identical[/Colour] overlapping[/Colour] tags.&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;This is a test of an [Colour Value=ff0000]invalid range tag.&quot;</span></div>
</div><!-- fragment --> The first test string should produce a string where every character is the layers default character colour with the exception of the characters in the "Markup" word, which should be red. <br/>
The second text string should produce a string where every character is the layers default character colour and uses the default set font (for example "Times New Roman") for every work except "another", which should use the Ubuntu font as defined in the layer atlas. If the default font is set to "Ubuntu" in this example, there should be no distinguishable effect. <br/>
The third test should display an image/sprite of a bird (or a sprite named "BirdSprite" in the layers atlas at least) at the end of the String that is 10 pixels by 5 pixels. The size parameter is purely optional and if not defined then the characters size on the atlas will be used, unless text scaling on the parent TextLayer is enabled, in which case it will be scaled appropriately. <br/>
The fourth test string should display the "This is a" section as the layers default character colour and the layers default font. The "test of" section should be red text in default font. The "different" word should be red text in Ubuntu font. The "overlapping" word should be the layers default character colour in Ubuntu font. The "tags" word should be the layers default character colour in the layers default font. <br/>
The fifth test string should display the "This is a" section in the layers default character colour. The "test of" section should be red text. The "identical" word should be green text. The "overlapping" word should be red text. The "tags" word should be the layers default character colour. All text should be in the layers default font. <br/>
The sixth test string should display the entire text, including "[Colour Value=ff0000]", in the layers default font and text colour. <br/>
A few extra notes about the tags: The names of both the tags and their parameters are case sensitive and the parameters must not have spaces when defining their values, only when separating different parameters or the tag name. For example: "[Colour Value=ff0000]" is good, while "[Colour Value = ff0000]" is bad. <br/>
More information on creating and setting a MarkupParser that isn't the default can be found here: <a class="el" href="UIManual.html#UIMarkup">Markup Parsers</a> . <br/>
 <br/>
Glyphs or Sprites can be inserted directly into a TextLayer or removed from a TextLayer using the following methods: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#af885ad32213adc3b01974d0b91809f6c">Mezzanine::UI::TextLayer::InsertCharacterAtIndex(const Integer, const UInt32)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#aae060ebd49809c748b7f75ac9a818b42">Mezzanine::UI::TextLayer::InsertCharactersAtIndex(const Integer, const Char8*, const UInt32)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a6eee436d3e764ea49a19527852aab116">Mezzanine::UI::TextLayer::InsertCharactersAtIndex(const Integer, const UInt32*, const UInt32)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a65082b7afc91760472cee2331ec8247c">Mezzanine::UI::TextLayer::RemoveCharacterAtIndex(const Integer)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a1b3de1cb27cd11afc7b643c06e8f9949">Mezzanine::UI::TextLayer::RemoveCharactersAtIndex(const Integer, const UInt32)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a8f635077e35ce4140c2e194475a9ca82">Mezzanine::UI::TextLayer::RemoveCharacterRange(const Integer, const Integer)</a> <br/>
<br/>
Each of these methods accepts an Integer for where in the string the manipulation will take place. Passing in a negative index will always cause the operation to occur at the last index in the TextLayer. The index used corresponds to the index among the characters that were generated from the original string, not the index of the raw string passed in. So if you have working tags in the raw string that was passed in, and they are hidden from rendering then they aren't considered for the index. The <a class="el" href="classMezzanine_1_1UI_1_1TextCursor.html">Mezzanine::UI::TextCursor</a> class is also available to help with insertion or removal operations by allowing you to insert or remove characters from either side of the cursor. By default the cursor for a TextLayer is disabled. You can enable the TextCursor using the <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#ab41875b0792f44c26cb067b08393e49b">Mezzanine::UI::TextLayer::SetCursorEnabled(Boole)</a> method. <br/>
 <br/>
Highlighting characters within a TextLayer can be done conveniently using one of the following methods: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a7d70b3df76717f8bf51bd171bc265011">Mezzanine::UI::TextLayer::Highlight()</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#aa3ec3d5fbbea6dbfca3d886c23b965e7">Mezzanine::UI::TextLayer::Highlight(const Integer)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a815e2dc9ce4db59f957839f321044d92">Mezzanine::UI::TextLayer::Highlight(const Integer, const Integer)</a> <br/>
<br/>
Once again the integer passed in is referring to the index among the rendered characters, not the raw index of the string passed into the TextLayer. Also, any highlighting operation will clear any previously set highlights when using these methods. The TextLayer will only attempt to keep track of a single range of highlighted characters at a time. <br/>
 <br/>
There are two types of scaling that can be set for text displayed by a TextLayer: Manual and Auto. Manual text scaling is set with the <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#a8244dd79624e998df83071a2c2c57d1d">Mezzanine::UI::TextLayer::SetManualTextScale(const Vector2&amp;)</a> method and it simply applies the values of the provided vector to each of the characters within the TextLayer. Auto text scaling is set with the <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html#ad8f1d71f9d6cf9be4abeb89412bd427c">Mezzanine::UI::TextLayer::SetAutoTextScale(const TextLayer::ScalingMode, const Real)</a> method and will instead scale both axes evenly based on how much Y scaling is needed to achieve the desired height for a given character. The height that is used to calculate this isn't based on the pixel height of the character if it is a glyph, but rather the line height of the font used by that character. So you don't have to worry about strange and unevenly stretched glyphs from the same font. If both manual and auto text scaling are enabled on a TextLayer, then the auto scaling will be applied first, getting it to the desired height and then manual scaling will be applied. <br/>
 <br/>
Compared to the <a class="el" href="classMezzanine_1_1UI_1_1TextLayer.html">Mezzanine::UI::TextLayer</a> base class the <a class="el" href="classMezzanine_1_1UI_1_1SingleLineTextLayer.html">Mezzanine::UI::SingleLineTextLayer</a> and <a class="el" href="classMezzanine_1_1UI_1_1MultiLineTextLayer.html">Mezzanine::UI::MultiLineTextLayer</a> classes are quite small; focusing what what little additional functionality is needed for rendering to a single line, or multiple lines respectively. Between the two classes there is only one bit of publicly exposed functionality. The <a class="el" href="classMezzanine_1_1UI_1_1SingleLineTextLayer.html#a1c04df181cf7a787fe480c6fbff5cc45">Mezzanine::UI::SingleLineTextLayer::SetStartIndex(const Integer&amp;)</a> can be used to exclude the rendering of the first (n) characters of the string to be rendered. <br/>
 <br/>
In any Widget that uses an auto-generated TextLayer to fulfill its purpose (such as the EditBox Widget) then the TextLayer will be given a ZOrder of 5 in both the Normal and Hovered groups, as well as any other group that Widget automatically creates. <br/>
 <br/>
</li>
</ul>
<h2><a class="anchor" id="UILayerGroups"></a>
Render Layer Groups</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1RenderLayerGroup.html">Mezzanine::UI::RenderLayerGroup</a> class is a grouping of RenderLayers sorted by ZOrder to achieve a specific visual effect. RenderLayerGroups can have RenderLayers belonging to the same QuadRenderable added to them. RenderLayerGroups are initialized from the QuadRenderable class using either the <a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#abc1e4f097323de7edd22e624c1f5afe6">Mezzanine::UI::QuadRenderable::CreateRenderLayerGroup(const UInt16)</a> method or the <a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a17d4139c084c798d1091bbc9f8fbcc34">Mezzanine::UI::QuadRenderable::CreateOrRetrieveRenderLayerGroup(const UInt16)</a> method. The ID passed in needs to be unique among the RenderGroupLayers in that QuadRenderable or an exception will be thrown. To help with keeping track of IDs the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html#a2f58e30c86e8a9db93b95ff577d33653">Mezzanine::UI::Widget::WidgetGroupID</a> enum has a few named defaults based on the available Widget states. <br/>
 <br/>
RenderLayers can have a different ZOrder for each RenderLayerGroup they belong to and can be in an any number of RenderLayerGroups. Like with QuadRenderables, RenderLayers are sorted in the RenderLayerGroup by ZOrder from lowest to highest. It also determines which RenderLayer will be more visible if there is an overlap. Unlike the QuadRenderable class, by design there should be a considerable amount of overlap among RenderLayers within a RenderLayerGroup. The RenderLayers with higher ZOrders will be rendered on top of lower ZOrder RenderLayers; making them more visible. For example, in many cases a RenderLayerGroup will have 2 RenderLayers. One SingleImageRenderLayer with a lower ZOrder and a SingleLineTextLayer with text to create a button. You could further customize it's appearance with another SingleImageLayer at the highest ZOrder that is just an image of a border fitting your application art style. Assuming the center of the border image is transparent, then you could create a golden bordered button labeled "Start" with a blue marble background. <br/>
 <br/>
The UI::Mezzanine::Widget class also has a way to bind a specific RenderLayerGroup to a WidgetState for that particular Widget ( covered in more detail here: UIWidget ). So the RenderLayerGroup in the previous example could be set to the "WS_Untouched" state, while another similar RenderLayerGroup that reuses the border and text RenderLayers with a new SingleImageLayer that has an alternate background art could be bound to a state with "WS_Hovered" in it. This gives you a look that will automatically be updated when the mouse is hovered over that Widget. In practice however, the base Widget class already creates a "Normal" and "Hovered" RenderLayerGroups that you can add RenderLayers to, so the tedious parts that are common to do are done for you. <br/>
 <br/>
</p>
<h2><a class="anchor" id="UICaching"></a>
Local Vertex Caching</h2>
<p>Local Vertex Caching is a feature available to each QuadRenderable and is designed to be a minor optimization that can be enabled for static portions of a UI. Vertex Caching can be enabled using the Mezzanine::QuadRenderable::SetLocalVertexCaching(Boole) method. This will create an instance of a RenderData that will be populated with all of the RenderData belonging to that QuadRenderable and all child QuadRenderables saving the trouble of the iterations, checks, and appends that would otherwise be necessary. When the child of a QuadRenderable with Local Vertex Caching is altered, then it still has to go through all of the same processes to update the cache. So QuadRenderables that get updated frequently (or have children that are) are not good candidates for Local Vertex Caching. By default, all QuadRenderables that are direct children of the Screen have Local Vertex Caching enabled, but this is in no way required and can be disabled if it doesn't make sense for that QuadRenderable.</p>
<p><br/>
 <br/>
</p>
<h1><a class="anchor" id="UIInputLife"></a>
The Lifetime of an Input</h1>
<p>The lifetime of an input making it's journey through <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> starts with a call to <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#aacb361620fdc4810031ac35c0f5b1792" title="Injects a metacode into this manager, allowing the UI system to be aware of it. ">Mezzanine::UI::UIManager::InjectInput(const Input::MetaCode&amp;)</a> . The "Input" referred to in this section is a <a class="el" href="classMezzanine_1_1Input_1_1MetaCode.html" title="This Determines the kind of user input. ">Mezzanine::Input::MetaCode</a> instance. Inside a call to "InjectInput" checks are performed on the input to see if any variables need to be set before processing and then it is stored in another container which will be used when the <a class="el" href="classMezzanine_1_1UI_1_1WidgetUpdateWorkUnit.html" title="This is a Mezzanine::Threading::iWorkUnit for the updating of widgets in the UI system. ">Mezzanine::UI::WidgetUpdateWorkUnit</a> is run in the framescheduler. When <a class="el" href="classMezzanine_1_1UI_1_1WidgetUpdateWorkUnit.html" title="This is a Mezzanine::Threading::iWorkUnit for the updating of widgets in the UI system. ">Mezzanine::UI::WidgetUpdateWorkUnit</a> is run it will automatically collect all of the inputs new since the last frame from the <a class="el" href="classMezzanine_1_1Input_1_1InputManager.html" title="This is the manager responsible for the handling of input devices and events. ">Mezzanine::Input::InputManager</a> , so this does not need to be done manually and can get you some weird behavior if you attempt to do so. Manual calls to "InjectInput" should only be done in special cases where you are simulating an input that was not made by the user or in <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> configurations without an InputManager. <br/>
 <br/>
After all of the new inputs from the input subsystem have been collected and a few other non-input checks have been performed, each input is processed individually. Inputs are first passed over to "pre-focus" checks, which are checks that are performed by the UI manager prior to being passed off to the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a> wtih focus if one is set. This is where checks for locking and unlocking the focus are done. A focus can be set by clicking any mouse button while the mouse is hovered over a <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a>. If a focus is already set then it is dropped as the focus before setting the new one. This is prevented if the focus is locked. Focus is locked (in addition to gaining focus) when a mouse button is pressed over a <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a>. The UI manager keeps track of that input and looks for a corresponding "Lift" input for that button. When it detects it the lock will be lifted and a switch will be allowed. A lock being lifted doesn't mean that a switch will happen immediately and the same Widget can keep it's focus or even have it's focus locked again. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000133">Todo:</a></b></dt><dd>When hotkeys become available, they will also be able to manipulate/switch the focus.</dd></dl>
<p><br/>
 <br/>
Once the pre-focus checks are complete the input will be passed off to the focus if one is set. If no focus is set then this set is skipped for that input and it's passed on to the post-focus checks. If one is set then the Mezzanine::UI::Widget::HandleInput(const Input::MetaCode&amp;) method is called on the focus, which internally calls Mezzanine::UI::HandleInputImpl(const Input::MetaCode&amp;) to be processed by the specific <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a> implementation. In the implementation method the input will be relevant and "consumed" or it will be an input that the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a> cannot use. If the input is consumed, then the internal method will return true, which will also return true to the UI manager. However if the input is something it cannot use then the implementation method will return false and cause the input to be passed up the <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a> hierarchy starting with the parent of the focus. The parent of the focus then goes through all the same processes as the focus. It goes to the implementation method and can be consumed. If it is then true is returned to the UI manager indicating it was consumed. Otherwise the parent of that <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a> gets an opportunity to consume the input and so on until either a <a class="el" href="classMezzanine_1_1UI_1_1Widget.html" title="This is the base class for all widgets. ">Mezzanine::UI::Widget</a> consumes the input or the Screen all these Widgets belong to is reached. If true is returned to the UI manager from any of these checks then post-focus checks are skipped for that input. <br/>
 <br/>
If the input was consumed, then the UI manager will move on to the next input and repeat the cycle starting at pre-focus checks. If the focus (or any of it's parent Widgets) did not consume the input, then it'll move on to the post-focus checks. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000134">Todo:</a></b></dt><dd>Currently this is a (very) small section because while the structure is there no actual checks are performed. In the future Actions or tab switching between Widgets may go here.</dd></dl>
<p><br/>
 <br/>
After all of the inputs have been processed, then the container storing the inputs is cleared to make room for the next frames inputs. In most cases the number of inputs to be processed in a given frame will be either 0 or 1. A typical frame where there is mouse movement is 4 or 5 inputs. In the extreme case where you would have a 4-way split screen with controllers there could be upwards of ~40 inputs to be processed in a given update.</p>
<p><br/>
 <br/>
</p>
<h1><a class="anchor" id="UIConfig"></a>
Configuring and Expanding</h1>
<ul>
<li><a class="el" href="UIManual.html#UISizePos">Sizing and Positioning</a></li>
<li><a class="el" href="UIManual.html#UILayout">Layout Strategies</a></li>
<li><a class="el" href="UIManual.html#UIFactories">Widget Factories</a></li>
<li><a class="el" href="UIManual.html#UIMarkup">Markup Parsers</a></li>
</ul>
<h2><a class="anchor" id="UISizePos"></a>
Sizing and Positioning</h2>
<p>Positioning and Sizing of QuadRenderables in <a class="el" href="namespaceMezzanine_1_1UI.html" title="This namespace is for all the classes belonging to the Graphical User Interface Subsystem. ">Mezzanine::UI</a> does not lock you into either Absolute(pixel) or Relative units to define the sizes. Both modes are supported and can even be blended to achieve very finely grained configurations. The primary classes that support this are: <a class="el" href="classMezzanine_1_1UI_1_1UnifiedDim.html">Mezzanine::UI::UnifiedDim</a> , <a class="el" href="classMezzanine_1_1UI_1_1UnifiedVec2.html">Mezzanine::UI::UnifiedVec2</a> , and <a class="el" href="classMezzanine_1_1UI_1_1UnifiedRect.html">Mezzanine::UI::UnifiedRect</a> . The UnifiedDim class stores two Reals, one for relative and one for absolute, to express it's length on a given dimension. The Mezzanine::UI::UnifiedDim::CalculateActualDimension(const Real&amp;) const method accepts a Real that is expected to be an absolute length that the relative portion is to be based on. Using that, it will first multiply the relative value with the parameter passed in and add the stored absolute value to it. Either the relative or absolute components can be zero, or even negative if that is what your configuration calls for. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> ParentXSize = 70;                                              <span class="comment">// 70 pixel wide parent</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> AltParentXSize = 25;                                           <span class="comment">// Alternate parent size of 25 pixels</span></div>
<div class="line"></div>
<div class="line">UI::UnifiedDim ChildXSize(0.6,-10.0);                               <span class="comment">// We want the child to always be a little over half the size of the parent, minus 10 pixels</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> Ret1 = ChildXSize.CalculateActualDimension(ParentXSize);       <span class="comment">// ( 70 * 0.6 ) + -10.0 = 32 pixels</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> Ret2 = ChildXSize.CalculateActualDimension(AltParentSize);     <span class="comment">// ( 25 * 0.6 ) + -10.0 = 5 pixels</span></div>
<div class="line"></div>
<div class="line">UI::UnifiedDim AbsChildXSize(0.0,25.0);                             <span class="comment">// Fixed size child with only the absolute portion with a non-zero value.</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> Ret3 = AbsChildXSize.CalculateActualDimension(ParentXSize);    <span class="comment">// ( 70 * 0.0 ) + 25.0 = 25 pixels</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> Ret4 = AbsChildXSize.CalculateActualDimension(AldParentXSize); <span class="comment">// ( 25 * 0.0 ) + 25.0 = 25 pixels</span></div>
<div class="line"></div>
<div class="line">UI::UnifiedDim.RelChildXSize(0.4,0.0);                              <span class="comment">// Pure scaling child with only the relative portion with a non-zero value.</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> Ret5 = RelChildXSize.CalculateActualDimension(ParentXSize);    <span class="comment">// ( 70 * 0.4 ) + 0.0 = 28 pixels</span></div>
<div class="line"><a class="code" href="namespaceMezzanine.html#a726731b1a7df72bf3583e4a97282c6f6">Real</a> Ret6 = RelChildXSize.CalculateActualDimension(AldParentXSize); <span class="comment">// ( 25 * 0.4 ) + 0.0 = 10 pixels</span></div>
</div><!-- fragment --><p> Negative results for sizes will always be clamped to 0 to prevent rendering artifacts. <br/>
When the dimension calculated is going to be used for a position, then the relative component will still use the parents size for it's calculation, and then it will be added to the parents position. This will cause negative results for positions to move the child QuadRenderable outside of the bounds of it's parent (up if on the Y axis, to the left if on the X axis). Note that moving outside the bounds of the parent is perfectly valid from a technical standpoint, as is having a child be larger than it's parent. </p>
<div class="fragment"><div class="line">UI::Rect ParentRect(75.0,100.0,150.0,120.0);                        <span class="comment">// Rect at pixel position (75,100) that is 150 pixels wide and 120 pixels tall</span></div>
<div class="line">UI::UnifiedRect RelRect(0.2,0.2,0.6,0.6);                           <span class="comment">// Pure scaling child rect that is a little over half the size of the parent and centered</span></div>
<div class="line">UI::UnifiedRect NegRect(0.0,-0.1,1.0,0.1);                          <span class="comment">// Pure scaling child rect that is outside the parents bounds, matches the width of the parent and is one tenth it&#39;s height</span></div>
<div class="line">UI::UnifiedRect MixRect(0.1,0.1,0.8,0.8,-5.0,-5.0,5.0,5.0);         <span class="comment">// Rect that is 4/5&#39;s the size of it&#39;s parent and centered with an additional 5 pixels added to it&#39;s size</span></div>
<div class="line"></div>
<div class="line">UI::Rect Ret1 = RelRect.CalculateActualDimension(ParentRect);       <span class="comment">// Position.X: 75 + ( ( 150 * 0.2 ) + 0.0 ) = 105 pixels from the left</span></div>
<div class="line">                                                                    <span class="comment">// Position.Y: 100 + ( ( 120 * 0.2 ) + 0.0 ) = 124 pixels from the top</span></div>
<div class="line">                                                                    <span class="comment">// Size.X:     ( 150 * 0.6 ) + 0.0 = 90 pixels</span></div>
<div class="line">                                                                    <span class="comment">// Size.Y:     ( 120 * 0.6 ) + 0.0 = 72 pixels</span></div>
<div class="line"></div>
<div class="line">UI::Rect Ret2 = NegRect.CalculateActualDimension(ParentRect);       <span class="comment">// Position.X: 75 + ( ( 150 * 0.0 ) + 0.0 ) = 75 pixels from the left</span></div>
<div class="line">                                                                    <span class="comment">// Position.Y: 100 + ( ( 120 * -0.1 ) + 0.0 ) = 88 pixels from the top</span></div>
<div class="line">                                                                    <span class="comment">// Size.X:     ( 150 * 1.0 ) + 0.0 = 150 pixels</span></div>
<div class="line">                                                                    <span class="comment">// Size.Y:     ( 120 * 0.1 ) + 0.0 = 12 pixels</span></div>
<div class="line"></div>
<div class="line">UI::Rect Ret3 = MixRect.CalculateActualDimension(ParentRect);       <span class="comment">// Position.X: 75 + ( ( 150 * 0.1 ) + -5.0 ) = 85 pixels from the left</span></div>
<div class="line">                                                                    <span class="comment">// Position.Y: 100 + ( ( 120 * 0.1 ) + -5.0 ) = 107 pixels from the top</span></div>
<div class="line">                                                                    <span class="comment">// Size.X:     ( 150 * 0.8 ) + 5.0 = 125 pixels</span></div>
<div class="line">                                                                    <span class="comment">// Size.Y:     ( 120 * 0.8 ) + 5.0 = 101 pixels</span></div>
</div><!-- fragment --><p> The last thing to keep in mind when using Unified Dimensions is that all relative components are relative to the immediate parents size, not the size of the Screen or highest non-Screen parent. So the same UnifiedRect will cause lower children to shrink more and more if the relative components are less than 1, or grow more and more if the relative components are more than 1. When a final value for position or size is found, it will be Ceil'd to ensure no unintended blending occurs. So each final value should be a whole number expressed as a Real. </p>
<div class="fragment"><div class="line">UI::Rect ParentRect(75.0,100.0,160.0,120.0);                        <span class="comment">// Rect at pixel position (75,100) that is 150 pixels wide and 120 pixels tall</span></div>
<div class="line">UI::UnifiedRect ChildRect(0.25,0.25,0.5,0.5);                       <span class="comment">// Child rect that is half the size of it&#39;s parent and centered</span></div>
<div class="line">UI::UnifiedRect GrandChildRect(0.25,0.25,0.5,0.5);                  <span class="comment">// Child rect that is half the size of it&#39;s parent and centered</span></div>
<div class="line"></div>
<div class="line">UI::Rect ChildRet = ChildRect.CalculateActualDimension(ParentRect); <span class="comment">// Position.X: 75 + ( ( 160 * 0.25 ) + 0.0 ) = 115 pixels from the left</span></div>
<div class="line">                                                                    <span class="comment">// Position.Y: 100 + ( ( 120 * 0.25 ) + 0.0 ) = 140 pixels from the top</span></div>
<div class="line">                                                                    <span class="comment">// Size.X:     ( 150 * 0.5 ) + 0.0 = 75 pixels</span></div>
<div class="line">                                                                    <span class="comment">// Size.Y:     ( 120 * 0.5 ) + 0.0 = 60 pixels</span></div>
<div class="line"></div>
<div class="line">UI::Rect GrandChildRet = GrandChildRect.CalculateActualDimension(ChildRet); <span class="comment">// Position.X: 115 + ( ( 75 * 0.25 ) + 0.0 ) = 134 pixels from the left - Relative portion ceil&#39;d to 19</span></div>
<div class="line">                                                                            <span class="comment">// Position.Y: 140 + ( ( 60 * 0.25 ) + 0.0 ) = 155 pixels from the top</span></div>
<div class="line">                                                                            <span class="comment">// Size.X:     ( 75 * 0.5 ) + 0.0 = 38 pixels - Relative portion ceil&#39;d to 38</span></div>
<div class="line">                                                                            <span class="comment">// Size.Y:     ( 60 * 0.5 ) + 0.0 = 30 pixels</span></div>
</div><!-- fragment --><p> In practice you should never need to call "CalculateActualDimension" manually. You can set the UnifiedDims and positioning/sizing flags and the system will handle those calls for you. The QuadRenderable has the following methods to set UnifiedDims: <br/>
</p>
<ul>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a521dd7608b2042075247af353313da5c">Mezzanine::UI::QuadRenderable::SetUnifiedPosition(const UnifiedVec2&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#ad6e1f950a361cc5812ae02a1452bcc4a">Mezzanine::UI::QuadRenderable::SetUnifiedSize(const UnifiedVec2&amp;)</a> <br/>
<br/>
In addition to UnifiedDim's, there are flags that can be set to manipulate how positions and sizes are calculated. Some of which don't require you to set UnifedDim's at all. The Mezzanine::UI::PositionFlags enum is used to describe how a QuadRenderable is to be positioned on an update. The <a class="el" href="namespaceMezzanine_1_1UI.html#af126c73bf3db9e5ae1409a386376c73f">Mezzanine::UI::SizingRules</a> enum is used to describe how a QuadRenderable is to be sized during an update. For both of these enums the default value is to use the set UnifiedDims exclusively. Both positioning and sizing can be set per-axis. <br/>
 <br/>
The Mezzanine::UI::PositionFlags enum is designed to define offsets and edges to apply those offsets to. The "PF_Anchor_Prev_Offset", "PF_Anchor_ParentSize", and "PF_Anchor_SelfSize" enum values are designed to allow you to define how the offset is to be calculated. The "PF_Anchor_Top", "PF_Anchor_Bottom", "PF_Anchor_Left", and "PF_Anchor_Right" enum values (and the values that are the combined results of those values) are used to define the edge to use for the offset. A center positioning is allowed and support through either the convenience enum value or setting both edges on a given axis. The edge defined is for both the parent and the child. So setting the positioning flags to "PF_Anchor_Prev_Offset | PF_Anchor_Top" then it will get the distance between the parents top edge and the childs top edge before the update occured, and will ensure that the new position of the child will have the same distance. If multiple offset flags are defined then the flag with the lowest value will be applied. This is simply a consequence of how the algorithm was written and positioning is not designed to have multiple offsets set for a single QuadRenderable. You should set either 0 or 1 offset value. If no offset enum value is defined then the offset will be 0. Mixing axes when setting positioning flags will cause the invalid axis values to be ignored. You cannot set the horizontal positioning of a QuadRenderable to anchor to the top edge of it's parent. The QuadRenderable has the following methods to set positioning flags: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#adc8b6902fbc92df534d792d7b054c271">Mezzanine::UI::QuadRenderable::SetHorizontalPositioningRules(const Whole)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#aa9b81cbd50f854b274dfe94bb400439f">Mezzanine::UI::QuadRenderable::SetVerticalPositioningRules(const Whole)</a> <br/>
<br/>
The <a class="el" href="namespaceMezzanine_1_1UI.html#af126c73bf3db9e5ae1409a386376c73f">Mezzanine::UI::SizingRules</a> enum doesn't have any special tricks like the positioning flags do. Despite the fact that the SizingRules enum is set up like a bitfield, only one value is intended to be set at a given time. The "SR_Match_Other_Axis", "SR_Match_Other_Axis_Unified", and "SR_Size_For_Text" being set on a given axis will require the opposite axis to be calculated first. If both axes have a SizingRules set that causes them to depend on the other, a circular dependency will occur and an exception will be thrown. The "SR_Fill_Available" value will cause the QuadRenderable it is applied to to expand on that axis dynamically based on the space available in the parent. This type of sizing is somewhat limited in where it can be used. The default <a class="el" href="classMezzanine_1_1UI_1_1LayoutStrategy.html">Mezzanine::UI::LayoutStrategy</a> class does not support it's use and if it is applied to a QuadRenderable that is updated by it then UnifiedDims will be used. The Mezzanine::UI::HorizontalStrategy and Mezzanine::UI::VerticalStrategy classes support this value being set by children updated by it. More information on LayoutStrategies, their use, thier features, and extending them is available here: <a class="el" href="UIManual.html#UILayout">Layout Strategies</a> . The QuadRenderable has the following methods to set sizing rules: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a54572ea07c8f82565cd1825caf48fc0c">Mezzanine::UI::QuadRenderable::SetHorizontalSizingRules(const Whole)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#aa434bfccacccbe6aeef03c39d3c7f38a">Mezzanine::UI::QuadRenderable::SetVerticalSizingRules(const Whole)</a> <br/>
<br/>
The <a class="el" href="namespaceMezzanine_1_1UI.html#a6885a21f0bd018f7af3dc0a0d10b8aea">Mezzanine::UI::AspectRatioLock</a> enum is used to set how a QuadRenderable is to react to changes to its aspect ratio. In many cases either "ARL_Ratio_Unlocked" or "ARL_Ratio_Y_Axis" will be sufficient for most QuadRenderables. "ARL_Ratio_Y_Axis" in particular is useful if you are only worried about switch between widescreen and non-widescreen resolutions. The "ARL_Ratio_Locked_Expanding" and "ARL_Ratio_Locked_Shrinking" enum values do not favor one axis over the other when locking the aspect ratio. "ARL_Ratio_Locked_Expanding" will force the axis with the less growth to match the relative growth of the axis with more growth. "ARL_Ratio_Locked_Shrinking" is like "ARL_Ratio_Locked_Expanding" but will clamp to less growth instead. The QuadRenderable has the following method to set aspect ratio lock: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#ab1203dda292388892814e1c887b0c103">Mezzanine::UI::QuadRenderable::SetAspectRatioLock(const UI::AspectRatioLock)</a> <br/>
<br/>
A minimum and maximum size can be set for any QuadRenderable. Minimum and maximum sizes can be expressed as UnifiedDims allowing them to change dynamically as sizes change. Checks for enforcing minimum and maximum sizes are done after all calculations for the new size are done, and then they are clamped. Zero'd out UnifiedDims indicate that the feature is disabled. The QuadRenderable has the following methods to set the minimum and maximum sizes: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#abea8ee5e5699b3558ee7de07de0db59f">Mezzanine::UI::QuadRenderable::SetMinSize(const UnifiedVec2&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a76fc4d621aae9d069c65cea9300082c6">Mezzanine::UI::QuadRenderable::SetMaxSize(const UnifiedVec2&amp;)</a> <br/>
<br/>
The <a class="el" href="classMezzanine_1_1UI_1_1SizingInfo.html">Mezzanine::UI::SizingInfo</a> and <a class="el" href="classMezzanine_1_1UI_1_1PositioningInfo.html">Mezzanine::UI::PositioningInfo</a> classes are used by the QuadRenderable class to store all the information needed for the particular type of operation including all of the features covered in this section. Instances of <a class="el" href="classMezzanine_1_1UI_1_1SizingInfo.html">Mezzanine::UI::SizingInfo</a> or <a class="el" href="classMezzanine_1_1UI_1_1PositioningInfo.html">Mezzanine::UI::PositioningInfo</a> can be applied to and/or retrieved from a QuadRenderable using the following methods: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a9154e0be1a45989f423fd80a7afbd23e">Mezzanine::UI::QuadRenderable::SetPositioningPolicy(const PositioningInfo&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a81b3bdc50f2f1aaffb6cc2a2c7051066">Mezzanine::UI::QuadRenderable::GetPositioningPolicy() const </a><br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a40e894ca355727b36122e4afc68be6d0">Mezzanine::UI::QuadRenderable::SetSizingPolicy(const SizingInfo&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a6af297218ed4c18d7cc80a4ddc4e243b">Mezzanine::UI::QuadRenderable::GetSizingPolicy() const </a><br/>
<br/>
</li>
</ul>
<h2><a class="anchor" id="UILayout"></a>
Layout Strategies</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1LayoutStrategy.html">Mezzanine::UI::LayoutStrategy</a> base class is an abstraction that performs the actual positioning and sizing of child Widgets within a QuadRenderable. LayoutStrategies can be applied to QuadRenderables using the <a class="el" href="classMezzanine_1_1UI_1_1QuadRenderable.html#a46bc65bc5909d3f589da48b26173442b">Mezzanine::UI::QuadRenderable::_SetLayoutStrat(LayoutStrategy*)</a> method. All Widgets that expect to have children have their appropriate LayoutStrategy applied by their respective factory immediately after construction. Widgets that do not expect to have Widget children do not recieve a LayoutStrategy and any children that are added to it will not have thier dimensions updated. In nearly all cases you shouldn't need to change the LayoutStrategy of a QuadRenderable. All Widgets provided by default have which LayoutStrategy they use (if any) in their detailed description. <br/>
 <br/>
The <a class="el" href="classMezzanine_1_1UI_1_1HorizontalLayoutStrategy.html">Mezzanine::UI::HorizontalLayoutStrategy</a> and <a class="el" href="classMezzanine_1_1UI_1_1VerticalLayoutStrategy.html">Mezzanine::UI::VerticalLayoutStrategy</a> classes exist to enable the use of the "SR_Fill_Available" value for sizing child Widgets, as that value is not supported and is ignored by the LayoutStrategy base class. These are both LayoutStrategies that are designed to be used with Widets that have their children placed in a linear sequence. <br/>
 <br/>
</p>
<h2><a class="anchor" id="UIFactories"></a>
Widget Factories</h2>
<p>Widgets use a factory pattern to handle their construction and destruction. An implementation of a <a class="el" href="classMezzanine_1_1UI_1_1WidgetFactory.html">Mezzanine::UI::WidgetFactory</a> must be created and then registered with a UI Screen using the <a class="el" href="classMezzanine_1_1UI_1_1Screen.html#adfb24b6b346aa3cd9d368fb8c1dfdffd">Mezzanine::UI::Screen::AddWidgetFactory(WidgetFactory*)</a> method for a Screen to be able to create a Widget of that type. For convenience, all of the default provided Widgets are automatically registered for each Screen when it is constructed. There are also a large number of convenience methods that wrap calls to the polymorphic factories to make them simpler to work with. <br/>
 <br/>
If you want to create a new Widget outside of the default Widget set you will have to create a factory of that Widget. The factories for the default Widgets all have convenience methods that cast to the appropriate created type, but similar methods are not necessary when creating a Widget factory. After registering the factory with the method described above, you can use one of the following methods to create a Widget of that type: <br/>
</p>
<ul>
<li><a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a6e924c2413938e77b31fac1115df09d8">Mezzanine::UI::Screen::CreateWidget(const XML::Node&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1Screen.html#a7ec259e5da49af23b63539f1fb119a4c">Mezzanine::UI::Screen::CreateWidget(const String&amp;, const String&amp;, const NameValuePairMap&amp;)</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1Screen.html#ad6c62263a08824e8213c753f76bc0881">Mezzanine::UI::Screen::CreateWidget(const String&amp;, const String&amp;, const UnifiedRect&amp;, const NameValuePairMap&amp;)</a> <br/>
 <br/>
Currently there are no methods to allow the external creation of Widgets for a Screen. Attempting to access the factory and calling the method to create the Widget should not be attempted. It should successfully create the Widget, but then there is no functionality to add it to the Screen afterwards. Aside from defining the <a class="el" href="classMezzanine_1_1UI_1_1WidgetFactory.html#ad3e296fa7f746c7fbcdb17d14a80fe9e">Mezzanine::UI::WidgetFactory::DestroyWidget(Widget*)</a> method on a factory, the system automatically handles the destruction of all Widget instances, so no special tricks are needed. <br/>
 <br/>
</li>
</ul>
<h2><a class="anchor" id="UIMarkup"></a>
Markup Parsers</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1MarkupParser.html">Mezzanine::UI::MarkupParser</a> base class is used by TextLayers to enable markup in the text they display. The markup supported is very simple, currently limited to just a few exposed rendering properties. A markup parser can be created and then made available to the UI system using the <a class="el" href="classMezzanine_1_1UI_1_1UIManager.html#a8069bfc57230320c6a75294099a74d42">Mezzanine::UI::UIManager::RegisterMarkupParser(const String&amp;, MarkupParser*)</a> method. Registering a markup parser with the UI manager is not required, however if you do not then TextLayers that are deserialized may not have their markup parsers set properly and any use of markup in those TextLayers may fail. A <a class="el" href="classMezzanine_1_1UI_1_1DefaultMarkupParser.html">Mezzanine::UI::DefaultMarkupParser</a> is automatically created and registered on the UI manager when it is constructed. <br/>
 <br/>
Most of the functionality needed for a MarkupParser is provided in the base class. When a string is parsed it is first lex'd into a series of tokens that separates the rendered text from the valid start/end/insert tags. Characters that denote the start and end of a tag can be customized in a derived markup parser. This operation is done in the <a class="el" href="classMezzanine_1_1UI_1_1MarkupParser.html#ac5b51a9abede344173138b4e6f676495">method</a>. The returned <a class="el" href="classMezzanine_1_1UI_1_1TokenString.html">Mezzanine::UI::TokenString</a> is then passed into <a class="el" href="classMezzanine_1_1UI_1_1MarkupParser.html#a6742b9412066917ecb41b11174a22025">method</a>, which will process all of the tag tokens generate characters from the next with the character traits desired. The <a class="el" href="classMezzanine_1_1UI_1_1MarkupTag.html">Mezzanine::UI::MarkupTag</a> base class is available to define a valid tag for a MarkupParser and how it affects text that is to be rendered. <br/>
 <br/>
The <a class="el" href="classMezzanine_1_1UI_1_1DefaultMarkupParser.html">Mezzanine::UI::DefaultMarkupParser</a> class provides a basic implementation of a MarkupParser that enables users to change the colour or font of a range of characters, or insert a Sprite into the characters to be rendered. When changing the appearance of a range of text, you are limited to the properties available on the <a class="el" href="classMezzanine_1_1UI_1_1CharacterTraits.html">Mezzanine::UI::CharacterTraits</a> class. Those available properties are likely to be expanded in the future to include things such as Bold, Italics, and Underline after Vector fonts become supported. If you are creating an insert tag, the character it creates must be returned with a Mezzanine::UI::MarkupParser::ProcessResult . The <a class="el" href="classMezzanine_1_1UI_1_1MarkupParser.html#a3d90382e3c68b832f1d9cbe712303c82">Mezzanine::UI::MarkupParser::Initialize()</a> method is designed to be where the supported tags are created and added.</p>
<p><br/>
 <br/>
</p>
<h1><a class="anchor" id="UIContainer"></a>
Container Widgets</h1>
<ul>
<li><a class="el" href="UIManual.html#UIPaged">Paged Containers and Providers</a></li>
<li><a class="el" href="UIManual.html#UIStacked">Stacked Containers and Buttons</a></li>
</ul>
<p><br/>
Most default provided Widgets are not designed and do not expect to have any children added to them, filling a narrow role where any child it needs is automatically initialized. The base <a class="el" href="classMezzanine_1_1UI_1_1Widget.html">Mezzanine::UI::Widget</a> class is a good really basic container for abitrary combinations of other Widgets. However it doesn't have any special behaviors for hiding a portion of its children based on other factors. To meet that need, there are a few Widgets explicitly designed to be containers that only show a portion of their children at a time. These containers come in two flavors; containers derived from <a class="el" href="classMezzanine_1_1UI_1_1PagedContainer.html">Mezzanine::UI::PagedContainer</a> and containers derived from <a class="el" href="classMezzanine_1_1UI_1_1StackedContainer.html">Mezzanine::UI::StackedContainer</a> . <br/>
 <br/>
</p>
<h2><a class="anchor" id="UIPaged"></a>
Paged Containers and Providers</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1PagedContainer.html">Mezzanine::UI::PagedContainer</a> is a container class that uses an area larger than what can be seen to place Widgets into. The View area is the actual Widget size in which children can be rendered. The Work area is (usually) larger than the View area and stores how much space is being taken up by children. For all paged containers the Work area size is automatically calcaulted when a paged container has it's dimensions updated, or a child is added/removed from it. The Work area is a square that is needed to encompass the all of the children being stored by that container. <br/>
 <br/>
The "position" of the View area within the Work area is determined by a <a class="el" href="classMezzanine_1_1UI_1_1PageProvider.html">Mezzanine::UI::PageProvider</a> . The Work area is divided by the View area for a given axis to determine the number of pages that exist on that axis. A PageProvider can then be set as the provider for that axis and any value between 0 and the max number of pages is valid. The number that is returned by <a class="el" href="classMezzanine_1_1UI_1_1PageProvider.html#a320e87f4e6b947149ee38b73e9861b22">or</a> <a class="el" href="classMezzanine_1_1UI_1_1PageProvider.html#a7d7a3ca262bc513299ab3ebe59350bb9">Mezzanine::UI::PageProvider::GetCurrentYPage() const </a>(depending on the axis it is set to) is the top or left position of the view area expressed as a page. Pages do not have to be Whole numbers and are returned from PageProviders as Real numbers. This page value is then multiplied by the size of the View area on that axis to get the actual position of the View area within the Work area. Children are then compared against this to determine if they should be rendered. Only children that can be rendered completely are rendered. Currently there is no clipping supported due to limitations of rendering, but that is subject to change in the future. See issue #103 on the <a class="el" href="namespaceMezzanine.html" title="The bulk of the engine components go in this namspace. ">Mezzanine</a> issue tracker ( <a href="https://github.com/BlackToppStudios/Mezzanine/issues">https://github.com/BlackToppStudios/Mezzanine/issues</a> ) for more information on this potential change. PageProviders are set to one or both axes using one of the following methods: <br/>
</p>
<ul>
<li>Mezzanine::UI::PageProvider::SetProviders(PageProvider*, PageProvider*) <br/>
</li>
<li>Mezzanine::UI::PageProvider::SetXProvider(PageProvider*) <br/>
</li>
<li>Mezzanine::UI::PageProvider::SetYProvider(PageProvider*) <br/>
</li>
<li>Mezzanine::UI::PageProvider::SetXYProvider(PageProvider*) <br/>
 <br/>
PagedContainers also check for when a child gains focus, and stores the last child to have gained focus as a convenience for additional custom behaviors with derived classes. The PageContainer has a single event that can be subscribed to for custom behaviors outside of the class as well; <a class="el" href="classMezzanine_1_1UI_1_1PagedContainer.html#a2aae4b7b7016333d2205812fc65786a4">Mezzanine::UI::PagedContainer::EventChildSelected</a> . If your needs are simpler, you can retrieve a pointer to the child directly using the <a class="el" href="classMezzanine_1_1UI_1_1PagedContainer.html#ae9c205b9cc4b48e5ff38a2f73c17e001">method</a>. The last selected child can also be cleared for future checks in needed using the <a class="el" href="classMezzanine_1_1UI_1_1PagedContainer.html#a361920557b4f31e680b306c527230564">Mezzanine::UI::PagedContainer::ClearSelectedChild()</a> method. The following classes are examples of PagedContainers: <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1GridContainer.html">Mezzanine::UI::GridContainer</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1HorizontalContainer.html">Mezzanine::UI::HorizontalContainer</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1VerticalContainer.html">Mezzanine::UI::VerticalContainer</a> <br/>
 <br/>
</li>
</ul>
<h2><a class="anchor" id="UIStacked"></a>
Stacked Containers and Buttons</h2>
<p>The <a class="el" href="classMezzanine_1_1UI_1_1StackedContainer.html">Mezzanine::UI::StackedContainer</a> is a container class that stores children in explicit sets and intends for a single set to be rendered at a time. These containers are conceptually much more simple than PagedContainers, and primarily use the Mezzanine::UI::StackedButton class to handle the visibility of a given set of Widgets. The StackedContainer class does not enforce how the sets of Widgets are stored. However, sets of Widgets are expected to have an ID expressed as a UInt16 (or enum value within that range) and somehow possible to be bound to a StackButton. When that StackButton is activated, the bound set will become visible. In many cases you will want to make the previously visible set invisible, but that is ultimately up to the implementation. The following classes are examples of StackedContainers: <br/>
</p>
<ul>
<li><a class="el" href="classMezzanine_1_1UI_1_1MenuEntry.html">Mezzanine::UI::MenuEntry</a> <br/>
</li>
<li><a class="el" href="classMezzanine_1_1UI_1_1TabSet.html">Mezzanine::UI::TabSet</a> <br/>
 </li>
</ul>
</div></div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 26 2014 18:41:57 for MezzanineEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6</small></address>
</body>
</html>
