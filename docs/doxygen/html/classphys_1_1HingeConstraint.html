<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PhysGameEngine: phys::HingeConstraint Class Reference</title>
<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<!-- <link href="doxygen.css" rel="stylesheet" type="text/css"/> -->
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"></a>PhysGameEngine&#160;<span id="projectnumber">August 7, 2011</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacephys.html">phys</a>      </li>
      <li class="navelem"><a class="el" href="classphys_1_1HingeConstraint.html">HingeConstraint</a>      </li>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>phys::HingeConstraint Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="phys::HingeConstraint" --><!-- doxytag: inherits="phys::DualTransformConstraint" -->
<p>This is a constraint to be used to restrict the movement between two objects to angular rotation on a single axis.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="constraint_8h_source.html">constraint.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for phys::HingeConstraint:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classphys_1_1HingeConstraint.png" usemap="#phys::HingeConstraint_map" alt=""/>
  <map id="phys::HingeConstraint_map" name="phys::HingeConstraint_map">
<area href="classphys_1_1DualTransformConstraint.html" alt="phys::DualTransformConstraint" shape="rect" coords="0,56,185,80"/>
<area href="classphys_1_1TypedConstraint.html" alt="phys::TypedConstraint" shape="rect" coords="0,0,185,24"/>
</map>
 </div></div>

<p><a href="classphys_1_1HingeConstraint-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a90baa9ae0a582d42dc7757d14fd56299">EnableMotor</a> (bool EnableMotor, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> TargetVelocity, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> MaxMotorImpulse)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables(or Disables) the motor on the hinge and sets it's parameters.  <a href="#a90baa9ae0a582d42dc7757d14fd56299"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#acc2a3459cfbfef7dc7a211e3e7569358">GetAPivotRotation</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relative rotation for ActorA.  <a href="#acc2a3459cfbfef7dc7a211e3e7569358"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a4039ca63ae04464b6d29193348f1e1ee">GetBPivotRotation</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the relative rotation for ActorB.  <a href="#a4039ca63ae04464b6d29193348f1e1ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a2c3b1f4f5242b35ddb9b9e9d00f76812">GetLimitBiasFactor</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bias factor of the hinge (Not entirely certain hat this on is)  <a href="#a2c3b1f4f5242b35ddb9b9e9d00f76812"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ae633b31c347af338042e87738d7694ff">GetLimitHigh</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Upper Limit of the hinge.  <a href="#ae633b31c347af338042e87738d7694ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a2e467d00131cbfd61070c10749403546">GetLimitLow</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Lower Limit of the hinge.  <a href="#a2e467d00131cbfd61070c10749403546"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a65bfeef0326cd74fd3209940f5a14bbc">GetLimitRelaxationFactor</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Relaxation Factor of the hinge.  <a href="#a65bfeef0326cd74fd3209940f5a14bbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a9c87c6f21dd7959cfb5c3c7a63014171">GetLimitSoftness</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Softness of the hinge.  <a href="#a9c87c6f21dd7959cfb5c3c7a63014171"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a954621d35173f9de5d7f44760559040e">GetMaxMotorImpulse</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum amount of force the motor is to apply.  <a href="#a954621d35173f9de5d7f44760559040e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#abc2a2e5046276f3cdab285d87f969c8a">GetMotorEnabled</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables(or Disables) the motor on the hinge.  <a href="#abc2a2e5046276f3cdab285d87f969c8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#aeb1844f6bffeb72995e95b9ea25be3b7">GetMotorTargetVelocity</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Desired angular velocity of the motor.  <a href="#aeb1844f6bffeb72995e95b9ea25be3b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1Vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a099fec821a9194cd3c8268d764ec8ea8">GetPivotALocation</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of the hinge pivot relative to ActorA's Center of gravity.  <a href="#a099fec821a9194cd3c8268d764ec8ea8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ac210cfa2fe2d4d6b2bf9e626441546b7">GetPivotATransform</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1Vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a7b0ed683e55a1500e4c8cc6c04e8e140">GetPivotBLocation</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the location of the hinge pivot relative to ActorB's Center of gravity.  <a href="#a7b0ed683e55a1500e4c8cc6c04e8e140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1Transform.html">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ac328b988f24c490084fdb4567cd5df06">GetPivotBTransform</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a411bf09ec4aade190de13eb5a7f46b8a">GetUseFrameOffset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the stored value from the physics subsystem(bullet)  <a href="#a411bf09ec4aade190de13eb5a7f46b8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ab90932d63a43ba7a55afadbe396a0951">GetUseReferenceFrameA</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this Using Reference Frame A.  <a href="#ab90932d63a43ba7a55afadbe396a0951"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ad8d648a1c484966a828e7af71286e8b4">HasParamBeenSet</a> (<a class="el" href="namespacephys.html#aa1e7cf2d7efcaeaeac304f711e7564e8">ConstraintParam</a> Param, int Axis) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a725b932ea223d2218f0b7a03b61e1650">HingeConstraint</a> (<a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *ActorA, <a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *ActorB, const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;TransformA, const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;TransformB, bool UseReferenceFrameA=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Hinge with components of a tranform.  <a href="#a725b932ea223d2218f0b7a03b61e1650"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#aa4e74519af2c4773de038fb1ae2776eb">HingeConstraint</a> (<a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *ActorA, <a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *ActorB, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;PivotInA, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;PivotInB, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;AxisInA, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;AxisInB, bool UseReferenceFrameA=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Hinge constraint that will connect two actors together by their offsets.  <a href="#aa4e74519af2c4773de038fb1ae2776eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#af21f5ee3889f1bd9e70063c04db32af0">HingeConstraint</a> (<a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *ActorA, <a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *ActorB, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;VectorA, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;VectorB, const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;QuaternionA, const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;QuaternionB, bool UseReferenceFrameA=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Hinge with components of a tranform.  <a href="#af21f5ee3889f1bd9e70063c04db32af0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ab112696e53f61f57f4ca53b299e9ef87">HingeConstraint</a> (<a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *ActorA, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;PivotInA, const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;AxisInA, bool UseReferenceFrameA=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Hinge constraint that will attach an actor to a point in world space.  <a href="#ab112696e53f61f57f4ca53b299e9ef87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a63ca807d27fd21a24b4bcaa642febc77">ProtoDeSerialize</a> (const <a class="el" href="classphys_1_1xml_1_1Node.html">xml::Node</a> &amp;OneNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the data stored in an XML and overwrite this instance of this object with it.  <a href="#a63ca807d27fd21a24b4bcaa642febc77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a04fac5312ddf891adcfff67e98f75861">ProtoSerialize</a> (<a class="el" href="classphys_1_1xml_1_1Node.html">xml::Node</a> &amp;CurrentRoot) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this class to an <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">xml::Node</a> ready for serialization.  <a href="#a04fac5312ddf891adcfff67e98f75861"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacephys.html#aa03900411993de7fbfec4789bc1d392e">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a64804b6c98ed930f9acb05414defcdcc">SerializableName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the the XML tag this class will leave behind as its instances are serialized.  <a href="#a64804b6c98ed930f9acb05414defcdcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a7f597ee71540986b446a2771f25b791c">SetAPivotRotation</a> (const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;Rotation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set The relative rotation of ActorA.  <a href="#a7f597ee71540986b446a2771f25b791c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a4eb0343f43b86fabef1fbe43857f9df8">SetAxis</a> (const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;AxisInA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the axis on which this constraint acts.  <a href="#a4eb0343f43b86fabef1fbe43857f9df8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ae7c0db15c76fa1f7d78ca60d3c7368cd">SetBPivotRotation</a> (const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;Rotation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set The relative rotation of ActorB.  <a href="#ae7c0db15c76fa1f7d78ca60d3c7368cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a2267ee2b124aae7a35d70f48831548bc">SetLimit</a> (<a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> Low, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> High, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> Softness=0.9, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> BiasFactor=0.3, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> RelaxationFactor=1.0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angle limits of the constraint in radians.  <a href="#a2267ee2b124aae7a35d70f48831548bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ae3038cabdde1b676c0e6b9665807c917">SetMotorTarget</a> (const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;QuatAInB, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> Dt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a Target Velocity, indirectly using the angle stored in a quaternion.  <a href="#ae3038cabdde1b676c0e6b9665807c917"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ac9eb6207043906b972c8ad897ead15df">SetMotorTarget</a> (<a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> TargetAngle, <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> Dt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Rotational velocity in a more direct fashion.  <a href="#ac9eb6207043906b972c8ad897ead15df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a6baadfc607e0d7c2167c9201bd4f8bdf">SetPivotALocation</a> (const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;Location)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set The relative location of the hinge pivot from ActorA's Center of gravity.  <a href="#a6baadfc607e0d7c2167c9201bd4f8bdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#af6fd3ac147683eecb2c98c60c58f386c">SetPivotATransform</a> (const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;TranA)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#abaf055b50289aae35e7ea9f796677b18">SetPivotBLocation</a> (const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;Location)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set The relative location of the hinge pivot from ActorB's Center of gravity.  <a href="#abaf055b50289aae35e7ea9f796677b18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a79ef3dc47fa94a7a9f98f7934e786a6b">SetPivotBTransform</a> (const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;TranB)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a3452b2c810cc0fb814f1158306e2b155">SetUseFrameOffset</a> (bool FrameOffset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stored value for UseFrameOffset on this hinge in the physics subsystem(bullet)  <a href="#a3452b2c810cc0fb814f1158306e2b155"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ac1771e0f44124fc84b2f847fde10cb15">SetUseReferenceFrameA</a> (bool UseReferenceFrameA=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change whether this is Using Reference Frame A or not.  <a href="#ac1771e0f44124fc84b2f847fde10cb15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1TypedConstraint.html#a26261a4055e84e104c58d84eea5667c2">TypedConstraint::AxisList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#aceb0c3739cbde8692e4aad5695de9306">ValidAngularAxis</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1TypedConstraint.html#a26261a4055e84e104c58d84eea5667c2">TypedConstraint::AxisList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#ab3316794eec67ca2a9c1b11925e64e23">ValidLinearAxis</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphys_1_1TypedConstraint.html#a4c2dcea3fbb764e454840329126d034e">TypedConstraint::ParamList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a7fd949b157deabe3b955fd618134b1de">ValidParamOnAxis</a> (int Axis) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#a242cdfc8ab59d608bfbd9290119d81d9">~HingeConstraint</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor.  <a href="#a242cdfc8ab59d608bfbd9290119d81d9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual btTypedConstraint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#afd52bcc691313cc175d0a409d5594df2">GetConstraintBase</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa4e4f1595d6420f21449d5e3b730f49"></a><!-- doxytag: member="phys::HingeConstraint::Hinge" ref="afa4e4f1595d6420f21449d5e3b730f49" args="" -->
btHingeConstraint *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphys_1_1HingeConstraint.html#afa4e4f1595d6420f21449d5e3b730f49">Hinge</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bullet constraint that this class encapsulates. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is a constraint to be used to restrict the movement between two objects to angular rotation on a single axis. </p>
<p>As the name suggests, this constraint essentially works like a door Hinge. </p>

<p>Definition at line <a class="el" href="constraint_8h_source.html#l00967">967</a> of file <a class="el" href="constraint_8h_source.html">constraint.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa4e74519af2c4773de038fb1ae2776eb"></a><!-- doxytag: member="phys::HingeConstraint::HingeConstraint" ref="aa4e74519af2c4773de038fb1ae2776eb" args="(ActorRigid *ActorA, ActorRigid *ActorB, const Vector3 &amp;PivotInA, const Vector3 &amp;PivotInB, const Vector3 &amp;AxisInA, const Vector3 &amp;AxisInB, bool UseReferenceFrameA=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">phys::HingeConstraint::HingeConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *&#160;</td>
          <td class="paramname"><em>ActorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *&#160;</td>
          <td class="paramname"><em>ActorB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>PivotInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>PivotInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>AxisInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>AxisInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UseReferenceFrameA</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a Hinge constraint that will connect two actors together by their offsets. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ActorA</td><td>The first actor to apply this constraint to. </td></tr>
    <tr><td class="paramname">ActorB</td><td>The second actor to apply this constraint to. </td></tr>
    <tr><td class="paramname">PivotA</td><td>The location in ActorA's local space to apply the constraint to. </td></tr>
    <tr><td class="paramname">PivotB</td><td>The location in ActorB's local space to apply the constraint to. </td></tr>
    <tr><td class="paramname">AxisInA</td><td>The axis(for ActorA) on which the hinge is to act. For example, a door hinge would be (0.0,1.0,0.0), aka the positive Y axis. </td></tr>
    <tr><td class="paramname">AxisInB</td><td>The axis(for ActorB) on which the hinge is to act. For example, a door hinge would be (0.0,1.0,0.0), aka the positive Y axis. </td></tr>
    <tr><td class="paramname">UseReferenceFrameA</td><td>By default, this constraint uses ActorB's local space as the reference for certain values, such as the rotational limits. This simply controls whether or not it should use ActorA's local space instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab112696e53f61f57f4ca53b299e9ef87"></a><!-- doxytag: member="phys::HingeConstraint::HingeConstraint" ref="ab112696e53f61f57f4ca53b299e9ef87" args="(ActorRigid *ActorA, const Vector3 &amp;PivotInA, const Vector3 &amp;AxisInA, bool UseReferenceFrameA=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">phys::HingeConstraint::HingeConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *&#160;</td>
          <td class="paramname"><em>ActorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>PivotInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>AxisInA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UseReferenceFrameA</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a Hinge constraint that will attach an actor to a point in world space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ActorA</td><td>The actor to apply this constraint to. </td></tr>
    <tr><td class="paramname">PivotInA</td><td>The point in the object's(ActorA) local space where the constraint is to be attached to world space. </td></tr>
    <tr><td class="paramname">AxisInA</td><td>The axis(for ActorA) on which the hinge is to act. For example, a door hinge would be (0.0,1.0,0.0), aka the positive Y axis. </td></tr>
    <tr><td class="paramname">UseReferenceFrameA</td><td>By default, this constraint uses ActorB's local space as the reference for certain values, such as the rotational limits. This simply controls whether or not it should use ActorA's local space instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af21f5ee3889f1bd9e70063c04db32af0"></a><!-- doxytag: member="phys::HingeConstraint::HingeConstraint" ref="af21f5ee3889f1bd9e70063c04db32af0" args="(ActorRigid *ActorA, ActorRigid *ActorB, const Vector3 &amp;VectorA, const Vector3 &amp;VectorB, const Quaternion &amp;QuaternionA, const Quaternion &amp;QuaternionB, bool UseReferenceFrameA=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">phys::HingeConstraint::HingeConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *&#160;</td>
          <td class="paramname"><em>ActorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *&#160;</td>
          <td class="paramname"><em>ActorB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>VectorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>VectorB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>QuaternionA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>QuaternionB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UseReferenceFrameA</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a Hinge with components of a tranform. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ActorA</td><td>The first actor to apply this constraint to. </td></tr>
    <tr><td class="paramname">ActorB</td><td>The second actor to apply this constraint to. </td></tr>
    <tr><td class="paramname">VectorA</td><td>The location component of <a class="el" href="classphys_1_1Transform.html" title="Stores information about relative location and rotation in 3d space.">Transform</a> A </td></tr>
    <tr><td class="paramname">VectorB</td><td>The location component of <a class="el" href="classphys_1_1Transform.html" title="Stores information about relative location and rotation in 3d space.">Transform</a> B </td></tr>
    <tr><td class="paramname">QuaternionA</td><td>The rotation component of <a class="el" href="classphys_1_1Transform.html" title="Stores information about relative location and rotation in 3d space.">Transform</a> A </td></tr>
    <tr><td class="paramname">QuaternionB</td><td>The rotation component of <a class="el" href="classphys_1_1Transform.html" title="Stores information about relative location and rotation in 3d space.">Transform</a> B </td></tr>
    <tr><td class="paramname">UseReferenceFrameA</td><td>By default, this constraint uses ActorB's local space as the reference for certain values, such as the rotational limits. This simply controls whether or not it should use ActorA's local space instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a725b932ea223d2218f0b7a03b61e1650"></a><!-- doxytag: member="phys::HingeConstraint::HingeConstraint" ref="a725b932ea223d2218f0b7a03b61e1650" args="(ActorRigid *ActorA, ActorRigid *ActorB, const Transform &amp;TransformA, const Transform &amp;TransformB, bool UseReferenceFrameA=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">phys::HingeConstraint::HingeConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *&#160;</td>
          <td class="paramname"><em>ActorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphys_1_1ActorRigid.html">ActorRigid</a> *&#160;</td>
          <td class="paramname"><em>ActorB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>TransformA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>TransformB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UseReferenceFrameA</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a Hinge with components of a tranform. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ActorA</td><td>The first actor to apply this constraint to. </td></tr>
    <tr><td class="paramname">ActorB</td><td>The second actor to apply this constraint to. </td></tr>
    <tr><td class="paramname">TransformA</td><td>The location component of <a class="el" href="classphys_1_1Transform.html" title="Stores information about relative location and rotation in 3d space.">Transform</a> A </td></tr>
    <tr><td class="paramname">TransformB</td><td>The location component of <a class="el" href="classphys_1_1Transform.html" title="Stores information about relative location and rotation in 3d space.">Transform</a> B </td></tr>
    <tr><td class="paramname">UseReferenceFrameA</td><td>By default, this constraint uses ActorB's local space as the reference for certain values, such as the rotational limits. This simply controls whether or not it should use ActorA's local space instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a242cdfc8ab59d608bfbd9290119d81d9"></a><!-- doxytag: member="phys::HingeConstraint::~HingeConstraint" ref="a242cdfc8ab59d608bfbd9290119d81d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual phys::HingeConstraint::~HingeConstraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Class destructor. </p>
<p>The class destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a90baa9ae0a582d42dc7757d14fd56299"></a><!-- doxytag: member="phys::HingeConstraint::EnableMotor" ref="a90baa9ae0a582d42dc7757d14fd56299" args="(bool EnableMotor, Real TargetVelocity, Real MaxMotorImpulse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::EnableMotor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>EnableMotor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>TargetVelocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>MaxMotorImpulse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables(or Disables) the motor on the hinge and sets it's parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">EnableMotor</td><td>Sets whether or not the motor on this constraint is enabled. </td></tr>
    <tr><td class="paramname">TargetVelocity</td><td>The desired velocity of rotation the motor will have. This may or may not be achieved based on obstructions in the simulation. </td></tr>
    <tr><td class="paramname">MaxMotorImpulse</td><td>The maximum amount of force the motor is to apply to try and reach it's target velocity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc2a3459cfbfef7dc7a211e3e7569358"></a><!-- doxytag: member="phys::HingeConstraint::GetAPivotRotation" ref="acc2a3459cfbfef7dc7a211e3e7569358" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> phys::HingeConstraint::GetAPivotRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the relative rotation for ActorA. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classphys_1_1Quaternion.html" title="This is used to store information about rotation in 3d space.">Quaternion</a> that has the rotation</dd></dl>
<p>This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

</div>
</div>
<a class="anchor" id="a4039ca63ae04464b6d29193348f1e1ee"></a><!-- doxytag: member="phys::HingeConstraint::GetBPivotRotation" ref="a4039ca63ae04464b6d29193348f1e1ee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> phys::HingeConstraint::GetBPivotRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the relative rotation for ActorB. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classphys_1_1Quaternion.html" title="This is used to store information about rotation in 3d space.">Quaternion</a> that has the rotation</dd></dl>
<p>This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

</div>
</div>
<a class="anchor" id="afd52bcc691313cc175d0a409d5594df2"></a><!-- doxytag: member="phys::HingeConstraint::GetConstraintBase" ref="afd52bcc691313cc175d0a409d5594df2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btTypedConstraint* phys::HingeConstraint::GetConstraintBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the Bullet constraint that this class encapsulates. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the btTypedConstraint that stores the underlying constraint. </dd></dl>
 
<p>Implements <a class="el" href="classphys_1_1TypedConstraint.html#ab3bd2baa58d3f0d812401cbf59159a8b">phys::TypedConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a2c3b1f4f5242b35ddb9b9e9d00f76812"></a><!-- doxytag: member="phys::HingeConstraint::GetLimitBiasFactor" ref="a2c3b1f4f5242b35ddb9b9e9d00f76812" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> phys::HingeConstraint::GetLimitBiasFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the bias factor of the hinge (Not entirely certain hat this on is) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A real containing the bias Factor </dd></dl>

</div>
</div>
<a class="anchor" id="ae633b31c347af338042e87738d7694ff"></a><!-- doxytag: member="phys::HingeConstraint::GetLimitHigh" ref="ae633b31c347af338042e87738d7694ff" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> phys::HingeConstraint::GetLimitHigh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Upper Limit of the hinge. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A real containing the Higher Limit </dd></dl>

</div>
</div>
<a class="anchor" id="a2e467d00131cbfd61070c10749403546"></a><!-- doxytag: member="phys::HingeConstraint::GetLimitLow" ref="a2e467d00131cbfd61070c10749403546" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> phys::HingeConstraint::GetLimitLow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Lower Limit of the hinge. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A real containing the Lower Limit </dd></dl>

</div>
</div>
<a class="anchor" id="a65bfeef0326cd74fd3209940f5a14bbc"></a><!-- doxytag: member="phys::HingeConstraint::GetLimitRelaxationFactor" ref="a65bfeef0326cd74fd3209940f5a14bbc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> phys::HingeConstraint::GetLimitRelaxationFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Relaxation Factor of the hinge. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A real containing the Relaxation Factor </dd></dl>

</div>
</div>
<a class="anchor" id="a9c87c6f21dd7959cfb5c3c7a63014171"></a><!-- doxytag: member="phys::HingeConstraint::GetLimitSoftness" ref="a9c87c6f21dd7959cfb5c3c7a63014171" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> phys::HingeConstraint::GetLimitSoftness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the Softness of the hinge. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A real containing the Softness </dd></dl>

</div>
</div>
<a class="anchor" id="a954621d35173f9de5d7f44760559040e"></a><!-- doxytag: member="phys::HingeConstraint::GetMaxMotorImpulse" ref="a954621d35173f9de5d7f44760559040e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> phys::HingeConstraint::GetMaxMotorImpulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum amount of force the motor is to apply. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">MaxMotorImpulse</td><td>The maximum amount of force the motor is to apply to try and reach it's target velocity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc2a2e5046276f3cdab285d87f969c8a"></a><!-- doxytag: member="phys::HingeConstraint::GetMotorEnabled" ref="abc2a2e5046276f3cdab285d87f969c8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool phys::HingeConstraint::GetMotorEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables(or Disables) the motor on the hinge. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">EnableMotor</td><td>Sets whether or not the motor on this constraint is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb1844f6bffeb72995e95b9ea25be3b7"></a><!-- doxytag: member="phys::HingeConstraint::GetMotorTargetVelocity" ref="aeb1844f6bffeb72995e95b9ea25be3b7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a> phys::HingeConstraint::GetMotorTargetVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Desired angular velocity of the motor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetVelocity</td><td>The Desired velocity </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Causes segfaults in some tests. </dd></dl>

</div>
</div>
<a class="anchor" id="a099fec821a9194cd3c8268d764ec8ea8"></a><!-- doxytag: member="phys::HingeConstraint::GetPivotALocation" ref="a099fec821a9194cd3c8268d764ec8ea8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1Vector3.html">Vector3</a> phys::HingeConstraint::GetPivotALocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the location of the hinge pivot relative to ActorA's Center of gravity. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classphys_1_1Vector3.html" title="This is used to represent a point in space, or a vector through space.">Vector3</a> with the pivot location.</dd></dl>
<p>This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

<p>Reimplemented from <a class="el" href="classphys_1_1DualTransformConstraint.html#a0458c4b3d9bad6aa8b725a35e922ca05">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="ac210cfa2fe2d4d6b2bf9e626441546b7"></a><!-- doxytag: member="phys::HingeConstraint::GetPivotATransform" ref="ac210cfa2fe2d4d6b2bf9e626441546b7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1Transform.html">Transform</a> phys::HingeConstraint::GetPivotATransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
 
<p>Implements <a class="el" href="classphys_1_1DualTransformConstraint.html#a2c6e75dca5399af5ff59a9a11f22b50b">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a7b0ed683e55a1500e4c8cc6c04e8e140"></a><!-- doxytag: member="phys::HingeConstraint::GetPivotBLocation" ref="a7b0ed683e55a1500e4c8cc6c04e8e140" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1Vector3.html">Vector3</a> phys::HingeConstraint::GetPivotBLocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the location of the hinge pivot relative to ActorB's Center of gravity. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classphys_1_1Vector3.html" title="This is used to represent a point in space, or a vector through space.">Vector3</a> with the pivot location.</dd></dl>
<p>This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

<p>Reimplemented from <a class="el" href="classphys_1_1DualTransformConstraint.html#a7a51a331dea27522f6d596bf3aff5de4">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="ac328b988f24c490084fdb4567cd5df06"></a><!-- doxytag: member="phys::HingeConstraint::GetPivotBTransform" ref="ac328b988f24c490084fdb4567cd5df06" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1Transform.html">Transform</a> phys::HingeConstraint::GetPivotBTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
 
<p>Implements <a class="el" href="classphys_1_1DualTransformConstraint.html#a7ef9820bbfa2f0d70019743e16cb2618">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a411bf09ec4aade190de13eb5a7f46b8a"></a><!-- doxytag: member="phys::HingeConstraint::GetUseFrameOffset" ref="a411bf09ec4aade190de13eb5a7f46b8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool phys::HingeConstraint::GetUseFrameOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the stored value from the physics subsystem(bullet) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a True or false. </dd></dl>

</div>
</div>
<a class="anchor" id="ab90932d63a43ba7a55afadbe396a0951"></a><!-- doxytag: member="phys::HingeConstraint::GetUseReferenceFrameA" ref="ab90932d63a43ba7a55afadbe396a0951" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool phys::HingeConstraint::GetUseReferenceFrameA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is this Using Reference Frame A. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A the value UseReferenceFrameA is set to internally. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8d648a1c484966a828e7af71286e8b4"></a><!-- doxytag: member="phys::HingeConstraint::HasParamBeenSet" ref="ad8d648a1c484966a828e7af71286e8b4" args="(ConstraintParam Param, int Axis) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool phys::HingeConstraint::HasParamBeenSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephys.html#aa1e7cf2d7efcaeaeac304f711e7564e8">ConstraintParam</a>&#160;</td>
          <td class="paramname"><em>Param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
 
<p>Implements <a class="el" href="classphys_1_1TypedConstraint.html#a849e7b91306f444cb8c73d52707a9521">phys::TypedConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a63ca807d27fd21a24b4bcaa642febc77"></a><!-- doxytag: member="phys::HingeConstraint::ProtoDeSerialize" ref="a63ca807d27fd21a24b4bcaa642febc77" args="(const xml::Node &amp;OneNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::ProtoDeSerialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1xml_1_1Node.html">xml::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>OneNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take the data stored in an XML and overwrite this instance of this object with it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">OneNode</td><td>and <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">xml::Node</a> containing the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A precondition of using this is that all of the actors intended for use must already be Deserialized. </dd></dl>

<p>Reimplemented from <a class="el" href="classphys_1_1DualTransformConstraint.html#a72bb3a5f35dffc4b6b9b860eb232b7a3">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a04fac5312ddf891adcfff67e98f75861"></a><!-- doxytag: member="phys::HingeConstraint::ProtoSerialize" ref="a04fac5312ddf891adcfff67e98f75861" args="(xml::Node &amp;CurrentRoot) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::ProtoSerialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphys_1_1xml_1_1Node.html">xml::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>CurrentRoot</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert this class to an <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">xml::Node</a> ready for serialization. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">CurrentRoot</td><td>The point in the XML hierarchy that all this vectorw should be appended to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classphys_1_1DualTransformConstraint.html#aa1e3919874eceedb6ba708af4d540b9b">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a64804b6c98ed930f9acb05414defcdcc"></a><!-- doxytag: member="phys::HingeConstraint::SerializableName" ref="a64804b6c98ed930f9acb05414defcdcc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacephys.html#aa03900411993de7fbfec4789bc1d392e">String</a> phys::HingeConstraint::SerializableName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of the the XML tag this class will leave behind as its instances are serialized. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A string containing "HingeConstraint" </dd></dl>

<p>Reimplemented from <a class="el" href="classphys_1_1DualTransformConstraint.html#ad810321a7395cbd5cc0ba8cac0d3b136">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a7f597ee71540986b446a2771f25b791c"></a><!-- doxytag: member="phys::HingeConstraint::SetAPivotRotation" ref="a7f597ee71540986b446a2771f25b791c" args="(const Quaternion &amp;Rotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetAPivotRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>Rotation</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set The relative rotation of ActorA. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Rotation</td><td>The new rotation amount for A</td></tr>
  </table>
  </dd>
</dl>
<p>Ultimately this information winds up being stored in the TransformA. This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

</div>
</div>
<a class="anchor" id="a4eb0343f43b86fabef1fbe43857f9df8"></a><!-- doxytag: member="phys::HingeConstraint::SetAxis" ref="a4eb0343f43b86fabef1fbe43857f9df8" args="(const Vector3 &amp;AxisInA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetAxis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>AxisInA</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the axis on which this constraint acts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">AxisInA</td><td>A vector3 representing the axis to be used with this constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7c0db15c76fa1f7d78ca60d3c7368cd"></a><!-- doxytag: member="phys::HingeConstraint::SetBPivotRotation" ref="ae7c0db15c76fa1f7d78ca60d3c7368cd" args="(const Quaternion &amp;Rotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetBPivotRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>Rotation</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set The relative rotation of ActorB. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">otation</td><td>The new rotation amount for B</td></tr>
  </table>
  </dd>
</dl>
<p>Ultimately this information winds up being stored in the TransformB. This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

</div>
</div>
<a class="anchor" id="a2267ee2b124aae7a35d70f48831548bc"></a><!-- doxytag: member="phys::HingeConstraint::SetLimit" ref="a2267ee2b124aae7a35d70f48831548bc" args="(Real Low, Real High, Real Softness=0.9, Real BiasFactor=0.3, Real RelaxationFactor=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>Low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>High</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>Softness</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>BiasFactor</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>RelaxationFactor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the angle limits of the constraint in radians. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Low</td><td>The minimum angle limit for the constraint in radians. </td></tr>
    <tr><td class="paramname">High</td><td>The maximum angle limit for the constraint in radians. </td></tr>
    <tr><td class="paramname">Softness</td><td>Not currently used internally. </td></tr>
    <tr><td class="paramname">BiasFactor</td><td>Multiplier for the constraint error, constraint appears more "soft" when closer to zero. </td></tr>
    <tr><td class="paramname">RelaxationFactor</td><td>The amount of bounce to apply when the constraint reaches it's limit. Range: 0.0-1.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9eb6207043906b972c8ad897ead15df"></a><!-- doxytag: member="phys::HingeConstraint::SetMotorTarget" ref="ac9eb6207043906b972c8ad897ead15df" args="(Real TargetAngle, Real Dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetMotorTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>TargetAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>Dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Rotational velocity in a more direct fashion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">TargetAngle</td><td>The desired angle in radians. </td></tr>
    <tr><td class="paramname">Dt</td><td>The Desired <a class="el" href="structphys_1_1Time.html" title="A container for the metrics of time relevant for the timer class.">Time</a> steps that the target rotational velocity should be reached in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3038cabdde1b676c0e6b9665807c917"></a><!-- doxytag: member="phys::HingeConstraint::SetMotorTarget" ref="ae3038cabdde1b676c0e6b9665807c917" args="(const Quaternion &amp;QuatAInB, Real Dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetMotorTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>QuatAInB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephys.html#af7eb897198d265b8e868f45240230d5f">Real</a>&#160;</td>
          <td class="paramname"><em>Dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a Target Velocity, indirectly using the angle stored in a quaternion. </p>
<p>Is implemented in terms of <a class="el" href="classphys_1_1HingeConstraint.html#ac9eb6207043906b972c8ad897ead15df" title="Set the Rotational velocity in a more direct fashion.">SetMotorTarget(Real, Real)</a>; </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">QuatAInB</td><td>The angle a quaternion relative to the two objects in the constraint. </td></tr>
    <tr><td class="paramname">Dt</td><td>The Desired <a class="el" href="structphys_1_1Time.html" title="A container for the metrics of time relevant for the timer class.">Time</a> steps that the target rotational velocity should be reached in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6baadfc607e0d7c2167c9201bd4f8bdf"></a><!-- doxytag: member="phys::HingeConstraint::SetPivotALocation" ref="a6baadfc607e0d7c2167c9201bd4f8bdf" args="(const Vector3 &amp;Location)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetPivotALocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Location</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set The relative location of the hinge pivot from ActorA's Center of gravity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Location</td><td>The New value for PivotA</td></tr>
  </table>
  </dd>
</dl>
<p>Ultimately this information winds up being stored in the TransformA. This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

<p>Reimplemented from <a class="el" href="classphys_1_1DualTransformConstraint.html#a0e074a05eeb464ebda332ac2f09c9412">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="af6fd3ac147683eecb2c98c60c58f386c"></a><!-- doxytag: member="phys::HingeConstraint::SetPivotATransform" ref="af6fd3ac147683eecb2c98c60c58f386c" args="(const Transform &amp;TranA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetPivotATransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>TranA</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
 
<p>Implements <a class="el" href="classphys_1_1DualTransformConstraint.html#af2ff2bca0d94f113ef47a8dfddeadb3a">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="abaf055b50289aae35e7ea9f796677b18"></a><!-- doxytag: member="phys::HingeConstraint::SetPivotBLocation" ref="abaf055b50289aae35e7ea9f796677b18" args="(const Vector3 &amp;Location)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetPivotBLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>Location</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set The relative location of the hinge pivot from ActorB's Center of gravity. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Location</td><td>The New value for PivotB</td></tr>
  </table>
  </dd>
</dl>
<p>Ultimately this information winds up being stored in the TransformB. This implements a more Hinge specific version of the logic than <a class="el" href="classphys_1_1DualTransformConstraint.html" title="All constraints that track rotation and location of the Pivot relative to each Actor inherit from thi...">DualTransformConstraint</a> for efficiency reasons. </p>

<p>Reimplemented from <a class="el" href="classphys_1_1DualTransformConstraint.html#aa9e0ebd04572d18f344b701637270248">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a79ef3dc47fa94a7a9f98f7934e786a6b"></a><!-- doxytag: member="phys::HingeConstraint::SetPivotBTransform" ref="a79ef3dc47fa94a7a9f98f7934e786a6b" args="(const Transform &amp;TranB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetPivotBTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphys_1_1Transform.html">Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>TranB</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
 
<p>Implements <a class="el" href="classphys_1_1DualTransformConstraint.html#acda6a28b585c52fd7da1e79d85f4cf53">phys::DualTransformConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a3452b2c810cc0fb814f1158306e2b155"></a><!-- doxytag: member="phys::HingeConstraint::SetUseFrameOffset" ref="a3452b2c810cc0fb814f1158306e2b155" args="(bool FrameOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetUseFrameOffset </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>FrameOffset</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the stored value for UseFrameOffset on this hinge in the physics subsystem(bullet) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">FrameOffset</td><td>The new desired value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1771e0f44124fc84b2f847fde10cb15"></a><!-- doxytag: member="phys::HingeConstraint::SetUseReferenceFrameA" ref="ac1771e0f44124fc84b2f847fde10cb15" args="(bool UseReferenceFrameA=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void phys::HingeConstraint::SetUseReferenceFrameA </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>UseReferenceFrameA</em> = <code>false</code></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change whether this is Using Reference Frame A or not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">UseReferenceFrameA</td><td>Whether certain math be performed from the perspective of Actor A or Actor B (we think this is the case, but we have not test thoroughly) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aceb0c3739cbde8692e4aad5695de9306"></a><!-- doxytag: member="phys::HingeConstraint::ValidAngularAxis" ref="aceb0c3739cbde8692e4aad5695de9306" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1TypedConstraint.html#a26261a4055e84e104c58d84eea5667c2">TypedConstraint::AxisList</a> phys::HingeConstraint::ValidAngularAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get A list sorted (low to high) of all axis that operate Angularly (that lock sliding/translation) </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Odd behaviors, maybe even undefined behavior can happen if This returns a matching Axis to a Linear Axis. Any given axis should only be one or the other </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An Axislist with the Axis this constraint Angularly supports. </dd></dl>
 
<p>Implements <a class="el" href="classphys_1_1TypedConstraint.html#afd67483ff73a4b8ffef17c149b8a6cfa">phys::TypedConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="ab3316794eec67ca2a9c1b11925e64e23"></a><!-- doxytag: member="phys::HingeConstraint::ValidLinearAxis" ref="ab3316794eec67ca2a9c1b11925e64e23" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1TypedConstraint.html#a26261a4055e84e104c58d84eea5667c2">TypedConstraint::AxisList</a> phys::HingeConstraint::ValidLinearAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a sorted (low to high) list of all axis that operate linearly (that lock sliding/translation) </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Odd behaviors, maybe even undefined behavior can happen if This returns a matching Axis to a Linear Axis. Any given axis should only be one or the other </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An Axislist with the Axis this constraint linearly supports. </dd></dl>
 
<p>Implements <a class="el" href="classphys_1_1TypedConstraint.html#af9d5a6630d5f384825388a1e73c88b3a">phys::TypedConstraint</a>.</p>

</div>
</div>
<a class="anchor" id="a7fd949b157deabe3b955fd618134b1de"></a><!-- doxytag: member="phys::HingeConstraint::ValidParamOnAxis" ref="a7fd949b157deabe3b955fd618134b1de" args="(int Axis) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphys_1_1TypedConstraint.html#a4c2dcea3fbb764e454840329126d034e">TypedConstraint::ParamList</a> phys::HingeConstraint::ValidParamOnAxis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Axis</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a sorted (low to high) list of Parameters that are valid on this Axis. </p>
<p>Parameters returned from this will work on the given axis even if they are not valid on any other axis. There is no guarantee that the Parameters will be uniquely stored per an axis. There is no guarantee that changing one parameter will not change another. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Axis</td><td>the Axis to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A Paramlist with all the valid parameters for this axis. </dd></dl>
 
<p>Implements <a class="el" href="classphys_1_1TypedConstraint.html#af9f4c03dbba0d55e60dce341dbdc1105">phys::TypedConstraint</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="constraint_8h_source.html">constraint.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 2 2011 21:58:29 for PhysGameEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3</small></address>
</body>
</html>
