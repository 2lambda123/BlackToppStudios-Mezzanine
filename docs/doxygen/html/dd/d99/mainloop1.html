<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PhysGameEngine: Main Loop Structure and Flow</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../index.html">Physgame</a>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="mainloop1">Main Loop Structure and Flow </a></h1><p>The MainLoop is heart of most vidoe games and simulations.</p>
<h2><a class="anchor" id="mainloopoverview1">
Main loop Overview</a></h2>
<p>The Main loop runs in <a class="el" href="../../da/ddf/classphys_1_1World.html#af1d9e36d43f5e50543fa2351a32c8362" title="This Function house the main loop.">World.MainLoop()</a> which is called by default from <a class="el" href="../../da/ddf/classphys_1_1World.html#a21cc36be08a61f40619584d4c438936b">World::GameInit()</a>. By default this Method also starts the render, the physics andthe input systems. It does very little on it's own. It uses the default callback manager (which you can swap out if you want), which is the callback manager point to by <a class="el" href="../../da/ddf/classphys_1_1World.html#a22a1624c63198f49fdf8e448881bdb2e" title="This is a point to the default Call BackManager.">World::CallBacks</a> . Once started it runs the callbacks present in the callback manager until one of them returns false. It has a pretty specific work flow. Starting with input, then physics, then rendering. There is a callback before and after each of these tasks. <br/>
 <br/>
 The user input task is never started if there is no Pre or Post callback set. It won't crash or throw any weird error condtions, it was specifically designed this way. This allows the input buffering to be turned off by simply removing the callbacks. This might not sound like much, but if you simply don't need input this can be a little performance bump. It sounds even better when we say it works the same way for physics. If you do not have a pre or post physic callback set physics simply is not run. This allows for easy control over the state of motion in a world. Currently Rendering is performed each iteration of the main loop, regardless of what Callbacks are set. This may be changed at some point in the future, but no immediate plans to change it are in the works. <br/>
 <br/>
 One iteration of the main loops is about 1/60 of a second (by default) and will render 1 frame and step physics about 1/60 (1/62.5 usually) of a second. Currently there is no way to uncap the framerate, we did not see a need for more (but the cap can be adjusted using <a class="el" href="../../da/ddf/classphys_1_1World.html#ad95b5a5ad73e0a05826b5bd834876333" title="This sets a new Target Time.">World::SetTargetFrameTime</a> or <a class="el" href="../../da/ddf/classphys_1_1World.html#a76dfcde35392291aafd6eb1a64b3c95c" title="This sets a new Target Frame Rate.">World::SetTargetFrameRate</a> ). Situations with low performance should automatically be handled but increasing the size of physics steps and automatically not rendering frames when not appropriate. There will be fewer calls on callbacks, but the engine will not inhibit gameplay below the the target framerate. <br/>
 </p>
<h2><a class="anchor" id="callbacks1">
1) Input Callbacks and Buffering</a></h2>
<p>User input is the first task performed each main loop. This was done because in most games and simulations everything depends on the user input. </p>
<h3><a class="anchor" id="input1">
1.A) PreInputCallback</a></h3>
<p>This can be set using the function in PhysWorldCallBackManager that have "PreInput" in their names. This is a great place to to do begining of loop items, like gathering data for computer controlled characters, checking if game goals are met, and other items that needs to be done it iteration of the game loop and don't directly relate to physics or Rendering. </p>
<h3><a class="anchor" id="input2">
1.B) Input Buffering</a></h3>
<p>During this step Input events are gathered fromt the input Subsystem (which could be any of a number of user input libraries), which are ultimately made by the Operating System and processed into <a class="el" href="../../d7/df5/classphys_1_1EventUserInput.html" title="This is a container for MetaCodes that is used in the physEventManager.">EventUserInput</a> objects, and placed in the Default event manager ( check the pointer <a class="el" href="../../da/ddf/classphys_1_1World.html#ad0b13f1f3caf0342f56671b522543453" title="This is the default pointer to the Event Manager.">World::Events</a> ). </p>
<h3><a class="anchor" id="input3">
1.C) PostInputCallback</a></h3>
<p>This callback is your first chance to access the userinput Events and try to use them. This callback can be managed by using methods in PhysWorldCallBackManager that have "PostInput" in their names. The functionality of this Callback slightly overlaps with the Prephysics Callbacks due to the timing of using them both. If both are used, one will be called immediately after the other. <br/>
 </p>
<h2><a class="anchor" id="callbacks2">
2) Physics callbacks and Event Buffering</a></h2>
<p>This step runs between user input and rendering to allow for changes caused by user input to be immediately visible to the user. </p>
<h3><a class="anchor" id="physics1">
2.A) PrePhysicsCallback</a></h3>
<p>The funtionality of this callback overlaps a great deal with the PostInputCallBack, but they both still exist to make organization easier when needed. You probably should have figured out by now how the Callbackmanager functions are named, the ones for this are ituitively named with "PrePhysics" in their name. </p>
<h3><a class="anchor" id="physics2">
2.B) Physics calculations and Event Buffering</a></h3>
<p>Physics will be run here, but currently is not fully implemented. But eventually physics event will be generated here. Including a system for checking for certain types of collisions. </p>
<h3><a class="anchor" id="physics3">
2.C) PostPhysicsCallback</a></h3>
<p>This Callback is you first chance to work with the physics events just generated. This is a good place to check if you want items to adjust hitpoints, explode, die or take some other action based on physics. <br/>
 </p>
<h2><a class="anchor" id="callbacks3">
3) Rendering</a></h2>
<p>Unlike Input and Physics this rendering will be performed each Frame regardless of what callbacks are set. Rendering is done last so that any changes to the game world physics makes are made visible in the same loop iteration. </p>
<h3><a class="anchor" id="rendering1">
3.A) PerRenderCallback</a></h3>
<p>Any tasks that could not be complete in the PostPhysics Callback can be performed here or you use this to make last minute preparations for rendering. </p>
<h3><a class="anchor" id="rendering2">
3.B) Rendering</a></h3>
<p>This is where the rendering actually occurs. The state of all the items in the world is grabbed from the physics subsystem and rendered. Additionally this is where the FrameDelay is calculated and acted on, so the frame rate can stay consistent. </p>
<h3><a class="anchor" id="rendering3">
3.C) PostRenderCallback</a></h3>
<p>This is a great place to switch out the Callback Manager, for accomplishing tasks like switching between in game menus and actual gameplay. This is also a decent place to get a head start on anything that would be run in the PreInputCallback. <br/>
 </p>
<h2><a class="anchor" id="endingmainloop1">
Ending the Main Loop</a></h2>
<p>The main loop stores the return values of each of the 6 callbacks. If they are all true the mainloop continues to it's next iteration. If one or more of any of the callbacks returns false then the main loop ends, and the game engine exits gracefully, cleanly up the physics, graphics and any others subsystems it opened. No attempt will be made by the engine to clean up data in the callback manager. If the game code does not free these items the operating system had better do it automatically. On most PC platform this is not an issue, but it could be disastrous on a mobile, or underperforming gaming platform. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Jun 17 11:40:23 2010 for PhysGameEngine by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
