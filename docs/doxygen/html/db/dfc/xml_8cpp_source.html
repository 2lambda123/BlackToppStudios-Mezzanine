<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PhysGameEngine: xml.cpp Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>xml.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//© Copyright 2010 Joseph Toppi and John Blackwood </span>
<a name="l00002"></a>00002 <span class="comment">/* This file is part of The PhysGame Engine. </span>
<a name="l00003"></a>00003 <span class="comment"> </span>
<a name="l00004"></a>00004 <span class="comment">    The PhysGame Engine is free software: you can redistribute it and/or modify </span>
<a name="l00005"></a>00005 <span class="comment">    it under the terms of the GNU General Public License as published by </span>
<a name="l00006"></a>00006 <span class="comment">    the Free Software Foundation, either version 3 of the License, or </span>
<a name="l00007"></a>00007 <span class="comment">    (at your option) any later version. </span>
<a name="l00008"></a>00008 <span class="comment"> </span>
<a name="l00009"></a>00009 <span class="comment">    The PhysGame Engine is distributed in the hope that it will be useful, </span>
<a name="l00010"></a>00010 <span class="comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<a name="l00011"></a>00011 <span class="comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the </span>
<a name="l00012"></a>00012 <span class="comment">    GNU General Public License for more details. </span>
<a name="l00013"></a>00013 <span class="comment"> </span>
<a name="l00014"></a>00014 <span class="comment">    You should have received a copy of the GNU General Public License </span>
<a name="l00015"></a>00015 <span class="comment">    along with The PhysGame Engine.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  </span>
<a name="l00016"></a>00016 <span class="comment">*/</span> 
<a name="l00017"></a>00017 <span class="comment">/* The original authors have included a copy of the license specified above in the </span>
<a name="l00018"></a>00018 <span class="comment">   &#39;Docs&#39; folder. See &#39;gpl.txt&#39; </span>
<a name="l00019"></a>00019 <span class="comment">*/</span> 
<a name="l00020"></a>00020 <span class="comment">/* We welcome the use of The PhysGame anyone, including companies who wish to  </span>
<a name="l00021"></a>00021 <span class="comment">   Build professional software and charge for their product. </span>
<a name="l00022"></a>00022 <span class="comment"> </span>
<a name="l00023"></a>00023 <span class="comment">   However there are some practical restrictions, so if your project involves </span>
<a name="l00024"></a>00024 <span class="comment">   any of the following you should contact us and we will try to work something </span>
<a name="l00025"></a>00025 <span class="comment">   out: </span>
<a name="l00026"></a>00026 <span class="comment">    - DRM or Copy Protection of any kind(except Copyrights) </span>
<a name="l00027"></a>00027 <span class="comment">    - Software Patents You Do Not Wish to Freely License </span>
<a name="l00028"></a>00028 <span class="comment">    - Any Kind of Linking to Non-GPL licensed Works </span>
<a name="l00029"></a>00029 <span class="comment">    - Are Currently In Violation of Another Copyright Holder&#39;s GPL License </span>
<a name="l00030"></a>00030 <span class="comment">    - If You want to change our code and not add a few hundred MB of stuff to  </span>
<a name="l00031"></a>00031 <span class="comment">        your distribution </span>
<a name="l00032"></a>00032 <span class="comment"> </span>
<a name="l00033"></a>00033 <span class="comment">   These and other limitations could cause serious legal problems if you ignore </span>
<a name="l00034"></a>00034 <span class="comment">   them, so it is best to simply contact us or the Free Software Foundation, if </span>
<a name="l00035"></a>00035 <span class="comment">   you have any questions.  </span>
<a name="l00036"></a>00036 <span class="comment"> </span>
<a name="l00037"></a>00037 <span class="comment">   Joseph Toppi - toppij@gmail.com </span>
<a name="l00038"></a>00038 <span class="comment">   John Blackwood - makoenergy02@gmail.com </span>
<a name="l00039"></a>00039 <span class="comment">*/</span> 
<a name="l00040"></a>00040 <span class="preprocessor">#ifdef PHYSXML </span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="comment">/* </span>
<a name="l00042"></a>00042 <span class="comment"> * </span>
<a name="l00043"></a>00043 <span class="comment"> * Software, Files, Libraries and all other items referenced in this clause refers only </span>
<a name="l00044"></a>00044 <span class="comment"> * to the contents of this file and associated documentation. </span>
<a name="l00045"></a>00045 <span class="comment"> * </span>
<a name="l00046"></a>00046 <span class="comment"> * Pugixml parser - version 1.0 </span>
<a name="l00047"></a>00047 <span class="comment"> * -------------------------------------------------------- </span>
<a name="l00048"></a>00048 <span class="comment"> * Copyright © 2006-2010, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com) </span>
<a name="l00049"></a>00049 <span class="comment"> * Report bugs and downLoad new versions at http://pugixml.org/ </span>
<a name="l00050"></a>00050 <span class="comment"> * </span>
<a name="l00051"></a>00051 <span class="comment"> * This library is distributed under the MIT License. See notice at the end </span>
<a name="l00052"></a>00052 <span class="comment"> * of this file. </span>
<a name="l00053"></a>00053 <span class="comment"> * </span>
<a name="l00054"></a>00054 <span class="comment"> * This work is based on the pugxml parser, which is: </span>
<a name="l00055"></a>00055 <span class="comment"> * Copyright © 2003, by Kristen Wegner (kristen@tima.net) </span>
<a name="l00056"></a>00056 <span class="comment"> */</span> 
<a name="l00057"></a>00057  
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="../../d0/d62/xml_8h.html" title="This is where bulk of the XML subsystem is declare, there are numerous class that are all tighlty int...">xml.h</a>&quot;</span> 
<a name="l00059"></a>00059  
<a name="l00060"></a>00060 <span class="preprocessor">#include &lt;stdlib.h&gt;</span> 
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;stdio.h&gt;</span> 
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;string.h&gt;</span> 
<a name="l00063"></a>00063 <span class="preprocessor">#include &lt;assert.h&gt;</span> 
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;setjmp.h&gt;</span> 
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;wchar.h&gt;</span> 
<a name="l00066"></a>00066  
<a name="l00067"></a>00067 <span class="preprocessor">#ifndef XML_NO_XPATH </span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#       include &lt;math.h&gt;</span> 
<a name="l00069"></a>00069 <span class="preprocessor">#       include &lt;float.h&gt;</span> 
<a name="l00070"></a>00070 <span class="preprocessor">#endif </span>
<a name="l00071"></a>00071 <span class="preprocessor"></span> 
<a name="l00072"></a>00072 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#       include &lt;istream&gt;</span> 
<a name="l00074"></a>00074 <span class="preprocessor">#       include &lt;ostream&gt;</span> 
<a name="l00075"></a>00075 <span class="preprocessor">#       include &lt;string&gt;</span> 
<a name="l00076"></a>00076 <span class="preprocessor">#endif </span>
<a name="l00077"></a>00077 <span class="preprocessor"></span> 
<a name="l00078"></a>00078 <span class="comment">// For placement new </span>
<a name="l00079"></a>00079 <span class="preprocessor">#include &lt;new&gt;</span> 
<a name="l00080"></a>00080  
<a name="l00081"></a>00081 <span class="preprocessor">#ifdef _MSC_VER </span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#       pragma warning(disable: 4127) // conditional expression is constant </span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#       pragma warning(disable: 4324) // structure was padded due to __declspec(align()) </span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#       pragma warning(disable: 4611) // interaction between &#39;_setjmp&#39; and C++ object destruction is non-portable </span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#       pragma warning(disable: 4702) // unreachable code </span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#       pragma warning(disable: 4996) // this function or variable may be unsafe </span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l00088"></a>00088 <span class="preprocessor"></span> 
<a name="l00089"></a>00089 <span class="preprocessor">#ifdef __INTEL_COMPILER </span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#       pragma warning(disable: 177) // function was declared but never referenced  </span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">#       pragma warning(disable: 1478 1786) // function was declared &quot;deprecated&quot; </span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l00093"></a>00093 <span class="preprocessor"></span> 
<a name="l00094"></a>00094 <span class="preprocessor">#ifdef __BORLANDC__ </span>
<a name="l00095"></a>00095 <span class="preprocessor"></span><span class="preprocessor">#       pragma warn -8008 // condition is always false </span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#       pragma warn -8066 // unreachable code </span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l00098"></a>00098 <span class="preprocessor"></span> 
<a name="l00099"></a>00099 <span class="preprocessor">#ifdef __SNC__ </span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#       pragma diag_suppress=178 // function was declared but never referenced </span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">#       pragma diag_suppress=237 // controlling expression is constant </span>
<a name="l00102"></a>00102 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l00103"></a>00103 <span class="preprocessor"></span> 
<a name="l00104"></a>00104 <span class="comment">// uintptr_t </span>
<a name="l00105"></a>00105 <span class="preprocessor">#if !defined(_MSC_VER) || _MSC_VER &gt;= 1600 </span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#       include &lt;stdint.h&gt;</span> 
<a name="l00107"></a>00107 <span class="preprocessor">#else </span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#       if _MSC_VER &lt; 1300 </span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="comment">// No native uintptr_t in MSVC6 </span>
<a name="l00110"></a>00110 <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> uintptr_t; 
<a name="l00111"></a>00111 <span class="preprocessor">#       endif </span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> __int8 uint8_t; 
<a name="l00113"></a>00113 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> __int16 uint16_t; 
<a name="l00114"></a>00114 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> __int32 uint32_t; 
<a name="l00115"></a>00115 <span class="keyword">typedef</span> __int32 int32_t; 
<a name="l00116"></a>00116 <span class="preprocessor">#endif </span>
<a name="l00117"></a>00117 <span class="preprocessor"></span> 
<a name="l00118"></a>00118 <span class="comment">// Inlining controls </span>
<a name="l00119"></a>00119 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1300 </span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor">#       define XML_NO_INLINE __declspec(noinline) </span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#elif defined(__GNUC__) </span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor">#       define XML_NO_INLINE __attribute__((noinline)) </span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#else </span>
<a name="l00124"></a>00124 <span class="preprocessor"></span><span class="preprocessor">#       define XML_NO_INLINE  </span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l00126"></a>00126 <span class="preprocessor"></span> 
<a name="l00127"></a>00127 <span class="comment">// Simple static assertion </span>
<a name="l00128"></a>00128 <span class="preprocessor">#define STATIC_ASSERT(cond) { static const char condition_failed[(cond) ? 1 : -1] = {0}; (void)condition_failed[0]; } </span>
<a name="l00129"></a>00129 <span class="preprocessor"></span> 
<a name="l00130"></a>00130 <span class="comment">// Digital Mars C++ bug workaround for passing char Loaded from memory via stack </span>
<a name="l00131"></a>00131 <span class="preprocessor">#ifdef __DMC__ </span>
<a name="l00132"></a>00132 <span class="preprocessor"></span><span class="preprocessor">#       define DMC_VOLATILE volatile </span>
<a name="l00133"></a>00133 <span class="preprocessor"></span><span class="preprocessor">#else </span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#       define DMC_VOLATILE </span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l00136"></a>00136 <span class="preprocessor"></span> 
<a name="l00137"></a>00137 <span class="keyword">using namespace </span>phys::xml; 
<a name="l00138"></a>00138  
<a name="l00139"></a>00139 <span class="comment">// Memory allocation </span>
<a name="l00140"></a>00140 <span class="keyword">namespace </span>
<a name="l00141"></a>00141 { 
<a name="l00142"></a>00142         <span class="keywordtype">void</span>* default_allocate(<span class="keywordtype">size_t</span> size) 
<a name="l00143"></a>00143         { 
<a name="l00144"></a>00144                 <span class="keywordflow">return</span> malloc(size); 
<a name="l00145"></a>00145         } 
<a name="l00146"></a>00146  
<a name="l00147"></a>00147         <span class="keywordtype">void</span> default_deallocate(<span class="keywordtype">void</span>* ptr) 
<a name="l00148"></a>00148         { 
<a name="l00149"></a>00149                 free(ptr); 
<a name="l00150"></a>00150         } 
<a name="l00151"></a>00151  
<a name="l00152"></a>00152         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a6d772c4cf52d017d4d6ad68ddcbd493f" title="Memory allocation function interface; returns pointer to allocated memory or NULL on failure...">AllocationFunction</a> global_allocate = default_allocate; 
<a name="l00153"></a>00153         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#af98b1cb6640aa712180aad89a1c776d8" title="Memory deallocation function interface.">deAllocationFunction</a> global_deallocate = default_deallocate; 
<a name="l00154"></a>00154 } 
<a name="l00155"></a>00155  
<a name="l00156"></a>00156 <span class="comment">// String utilities </span>
<a name="l00157"></a>00157 <span class="keyword">namespace </span>
<a name="l00158"></a>00158 { 
<a name="l00159"></a>00159         <span class="comment">// Get string length </span>
<a name="l00160"></a>00160         <span class="keywordtype">size_t</span> strlength(<span class="keyword">const</span> char_t* s) 
<a name="l00161"></a>00161         { 
<a name="l00162"></a>00162                 assert(s); 
<a name="l00163"></a>00163  
<a name="l00164"></a>00164 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>                <span class="keywordflow">return</span> wcslen(s); 
<a name="l00166"></a>00166 <span class="preprocessor">        #else </span>
<a name="l00167"></a>00167 <span class="preprocessor"></span>                <span class="keywordflow">return</span> strlen(s); 
<a name="l00168"></a>00168 <span class="preprocessor">        #endif </span>
<a name="l00169"></a>00169 <span class="preprocessor"></span>        } 
<a name="l00170"></a>00170  
<a name="l00171"></a>00171         <span class="comment">// Compare two strings </span>
<a name="l00172"></a>00172         <span class="keywordtype">bool</span> strequal(<span class="keyword">const</span> char_t* src, <span class="keyword">const</span> char_t* dst) 
<a name="l00173"></a>00173         { 
<a name="l00174"></a>00174                 assert(src &amp;&amp; dst); 
<a name="l00175"></a>00175  
<a name="l00176"></a>00176 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>                <span class="keywordflow">return</span> wcscmp(src, dst) == 0; 
<a name="l00178"></a>00178 <span class="preprocessor">        #else </span>
<a name="l00179"></a>00179 <span class="preprocessor"></span>                <span class="keywordflow">return</span> strcmp(src, dst) == 0; 
<a name="l00180"></a>00180 <span class="preprocessor">        #endif </span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>        } 
<a name="l00182"></a>00182  
<a name="l00183"></a>00183         <span class="comment">// Compare lhs with [rhs_begin, rhs_end) </span>
<a name="l00184"></a>00184         <span class="keywordtype">bool</span> strequalrange(<span class="keyword">const</span> char_t* lhs, <span class="keyword">const</span> char_t* rhs, <span class="keywordtype">size_t</span> count) 
<a name="l00185"></a>00185         { 
<a name="l00186"></a>00186                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i) 
<a name="l00187"></a>00187                         <span class="keywordflow">if</span> (lhs[i] != rhs[i]) 
<a name="l00188"></a>00188                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l00189"></a>00189          
<a name="l00190"></a>00190                 <span class="keywordflow">return</span> lhs[count] == 0; 
<a name="l00191"></a>00191         } 
<a name="l00192"></a>00192          
<a name="l00193"></a>00193 <span class="preprocessor">#ifdef XML_WCHAR_MODE </span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>        <span class="comment">// Convert string to wide string, assuming all symbols are ASCII </span>
<a name="l00195"></a>00195         <span class="keywordtype">void</span> widen_ascii(<span class="keywordtype">wchar_t</span>* dest, <span class="keyword">const</span> <span class="keywordtype">char</span>* source) 
<a name="l00196"></a>00196         { 
<a name="l00197"></a>00197                 <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>* i = source; *i; ++i) *dest++ = *i; 
<a name="l00198"></a>00198                 *dest = 0; 
<a name="l00199"></a>00199         } 
<a name="l00200"></a>00200 <span class="preprocessor">#endif </span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>} 
<a name="l00202"></a>00202  
<a name="l00203"></a>00203 <span class="preprocessor">#if !defined(XML_NO_STL) || !defined(XML_NO_XPATH) </span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="comment">// auto_ptr-like buffer holder for exception recovery </span>
<a name="l00205"></a>00205 <span class="keyword">namespace </span>
<a name="l00206"></a>00206 { 
<a name="l00207"></a>00207         <span class="keyword">struct </span>buffer_holder 
<a name="l00208"></a>00208         { 
<a name="l00209"></a>00209                 <span class="keywordtype">void</span>* data; 
<a name="l00210"></a>00210                 void (*deleter)(<span class="keywordtype">void</span>*); 
<a name="l00211"></a>00211  
<a name="l00212"></a>00212                 buffer_holder(<span class="keywordtype">void</span>* data, <span class="keywordtype">void</span> (*deleter)(<span class="keywordtype">void</span>*)): data(data), deleter(deleter) 
<a name="l00213"></a>00213                 { 
<a name="l00214"></a>00214                 } 
<a name="l00215"></a>00215  
<a name="l00216"></a>00216                 ~buffer_holder() 
<a name="l00217"></a>00217                 { 
<a name="l00218"></a>00218                         <span class="keywordflow">if</span> (data) deleter(data); 
<a name="l00219"></a>00219                 } 
<a name="l00220"></a>00220  
<a name="l00221"></a>00221                 <span class="keywordtype">void</span>* release() 
<a name="l00222"></a>00222                 { 
<a name="l00223"></a>00223                         <span class="keywordtype">void</span>* Result = data; 
<a name="l00224"></a>00224                         data = 0; 
<a name="l00225"></a>00225                         <span class="keywordflow">return</span> Result; 
<a name="l00226"></a>00226                 } 
<a name="l00227"></a>00227         }; 
<a name="l00228"></a>00228 } 
<a name="l00229"></a>00229 <span class="preprocessor">#endif </span>
<a name="l00230"></a>00230 <span class="preprocessor"></span> 
<a name="l00231"></a>00231 <span class="keyword">namespace </span>
<a name="l00232"></a>00232 { 
<a name="l00233"></a>00233         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> MemoryPage_size = 32768; 
<a name="l00234"></a>00234  
<a name="l00235"></a>00235         <span class="keyword">static</span> <span class="keyword">const</span> uintptr_t MemoryPage_alignment = 32; 
<a name="l00236"></a>00236         <span class="keyword">static</span> <span class="keyword">const</span> uintptr_t MemoryPage_pointer_mask = ~(MemoryPage_alignment - 1); 
<a name="l00237"></a>00237         <span class="keyword">static</span> <span class="keyword">const</span> uintptr_t MemoryPage_Name_allocated_mask = 16; 
<a name="l00238"></a>00238         <span class="keyword">static</span> <span class="keyword">const</span> uintptr_t MemoryPage_Value_allocated_mask = 8; 
<a name="l00239"></a>00239         <span class="keyword">static</span> <span class="keyword">const</span> uintptr_t MemoryPage_type_mask = 7; 
<a name="l00240"></a>00240  
<a name="l00241"></a>00241         <span class="keyword">struct </span>Allocator; 
<a name="l00242"></a>00242  
<a name="l00243"></a>00243         <span class="keyword">struct </span>MemoryPage 
<a name="l00244"></a>00244         { 
<a name="l00245"></a>00245                 <span class="keyword">static</span> MemoryPage* construct(<span class="keywordtype">void</span>* memory) 
<a name="l00246"></a>00246                 { 
<a name="l00247"></a>00247                         <span class="keywordflow">if</span> (!memory) <span class="keywordflow">return</span> 0; <span class="comment">//$ redundant, left for performance </span>
<a name="l00248"></a>00248  
<a name="l00249"></a>00249                         MemoryPage* Result = <span class="keyword">static_cast&lt;</span>MemoryPage*<span class="keyword">&gt;</span>(memory); 
<a name="l00250"></a>00250  
<a name="l00251"></a>00251                         Result-&gt;allocator = 0; 
<a name="l00252"></a>00252                         Result-&gt;memory = 0; 
<a name="l00253"></a>00253                         Result-&gt;prev = 0; 
<a name="l00254"></a>00254                         Result-&gt;next = 0; 
<a name="l00255"></a>00255                         Result-&gt;busy_size = 0; 
<a name="l00256"></a>00256                         Result-&gt;freed_size = 0; 
<a name="l00257"></a>00257  
<a name="l00258"></a>00258                         <span class="keywordflow">return</span> Result; 
<a name="l00259"></a>00259                 } 
<a name="l00260"></a>00260  
<a name="l00261"></a>00261                 Allocator* allocator; 
<a name="l00262"></a>00262  
<a name="l00263"></a>00263                 <span class="keywordtype">void</span>* memory; 
<a name="l00264"></a>00264  
<a name="l00265"></a>00265                 MemoryPage* prev; 
<a name="l00266"></a>00266                 MemoryPage* next; 
<a name="l00267"></a>00267  
<a name="l00268"></a>00268                 <span class="keywordtype">size_t</span> busy_size; 
<a name="l00269"></a>00269                 <span class="keywordtype">size_t</span> freed_size; 
<a name="l00270"></a>00270  
<a name="l00271"></a>00271                 <span class="keywordtype">char</span> data[1]; 
<a name="l00272"></a>00272         }; 
<a name="l00273"></a>00273  
<a name="l00274"></a>00274         <span class="keyword">struct </span>MemoryString_header 
<a name="l00275"></a>00275         { 
<a name="l00276"></a>00276                 uint16_t page_Offset; <span class="comment">// Offset from page-&gt;data </span>
<a name="l00277"></a>00277                 uint16_t full_size; <span class="comment">// 0 if string occupies whole page </span>
<a name="l00278"></a>00278         }; 
<a name="l00279"></a>00279  
<a name="l00280"></a>00280         <span class="keyword">struct </span>Allocator 
<a name="l00281"></a>00281         { 
<a name="l00282"></a>00282                 Allocator(MemoryPage* GetRoot): _GetRoot(GetRoot), _busy_size(GetRoot-&gt;busy_size) 
<a name="l00283"></a>00283                 { 
<a name="l00284"></a>00284                 } 
<a name="l00285"></a>00285  
<a name="l00286"></a>00286                 MemoryPage* allocate_page(<span class="keywordtype">size_t</span> data_size) 
<a name="l00287"></a>00287                 { 
<a name="l00288"></a>00288                         <span class="keywordtype">size_t</span> size = offsetof(MemoryPage, data) + data_size; 
<a name="l00289"></a>00289  
<a name="l00290"></a>00290                         <span class="comment">// allocate block with some alignment, leaving memory for worst-case padding </span>
<a name="l00291"></a>00291                         <span class="keywordtype">void</span>* memory = global_allocate(size + MemoryPage_alignment); 
<a name="l00292"></a>00292                         <span class="keywordflow">if</span> (!memory) <span class="keywordflow">return</span> 0; 
<a name="l00293"></a>00293  
<a name="l00294"></a>00294                         <span class="comment">// align upwards to page boundary </span>
<a name="l00295"></a>00295                         <span class="keywordtype">void</span>* page_memory = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>((<span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(memory) + (MemoryPage_alignment - 1)) &amp; ~(MemoryPage_alignment - 1)); 
<a name="l00296"></a>00296  
<a name="l00297"></a>00297                         <span class="comment">// prepare page structure </span>
<a name="l00298"></a>00298                         MemoryPage* page = MemoryPage::construct(page_memory); 
<a name="l00299"></a>00299  
<a name="l00300"></a>00300                         page-&gt;memory = memory; 
<a name="l00301"></a>00301                         page-&gt;allocator = _GetRoot-&gt;allocator; 
<a name="l00302"></a>00302  
<a name="l00303"></a>00303                         <span class="keywordflow">return</span> page; 
<a name="l00304"></a>00304                 } 
<a name="l00305"></a>00305  
<a name="l00306"></a>00306                 <span class="keyword">static</span> <span class="keywordtype">void</span> deallocate_page(MemoryPage* page) 
<a name="l00307"></a>00307                 { 
<a name="l00308"></a>00308                         global_deallocate(page-&gt;memory); 
<a name="l00309"></a>00309                 } 
<a name="l00310"></a>00310  
<a name="l00311"></a>00311                 <span class="keywordtype">void</span>* allocate_memory_oob(<span class="keywordtype">size_t</span> size, MemoryPage*&amp; out_page); 
<a name="l00312"></a>00312  
<a name="l00313"></a>00313                 <span class="keywordtype">void</span>* allocate_memory(<span class="keywordtype">size_t</span> size, MemoryPage*&amp; out_page) 
<a name="l00314"></a>00314                 { 
<a name="l00315"></a>00315                         <span class="keywordflow">if</span> (_busy_size + size &gt; MemoryPage_size) <span class="keywordflow">return</span> allocate_memory_oob(size, out_page); 
<a name="l00316"></a>00316  
<a name="l00317"></a>00317                         <span class="keywordtype">void</span>* buf = _GetRoot-&gt;data + _busy_size; 
<a name="l00318"></a>00318  
<a name="l00319"></a>00319                         _busy_size += size; 
<a name="l00320"></a>00320  
<a name="l00321"></a>00321                         out_page = _GetRoot; 
<a name="l00322"></a>00322  
<a name="l00323"></a>00323                         <span class="keywordflow">return</span> buf; 
<a name="l00324"></a>00324                 } 
<a name="l00325"></a>00325  
<a name="l00326"></a>00326                 <span class="keywordtype">void</span> deallocate_memory(<span class="keywordtype">void</span>* ptr, <span class="keywordtype">size_t</span> size, MemoryPage* page) 
<a name="l00327"></a>00327                 { 
<a name="l00328"></a>00328                         <span class="keywordflow">if</span> (page == _GetRoot) page-&gt;busy_size = _busy_size; 
<a name="l00329"></a>00329  
<a name="l00330"></a>00330                         assert(ptr &gt;= page-&gt;data &amp;&amp; ptr &lt; page-&gt;data + page-&gt;busy_size); 
<a name="l00331"></a>00331                         (void)!ptr; 
<a name="l00332"></a>00332  
<a name="l00333"></a>00333                         page-&gt;freed_size += size; 
<a name="l00334"></a>00334                         assert(page-&gt;freed_size &lt;= page-&gt;busy_size); 
<a name="l00335"></a>00335  
<a name="l00336"></a>00336                         <span class="keywordflow">if</span> (page-&gt;freed_size == page-&gt;busy_size) 
<a name="l00337"></a>00337                         { 
<a name="l00338"></a>00338                                 <span class="keywordflow">if</span> (page-&gt;next == 0) 
<a name="l00339"></a>00339                                 { 
<a name="l00340"></a>00340                                         assert(_GetRoot == page); 
<a name="l00341"></a>00341  
<a name="l00342"></a>00342                                         <span class="comment">// top page freed, just Reset sizes </span>
<a name="l00343"></a>00343                                         page-&gt;busy_size = page-&gt;freed_size = 0; 
<a name="l00344"></a>00344                                         _busy_size = 0; 
<a name="l00345"></a>00345                                 } 
<a name="l00346"></a>00346                                 <span class="keywordflow">else</span> 
<a name="l00347"></a>00347                                 { 
<a name="l00348"></a>00348                                         assert(_GetRoot != page); 
<a name="l00349"></a>00349                                         assert(page-&gt;prev); 
<a name="l00350"></a>00350  
<a name="l00351"></a>00351                                         <span class="comment">// remove from the list </span>
<a name="l00352"></a>00352                                         page-&gt;prev-&gt;next = page-&gt;next; 
<a name="l00353"></a>00353                                         page-&gt;next-&gt;prev = page-&gt;prev; 
<a name="l00354"></a>00354  
<a name="l00355"></a>00355                                         <span class="comment">// deallocate </span>
<a name="l00356"></a>00356                                         deallocate_page(page); 
<a name="l00357"></a>00357                                 } 
<a name="l00358"></a>00358                         } 
<a name="l00359"></a>00359                 } 
<a name="l00360"></a>00360  
<a name="l00361"></a>00361                 char_t* allocate_string(<span class="keywordtype">size_t</span> length) 
<a name="l00362"></a>00362                 { 
<a name="l00363"></a>00363                         <span class="comment">// allocate memory for string and header block </span>
<a name="l00364"></a>00364                         <span class="keywordtype">size_t</span> size = <span class="keyword">sizeof</span>(MemoryString_header) + length * <span class="keyword">sizeof</span>(char_t); 
<a name="l00365"></a>00365                          
<a name="l00366"></a>00366                         <span class="comment">// round size up to pointer alignment boundary </span>
<a name="l00367"></a>00367                         <span class="keywordtype">size_t</span> full_size = (size + (<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1)) &amp; ~(<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1); 
<a name="l00368"></a>00368  
<a name="l00369"></a>00369                         MemoryPage* page; 
<a name="l00370"></a>00370                         MemoryString_header* header = <span class="keyword">static_cast&lt;</span>MemoryString_header*<span class="keyword">&gt;</span>(allocate_memory(full_size, page)); 
<a name="l00371"></a>00371  
<a name="l00372"></a>00372                         <span class="keywordflow">if</span> (!header) <span class="keywordflow">return</span> 0; 
<a name="l00373"></a>00373  
<a name="l00374"></a>00374                         <span class="comment">// setup header </span>
<a name="l00375"></a>00375                         ptrdiff_t page_Offset = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(header) - page-&gt;data; 
<a name="l00376"></a>00376  
<a name="l00377"></a>00377                         assert(page_Offset &gt;= 0 &amp;&amp; page_Offset &lt; (1 &lt;&lt; 16)); 
<a name="l00378"></a>00378                         header-&gt;page_Offset = <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(page_Offset); 
<a name="l00379"></a>00379  
<a name="l00380"></a>00380                         <span class="comment">// full_size == 0 for large strings that occupy the whole page </span>
<a name="l00381"></a>00381                         assert(full_size &lt; (1 &lt;&lt; 16) || (page-&gt;busy_size == full_size &amp;&amp; page_Offset == 0)); 
<a name="l00382"></a>00382                         header-&gt;full_size = <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(full_size &lt; (1 &lt;&lt; 16) ? full_size : 0); 
<a name="l00383"></a>00383  
<a name="l00384"></a>00384                         <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(header + 1); 
<a name="l00385"></a>00385                 } 
<a name="l00386"></a>00386  
<a name="l00387"></a>00387                 <span class="keywordtype">void</span> deallocate_string(char_t* <span class="keywordtype">string</span>) 
<a name="l00388"></a>00388                 { 
<a name="l00389"></a>00389                         <span class="comment">// get header </span>
<a name="l00390"></a>00390                         MemoryString_header* header = <span class="keyword">reinterpret_cast&lt;</span>MemoryString_header*<span class="keyword">&gt;</span>(string) - 1; 
<a name="l00391"></a>00391  
<a name="l00392"></a>00392                         <span class="comment">// deallocate </span>
<a name="l00393"></a>00393                         <span class="keywordtype">size_t</span> page_Offset = offsetof(MemoryPage, data) + header-&gt;page_Offset; 
<a name="l00394"></a>00394                         MemoryPage* page = <span class="keyword">reinterpret_cast&lt;</span>MemoryPage*<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(header) - page_Offset); 
<a name="l00395"></a>00395  
<a name="l00396"></a>00396                         <span class="comment">// if full_size == 0 then this string occupies the whole page </span>
<a name="l00397"></a>00397                         <span class="keywordtype">size_t</span> full_size = header-&gt;full_size == 0 ? page-&gt;busy_size : header-&gt;full_size; 
<a name="l00398"></a>00398  
<a name="l00399"></a>00399                         deallocate_memory(header, full_size, page); 
<a name="l00400"></a>00400                 } 
<a name="l00401"></a>00401  
<a name="l00402"></a>00402                 MemoryPage* _GetRoot; 
<a name="l00403"></a>00403                 <span class="keywordtype">size_t</span> _busy_size; 
<a name="l00404"></a>00404         }; 
<a name="l00405"></a>00405  
<a name="l00406"></a>00406         XML_NO_INLINE <span class="keywordtype">void</span>* Allocator::allocate_memory_oob(<span class="keywordtype">size_t</span> size, MemoryPage*&amp; out_page) 
<a name="l00407"></a>00407         { 
<a name="l00408"></a>00408                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> large_allocation_threshold = MemoryPage_size / 4; 
<a name="l00409"></a>00409  
<a name="l00410"></a>00410                 MemoryPage* page = allocate_page(size &lt;= large_allocation_threshold ? MemoryPage_size : size); 
<a name="l00411"></a>00411                 <span class="keywordflow">if</span> (!page) <span class="keywordflow">return</span> 0; 
<a name="l00412"></a>00412  
<a name="l00413"></a>00413                 <span class="keywordflow">if</span> (size &lt;= large_allocation_threshold) 
<a name="l00414"></a>00414                 { 
<a name="l00415"></a>00415                         _GetRoot-&gt;busy_size = _busy_size; 
<a name="l00416"></a>00416  
<a name="l00417"></a>00417                         <span class="comment">// insert page at the end of linked list </span>
<a name="l00418"></a>00418                         page-&gt;prev = _GetRoot; 
<a name="l00419"></a>00419                         _GetRoot-&gt;next = page; 
<a name="l00420"></a>00420                         _GetRoot = page; 
<a name="l00421"></a>00421  
<a name="l00422"></a>00422                         _busy_size = size; 
<a name="l00423"></a>00423                 } 
<a name="l00424"></a>00424                 <span class="keywordflow">else</span> 
<a name="l00425"></a>00425                 { 
<a name="l00426"></a>00426                         <span class="comment">// insert page before the end of linked list, so that it is deleted as soon as possible </span>
<a name="l00427"></a>00427                         <span class="comment">// the last page is not deleted even if it&#39;s empty (see deallocate_memory) </span>
<a name="l00428"></a>00428                         assert(_GetRoot-&gt;prev); 
<a name="l00429"></a>00429  
<a name="l00430"></a>00430                         page-&gt;prev = _GetRoot-&gt;prev; 
<a name="l00431"></a>00431                         page-&gt;next = _GetRoot; 
<a name="l00432"></a>00432  
<a name="l00433"></a>00433                         _GetRoot-&gt;prev-&gt;next = page; 
<a name="l00434"></a>00434                         _GetRoot-&gt;prev = page; 
<a name="l00435"></a>00435                 } 
<a name="l00436"></a>00436  
<a name="l00437"></a>00437                 <span class="comment">// allocate inside page </span>
<a name="l00438"></a>00438                 page-&gt;busy_size = size; 
<a name="l00439"></a>00439  
<a name="l00440"></a>00440                 out_page = page; 
<a name="l00441"></a>00441                 <span class="keywordflow">return</span> page-&gt;data; 
<a name="l00442"></a>00442         } 
<a name="l00443"></a>00443 } 
<a name="l00444"></a>00444  
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="keyword">namespace </span>phys
<a name="l00447"></a><a class="code" href="../../d9/d27/namespacephys_1_1xml.html">00447</a> { <span class="keyword">namespace </span>xml
<a name="l00448"></a>00448 { <span class="comment"></span>
<a name="l00449"></a>00449 <span class="comment">        //// A &#39;Name=Value&#39; XML GetAttribute structure. </span>
<a name="l00450"></a><a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html">00450</a> <span class="comment"></span>        <span class="keyword">struct </span><a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a> 
<a name="l00451"></a>00451         { <span class="comment"></span>
<a name="l00452"></a>00452 <span class="comment">                //// Default ctor </span>
<a name="l00453"></a>00453 <span class="comment"></span>                <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>(MemoryPage* page): header(reinterpret_cast&lt;uintptr_t&gt;(page)), Name(0), Value(0), prev_attribute_c(0), GetNextAttribute(0) 
<a name="l00454"></a>00454                 { 
<a name="l00455"></a>00455                 } 
<a name="l00456"></a>00456  
<a name="l00457"></a>00457                 uintptr_t header; 
<a name="l00458"></a>00458  
<a name="l00459"></a>00459                 char_t* Name;   <span class="comment">////&lt; Pointer to GetAttribute Name. </span>
<a name="l00460"></a>00460 <span class="comment"></span>                char_t* Value;  <span class="comment">////&lt; Pointer to GetAttribute Value. </span>
<a name="l00461"></a>00461 <span class="comment"></span> 
<a name="l00462"></a>00462                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* prev_attribute_c;      <span class="comment">////&lt; Previous GetAttribute (cyclic list) </span>
<a name="l00463"></a>00463 <span class="comment"></span>                <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* GetNextAttribute;      <span class="comment">////&lt; Next GetAttribute </span>
<a name="l00464"></a>00464 <span class="comment"></span>        }; 
<a name="l00465"></a>00465  <span class="comment"></span>
<a name="l00466"></a>00466 <span class="comment">        //// An XML document tree node. </span>
<a name="l00467"></a><a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html">00467</a> <span class="comment"></span>        <span class="keyword">struct </span><a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a> 
<a name="l00468"></a>00468         { <span class="comment"></span>
<a name="l00469"></a>00469 <span class="comment">                //// Default ctor </span>
<a name="l00470"></a>00470 <span class="comment">                //// \param Type - node Type </span>
<a name="l00471"></a>00471 <span class="comment"></span>                <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>(MemoryPage* page, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type): header(reinterpret_cast&lt;uintptr_t&gt;(page) | (Type - 1)), GetParent(0), Name(0), Value(0), GetFirstChild(0), prev_sibling_c(0), GetNextSibling(0), GetFirstAttribute(0) 
<a name="l00472"></a>00472                 { 
<a name="l00473"></a>00473                 } 
<a name="l00474"></a>00474  
<a name="l00475"></a>00475                 uintptr_t header; 
<a name="l00476"></a>00476  
<a name="l00477"></a>00477                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>*             GetParent;                                      <span class="comment">////&lt; Pointer to GetParent </span>
<a name="l00478"></a>00478 <span class="comment"></span> 
<a name="l00479"></a>00479                 char_t*                                 Name;                                   <span class="comment">////&lt; Pointer to element Name. </span>
<a name="l00480"></a>00480 <span class="comment"></span>                char_t*                                 Value;                                  <span class="comment">////&lt; Pointer to any associated string data. </span>
<a name="l00481"></a>00481 <span class="comment"></span> 
<a name="l00482"></a>00482                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>*             GetFirstChild;                  <span class="comment">////&lt; First GetChild </span>
<a name="l00483"></a>00483 <span class="comment"></span>                 
<a name="l00484"></a>00484                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>*             prev_sibling_c;                 <span class="comment">////&lt; Left brother (cyclic list) </span>
<a name="l00485"></a>00485 <span class="comment"></span>                <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>*             GetNextSibling;                 <span class="comment">////&lt; Right brother </span>
<a name="l00486"></a>00486 <span class="comment"></span>                 
<a name="l00487"></a>00487                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>*        GetFirstAttribute;              <span class="comment">////&lt; First GetAttribute </span>
<a name="l00488"></a>00488 <span class="comment"></span>        }; 
<a name="l00489"></a>00489 } 
<a name="l00490"></a>00490 } <span class="comment">// \phys</span>
<a name="l00491"></a>00491  
<a name="l00492"></a>00492 <span class="keyword">namespace </span>
<a name="l00493"></a>00493 { 
<a name="l00494"></a>00494         <span class="keyword">struct </span>DocumentStruct: <span class="keyword">public</span> <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>, <span class="keyword">public</span> Allocator 
<a name="l00495"></a>00495         { 
<a name="l00496"></a>00496                 DocumentStruct(MemoryPage* page): <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>(page, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3acfe92e6bd275972917b95f08bd46e09f" title="A document tree&amp;#39;s absolute root.">NodeDocument</a>), Allocator(page), buffer(0) 
<a name="l00497"></a>00497                 { 
<a name="l00498"></a>00498                 } 
<a name="l00499"></a>00499  
<a name="l00500"></a>00500                 <span class="keyword">const</span> char_t* buffer; 
<a name="l00501"></a>00501         }; 
<a name="l00502"></a>00502  
<a name="l00503"></a>00503         <span class="keyword">static</span> <span class="keyword">inline</span> Allocator&amp; GetAllocator(<span class="keyword">const</span> <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* node) 
<a name="l00504"></a>00504         { 
<a name="l00505"></a>00505                 assert(node); 
<a name="l00506"></a>00506  
<a name="l00507"></a>00507                 <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span>MemoryPage*<span class="keyword">&gt;</span>(node-&gt;header &amp; MemoryPage_pointer_mask)-&gt;allocator; 
<a name="l00508"></a>00508         } 
<a name="l00509"></a>00509 } 
<a name="l00510"></a>00510  
<a name="l00511"></a>00511 <span class="comment">// Low-level DOM operations </span>
<a name="l00512"></a>00512 <span class="keyword">namespace </span>
<a name="l00513"></a>00513 { 
<a name="l00514"></a>00514         <span class="keyword">inline</span> <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* allocate_attribute(Allocator&amp; alloc) 
<a name="l00515"></a>00515         { 
<a name="l00516"></a>00516                 MemoryPage* page; 
<a name="l00517"></a>00517                 <span class="keywordtype">void</span>* memory = alloc.allocate_memory(<span class="keyword">sizeof</span>(<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>), page); 
<a name="l00518"></a>00518  
<a name="l00519"></a>00519                 <span class="keywordflow">return</span> <span class="keyword">new</span> (memory) <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>(page); 
<a name="l00520"></a>00520         } 
<a name="l00521"></a>00521  
<a name="l00522"></a>00522         <span class="keyword">inline</span> <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* allocate_node(Allocator&amp; alloc, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type) 
<a name="l00523"></a>00523         { 
<a name="l00524"></a>00524                 MemoryPage* page; 
<a name="l00525"></a>00525                 <span class="keywordtype">void</span>* memory = alloc.allocate_memory(<span class="keyword">sizeof</span>(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>), page); 
<a name="l00526"></a>00526  
<a name="l00527"></a>00527                 <span class="keywordflow">return</span> <span class="keyword">new</span> (memory) <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>(page, Type); 
<a name="l00528"></a>00528         } 
<a name="l00529"></a>00529  
<a name="l00530"></a>00530         <span class="keyword">inline</span> <span class="keywordtype">void</span> destroy_attribute(<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* a, Allocator&amp; alloc) 
<a name="l00531"></a>00531         { 
<a name="l00532"></a>00532                 uintptr_t header = a-&gt;header; 
<a name="l00533"></a>00533  
<a name="l00534"></a>00534                 <span class="keywordflow">if</span> (header &amp; MemoryPage_Name_allocated_mask) alloc.deallocate_string(a-&gt;Name); 
<a name="l00535"></a>00535                 <span class="keywordflow">if</span> (header &amp; MemoryPage_Value_allocated_mask) alloc.deallocate_string(a-&gt;Value); 
<a name="l00536"></a>00536  
<a name="l00537"></a>00537                 alloc.deallocate_memory(a, <span class="keyword">sizeof</span>(<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>), reinterpret_cast&lt;MemoryPage*&gt;(header &amp; MemoryPage_pointer_mask)); 
<a name="l00538"></a>00538         } 
<a name="l00539"></a>00539  
<a name="l00540"></a>00540         <span class="keyword">inline</span> <span class="keywordtype">void</span> destroy_node(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* n, Allocator&amp; alloc) 
<a name="l00541"></a>00541         { 
<a name="l00542"></a>00542                 uintptr_t header = n-&gt;header; 
<a name="l00543"></a>00543  
<a name="l00544"></a>00544                 <span class="keywordflow">if</span> (header &amp; MemoryPage_Name_allocated_mask) alloc.deallocate_string(n-&gt;Name); 
<a name="l00545"></a>00545                 <span class="keywordflow">if</span> (header &amp; MemoryPage_Value_allocated_mask) alloc.deallocate_string(n-&gt;Value); 
<a name="l00546"></a>00546  
<a name="l00547"></a>00547                 <span class="keywordflow">for</span> (<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* attr = n-&gt;GetFirstAttribute; attr; ) 
<a name="l00548"></a>00548                 { 
<a name="l00549"></a>00549                         <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* next = attr-&gt;GetNextAttribute; 
<a name="l00550"></a>00550  
<a name="l00551"></a>00551                         destroy_attribute(attr, alloc); 
<a name="l00552"></a>00552  
<a name="l00553"></a>00553                         attr = next; 
<a name="l00554"></a>00554                 } 
<a name="l00555"></a>00555  
<a name="l00556"></a>00556                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* GetChild = n-&gt;GetFirstChild; GetChild; ) 
<a name="l00557"></a>00557                 { 
<a name="l00558"></a>00558                         <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* next = GetChild-&gt;GetNextSibling; 
<a name="l00559"></a>00559  
<a name="l00560"></a>00560                         destroy_node(GetChild, alloc); 
<a name="l00561"></a>00561  
<a name="l00562"></a>00562                         GetChild = next; 
<a name="l00563"></a>00563                 } 
<a name="l00564"></a>00564  
<a name="l00565"></a>00565                 alloc.deallocate_memory(n, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>), reinterpret_cast&lt;MemoryPage*&gt;(header &amp; MemoryPage_pointer_mask)); 
<a name="l00566"></a>00566         } 
<a name="l00567"></a>00567  
<a name="l00568"></a>00568         XML_NO_INLINE <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* AppendNode(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* node, Allocator&amp; alloc, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type = <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>) 
<a name="l00569"></a>00569         { 
<a name="l00570"></a>00570                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* GetChild = allocate_node(alloc, Type); 
<a name="l00571"></a>00571                 <span class="keywordflow">if</span> (!GetChild) <span class="keywordflow">return</span> 0; 
<a name="l00572"></a>00572  
<a name="l00573"></a>00573                 GetChild-&gt;GetParent = node; 
<a name="l00574"></a>00574  
<a name="l00575"></a>00575                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* GetFirstChild = node-&gt;GetFirstChild; 
<a name="l00576"></a>00576                          
<a name="l00577"></a>00577                 <span class="keywordflow">if</span> (GetFirstChild) 
<a name="l00578"></a>00578                 { 
<a name="l00579"></a>00579                         <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* GetLastChild = GetFirstChild-&gt;prev_sibling_c; 
<a name="l00580"></a>00580  
<a name="l00581"></a>00581                         GetLastChild-&gt;GetNextSibling = GetChild; 
<a name="l00582"></a>00582                         GetChild-&gt;prev_sibling_c = GetLastChild; 
<a name="l00583"></a>00583                         GetFirstChild-&gt;prev_sibling_c = GetChild; 
<a name="l00584"></a>00584                 } 
<a name="l00585"></a>00585                 <span class="keywordflow">else</span> 
<a name="l00586"></a>00586                 { 
<a name="l00587"></a>00587                         node-&gt;GetFirstChild = GetChild; 
<a name="l00588"></a>00588                         GetChild-&gt;prev_sibling_c = GetChild; 
<a name="l00589"></a>00589                 } 
<a name="l00590"></a>00590                          
<a name="l00591"></a>00591                 <span class="keywordflow">return</span> GetChild; 
<a name="l00592"></a>00592         } 
<a name="l00593"></a>00593  
<a name="l00594"></a>00594         XML_NO_INLINE <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* AppendAttribute_ll(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* node, Allocator&amp; alloc) 
<a name="l00595"></a>00595         { 
<a name="l00596"></a>00596                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* a = allocate_attribute(alloc); 
<a name="l00597"></a>00597                 <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> 0; 
<a name="l00598"></a>00598  
<a name="l00599"></a>00599                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* GetFirstAttribute = node-&gt;GetFirstAttribute; 
<a name="l00600"></a>00600  
<a name="l00601"></a>00601                 <span class="keywordflow">if</span> (GetFirstAttribute) 
<a name="l00602"></a>00602                 { 
<a name="l00603"></a>00603                         <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* GetLastAttribute = GetFirstAttribute-&gt;prev_attribute_c; 
<a name="l00604"></a>00604  
<a name="l00605"></a>00605                         GetLastAttribute-&gt;GetNextAttribute = a; 
<a name="l00606"></a>00606                         a-&gt;prev_attribute_c = GetLastAttribute; 
<a name="l00607"></a>00607                         GetFirstAttribute-&gt;prev_attribute_c = a; 
<a name="l00608"></a>00608                 } 
<a name="l00609"></a>00609                 <span class="keywordflow">else</span> 
<a name="l00610"></a>00610                 { 
<a name="l00611"></a>00611                         node-&gt;GetFirstAttribute = a; 
<a name="l00612"></a>00612                         a-&gt;prev_attribute_c = a; 
<a name="l00613"></a>00613                 } 
<a name="l00614"></a>00614                          
<a name="l00615"></a>00615                 <span class="keywordflow">return</span> a; 
<a name="l00616"></a>00616         } 
<a name="l00617"></a>00617 } 
<a name="l00618"></a>00618  
<a name="l00619"></a>00619 <span class="comment">// Helper classes for code generation </span>
<a name="l00620"></a>00620 <span class="keyword">namespace </span>
<a name="l00621"></a>00621 { 
<a name="l00622"></a>00622         <span class="keyword">struct </span>opt_false 
<a name="l00623"></a>00623         { 
<a name="l00624"></a>00624                 <span class="keyword">enum</span> { Value = 0 }; 
<a name="l00625"></a>00625         }; 
<a name="l00626"></a>00626  
<a name="l00627"></a>00627         <span class="keyword">struct </span>opt_true 
<a name="l00628"></a>00628         { 
<a name="l00629"></a>00629                 <span class="keyword">enum</span> { Value = 1 }; 
<a name="l00630"></a>00630         }; 
<a name="l00631"></a>00631 } 
<a name="l00632"></a>00632  
<a name="l00633"></a>00633 <span class="comment">// Unicode utilities </span>
<a name="l00634"></a>00634 <span class="keyword">namespace </span>
<a name="l00635"></a>00635 { 
<a name="l00636"></a>00636         <span class="keyword">inline</span> uint16_t endian_swap(uint16_t Value) 
<a name="l00637"></a>00637         { 
<a name="l00638"></a>00638                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(((Value &amp; 0xff) &lt;&lt; 8) | (Value &gt;&gt; 8)); 
<a name="l00639"></a>00639         } 
<a name="l00640"></a>00640  
<a name="l00641"></a>00641         <span class="keyword">inline</span> uint32_t endian_swap(uint32_t Value) 
<a name="l00642"></a>00642         { 
<a name="l00643"></a>00643                 <span class="keywordflow">return</span> ((Value &amp; 0xff) &lt;&lt; 24) | ((Value &amp; 0xff00) &lt;&lt; 8) | ((Value &amp; 0xff0000) &gt;&gt; 8) | (Value &gt;&gt; 24); 
<a name="l00644"></a>00644         } 
<a name="l00645"></a>00645  
<a name="l00646"></a>00646         <span class="keyword">struct </span>utf8_counter 
<a name="l00647"></a>00647         { 
<a name="l00648"></a>00648                 <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> value_type; 
<a name="l00649"></a>00649  
<a name="l00650"></a>00650                 <span class="keyword">static</span> value_type low(value_type Result, uint32_t ch) 
<a name="l00651"></a>00651                 { 
<a name="l00652"></a>00652                         <span class="comment">// U+0000..U+007F </span>
<a name="l00653"></a>00653                         <span class="keywordflow">if</span> (ch &lt; 0x80) <span class="keywordflow">return</span> Result + 1; 
<a name="l00654"></a>00654                         <span class="comment">// U+0080..U+07FF </span>
<a name="l00655"></a>00655                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x800) <span class="keywordflow">return</span> Result + 2; 
<a name="l00656"></a>00656                         <span class="comment">// U+0800..U+FFFF </span>
<a name="l00657"></a>00657                         <span class="keywordflow">else</span> <span class="keywordflow">return</span> Result + 3; 
<a name="l00658"></a>00658                 } 
<a name="l00659"></a>00659  
<a name="l00660"></a>00660                 <span class="keyword">static</span> value_type high(value_type Result, uint32_t) 
<a name="l00661"></a>00661                 { 
<a name="l00662"></a>00662                         <span class="comment">// U+10000..U+10FFFF </span>
<a name="l00663"></a>00663                         <span class="keywordflow">return</span> Result + 4; 
<a name="l00664"></a>00664                 } 
<a name="l00665"></a>00665         }; 
<a name="l00666"></a>00666  
<a name="l00667"></a>00667         <span class="keyword">struct </span>utf8_WriterInstance 
<a name="l00668"></a>00668         { 
<a name="l00669"></a>00669                 <span class="keyword">typedef</span> uint8_t* value_type; 
<a name="l00670"></a>00670  
<a name="l00671"></a>00671                 <span class="keyword">static</span> value_type low(value_type Result, uint32_t ch) 
<a name="l00672"></a>00672                 { 
<a name="l00673"></a>00673                         <span class="comment">// U+0000..U+007F </span>
<a name="l00674"></a>00674                         <span class="keywordflow">if</span> (ch &lt; 0x80) 
<a name="l00675"></a>00675                         { 
<a name="l00676"></a>00676                                 *Result = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(ch); 
<a name="l00677"></a>00677                                 <span class="keywordflow">return</span> Result + 1; 
<a name="l00678"></a>00678                         } 
<a name="l00679"></a>00679                         <span class="comment">// U+0080..U+07FF </span>
<a name="l00680"></a>00680                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch &lt; 0x800) 
<a name="l00681"></a>00681                         { 
<a name="l00682"></a>00682                                 Result[0] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0xC0 | (ch &gt;&gt; 6)); 
<a name="l00683"></a>00683                                 Result[1] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0x80 | (ch &amp; 0x3F)); 
<a name="l00684"></a>00684                                 <span class="keywordflow">return</span> Result + 2; 
<a name="l00685"></a>00685                         } 
<a name="l00686"></a>00686                         <span class="comment">// U+0800..U+FFFF </span>
<a name="l00687"></a>00687                         <span class="keywordflow">else</span> 
<a name="l00688"></a>00688                         { 
<a name="l00689"></a>00689                                 Result[0] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0xE0 | (ch &gt;&gt; 12)); 
<a name="l00690"></a>00690                                 Result[1] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0x80 | ((ch &gt;&gt; 6) &amp; 0x3F)); 
<a name="l00691"></a>00691                                 Result[2] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0x80 | (ch &amp; 0x3F)); 
<a name="l00692"></a>00692                                 <span class="keywordflow">return</span> Result + 3; 
<a name="l00693"></a>00693                         } 
<a name="l00694"></a>00694                 } 
<a name="l00695"></a>00695  
<a name="l00696"></a>00696                 <span class="keyword">static</span> value_type high(value_type Result, uint32_t ch) 
<a name="l00697"></a>00697                 { 
<a name="l00698"></a>00698                         <span class="comment">// U+10000..U+10FFFF </span>
<a name="l00699"></a>00699                         Result[0] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0xF0 | (ch &gt;&gt; 18)); 
<a name="l00700"></a>00700                         Result[1] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0x80 | ((ch &gt;&gt; 12) &amp; 0x3F)); 
<a name="l00701"></a>00701                         Result[2] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0x80 | ((ch &gt;&gt; 6) &amp; 0x3F)); 
<a name="l00702"></a>00702                         Result[3] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(0x80 | (ch &amp; 0x3F)); 
<a name="l00703"></a>00703                         <span class="keywordflow">return</span> Result + 4; 
<a name="l00704"></a>00704                 } 
<a name="l00705"></a>00705  
<a name="l00706"></a>00706                 <span class="keyword">static</span> value_type any(value_type Result, uint32_t ch) 
<a name="l00707"></a>00707                 { 
<a name="l00708"></a>00708                         <span class="keywordflow">return</span> (ch &lt; 0x10000) ? low(Result, ch) : high(Result, ch); 
<a name="l00709"></a>00709                 } 
<a name="l00710"></a>00710         }; 
<a name="l00711"></a>00711  
<a name="l00712"></a>00712         <span class="keyword">struct </span>utf16_counter 
<a name="l00713"></a>00713         { 
<a name="l00714"></a>00714                 <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> value_type; 
<a name="l00715"></a>00715  
<a name="l00716"></a>00716                 <span class="keyword">static</span> value_type low(value_type Result, uint32_t) 
<a name="l00717"></a>00717                 { 
<a name="l00718"></a>00718                         <span class="keywordflow">return</span> Result + 1; 
<a name="l00719"></a>00719                 } 
<a name="l00720"></a>00720  
<a name="l00721"></a>00721                 <span class="keyword">static</span> value_type high(value_type Result, uint32_t) 
<a name="l00722"></a>00722                 { 
<a name="l00723"></a>00723                         <span class="keywordflow">return</span> Result + 2; 
<a name="l00724"></a>00724                 } 
<a name="l00725"></a>00725         }; 
<a name="l00726"></a>00726  
<a name="l00727"></a>00727         <span class="keyword">struct </span>utf16_WriterInstance 
<a name="l00728"></a>00728         { 
<a name="l00729"></a>00729                 <span class="keyword">typedef</span> uint16_t* value_type; 
<a name="l00730"></a>00730  
<a name="l00731"></a>00731                 <span class="keyword">static</span> value_type low(value_type Result, uint32_t ch) 
<a name="l00732"></a>00732                 { 
<a name="l00733"></a>00733                         *Result = <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(ch); 
<a name="l00734"></a>00734  
<a name="l00735"></a>00735                         <span class="keywordflow">return</span> Result + 1; 
<a name="l00736"></a>00736                 } 
<a name="l00737"></a>00737  
<a name="l00738"></a>00738                 <span class="keyword">static</span> value_type high(value_type Result, uint32_t ch) 
<a name="l00739"></a>00739                 { 
<a name="l00740"></a>00740                         uint32_t msh = (uint32_t)(ch - 0x10000) &gt;&gt; 10; 
<a name="l00741"></a>00741                         uint32_t lsh = (uint32_t)(ch - 0x10000) &amp; 0x3ff; 
<a name="l00742"></a>00742  
<a name="l00743"></a>00743                         Result[0] = <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(0xD800 + msh); 
<a name="l00744"></a>00744                         Result[1] = <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(0xDC00 + lsh); 
<a name="l00745"></a>00745  
<a name="l00746"></a>00746                         <span class="keywordflow">return</span> Result + 2; 
<a name="l00747"></a>00747                 } 
<a name="l00748"></a>00748  
<a name="l00749"></a>00749                 <span class="keyword">static</span> value_type any(value_type Result, uint32_t ch) 
<a name="l00750"></a>00750                 { 
<a name="l00751"></a>00751                         <span class="keywordflow">return</span> (ch &lt; 0x10000) ? low(Result, ch) : high(Result, ch); 
<a name="l00752"></a>00752                 } 
<a name="l00753"></a>00753         }; 
<a name="l00754"></a>00754  
<a name="l00755"></a>00755         <span class="keyword">struct </span>utf32_counter 
<a name="l00756"></a>00756         { 
<a name="l00757"></a>00757                 <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> value_type; 
<a name="l00758"></a>00758  
<a name="l00759"></a>00759                 <span class="keyword">static</span> value_type low(value_type Result, uint32_t) 
<a name="l00760"></a>00760                 { 
<a name="l00761"></a>00761                         <span class="keywordflow">return</span> Result + 1; 
<a name="l00762"></a>00762                 } 
<a name="l00763"></a>00763  
<a name="l00764"></a>00764                 <span class="keyword">static</span> value_type high(value_type Result, uint32_t) 
<a name="l00765"></a>00765                 { 
<a name="l00766"></a>00766                         <span class="keywordflow">return</span> Result + 1; 
<a name="l00767"></a>00767                 } 
<a name="l00768"></a>00768         }; 
<a name="l00769"></a>00769  
<a name="l00770"></a>00770         <span class="keyword">struct </span>utf32_WriterInstance 
<a name="l00771"></a>00771         { 
<a name="l00772"></a>00772                 <span class="keyword">typedef</span> uint32_t* value_type; 
<a name="l00773"></a>00773  
<a name="l00774"></a>00774                 <span class="keyword">static</span> value_type low(value_type Result, uint32_t ch) 
<a name="l00775"></a>00775                 { 
<a name="l00776"></a>00776                         *Result = ch; 
<a name="l00777"></a>00777  
<a name="l00778"></a>00778                         <span class="keywordflow">return</span> Result + 1; 
<a name="l00779"></a>00779                 } 
<a name="l00780"></a>00780  
<a name="l00781"></a>00781                 <span class="keyword">static</span> value_type high(value_type Result, uint32_t ch) 
<a name="l00782"></a>00782                 { 
<a name="l00783"></a>00783                         *Result = ch; 
<a name="l00784"></a>00784  
<a name="l00785"></a>00785                         <span class="keywordflow">return</span> Result + 1; 
<a name="l00786"></a>00786                 } 
<a name="l00787"></a>00787  
<a name="l00788"></a>00788                 <span class="keyword">static</span> value_type any(value_type Result, uint32_t ch) 
<a name="l00789"></a>00789                 { 
<a name="l00790"></a>00790                         *Result = ch; 
<a name="l00791"></a>00791  
<a name="l00792"></a>00792                         <span class="keywordflow">return</span> Result + 1; 
<a name="l00793"></a>00793                 } 
<a name="l00794"></a>00794         }; 
<a name="l00795"></a>00795  
<a name="l00796"></a>00796         <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> size&gt; <span class="keyword">struct </span>wchar_selector; 
<a name="l00797"></a>00797  
<a name="l00798"></a>00798         <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>wchar_selector&lt;2&gt; 
<a name="l00799"></a>00799         { 
<a name="l00800"></a>00800                 <span class="keyword">typedef</span> uint16_t Type; 
<a name="l00801"></a>00801                 <span class="keyword">typedef</span> utf16_counter counter; 
<a name="l00802"></a>00802                 <span class="keyword">typedef</span> utf16_WriterInstance WriterInstance; 
<a name="l00803"></a>00803         }; 
<a name="l00804"></a>00804  
<a name="l00805"></a>00805         <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>wchar_selector&lt;4&gt; 
<a name="l00806"></a>00806         { 
<a name="l00807"></a>00807                 <span class="keyword">typedef</span> uint32_t Type; 
<a name="l00808"></a>00808                 <span class="keyword">typedef</span> utf32_counter counter; 
<a name="l00809"></a>00809                 <span class="keyword">typedef</span> utf32_WriterInstance WriterInstance; 
<a name="l00810"></a>00810         }; 
<a name="l00811"></a>00811  
<a name="l00812"></a>00812         <span class="keyword">typedef</span> wchar_selector&lt;sizeof(wchar_t)&gt;::counter wchar_counter; 
<a name="l00813"></a>00813         <span class="keyword">typedef</span> wchar_selector&lt;sizeof(wchar_t)&gt;::WriterInstance wchar_WriterInstance; 
<a name="l00814"></a>00814  
<a name="l00815"></a>00815         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Traits, <span class="keyword">typename</span> opt_swap = opt_false&gt; <span class="keyword">struct </span>utf_decoder 
<a name="l00816"></a>00816         { 
<a name="l00817"></a>00817                 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">typename</span> Traits::value_type decode_utf8_block(<span class="keyword">const</span> uint8_t* data, <span class="keywordtype">size_t</span> size, <span class="keyword">typename</span> Traits::value_type Result) 
<a name="l00818"></a>00818                 { 
<a name="l00819"></a>00819                         <span class="keyword">const</span> uint8_t utf8_byte_mask = 0x3f; 
<a name="l00820"></a>00820  
<a name="l00821"></a>00821                         <span class="keywordflow">while</span> (size) 
<a name="l00822"></a>00822                         { 
<a name="l00823"></a>00823                                 uint8_t lead = *data; 
<a name="l00824"></a>00824  
<a name="l00825"></a>00825                                 <span class="comment">// 0xxxxxxx -&gt; U+0000..U+007F </span>
<a name="l00826"></a>00826                                 <span class="keywordflow">if</span> (lead &lt; 0x80) 
<a name="l00827"></a>00827                                 { 
<a name="l00828"></a>00828                                         Result = Traits::low(Result, lead); 
<a name="l00829"></a>00829                                         data += 1; 
<a name="l00830"></a>00830                                         size -= 1; 
<a name="l00831"></a>00831  
<a name="l00832"></a>00832                                         <span class="comment">// process aligned single-byte (ascii) blocks </span>
<a name="l00833"></a>00833                                         <span class="keywordflow">if</span> ((reinterpret_cast&lt;uintptr_t&gt;(data) &amp; 3) == 0) 
<a name="l00834"></a>00834                                         { 
<a name="l00835"></a>00835                                                 <span class="keywordflow">while</span> (size &gt;= 4 &amp;&amp; (*reinterpret_cast&lt;const uint32_t*&gt;(data) &amp; 0x80808080) == 0) 
<a name="l00836"></a>00836                                                 { 
<a name="l00837"></a>00837                                                         Result = Traits::low(Result, data[0]); 
<a name="l00838"></a>00838                                                         Result = Traits::low(Result, data[1]); 
<a name="l00839"></a>00839                                                         Result = Traits::low(Result, data[2]); 
<a name="l00840"></a>00840                                                         Result = Traits::low(Result, data[3]); 
<a name="l00841"></a>00841                                                         data += 4; 
<a name="l00842"></a>00842                                                         size -= 4; 
<a name="l00843"></a>00843                                                 } 
<a name="l00844"></a>00844                                         } 
<a name="l00845"></a>00845                                 } 
<a name="l00846"></a>00846                                 <span class="comment">// 110xxxxx -&gt; U+0080..U+07FF </span>
<a name="l00847"></a>00847                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)(lead - 0xC0) &lt; 0x20 &amp;&amp; size &gt;= 2 &amp;&amp; (data[1] &amp; 0xc0) == 0x80) 
<a name="l00848"></a>00848                                 { 
<a name="l00849"></a>00849                                         Result = Traits::low(Result, ((lead &amp; ~0xC0) &lt;&lt; 6) | (data[1] &amp; utf8_byte_mask)); 
<a name="l00850"></a>00850                                         data += 2; 
<a name="l00851"></a>00851                                         size -= 2; 
<a name="l00852"></a>00852                                 } 
<a name="l00853"></a>00853                                 <span class="comment">// 1110xxxx -&gt; U+0800-U+FFFF </span>
<a name="l00854"></a>00854                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)(lead - 0xE0) &lt; 0x10 &amp;&amp; size &gt;= 3 &amp;&amp; (data[1] &amp; 0xc0) == 0x80 &amp;&amp; (data[2] &amp; 0xc0) == 0x80) 
<a name="l00855"></a>00855                                 { 
<a name="l00856"></a>00856                                         Result = Traits::low(Result, ((lead &amp; ~0xE0) &lt;&lt; 12) | ((data[1] &amp; utf8_byte_mask) &lt;&lt; 6) | (data[2] &amp; utf8_byte_mask)); 
<a name="l00857"></a>00857                                         data += 3; 
<a name="l00858"></a>00858                                         size -= 3; 
<a name="l00859"></a>00859                                 } 
<a name="l00860"></a>00860                                 <span class="comment">// 11110xxx -&gt; U+10000..U+10FFFF </span>
<a name="l00861"></a>00861                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)(lead - 0xF0) &lt; 0x08 &amp;&amp; size &gt;= 4 &amp;&amp; (data[1] &amp; 0xc0) == 0x80 &amp;&amp; (data[2] &amp; 0xc0) == 0x80 &amp;&amp; (data[3] &amp; 0xc0) == 0x80) 
<a name="l00862"></a>00862                                 { 
<a name="l00863"></a>00863                                         Result = Traits::high(Result, ((lead &amp; ~0xF0) &lt;&lt; 18) | ((data[1] &amp; utf8_byte_mask) &lt;&lt; 12) | ((data[2] &amp; utf8_byte_mask) &lt;&lt; 6) | (data[3] &amp; utf8_byte_mask)); 
<a name="l00864"></a>00864                                         data += 4; 
<a name="l00865"></a>00865                                         size -= 4; 
<a name="l00866"></a>00866                                 } 
<a name="l00867"></a>00867                                 <span class="comment">// 10xxxxxx or 11111xxx -&gt; invalid </span>
<a name="l00868"></a>00868                                 <span class="keywordflow">else</span> 
<a name="l00869"></a>00869                                 { 
<a name="l00870"></a>00870                                         data += 1; 
<a name="l00871"></a>00871                                         size -= 1; 
<a name="l00872"></a>00872                                 } 
<a name="l00873"></a>00873                         } 
<a name="l00874"></a>00874  
<a name="l00875"></a>00875                         <span class="keywordflow">return</span> Result; 
<a name="l00876"></a>00876                 } 
<a name="l00877"></a>00877  
<a name="l00878"></a>00878                 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">typename</span> Traits::value_type decode_utf16_block(<span class="keyword">const</span> uint16_t* data, <span class="keywordtype">size_t</span> size, <span class="keyword">typename</span> Traits::value_type Result) 
<a name="l00879"></a>00879                 { 
<a name="l00880"></a>00880                         <span class="keyword">const</span> uint16_t* end = data + size; 
<a name="l00881"></a>00881  
<a name="l00882"></a>00882                         <span class="keywordflow">while</span> (data &lt; end) 
<a name="l00883"></a>00883                         { 
<a name="l00884"></a>00884                                 uint16_t lead = opt_swap::Value ? endian_swap(*data) : *data; 
<a name="l00885"></a>00885  
<a name="l00886"></a>00886                                 <span class="comment">// U+0000..U+D7FF </span>
<a name="l00887"></a>00887                                 <span class="keywordflow">if</span> (lead &lt; 0xD800) 
<a name="l00888"></a>00888                                 { 
<a name="l00889"></a>00889                                         Result = Traits::low(Result, lead); 
<a name="l00890"></a>00890                                         data += 1; 
<a name="l00891"></a>00891                                 } 
<a name="l00892"></a>00892                                 <span class="comment">// U+E000..U+FFFF </span>
<a name="l00893"></a>00893                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)(lead - 0xE000) &lt; 0x2000) 
<a name="l00894"></a>00894                                 { 
<a name="l00895"></a>00895                                         Result = Traits::low(Result, lead); 
<a name="l00896"></a>00896                                         data += 1; 
<a name="l00897"></a>00897                                 } 
<a name="l00898"></a>00898                                 <span class="comment">// surrogate pair lead </span>
<a name="l00899"></a>00899                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)(lead - 0xD800) &lt; 0x400 &amp;&amp; data + 1 &lt; end) 
<a name="l00900"></a>00900                                 { 
<a name="l00901"></a>00901                                         uint16_t next = opt_swap::Value ? endian_swap(data[1]) : data[1]; 
<a name="l00902"></a>00902  
<a name="l00903"></a>00903                                         <span class="keywordflow">if</span> ((<span class="keywordtype">unsigned</span>)(next - 0xDC00) &lt; 0x400) 
<a name="l00904"></a>00904                                         { 
<a name="l00905"></a>00905                                                 Result = Traits::high(Result, 0x10000 + ((lead &amp; 0x3ff) &lt;&lt; 10) + (next &amp; 0x3ff)); 
<a name="l00906"></a>00906                                                 data += 2; 
<a name="l00907"></a>00907                                         } 
<a name="l00908"></a>00908                                         <span class="keywordflow">else</span> 
<a name="l00909"></a>00909                                         { 
<a name="l00910"></a>00910                                                 data += 1; 
<a name="l00911"></a>00911                                         } 
<a name="l00912"></a>00912                                 } 
<a name="l00913"></a>00913                                 <span class="keywordflow">else</span> 
<a name="l00914"></a>00914                                 { 
<a name="l00915"></a>00915                                         data += 1; 
<a name="l00916"></a>00916                                 } 
<a name="l00917"></a>00917                         } 
<a name="l00918"></a>00918  
<a name="l00919"></a>00919                         <span class="keywordflow">return</span> Result; 
<a name="l00920"></a>00920                 } 
<a name="l00921"></a>00921  
<a name="l00922"></a>00922                 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">typename</span> Traits::value_type decode_utf32_block(<span class="keyword">const</span> uint32_t* data, <span class="keywordtype">size_t</span> size, <span class="keyword">typename</span> Traits::value_type Result) 
<a name="l00923"></a>00923                 { 
<a name="l00924"></a>00924                         <span class="keyword">const</span> uint32_t* end = data + size; 
<a name="l00925"></a>00925  
<a name="l00926"></a>00926                         <span class="keywordflow">while</span> (data &lt; end) 
<a name="l00927"></a>00927                         { 
<a name="l00928"></a>00928                                 uint32_t lead = opt_swap::Value ? endian_swap(*data) : *data; 
<a name="l00929"></a>00929  
<a name="l00930"></a>00930                                 <span class="comment">// U+0000..U+FFFF </span>
<a name="l00931"></a>00931                                 <span class="keywordflow">if</span> (lead &lt; 0x10000) 
<a name="l00932"></a>00932                                 { 
<a name="l00933"></a>00933                                         Result = Traits::low(Result, lead); 
<a name="l00934"></a>00934                                         data += 1; 
<a name="l00935"></a>00935                                 } 
<a name="l00936"></a>00936                                 <span class="comment">// U+10000..U+10FFFF </span>
<a name="l00937"></a>00937                                 <span class="keywordflow">else</span> 
<a name="l00938"></a>00938                                 { 
<a name="l00939"></a>00939                                         Result = Traits::high(Result, lead); 
<a name="l00940"></a>00940                                         data += 1; 
<a name="l00941"></a>00941                                 } 
<a name="l00942"></a>00942                         } 
<a name="l00943"></a>00943  
<a name="l00944"></a>00944                         <span class="keywordflow">return</span> Result; 
<a name="l00945"></a>00945                 } 
<a name="l00946"></a>00946         }; 
<a name="l00947"></a>00947  
<a name="l00948"></a>00948         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> convert_utf_endian_swap(T* Result, <span class="keyword">const</span> T* data, <span class="keywordtype">size_t</span> length) 
<a name="l00949"></a>00949         { 
<a name="l00950"></a>00950                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; length; ++i) Result[i] = endian_swap(data[i]); 
<a name="l00951"></a>00951         } 
<a name="l00952"></a>00952  
<a name="l00953"></a>00953         <span class="keyword">inline</span> <span class="keywordtype">void</span> convert_wchar_endian_swap(<span class="keywordtype">wchar_t</span>* Result, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* data, <span class="keywordtype">size_t</span> length) 
<a name="l00954"></a>00954         { 
<a name="l00955"></a>00955                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; length; ++i) Result[i] = static_cast&lt;wchar_t&gt;(endian_swap(<span class="keyword">static_cast&lt;</span>wchar_selector&lt;sizeof(wchar_t)&gt;::Type<span class="keyword">&gt;</span>(data[i]))); 
<a name="l00956"></a>00956         } 
<a name="l00957"></a>00957 } 
<a name="l00958"></a>00958  
<a name="l00959"></a>00959 <span class="keyword">namespace </span>
<a name="l00960"></a>00960 {        
<a name="l00961"></a>00961         <span class="keyword">enum</span> charCollectionType 
<a name="l00962"></a>00962         { 
<a name="l00963"></a>00963                 ct_ParsePcdata = 1,     <span class="comment">// \0, &amp;, \r, &lt; </span>
<a name="l00964"></a>00964                 ct_ParseAttr = 2,               <span class="comment">// \0, &amp;, \r, &#39;, &quot; </span>
<a name="l00965"></a>00965                 ct_ParseAttrWs = 4,     <span class="comment">// \0, &amp;, \r, &#39;, &quot;, \n, tab </span>
<a name="l00966"></a>00966                 ct_space = 8,                   <span class="comment">// \r, \n, space, tab </span>
<a name="l00967"></a>00967                 ct_ParseCdata = 16,     <span class="comment">// \0, ], &gt;, \r </span>
<a name="l00968"></a>00968                 ct_ParseComment = 32,   <span class="comment">// \0, -, &gt;, \r </span>
<a name="l00969"></a>00969                 ct_symbol = 64,                 <span class="comment">// Any symbol &gt; 127, a-z, A-Z, 0-9, _, :, -, . </span>
<a name="l00970"></a>00970                 ct_start_symbol = 128   <span class="comment">// Any symbol &gt; 127, a-z, A-Z, _, : </span>
<a name="l00971"></a>00971         }; 
<a name="l00972"></a>00972  
<a name="l00973"></a>00973         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> charCollectionTypeable[256] = 
<a name="l00974"></a>00974         { 
<a name="l00975"></a>00975                 55,  0,   0,   0,   0,   0,   0,   0,     0,   12,  12,  0,   0,   63,  0,   0,   <span class="comment">// 0-15 </span>
<a name="l00976"></a>00976                 0,   0,   0,   0,   0,   0,   0,   0,     0,   0,   0,   0,   0,   0,   0,   0,   <span class="comment">// 16-31 </span>
<a name="l00977"></a>00977                 8,   0,   6,   0,   0,   0,   7,   6,     0,   0,   0,   0,   0,   96,  64,  0,   <span class="comment">// 32-47 </span>
<a name="l00978"></a>00978                 64,  64,  64,  64,  64,  64,  64,  64,   64,  64,  192, 0,   1,   0,   48,  0,   <span class="comment">// 48-63 </span>
<a name="l00979"></a>00979                 0,   192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, <span class="comment">// 64-79 </span>
<a name="l00980"></a>00980                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 0,   0,   16,  0,   192, <span class="comment">// 80-95 </span>
<a name="l00981"></a>00981                 0,   192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, <span class="comment">// 96-111 </span>
<a name="l00982"></a>00982                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 0, 0, 0, 0, 0,              <span class="comment">// 112-127 </span>
<a name="l00983"></a>00983  
<a name="l00984"></a>00984                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, <span class="comment">// 128+ </span>
<a name="l00985"></a>00985                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 
<a name="l00986"></a>00986                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 
<a name="l00987"></a>00987                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 
<a name="l00988"></a>00988                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 
<a name="l00989"></a>00989                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 
<a name="l00990"></a>00990                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 
<a name="l00991"></a>00991                 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192 
<a name="l00992"></a>00992         }; 
<a name="l00993"></a>00993  
<a name="l00994"></a>00994         <span class="keyword">enum</span> charTypex_t 
<a name="l00995"></a>00995         { 
<a name="l00996"></a>00996                 ctx_special_pcdata = 1,   <span class="comment">// Any symbol &gt;= 0 and &lt; 32 (except \t, \r, \n), &amp;, &lt;, &gt; </span>
<a name="l00997"></a>00997                 ctx_special_attr = 2,    <span class="comment">// Any symbol &gt;= 0 and &lt; 32 (except \t), &amp;, &lt;, &gt;, &quot; </span>
<a name="l00998"></a>00998                 ctx_start_symbol = 4,     <span class="comment">// Any symbol &gt; 127, a-z, A-Z, _ </span>
<a name="l00999"></a>00999                 ctx_digit = 8,                    <span class="comment">// 0-9 </span>
<a name="l01000"></a>01000                 ctx_symbol = 16                   <span class="comment">// Any symbol &gt; 127, a-z, A-Z, 0-9, _, -, . </span>
<a name="l01001"></a>01001         }; 
<a name="l01002"></a>01002          
<a name="l01003"></a>01003         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> charTypex_table[256] = 
<a name="l01004"></a>01004         { 
<a name="l01005"></a>01005                 3,  3,  3,  3,  3,  3,  3,  3,   3,  0,  2,  3,  3,  2,  3,  3,  <span class="comment">// 0-15 </span>
<a name="l01006"></a>01006                 3,  3,  3,  3,  3,  3,  3,  3,   3,  3,  3,  3,  3,  3,  3,  3,  <span class="comment">// 16-31 </span>
<a name="l01007"></a>01007                 0,  0,  2,  0,  0,  0,  3,  0,   0,  0,  0,  0,  0, 16, 16,  0,  <span class="comment">// 32-47 </span>
<a name="l01008"></a>01008                 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 0,  0,  3,  0,  3,  0,   <span class="comment">// 48-63 </span>
<a name="l01009"></a>01009  
<a name="l01010"></a>01010                 0,  20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, <span class="comment">// 64-79 </span>
<a name="l01011"></a>01011                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0,  0,  0,  0,  20, <span class="comment">// 80-95 </span>
<a name="l01012"></a>01012                 0,  20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, <span class="comment">// 96-111 </span>
<a name="l01013"></a>01013                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 0,  0,  0,  0,  0,   <span class="comment">// 112-127 </span>
<a name="l01014"></a>01014  
<a name="l01015"></a>01015                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, <span class="comment">// 128+ </span>
<a name="l01016"></a>01016                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
<a name="l01017"></a>01017                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
<a name="l01018"></a>01018                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
<a name="l01019"></a>01019                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
<a name="l01020"></a>01020                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
<a name="l01021"></a>01021                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
<a name="l01022"></a>01022                 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 
<a name="l01023"></a>01023         }; 
<a name="l01024"></a>01024          
<a name="l01025"></a>01025 <span class="preprocessor">#ifdef XML_WCHAR_MODE </span>
<a name="l01026"></a>01026 <span class="preprocessor"></span><span class="preprocessor">        #define IS_CHARTYPE_IMPL(c, ct, table) ((static_cast&lt;unsigned int&gt;(c) &lt; 128 ? table[static_cast&lt;unsigned int&gt;(c)] : table[128]) &amp; (ct)) </span>
<a name="l01027"></a>01027 <span class="preprocessor"></span><span class="preprocessor">#else </span>
<a name="l01028"></a>01028 <span class="preprocessor"></span><span class="preprocessor">        #define IS_CHARTYPE_IMPL(c, ct, table) (table[static_cast&lt;unsigned char&gt;(c)] &amp; (ct)) </span>
<a name="l01029"></a>01029 <span class="preprocessor"></span><span class="preprocessor">#endif </span>
<a name="l01030"></a>01030 <span class="preprocessor"></span> 
<a name="l01031"></a>01031 <span class="preprocessor">        #define IS_CHARTYPE(c, ct) IS_CHARTYPE_IMPL(c, ct, charCollectionTypeable) </span>
<a name="l01032"></a>01032 <span class="preprocessor"></span><span class="preprocessor">        #define IS_CHARTYPEX(c, ct) IS_CHARTYPE_IMPL(c, ct, charTypex_table) </span>
<a name="l01033"></a>01033 <span class="preprocessor"></span> 
<a name="l01034"></a>01034         <span class="keywordtype">bool</span> is_little_endian() 
<a name="l01035"></a>01035         { 
<a name="l01036"></a>01036                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ui = 1; 
<a name="l01037"></a>01037  
<a name="l01038"></a>01038                 <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;ui) == 1; 
<a name="l01039"></a>01039         } 
<a name="l01040"></a>01040  
<a name="l01041"></a>01041         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> GetWchar_DocumentEncoding() 
<a name="l01042"></a>01042         { 
<a name="l01043"></a>01043                 STATIC_ASSERT(<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 2 || <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 4); 
<a name="l01044"></a>01044  
<a name="l01045"></a>01045                 <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 2) 
<a name="l01046"></a>01046                         <span class="keywordflow">return</span> is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> : EncodingUTF16BE; 
<a name="l01047"></a>01047                 <span class="keywordflow">else</span>  
<a name="l01048"></a>01048                         <span class="keywordflow">return</span> is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> : EncodingUTF32BE; 
<a name="l01049"></a>01049         } 
<a name="l01050"></a>01050  
<a name="l01051"></a>01051         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> guess_buffer_DocumentEncoding(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) 
<a name="l01052"></a>01052         { 
<a name="l01053"></a>01053                 <span class="comment">// look for BOM in first few bytes </span>
<a name="l01054"></a>01054                 <span class="keywordflow">if</span> (d0 == 0 &amp;&amp; d1 == 0 &amp;&amp; d2 == 0xfe &amp;&amp; d3 == 0xff) <span class="keywordflow">return</span> EncodingUTF32BE; 
<a name="l01055"></a>01055                 <span class="keywordflow">if</span> (d0 == 0xff &amp;&amp; d1 == 0xfe &amp;&amp; d2 == 0 &amp;&amp; d3 == 0) <span class="keywordflow">return</span> EncodingUTF32LE; 
<a name="l01056"></a>01056                 <span class="keywordflow">if</span> (d0 == 0xfe &amp;&amp; d1 == 0xff) <span class="keywordflow">return</span> EncodingUTF16BE; 
<a name="l01057"></a>01057                 <span class="keywordflow">if</span> (d0 == 0xff &amp;&amp; d1 == 0xfe) <span class="keywordflow">return</span> EncodingUTF16LE; 
<a name="l01058"></a>01058                 <span class="keywordflow">if</span> (d0 == 0xef &amp;&amp; d1 == 0xbb &amp;&amp; d2 == 0xbf) <span class="keywordflow">return</span> EncodingUTF8; 
<a name="l01059"></a>01059  
<a name="l01060"></a>01060                 <span class="comment">// look for &lt;, &lt;? or &lt;?xm in various DocumentEncodings </span>
<a name="l01061"></a>01061                 <span class="keywordflow">if</span> (d0 == 0 &amp;&amp; d1 == 0 &amp;&amp; d2 == 0 &amp;&amp; d3 == 0x3c) <span class="keywordflow">return</span> EncodingUTF32BE; 
<a name="l01062"></a>01062                 <span class="keywordflow">if</span> (d0 == 0x3c &amp;&amp; d1 == 0 &amp;&amp; d2 == 0 &amp;&amp; d3 == 0) <span class="keywordflow">return</span> EncodingUTF32LE; 
<a name="l01063"></a>01063                 <span class="keywordflow">if</span> (d0 == 0 &amp;&amp; d1 == 0x3c &amp;&amp; d2 == 0 &amp;&amp; d3 == 0x3f) <span class="keywordflow">return</span> EncodingUTF16BE; 
<a name="l01064"></a>01064                 <span class="keywordflow">if</span> (d0 == 0x3c &amp;&amp; d1 == 0 &amp;&amp; d2 == 0x3f &amp;&amp; d3 == 0) <span class="keywordflow">return</span> EncodingUTF16LE; 
<a name="l01065"></a>01065                 <span class="keywordflow">if</span> (d0 == 0x3c &amp;&amp; d1 == 0x3f &amp;&amp; d2 == 0x78 &amp;&amp; d3 == 0x6d) <span class="keywordflow">return</span> EncodingUTF8; 
<a name="l01066"></a>01066  
<a name="l01067"></a>01067                 <span class="comment">// look for utf16 &lt; followed by node Name (this may fail, but is better than utf8 since it&#39;s zero terminated so early) </span>
<a name="l01068"></a>01068                 <span class="keywordflow">if</span> (d0 == 0 &amp;&amp; d1 == 0x3c) <span class="keywordflow">return</span> EncodingUTF16BE; 
<a name="l01069"></a>01069                 <span class="keywordflow">if</span> (d0 == 0x3c &amp;&amp; d1 == 0) <span class="keywordflow">return</span> EncodingUTF16LE; 
<a name="l01070"></a>01070  
<a name="l01071"></a>01071                 <span class="comment">// no known BOM detected, assume utf8 </span>
<a name="l01072"></a>01072                 <span class="keywordflow">return</span> EncodingUTF8; 
<a name="l01073"></a>01073         } 
<a name="l01074"></a>01074  
<a name="l01075"></a>01075         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> GetBuffer_DocumentEncoding(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size) 
<a name="l01076"></a>01076         { 
<a name="l01077"></a>01077                 <span class="comment">// replace wchar DocumentEncoding with utf implementation </span>
<a name="l01078"></a>01078                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2bc9c8d42796901c8feaa25e17c56cef" title="The same document encoding wchar_t has (usually either UTF16 or UTF32).">Encodingwchar_t</a>) <span class="keywordflow">return</span> GetWchar_DocumentEncoding(); 
<a name="l01079"></a>01079  
<a name="l01080"></a>01080                 <span class="comment">// replace utf16 DocumentEncoding with utf16 with specific endianness </span>
<a name="l01081"></a>01081                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015ac19070aaf7044426b0fe8fa5af956130" title="UTF16 with native endianness.">EncodingUTF16</a>) <span class="keywordflow">return</span> is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> : EncodingUTF16BE; 
<a name="l01082"></a>01082  
<a name="l01083"></a>01083                 <span class="comment">// replace utf32 DocumentEncoding with utf32 with specific endianness </span>
<a name="l01084"></a>01084                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015ac61c2f632bd66c2466c29783beb33f8a" title="UTF32 with native endianness.">EncodingUTF32</a>) <span class="keywordflow">return</span> is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> : EncodingUTF32BE; 
<a name="l01085"></a>01085  
<a name="l01086"></a>01086                 <span class="comment">// only do autodetection if no explicit DocumentEncoding is requested </span>
<a name="l01087"></a>01087                 <span class="keywordflow">if</span> (DocumentEncoding != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2792ef334e1061e7ad177df463256d85" title="Auto-detect input document encoding using Byte Order Mark (BOM) or &amp;lt; / &amp;lt;? detection; use UTF8 i...">EncodingAuto</a>) <span class="keywordflow">return</span> DocumentEncoding; 
<a name="l01088"></a>01088  
<a name="l01089"></a>01089                 <span class="comment">// skip DocumentEncoding autodetection if input buffer is too small </span>
<a name="l01090"></a>01090                 <span class="keywordflow">if</span> (size &lt; 4) <span class="keywordflow">return</span> EncodingUTF8; 
<a name="l01091"></a>01091  
<a name="l01092"></a>01092                 <span class="comment">// try to guess DocumentEncoding (based on XML specification, Appendix F.1) </span>
<a name="l01093"></a>01093                 <span class="keyword">const</span> uint8_t* data = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(contents); 
<a name="l01094"></a>01094  
<a name="l01095"></a>01095                 DMC_VOLATILE uint8_t d0 = data[0], d1 = data[1], d2 = data[2], d3 = data[3]; 
<a name="l01096"></a>01096  
<a name="l01097"></a>01097                 <span class="keywordflow">return</span> guess_buffer_DocumentEncoding(d0, d1, d2, d3); 
<a name="l01098"></a>01098         } 
<a name="l01099"></a>01099  
<a name="l01100"></a>01100         <span class="keywordtype">bool</span> GetMutable_buffer(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">bool</span> is_mutable) 
<a name="l01101"></a>01101         { 
<a name="l01102"></a>01102                 <span class="keywordflow">if</span> (is_mutable) 
<a name="l01103"></a>01103                 { 
<a name="l01104"></a>01104                         out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(contents)); 
<a name="l01105"></a>01105                 } 
<a name="l01106"></a>01106                 <span class="keywordflow">else</span> 
<a name="l01107"></a>01107                 { 
<a name="l01108"></a>01108                         <span class="keywordtype">void</span>* buffer = global_allocate(size &gt; 0 ? size : 1); 
<a name="l01109"></a>01109                         <span class="keywordflow">if</span> (!buffer) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01110"></a>01110  
<a name="l01111"></a>01111                         memcpy(buffer, contents, size); 
<a name="l01112"></a>01112  
<a name="l01113"></a>01113                         out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(buffer); 
<a name="l01114"></a>01114                 } 
<a name="l01115"></a>01115  
<a name="l01116"></a>01116                 out_length = size / <span class="keyword">sizeof</span>(char_t); 
<a name="l01117"></a>01117  
<a name="l01118"></a>01118                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01119"></a>01119         } 
<a name="l01120"></a>01120  
<a name="l01121"></a>01121 <span class="preprocessor">#ifdef XML_WCHAR_MODE </span>
<a name="l01122"></a>01122 <span class="preprocessor"></span>        <span class="keyword">inline</span> <span class="keywordtype">bool</span> need_endian_swap_utf(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> le, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> re) 
<a name="l01123"></a>01123         { 
<a name="l01124"></a>01124                 <span class="keywordflow">return</span> (le == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a04fd7b1fef8d2dcc67a46b8fe4dbcaf4" title="Big-endian UTF16.">EncodingUTF16BE</a> &amp;&amp; re == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a>) || (le == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> &amp;&amp; re == EncodingUTF16BE) || 
<a name="l01125"></a>01125                            (le == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a5fb13deaf1552b0f4c00e2b8cafce0b9" title="Big-endian UTF32.">EncodingUTF32BE</a> &amp;&amp; re == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a>) || (le == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> &amp;&amp; re == EncodingUTF32BE); 
<a name="l01126"></a>01126         } 
<a name="l01127"></a>01127  
<a name="l01128"></a>01128         <span class="keywordtype">bool</span> convert_buffer_endian_swap(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">bool</span> is_mutable) 
<a name="l01129"></a>01129         { 
<a name="l01130"></a>01130                 <span class="keyword">const</span> char_t* data = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>char_t*<span class="keyword">&gt;</span>(contents); 
<a name="l01131"></a>01131          
<a name="l01132"></a>01132                 <span class="keywordflow">if</span> (is_mutable) 
<a name="l01133"></a>01133                 { 
<a name="l01134"></a>01134                         out_buffer = <span class="keyword">const_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(data); 
<a name="l01135"></a>01135                 } 
<a name="l01136"></a>01136                 <span class="keywordflow">else</span> 
<a name="l01137"></a>01137                 { 
<a name="l01138"></a>01138                         out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate(size &gt; 0 ? size : 1)); 
<a name="l01139"></a>01139                         <span class="keywordflow">if</span> (!out_buffer) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01140"></a>01140                 } 
<a name="l01141"></a>01141  
<a name="l01142"></a>01142                 out_length = size / <span class="keyword">sizeof</span>(char_t); 
<a name="l01143"></a>01143  
<a name="l01144"></a>01144                 convert_wchar_endian_swap(out_buffer, data, out_length); 
<a name="l01145"></a>01145  
<a name="l01146"></a>01146                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01147"></a>01147         } 
<a name="l01148"></a>01148  
<a name="l01149"></a>01149         <span class="keywordtype">bool</span> convert_buffer_utf8(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size) 
<a name="l01150"></a>01150         { 
<a name="l01151"></a>01151                 <span class="keyword">const</span> uint8_t* data = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(contents); 
<a name="l01152"></a>01152  
<a name="l01153"></a>01153                 <span class="comment">// first pass: get length in wchar_t units </span>
<a name="l01154"></a>01154                 out_length = utf_decoder&lt;wchar_counter&gt;::decode_utf8_block(data, size, 0); 
<a name="l01155"></a>01155  
<a name="l01156"></a>01156                 <span class="comment">// allocate buffer of suitable length </span>
<a name="l01157"></a>01157                 out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate((out_length &gt; 0 ? out_length : 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l01158"></a>01158                 <span class="keywordflow">if</span> (!out_buffer) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01159"></a>01159  
<a name="l01160"></a>01160                 <span class="comment">// second pass: convert utf8 input to wchar_t </span>
<a name="l01161"></a>01161                 wchar_WriterInstance::value_type out_begin = <span class="keyword">reinterpret_cast&lt;</span>wchar_WriterInstance::value_type<span class="keyword">&gt;</span>(out_buffer); 
<a name="l01162"></a>01162                 wchar_WriterInstance::value_type out_end = utf_decoder&lt;wchar_WriterInstance&gt;::decode_utf8_block(data, size, out_begin); 
<a name="l01163"></a>01163  
<a name="l01164"></a>01164                 assert(out_end == out_begin + out_length); 
<a name="l01165"></a>01165                 (void)!out_end; 
<a name="l01166"></a>01166  
<a name="l01167"></a>01167                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01168"></a>01168         } 
<a name="l01169"></a>01169  
<a name="l01170"></a>01170         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> opt_swap&gt; <span class="keywordtype">bool</span> convert_buffer_utf16(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, opt_swap) 
<a name="l01171"></a>01171         { 
<a name="l01172"></a>01172                 <span class="keyword">const</span> uint16_t* data = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint16_t*<span class="keyword">&gt;</span>(contents); 
<a name="l01173"></a>01173                 <span class="keywordtype">size_t</span> length = size / <span class="keyword">sizeof</span>(uint16_t); 
<a name="l01174"></a>01174  
<a name="l01175"></a>01175                 <span class="comment">// first pass: get length in wchar_t units </span>
<a name="l01176"></a>01176                 out_length = utf_decoder&lt;wchar_counter, opt_swap&gt;::decode_utf16_block(data, length, 0); 
<a name="l01177"></a>01177  
<a name="l01178"></a>01178                 <span class="comment">// allocate buffer of suitable length </span>
<a name="l01179"></a>01179                 out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate((out_length &gt; 0 ? out_length : 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l01180"></a>01180                 <span class="keywordflow">if</span> (!out_buffer) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01181"></a>01181  
<a name="l01182"></a>01182                 <span class="comment">// second pass: convert utf16 input to wchar_t </span>
<a name="l01183"></a>01183                 wchar_WriterInstance::value_type out_begin = <span class="keyword">reinterpret_cast&lt;</span>wchar_WriterInstance::value_type<span class="keyword">&gt;</span>(out_buffer); 
<a name="l01184"></a>01184                 wchar_WriterInstance::value_type out_end = utf_decoder&lt;wchar_WriterInstance, opt_swap&gt;::decode_utf16_block(data, length, out_begin); 
<a name="l01185"></a>01185  
<a name="l01186"></a>01186                 assert(out_end == out_begin + out_length); 
<a name="l01187"></a>01187                 (void)!out_end; 
<a name="l01188"></a>01188  
<a name="l01189"></a>01189                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01190"></a>01190         } 
<a name="l01191"></a>01191  
<a name="l01192"></a>01192         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> opt_swap&gt; <span class="keywordtype">bool</span> convert_buffer_utf32(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, opt_swap) 
<a name="l01193"></a>01193         { 
<a name="l01194"></a>01194                 <span class="keyword">const</span> uint32_t* data = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(contents); 
<a name="l01195"></a>01195                 <span class="keywordtype">size_t</span> length = size / <span class="keyword">sizeof</span>(uint32_t); 
<a name="l01196"></a>01196  
<a name="l01197"></a>01197                 <span class="comment">// first pass: get length in wchar_t units </span>
<a name="l01198"></a>01198                 out_length = utf_decoder&lt;wchar_counter, opt_swap&gt;::decode_utf32_block(data, length, 0); 
<a name="l01199"></a>01199  
<a name="l01200"></a>01200                 <span class="comment">// allocate buffer of suitable length </span>
<a name="l01201"></a>01201                 out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate((out_length &gt; 0 ? out_length : 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l01202"></a>01202                 <span class="keywordflow">if</span> (!out_buffer) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01203"></a>01203  
<a name="l01204"></a>01204                 <span class="comment">// second pass: convert utf32 input to wchar_t </span>
<a name="l01205"></a>01205                 wchar_WriterInstance::value_type out_begin = <span class="keyword">reinterpret_cast&lt;</span>wchar_WriterInstance::value_type<span class="keyword">&gt;</span>(out_buffer); 
<a name="l01206"></a>01206                 wchar_WriterInstance::value_type out_end = utf_decoder&lt;wchar_WriterInstance, opt_swap&gt;::decode_utf32_block(data, length, out_begin); 
<a name="l01207"></a>01207  
<a name="l01208"></a>01208                 assert(out_end == out_begin + out_length); 
<a name="l01209"></a>01209                 (void)!out_end; 
<a name="l01210"></a>01210  
<a name="l01211"></a>01211                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01212"></a>01212         } 
<a name="l01213"></a>01213  
<a name="l01214"></a>01214         <span class="keywordtype">bool</span> convert_buffer(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">bool</span> is_mutable) 
<a name="l01215"></a>01215         { 
<a name="l01216"></a>01216                 <span class="comment">// get native DocumentEncoding </span>
<a name="l01217"></a>01217                 <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> wchar_DocumentEncoding = GetWchar_DocumentEncoding(); 
<a name="l01218"></a>01218  
<a name="l01219"></a>01219                 <span class="comment">// fast Path: no conversion required </span>
<a name="l01220"></a>01220                 <span class="keywordflow">if</span> (DocumentEncoding == wchar_DocumentEncoding) <span class="keywordflow">return</span> GetMutable_buffer(out_buffer, out_length, contents, size, is_mutable); 
<a name="l01221"></a>01221  
<a name="l01222"></a>01222                 <span class="comment">// only endian-swapping is required </span>
<a name="l01223"></a>01223                 <span class="keywordflow">if</span> (need_endian_swap_utf(DocumentEncoding, wchar_DocumentEncoding)) <span class="keywordflow">return</span> convert_buffer_endian_swap(out_buffer, out_length, contents, size, is_mutable); 
<a name="l01224"></a>01224  
<a name="l01225"></a>01225                 <span class="comment">// source DocumentEncoding is utf8 </span>
<a name="l01226"></a>01226                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a7793b4cde174342c9450abbeab675743" title="UTF8 document encoding.">EncodingUTF8</a>) <span class="keywordflow">return</span> convert_buffer_utf8(out_buffer, out_length, contents, size); 
<a name="l01227"></a>01227  
<a name="l01228"></a>01228                 <span class="comment">// source DocumentEncoding is utf16 </span>
<a name="l01229"></a>01229                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a04fd7b1fef8d2dcc67a46b8fe4dbcaf4" title="Big-endian UTF16.">EncodingUTF16BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a>) 
<a name="l01230"></a>01230                 { 
<a name="l01231"></a>01231                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> : EncodingUTF16BE; 
<a name="l01232"></a>01232  
<a name="l01233"></a>01233                         <span class="keywordflow">return</span> (native_DocumentEncoding == DocumentEncoding) ? 
<a name="l01234"></a>01234                                 convert_buffer_utf16(out_buffer, out_length, contents, size, opt_false()) : 
<a name="l01235"></a>01235                                 convert_buffer_utf16(out_buffer, out_length, contents, size, opt_true()); 
<a name="l01236"></a>01236                 } 
<a name="l01237"></a>01237  
<a name="l01238"></a>01238                 <span class="comment">// source DocumentEncoding is utf32 </span>
<a name="l01239"></a>01239                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a5fb13deaf1552b0f4c00e2b8cafce0b9" title="Big-endian UTF32.">EncodingUTF32BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a>) 
<a name="l01240"></a>01240                 { 
<a name="l01241"></a>01241                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> : EncodingUTF32BE; 
<a name="l01242"></a>01242  
<a name="l01243"></a>01243                         <span class="keywordflow">return</span> (native_DocumentEncoding == DocumentEncoding) ? 
<a name="l01244"></a>01244                                 convert_buffer_utf32(out_buffer, out_length, contents, size, opt_false()) : 
<a name="l01245"></a>01245                                 convert_buffer_utf32(out_buffer, out_length, contents, size, opt_true()); 
<a name="l01246"></a>01246                 } 
<a name="l01247"></a>01247  
<a name="l01248"></a>01248                 assert(!<span class="stringliteral">&quot;Invalid DocumentEncoding&quot;</span>); 
<a name="l01249"></a>01249                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01250"></a>01250         } 
<a name="l01251"></a>01251 <span class="preprocessor">#else </span>
<a name="l01252"></a>01252 <span class="preprocessor"></span>        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> opt_swap&gt; <span class="keywordtype">bool</span> convert_buffer_utf16(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, opt_swap) 
<a name="l01253"></a>01253         { 
<a name="l01254"></a>01254                 <span class="keyword">const</span> uint16_t* data = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint16_t*<span class="keyword">&gt;</span>(contents); 
<a name="l01255"></a>01255                 <span class="keywordtype">size_t</span> length = size / <span class="keyword">sizeof</span>(uint16_t); 
<a name="l01256"></a>01256  
<a name="l01257"></a>01257                 <span class="comment">// first pass: get length in utf8 units </span>
<a name="l01258"></a>01258                 out_length = utf_decoder&lt;utf8_counter, opt_swap&gt;::decode_utf16_block(data, length, 0); 
<a name="l01259"></a>01259  
<a name="l01260"></a>01260                 <span class="comment">// allocate buffer of suitable length </span>
<a name="l01261"></a>01261                 out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate((out_length &gt; 0 ? out_length : 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l01262"></a>01262                 <span class="keywordflow">if</span> (!out_buffer) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01263"></a>01263  
<a name="l01264"></a>01264                 <span class="comment">// second pass: convert utf16 input to utf8 </span>
<a name="l01265"></a>01265                 uint8_t* out_begin = <span class="keyword">reinterpret_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(out_buffer); 
<a name="l01266"></a>01266                 uint8_t* out_end = utf_decoder&lt;utf8_WriterInstance, opt_swap&gt;::decode_utf16_block(data, length, out_begin); 
<a name="l01267"></a>01267  
<a name="l01268"></a>01268                 assert(out_end == out_begin + out_length); 
<a name="l01269"></a>01269                 (void)!out_end; 
<a name="l01270"></a>01270  
<a name="l01271"></a>01271                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01272"></a>01272         } 
<a name="l01273"></a>01273  
<a name="l01274"></a>01274         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> opt_swap&gt; <span class="keywordtype">bool</span> convert_buffer_utf32(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, opt_swap) 
<a name="l01275"></a>01275         { 
<a name="l01276"></a>01276                 <span class="keyword">const</span> uint32_t* data = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint32_t*<span class="keyword">&gt;</span>(contents); 
<a name="l01277"></a>01277                 <span class="keywordtype">size_t</span> length = size / <span class="keyword">sizeof</span>(uint32_t); 
<a name="l01278"></a>01278  
<a name="l01279"></a>01279                 <span class="comment">// first pass: get length in utf8 units </span>
<a name="l01280"></a>01280                 out_length = utf_decoder&lt;utf8_counter, opt_swap&gt;::decode_utf32_block(data, length, 0); 
<a name="l01281"></a>01281  
<a name="l01282"></a>01282                 <span class="comment">// allocate buffer of suitable length </span>
<a name="l01283"></a>01283                 out_buffer = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate((out_length &gt; 0 ? out_length : 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l01284"></a>01284                 <span class="keywordflow">if</span> (!out_buffer) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01285"></a>01285  
<a name="l01286"></a>01286                 <span class="comment">// second pass: convert utf32 input to utf8 </span>
<a name="l01287"></a>01287                 uint8_t* out_begin = <span class="keyword">reinterpret_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(out_buffer); 
<a name="l01288"></a>01288                 uint8_t* out_end = utf_decoder&lt;utf8_WriterInstance, opt_swap&gt;::decode_utf32_block(data, length, out_begin); 
<a name="l01289"></a>01289  
<a name="l01290"></a>01290                 assert(out_end == out_begin + out_length); 
<a name="l01291"></a>01291                 (void)!out_end; 
<a name="l01292"></a>01292  
<a name="l01293"></a>01293                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01294"></a>01294         } 
<a name="l01295"></a>01295  
<a name="l01296"></a>01296         <span class="keywordtype">bool</span> convert_buffer(char_t*&amp; out_buffer, <span class="keywordtype">size_t</span>&amp; out_length, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding, <span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">bool</span> is_mutable) 
<a name="l01297"></a>01297         { 
<a name="l01298"></a>01298                 <span class="comment">// fast Path: no conversion required </span>
<a name="l01299"></a>01299                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a7793b4cde174342c9450abbeab675743" title="UTF8 document encoding.">EncodingUTF8</a>) <span class="keywordflow">return</span> GetMutable_buffer(out_buffer, out_length, contents, size, is_mutable); 
<a name="l01300"></a>01300  
<a name="l01301"></a>01301                 <span class="comment">// source DocumentEncoding is utf16 </span>
<a name="l01302"></a>01302                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a04fd7b1fef8d2dcc67a46b8fe4dbcaf4" title="Big-endian UTF16.">EncodingUTF16BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a>) 
<a name="l01303"></a>01303                 { 
<a name="l01304"></a>01304                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> : EncodingUTF16BE; 
<a name="l01305"></a>01305  
<a name="l01306"></a>01306                         <span class="keywordflow">return</span> (native_DocumentEncoding == DocumentEncoding) ? 
<a name="l01307"></a>01307                                 convert_buffer_utf16(out_buffer, out_length, contents, size, opt_false()) : 
<a name="l01308"></a>01308                                 convert_buffer_utf16(out_buffer, out_length, contents, size, opt_true()); 
<a name="l01309"></a>01309                 } 
<a name="l01310"></a>01310  
<a name="l01311"></a>01311                 <span class="comment">// source DocumentEncoding is utf32 </span>
<a name="l01312"></a>01312                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a5fb13deaf1552b0f4c00e2b8cafce0b9" title="Big-endian UTF32.">EncodingUTF32BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a>) 
<a name="l01313"></a>01313                 { 
<a name="l01314"></a>01314                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> : EncodingUTF32BE; 
<a name="l01315"></a>01315  
<a name="l01316"></a>01316                         <span class="keywordflow">return</span> (native_DocumentEncoding == DocumentEncoding) ? 
<a name="l01317"></a>01317                                 convert_buffer_utf32(out_buffer, out_length, contents, size, opt_false()) : 
<a name="l01318"></a>01318                                 convert_buffer_utf32(out_buffer, out_length, contents, size, opt_true()); 
<a name="l01319"></a>01319                 } 
<a name="l01320"></a>01320  
<a name="l01321"></a>01321                 assert(!<span class="stringliteral">&quot;Invalid DocumentEncoding&quot;</span>); 
<a name="l01322"></a>01322                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01323"></a>01323         } 
<a name="l01324"></a>01324 <span class="preprocessor">#endif </span>
<a name="l01325"></a>01325 <span class="preprocessor"></span> 
<a name="l01326"></a>01326         <span class="keywordtype">size_t</span> AsUtf8_begin(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* str, <span class="keywordtype">size_t</span> length) 
<a name="l01327"></a>01327         { 
<a name="l01328"></a>01328                 STATIC_ASSERT(<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 2 || <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 4); 
<a name="l01329"></a>01329  
<a name="l01330"></a>01330                 <span class="comment">// get length in utf8 characters </span>
<a name="l01331"></a>01331                 <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(wchar_t) == 2 ? 
<a name="l01332"></a>01332                         utf_decoder&lt;utf8_counter&gt;::decode_utf16_block(reinterpret_cast&lt;const uint16_t*&gt;(str), length, 0) : 
<a name="l01333"></a>01333                         utf_decoder&lt;utf8_counter&gt;::decode_utf32_block(reinterpret_cast&lt;const uint32_t*&gt;(str), length, 0); 
<a name="l01334"></a>01334         } 
<a name="l01335"></a>01335  
<a name="l01336"></a>01336         <span class="keywordtype">void</span> AsUtf8_end(<span class="keywordtype">char</span>* buffer, <span class="keywordtype">size_t</span> size, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* str, <span class="keywordtype">size_t</span> length) 
<a name="l01337"></a>01337         { 
<a name="l01338"></a>01338                 STATIC_ASSERT(<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 2 || <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 4); 
<a name="l01339"></a>01339  
<a name="l01340"></a>01340                 <span class="comment">// convert to utf8 </span>
<a name="l01341"></a>01341                 uint8_t* begin = <span class="keyword">reinterpret_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(buffer); 
<a name="l01342"></a>01342                 uint8_t* end = <span class="keyword">sizeof</span>(wchar_t) == 2 ? 
<a name="l01343"></a>01343                         utf_decoder&lt;utf8_WriterInstance&gt;::decode_utf16_block(reinterpret_cast&lt;const uint16_t*&gt;(str), length, begin) : 
<a name="l01344"></a>01344                         utf_decoder&lt;utf8_WriterInstance&gt;::decode_utf32_block(reinterpret_cast&lt;const uint32_t*&gt;(str), length, begin); 
<a name="l01345"></a>01345          
<a name="l01346"></a>01346                 assert(begin + size == end); 
<a name="l01347"></a>01347                 (void)!end; 
<a name="l01348"></a>01348  
<a name="l01349"></a>01349                 <span class="comment">// zero-terminate </span>
<a name="l01350"></a>01350                 buffer[size] = 0; 
<a name="l01351"></a>01351         } 
<a name="l01352"></a>01352          
<a name="l01353"></a>01353 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l01354"></a>01354 <span class="preprocessor"></span>        std::string AsUtf8_impl(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* str, <span class="keywordtype">size_t</span> length) 
<a name="l01355"></a>01355         { 
<a name="l01356"></a>01356                 <span class="comment">// first pass: get length in utf8 characters </span>
<a name="l01357"></a>01357                 <span class="keywordtype">size_t</span> size = AsUtf8_begin(str, length); 
<a name="l01358"></a>01358  
<a name="l01359"></a>01359                 <span class="comment">// allocate Resulting string </span>
<a name="l01360"></a>01360                 std::string Result; 
<a name="l01361"></a>01361                 Result.resize(size); 
<a name="l01362"></a>01362  
<a name="l01363"></a>01363                 <span class="comment">// second pass: convert to utf8 </span>
<a name="l01364"></a>01364                 <span class="keywordflow">if</span> (size &gt; 0) AsUtf8_end(&amp;Result[0], size, str, length); 
<a name="l01365"></a>01365  
<a name="l01366"></a>01366                 <span class="keywordflow">return</span> Result; 
<a name="l01367"></a>01367         } 
<a name="l01368"></a>01368  
<a name="l01369"></a>01369         std::wstring AsWide_impl(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">size_t</span> size) 
<a name="l01370"></a>01370         { 
<a name="l01371"></a>01371                 <span class="keyword">const</span> uint8_t* data = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t*<span class="keyword">&gt;</span>(str); 
<a name="l01372"></a>01372  
<a name="l01373"></a>01373                 <span class="comment">// first pass: get length in wchar_t units </span>
<a name="l01374"></a>01374                 <span class="keywordtype">size_t</span> length = utf_decoder&lt;wchar_counter&gt;::decode_utf8_block(data, size, 0); 
<a name="l01375"></a>01375  
<a name="l01376"></a>01376                 <span class="comment">// allocate Resulting string </span>
<a name="l01377"></a>01377                 std::wstring Result; 
<a name="l01378"></a>01378                 Result.resize(length); 
<a name="l01379"></a>01379  
<a name="l01380"></a>01380                 <span class="comment">// second pass: convert to wchar_t </span>
<a name="l01381"></a>01381                 <span class="keywordflow">if</span> (length &gt; 0) 
<a name="l01382"></a>01382                 { 
<a name="l01383"></a>01383                         wchar_WriterInstance::value_type begin = <span class="keyword">reinterpret_cast&lt;</span>wchar_WriterInstance::value_type<span class="keyword">&gt;</span>(&amp;Result[0]); 
<a name="l01384"></a>01384                         wchar_WriterInstance::value_type end = utf_decoder&lt;wchar_WriterInstance&gt;::decode_utf8_block(data, size, begin); 
<a name="l01385"></a>01385  
<a name="l01386"></a>01386                         assert(begin + length == end); 
<a name="l01387"></a>01387                         (void)!end; 
<a name="l01388"></a>01388                 } 
<a name="l01389"></a>01389  
<a name="l01390"></a>01390                 <span class="keywordflow">return</span> Result; 
<a name="l01391"></a>01391         } 
<a name="l01392"></a>01392 <span class="preprocessor">#endif </span>
<a name="l01393"></a>01393 <span class="preprocessor"></span> 
<a name="l01394"></a>01394         <span class="keyword">inline</span> <span class="keywordtype">bool</span> strcpy_insitu_allow(<span class="keywordtype">size_t</span> length, uintptr_t allocated, char_t* target) 
<a name="l01395"></a>01395         { 
<a name="l01396"></a>01396                 assert(target); 
<a name="l01397"></a>01397                 <span class="keywordtype">size_t</span> tarGetLength = strlength(target); 
<a name="l01398"></a>01398  
<a name="l01399"></a>01399                 <span class="comment">// always reuse document buffer memory if possible </span>
<a name="l01400"></a>01400                 <span class="keywordflow">if</span> (!allocated) <span class="keywordflow">return</span> tarGetLength &gt;= length; 
<a name="l01401"></a>01401  
<a name="l01402"></a>01402                 <span class="comment">// reuse heap memory if waste is not too great </span>
<a name="l01403"></a>01403                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> reuse_threshold = 32; 
<a name="l01404"></a>01404  
<a name="l01405"></a>01405                 <span class="keywordflow">return</span> tarGetLength &gt;= length &amp;&amp; (tarGetLength &lt; reuse_threshold || tarGetLength - length &lt; tarGetLength / 2); 
<a name="l01406"></a>01406         } 
<a name="l01407"></a>01407  
<a name="l01408"></a>01408         <span class="keywordtype">bool</span> strcpy_insitu(char_t*&amp; dest, uintptr_t&amp; header, uintptr_t header_mask, <span class="keyword">const</span> char_t* source) 
<a name="l01409"></a>01409         { 
<a name="l01410"></a>01410                 <span class="keywordtype">size_t</span> source_length = strlength(source); 
<a name="l01411"></a>01411  
<a name="l01412"></a>01412                 <span class="keywordflow">if</span> (source_length == 0) 
<a name="l01413"></a>01413                 { 
<a name="l01414"></a>01414                         <span class="comment">// empty string and null pointer are equivalent, so just deallocate old memory </span>
<a name="l01415"></a>01415                         Allocator* alloc = <span class="keyword">reinterpret_cast&lt;</span>MemoryPage*<span class="keyword">&gt;</span>(header &amp; MemoryPage_pointer_mask)-&gt;allocator; 
<a name="l01416"></a>01416  
<a name="l01417"></a>01417                         <span class="keywordflow">if</span> (header &amp; header_mask) alloc-&gt;deallocate_string(dest); 
<a name="l01418"></a>01418                          
<a name="l01419"></a>01419                         <span class="comment">// mark the string as not allocated </span>
<a name="l01420"></a>01420                         dest = 0; 
<a name="l01421"></a>01421                         header &amp;= ~header_mask; 
<a name="l01422"></a>01422  
<a name="l01423"></a>01423                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01424"></a>01424                 } 
<a name="l01425"></a>01425                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dest &amp;&amp; strcpy_insitu_allow(source_length, header &amp; header_mask, dest)) 
<a name="l01426"></a>01426                 { 
<a name="l01427"></a>01427                         <span class="comment">// we can reuse old buffer, so just copy the new data (including zero terminator) </span>
<a name="l01428"></a>01428                         memcpy(dest, source, (source_length + 1) * <span class="keyword">sizeof</span>(char_t)); 
<a name="l01429"></a>01429                          
<a name="l01430"></a>01430                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01431"></a>01431                 } 
<a name="l01432"></a>01432                 <span class="keywordflow">else</span> 
<a name="l01433"></a>01433                 { 
<a name="l01434"></a>01434                         Allocator* alloc = <span class="keyword">reinterpret_cast&lt;</span>MemoryPage*<span class="keyword">&gt;</span>(header &amp; MemoryPage_pointer_mask)-&gt;allocator; 
<a name="l01435"></a>01435  
<a name="l01436"></a>01436                         <span class="comment">// allocate new buffer </span>
<a name="l01437"></a>01437                         char_t* buf = alloc-&gt;allocate_string(source_length + 1); 
<a name="l01438"></a>01438                         <span class="keywordflow">if</span> (!buf) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l01439"></a>01439  
<a name="l01440"></a>01440                         <span class="comment">// copy the string (including zero terminator) </span>
<a name="l01441"></a>01441                         memcpy(buf, source, (source_length + 1) * <span class="keyword">sizeof</span>(char_t)); 
<a name="l01442"></a>01442  
<a name="l01443"></a>01443                         <span class="comment">// deallocate old buffer (*after* the above to protect against overlapping memory and/or allocation failures) </span>
<a name="l01444"></a>01444                         <span class="keywordflow">if</span> (header &amp; header_mask) alloc-&gt;deallocate_string(dest); 
<a name="l01445"></a>01445                          
<a name="l01446"></a>01446                         <span class="comment">// the string is now allocated, so set the flag </span>
<a name="l01447"></a>01447                         dest = buf; 
<a name="l01448"></a>01448                         header |= header_mask; 
<a name="l01449"></a>01449  
<a name="l01450"></a>01450                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01451"></a>01451                 } 
<a name="l01452"></a>01452         } 
<a name="l01453"></a>01453  
<a name="l01454"></a>01454         <span class="keyword">struct </span>gap 
<a name="l01455"></a>01455         { 
<a name="l01456"></a>01456                 char_t* end; 
<a name="l01457"></a>01457                 <span class="keywordtype">size_t</span> size; 
<a name="l01458"></a>01458                          
<a name="l01459"></a>01459                 gap(): end(0), size(0) 
<a name="l01460"></a>01460                 { 
<a name="l01461"></a>01461                 } 
<a name="l01462"></a>01462                          
<a name="l01463"></a>01463                 <span class="comment">// Push new gap, move s count bytes further (skipping the gap). </span>
<a name="l01464"></a>01464                 <span class="comment">// Collapse previous gap. </span>
<a name="l01465"></a>01465                 <span class="keywordtype">void</span> push(char_t*&amp; s, <span class="keywordtype">size_t</span> count) 
<a name="l01466"></a>01466                 { 
<a name="l01467"></a>01467                         <span class="keywordflow">if</span> (end) <span class="comment">// there was a gap already; collapse it </span>
<a name="l01468"></a>01468                         { 
<a name="l01469"></a>01469                                 <span class="comment">// Move [old_gap_end, new_gap_start) to [old_gap_start, ...) </span>
<a name="l01470"></a>01470                                 assert(s &gt;= end); 
<a name="l01471"></a>01471                                 memmove(end - size, end, reinterpret_cast&lt;char*&gt;(s) - reinterpret_cast&lt;char*&gt;(end)); 
<a name="l01472"></a>01472                         } 
<a name="l01473"></a>01473                                  
<a name="l01474"></a>01474                         s += count; <span class="comment">// end of current gap </span>
<a name="l01475"></a>01475                                  
<a name="l01476"></a>01476                         <span class="comment">// &quot;merge&quot; two gaps </span>
<a name="l01477"></a>01477                         end = s; 
<a name="l01478"></a>01478                         size += count; 
<a name="l01479"></a>01479                 } 
<a name="l01480"></a>01480                          
<a name="l01481"></a>01481                 <span class="comment">// Collapse all gaps, return past-the-end pointer </span>
<a name="l01482"></a>01482                 char_t* flush(char_t* s) 
<a name="l01483"></a>01483                 { 
<a name="l01484"></a>01484                         <span class="keywordflow">if</span> (end) 
<a name="l01485"></a>01485                         { 
<a name="l01486"></a>01486                                 <span class="comment">// Move [old_gap_end, current_pos) to [old_gap_start, ...) </span>
<a name="l01487"></a>01487                                 assert(s &gt;= end); 
<a name="l01488"></a>01488                                 memmove(end - size, end, reinterpret_cast&lt;char*&gt;(s) - reinterpret_cast&lt;char*&gt;(end)); 
<a name="l01489"></a>01489  
<a name="l01490"></a>01490                                 <span class="keywordflow">return</span> s - size; 
<a name="l01491"></a>01491                         } 
<a name="l01492"></a>01492                         <span class="keywordflow">else</span> <span class="keywordflow">return</span> s; 
<a name="l01493"></a>01493                 } 
<a name="l01494"></a>01494         }; 
<a name="l01495"></a>01495          
<a name="l01496"></a>01496         char_t* strconv_escape(char_t* s, gap&amp; g) 
<a name="l01497"></a>01497         { 
<a name="l01498"></a>01498                 char_t* stre = s + 1; 
<a name="l01499"></a>01499  
<a name="l01500"></a>01500                 <span class="keywordflow">switch</span> (*stre) 
<a name="l01501"></a>01501                 { 
<a name="l01502"></a>01502                         <span class="keywordflow">case</span> <span class="charliteral">&#39;#&#39;</span>:       <span class="comment">// &amp;#... </span>
<a name="l01503"></a>01503                         { 
<a name="l01504"></a>01504                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ucsc = 0; 
<a name="l01505"></a>01505  
<a name="l01506"></a>01506                                 <span class="keywordflow">if</span> (stre[1] == <span class="charliteral">&#39;x&#39;</span>) <span class="comment">// &amp;#x... (hex code) </span>
<a name="l01507"></a>01507                                 { 
<a name="l01508"></a>01508                                         stre += 2; 
<a name="l01509"></a>01509  
<a name="l01510"></a>01510                                         char_t ch = *stre; 
<a name="l01511"></a>01511  
<a name="l01512"></a>01512                                         <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;;&#39;</span>) <span class="keywordflow">return</span> stre; 
<a name="l01513"></a>01513  
<a name="l01514"></a>01514                                         <span class="keywordflow">for</span> (;;) 
<a name="l01515"></a>01515                                         { 
<a name="l01516"></a>01516                                                 <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;(ch - <span class="charliteral">&#39;0&#39;</span>) &lt;= 9) 
<a name="l01517"></a>01517                                                         ucsc = 16 * ucsc + (ch - <span class="charliteral">&#39;0&#39;</span>); 
<a name="l01518"></a>01518                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;((ch | <span class="charliteral">&#39; &#39;</span>) - <span class="charliteral">&#39;a&#39;</span>) &lt;= 5) 
<a name="l01519"></a>01519                                                         ucsc = 16 * ucsc + ((ch | <span class="charliteral">&#39; &#39;</span>) - <span class="charliteral">&#39;a&#39;</span> + 10); 
<a name="l01520"></a>01520                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;;&#39;</span>) 
<a name="l01521"></a>01521                                                         <span class="keywordflow">break</span>; 
<a name="l01522"></a>01522                                                 <span class="keywordflow">else</span> <span class="comment">// cancel </span>
<a name="l01523"></a>01523                                                         <span class="keywordflow">return</span> stre; 
<a name="l01524"></a>01524  
<a name="l01525"></a>01525                                                 ch = *++stre; 
<a name="l01526"></a>01526                                         } 
<a name="l01527"></a>01527                                          
<a name="l01528"></a>01528                                         ++stre; 
<a name="l01529"></a>01529                                 } 
<a name="l01530"></a>01530                                 <span class="keywordflow">else</span>    <span class="comment">// &amp;#... (dec code) </span>
<a name="l01531"></a>01531                                 { 
<a name="l01532"></a>01532                                         char_t ch = *++stre; 
<a name="l01533"></a>01533  
<a name="l01534"></a>01534                                         <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;;&#39;</span>) <span class="keywordflow">return</span> stre; 
<a name="l01535"></a>01535  
<a name="l01536"></a>01536                                         <span class="keywordflow">for</span> (;;) 
<a name="l01537"></a>01537                                         { 
<a name="l01538"></a>01538                                                 <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;(ch - <span class="charliteral">&#39;0&#39;</span>) &lt;= 9) 
<a name="l01539"></a>01539                                                         ucsc = 10 * ucsc + (ch - <span class="charliteral">&#39;0&#39;</span>); 
<a name="l01540"></a>01540                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;;&#39;</span>) 
<a name="l01541"></a>01541                                                         <span class="keywordflow">break</span>; 
<a name="l01542"></a>01542                                                 <span class="keywordflow">else</span> <span class="comment">// cancel </span>
<a name="l01543"></a>01543                                                         <span class="keywordflow">return</span> stre; 
<a name="l01544"></a>01544  
<a name="l01545"></a>01545                                                 ch = *++stre; 
<a name="l01546"></a>01546                                         } 
<a name="l01547"></a>01547                                          
<a name="l01548"></a>01548                                         ++stre; 
<a name="l01549"></a>01549                                 } 
<a name="l01550"></a>01550  
<a name="l01551"></a>01551 <span class="preprocessor">                        #ifdef XML_WCHAR_MODE </span>
<a name="l01552"></a>01552 <span class="preprocessor"></span>                                s = <span class="keyword">reinterpret_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(wchar_WriterInstance::any(reinterpret_cast&lt;wchar_WriterInstance::value_type&gt;(s), ucsc)); 
<a name="l01553"></a>01553 <span class="preprocessor">                        #else </span>
<a name="l01554"></a>01554 <span class="preprocessor"></span>                                s = <span class="keyword">reinterpret_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(utf8_WriterInstance::any(reinterpret_cast&lt;uint8_t*&gt;(s), ucsc)); 
<a name="l01555"></a>01555 <span class="preprocessor">                        #endif </span>
<a name="l01556"></a>01556 <span class="preprocessor"></span>                                         
<a name="l01557"></a>01557                                 g.push(s, stre - s); 
<a name="l01558"></a>01558                                 <span class="keywordflow">return</span> stre; 
<a name="l01559"></a>01559                         } 
<a name="l01560"></a>01560                         <span class="keywordflow">case</span> <span class="charliteral">&#39;a&#39;</span>:       <span class="comment">// &amp;a </span>
<a name="l01561"></a>01561                         { 
<a name="l01562"></a>01562                                 ++stre; 
<a name="l01563"></a>01563  
<a name="l01564"></a>01564                                 <span class="keywordflow">if</span> (*stre == <span class="charliteral">&#39;m&#39;</span>) <span class="comment">// &amp;am </span>
<a name="l01565"></a>01565                                 { 
<a name="l01566"></a>01566                                         <span class="keywordflow">if</span> (*++stre == <span class="charliteral">&#39;p&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;;&#39;</span>) <span class="comment">// &amp;amp; </span>
<a name="l01567"></a>01567                                         { 
<a name="l01568"></a>01568                                                 *s++ = <span class="charliteral">&#39;&amp;&#39;</span>; 
<a name="l01569"></a>01569                                                 ++stre; 
<a name="l01570"></a>01570                                                          
<a name="l01571"></a>01571                                                 g.push(s, stre - s); 
<a name="l01572"></a>01572                                                 <span class="keywordflow">return</span> stre; 
<a name="l01573"></a>01573                                         } 
<a name="l01574"></a>01574                                 } 
<a name="l01575"></a>01575                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*stre == <span class="charliteral">&#39;p&#39;</span>) <span class="comment">// &amp;ap </span>
<a name="l01576"></a>01576                                 { 
<a name="l01577"></a>01577                                         <span class="keywordflow">if</span> (*++stre == <span class="charliteral">&#39;o&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;s&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;;&#39;</span>) <span class="comment">// &amp;apos; </span>
<a name="l01578"></a>01578                                         { 
<a name="l01579"></a>01579                                                 *s++ = <span class="charliteral">&#39;\&#39;&#39;</span>; 
<a name="l01580"></a>01580                                                 ++stre; 
<a name="l01581"></a>01581  
<a name="l01582"></a>01582                                                 g.push(s, stre - s); 
<a name="l01583"></a>01583                                                 <span class="keywordflow">return</span> stre; 
<a name="l01584"></a>01584                                         } 
<a name="l01585"></a>01585                                 } 
<a name="l01586"></a>01586                                 <span class="keywordflow">break</span>; 
<a name="l01587"></a>01587                         } 
<a name="l01588"></a>01588                         <span class="keywordflow">case</span> <span class="charliteral">&#39;g&#39;</span>: <span class="comment">// &amp;g </span>
<a name="l01589"></a>01589                         { 
<a name="l01590"></a>01590                                 <span class="keywordflow">if</span> (*++stre == <span class="charliteral">&#39;t&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;;&#39;</span>) <span class="comment">// &amp;gt; </span>
<a name="l01591"></a>01591                                 { 
<a name="l01592"></a>01592                                         *s++ = <span class="charliteral">&#39;&gt;&#39;</span>; 
<a name="l01593"></a>01593                                         ++stre; 
<a name="l01594"></a>01594                                          
<a name="l01595"></a>01595                                         g.push(s, stre - s); 
<a name="l01596"></a>01596                                         <span class="keywordflow">return</span> stre; 
<a name="l01597"></a>01597                                 } 
<a name="l01598"></a>01598                                 <span class="keywordflow">break</span>; 
<a name="l01599"></a>01599                         } 
<a name="l01600"></a>01600                         <span class="keywordflow">case</span> <span class="charliteral">&#39;l&#39;</span>: <span class="comment">// &amp;l </span>
<a name="l01601"></a>01601                         { 
<a name="l01602"></a>01602                                 <span class="keywordflow">if</span> (*++stre == <span class="charliteral">&#39;t&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;;&#39;</span>) <span class="comment">// &amp;lt; </span>
<a name="l01603"></a>01603                                 { 
<a name="l01604"></a>01604                                         *s++ = <span class="charliteral">&#39;&lt;&#39;</span>; 
<a name="l01605"></a>01605                                         ++stre; 
<a name="l01606"></a>01606                                                  
<a name="l01607"></a>01607                                         g.push(s, stre - s); 
<a name="l01608"></a>01608                                         <span class="keywordflow">return</span> stre; 
<a name="l01609"></a>01609                                 } 
<a name="l01610"></a>01610                                 <span class="keywordflow">break</span>; 
<a name="l01611"></a>01611                         } 
<a name="l01612"></a>01612                         <span class="keywordflow">case</span> <span class="charliteral">&#39;q&#39;</span>: <span class="comment">// &amp;q </span>
<a name="l01613"></a>01613                         { 
<a name="l01614"></a>01614                                 <span class="keywordflow">if</span> (*++stre == <span class="charliteral">&#39;u&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;o&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;t&#39;</span> &amp;&amp; *++stre == <span class="charliteral">&#39;;&#39;</span>) <span class="comment">// &amp;quot; </span>
<a name="l01615"></a>01615                                 { 
<a name="l01616"></a>01616                                         *s++ = <span class="charliteral">&#39;&quot;&#39;</span>; 
<a name="l01617"></a>01617                                         ++stre; 
<a name="l01618"></a>01618                                          
<a name="l01619"></a>01619                                         g.push(s, stre - s); 
<a name="l01620"></a>01620                                         <span class="keywordflow">return</span> stre; 
<a name="l01621"></a>01621                                 } 
<a name="l01622"></a>01622                                 <span class="keywordflow">break</span>; 
<a name="l01623"></a>01623                         } 
<a name="l01624"></a>01624                 } 
<a name="l01625"></a>01625                  
<a name="l01626"></a>01626                 <span class="keywordflow">return</span> stre; 
<a name="l01627"></a>01627         } 
<a name="l01628"></a>01628  
<a name="l01629"></a>01629         <span class="comment">// Utility macro for last character handling </span>
<a name="l01630"></a>01630 <span class="preprocessor">        #define ENDSWITH(c, e) ((c) == (e) || ((c) == 0 &amp;&amp; endch == (e))) </span>
<a name="l01631"></a>01631 <span class="preprocessor"></span> 
<a name="l01632"></a>01632         char_t* strconv_comment(char_t* s, char_t endch) 
<a name="l01633"></a>01633         { 
<a name="l01634"></a>01634                 gap g; 
<a name="l01635"></a>01635                  
<a name="l01636"></a>01636                 <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l01637"></a>01637                 { 
<a name="l01638"></a>01638                         <span class="keywordflow">while</span> (!IS_CHARTYPE(*s, ct_ParseComment)) ++s; 
<a name="l01639"></a>01639                  
<a name="l01640"></a>01640                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\r&#39;</span>) <span class="comment">// Either a single 0x0d or 0x0d 0x0a pair </span>
<a name="l01641"></a>01641                         { 
<a name="l01642"></a>01642                                 *s++ = <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// replace first one with 0x0a </span>
<a name="l01643"></a>01643                                  
<a name="l01644"></a>01644                                 <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\n&#39;</span>) g.push(s, 1); 
<a name="l01645"></a>01645                         } 
<a name="l01646"></a>01646                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; ENDSWITH(s[2], <span class="charliteral">&#39;&gt;&#39;</span>)) <span class="comment">// comment ends here </span>
<a name="l01647"></a>01647                         { 
<a name="l01648"></a>01648                                 *g.flush(s) = 0; 
<a name="l01649"></a>01649                                  
<a name="l01650"></a>01650                                 <span class="keywordflow">return</span> s + (s[2] == <span class="charliteral">&#39;&gt;&#39;</span> ? 3 : 2); 
<a name="l01651"></a>01651                         } 
<a name="l01652"></a>01652                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0) 
<a name="l01653"></a>01653                         { 
<a name="l01654"></a>01654                                 <span class="keywordflow">return</span> 0; 
<a name="l01655"></a>01655                         } 
<a name="l01656"></a>01656                         <span class="keywordflow">else</span> ++s; 
<a name="l01657"></a>01657                 } 
<a name="l01658"></a>01658         } 
<a name="l01659"></a>01659  
<a name="l01660"></a>01660         char_t* strconv_cdata(char_t* s, char_t endch) 
<a name="l01661"></a>01661         { 
<a name="l01662"></a>01662                 gap g; 
<a name="l01663"></a>01663                          
<a name="l01664"></a>01664                 <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l01665"></a>01665                 { 
<a name="l01666"></a>01666                         <span class="keywordflow">while</span> (!IS_CHARTYPE(*s, ct_ParseCdata)) ++s; 
<a name="l01667"></a>01667                          
<a name="l01668"></a>01668                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\r&#39;</span>) <span class="comment">// Either a single 0x0d or 0x0d 0x0a pair </span>
<a name="l01669"></a>01669                         { 
<a name="l01670"></a>01670                                 *s++ = <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// replace first one with 0x0a </span>
<a name="l01671"></a>01671                                  
<a name="l01672"></a>01672                                 <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\n&#39;</span>) g.push(s, 1); 
<a name="l01673"></a>01673                         } 
<a name="l01674"></a>01674                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; ENDSWITH(s[2], <span class="charliteral">&#39;&gt;&#39;</span>)) <span class="comment">// CDATA ends here </span>
<a name="l01675"></a>01675                         { 
<a name="l01676"></a>01676                                 *g.flush(s) = 0; 
<a name="l01677"></a>01677                                  
<a name="l01678"></a>01678                                 <span class="keywordflow">return</span> s + 1; 
<a name="l01679"></a>01679                         } 
<a name="l01680"></a>01680                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0) 
<a name="l01681"></a>01681                         { 
<a name="l01682"></a>01682                                 <span class="keywordflow">return</span> 0; 
<a name="l01683"></a>01683                         } 
<a name="l01684"></a>01684                         <span class="keywordflow">else</span> ++s; 
<a name="l01685"></a>01685                 } 
<a name="l01686"></a>01686         } 
<a name="l01687"></a>01687          
<a name="l01688"></a>01688         <span class="keyword">typedef</span> char_t* (*strconv_pcdata_t)(char_t*); 
<a name="l01689"></a>01689                  
<a name="l01690"></a>01690         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> opt_eol, <span class="keyword">typename</span> opt_escape&gt; <span class="keyword">struct </span>strconv_pcdata_impl 
<a name="l01691"></a>01691         { 
<a name="l01692"></a>01692                 <span class="keyword">static</span> char_t* parse(char_t* s) 
<a name="l01693"></a>01693                 { 
<a name="l01694"></a>01694                         gap g; 
<a name="l01695"></a>01695                          
<a name="l01696"></a>01696                         <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l01697"></a>01697                         { 
<a name="l01698"></a>01698                                 <span class="keywordflow">while</span> (!IS_CHARTYPE(*s, ct_ParsePcdata)) ++s; 
<a name="l01699"></a>01699                                          
<a name="l01700"></a>01700                                 <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;&lt;&#39;</span>) <span class="comment">// PCDATA ends here </span>
<a name="l01701"></a>01701                                 { 
<a name="l01702"></a>01702                                         *g.flush(s) = 0; 
<a name="l01703"></a>01703                                          
<a name="l01704"></a>01704                                         <span class="keywordflow">return</span> s + 1; 
<a name="l01705"></a>01705                                 } 
<a name="l01706"></a>01706                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt_eol::Value &amp;&amp; *s == <span class="charliteral">&#39;\r&#39;</span>) <span class="comment">// Either a single 0x0d or 0x0d 0x0a pair </span>
<a name="l01707"></a>01707                                 { 
<a name="l01708"></a>01708                                         *s++ = <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">// replace first one with 0x0a </span>
<a name="l01709"></a>01709                                          
<a name="l01710"></a>01710                                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\n&#39;</span>) g.push(s, 1); 
<a name="l01711"></a>01711                                 } 
<a name="l01712"></a>01712                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt_escape::Value &amp;&amp; *s == <span class="charliteral">&#39;&amp;&#39;</span>) 
<a name="l01713"></a>01713                                 { 
<a name="l01714"></a>01714                                         s = strconv_escape(s, g); 
<a name="l01715"></a>01715                                 } 
<a name="l01716"></a>01716                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0) 
<a name="l01717"></a>01717                                 { 
<a name="l01718"></a>01718                                         <span class="keywordflow">return</span> s; 
<a name="l01719"></a>01719                                 } 
<a name="l01720"></a>01720                                 <span class="keywordflow">else</span> ++s; 
<a name="l01721"></a>01721                         } 
<a name="l01722"></a>01722                 } 
<a name="l01723"></a>01723         }; 
<a name="l01724"></a>01724          
<a name="l01725"></a>01725         strconv_pcdata_t GetStrconv_pcdata(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> optmask) 
<a name="l01726"></a>01726         { 
<a name="l01727"></a>01727                 STATIC_ASSERT(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a6463412ba9e404b6890e4721255cd8ed" title="This flag determines if character and entity references are expanded during parsing. This flag is on by default.">ParseEscapes</a> == 0x10 &amp;&amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a52af747730d2b3a313eebed4cf49a333" title="This flag determines if EOL characters are normalized (converted to xA) during parsing. This flag is on by default.">ParseEol</a> == 0x20); 
<a name="l01728"></a>01728  
<a name="l01729"></a>01729                 <span class="keywordflow">switch</span> ((optmask &gt;&gt; 4) &amp; 3) <span class="comment">// get bitmask for flags (eol escapes) </span>
<a name="l01730"></a>01730                 { 
<a name="l01731"></a>01731                 <span class="keywordflow">case</span> 0: <span class="keywordflow">return</span> strconv_pcdata_impl&lt;opt_false, opt_false&gt;::parse; 
<a name="l01732"></a>01732                 <span class="keywordflow">case</span> 1: <span class="keywordflow">return</span> strconv_pcdata_impl&lt;opt_false, opt_true&gt;::parse; 
<a name="l01733"></a>01733                 <span class="keywordflow">case</span> 2: <span class="keywordflow">return</span> strconv_pcdata_impl&lt;opt_true, opt_false&gt;::parse; 
<a name="l01734"></a>01734                 <span class="keywordflow">case</span> 3: <span class="keywordflow">return</span> strconv_pcdata_impl&lt;opt_true, opt_true&gt;::parse; 
<a name="l01735"></a>01735                 <span class="keywordflow">default</span>: <span class="keywordflow">return</span> 0; <span class="comment">// should not get here </span>
<a name="l01736"></a>01736                 } 
<a name="l01737"></a>01737         } 
<a name="l01738"></a>01738  
<a name="l01739"></a>01739         <span class="keyword">typedef</span> char_t* (*strconv_attribute_t)(char_t*, char_t); 
<a name="l01740"></a>01740          
<a name="l01741"></a>01741         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> opt_escape&gt; <span class="keyword">struct </span>strconv_attribute_impl 
<a name="l01742"></a>01742         { 
<a name="l01743"></a>01743                 <span class="keyword">static</span> char_t* ParseWnorm(char_t* s, char_t end_quote) 
<a name="l01744"></a>01744                 { 
<a name="l01745"></a>01745                         gap g; 
<a name="l01746"></a>01746  
<a name="l01747"></a>01747                         <span class="comment">// trim leading whitespaces </span>
<a name="l01748"></a>01748                         <span class="keywordflow">if</span> (IS_CHARTYPE(*s, ct_space)) 
<a name="l01749"></a>01749                         { 
<a name="l01750"></a>01750                                 char_t* str = s; 
<a name="l01751"></a>01751                                  
<a name="l01752"></a>01752                                 <span class="keywordflow">do</span> ++str; 
<a name="l01753"></a>01753                                 <span class="keywordflow">while</span> (IS_CHARTYPE(*str, ct_space)); 
<a name="l01754"></a>01754                                  
<a name="l01755"></a>01755                                 g.push(s, str - s); 
<a name="l01756"></a>01756                         } 
<a name="l01757"></a>01757  
<a name="l01758"></a>01758                         <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l01759"></a>01759                         { 
<a name="l01760"></a>01760                                 <span class="keywordflow">while</span> (!IS_CHARTYPE(*s, ct_ParseAttrWs | ct_space)) ++s; 
<a name="l01761"></a>01761                                  
<a name="l01762"></a>01762                                 <span class="keywordflow">if</span> (*s == end_quote) 
<a name="l01763"></a>01763                                 { 
<a name="l01764"></a>01764                                         char_t* str = g.flush(s); 
<a name="l01765"></a>01765                                          
<a name="l01766"></a>01766                                         <span class="keywordflow">do</span> *str-- = 0; 
<a name="l01767"></a>01767                                         <span class="keywordflow">while</span> (IS_CHARTYPE(*str, ct_space)); 
<a name="l01768"></a>01768                                  
<a name="l01769"></a>01769                                         <span class="keywordflow">return</span> s + 1; 
<a name="l01770"></a>01770                                 } 
<a name="l01771"></a>01771                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_CHARTYPE(*s, ct_space)) 
<a name="l01772"></a>01772                                 { 
<a name="l01773"></a>01773                                         *s++ = <span class="charliteral">&#39; &#39;</span>; 
<a name="l01774"></a>01774                  
<a name="l01775"></a>01775                                         <span class="keywordflow">if</span> (IS_CHARTYPE(*s, ct_space)) 
<a name="l01776"></a>01776                                         { 
<a name="l01777"></a>01777                                                 char_t* str = s + 1; 
<a name="l01778"></a>01778                                                 <span class="keywordflow">while</span> (IS_CHARTYPE(*str, ct_space)) ++str; 
<a name="l01779"></a>01779                                                  
<a name="l01780"></a>01780                                                 g.push(s, str - s); 
<a name="l01781"></a>01781                                         } 
<a name="l01782"></a>01782                                 } 
<a name="l01783"></a>01783                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt_escape::Value &amp;&amp; *s == <span class="charliteral">&#39;&amp;&#39;</span>) 
<a name="l01784"></a>01784                                 { 
<a name="l01785"></a>01785                                         s = strconv_escape(s, g); 
<a name="l01786"></a>01786                                 } 
<a name="l01787"></a>01787                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!*s) 
<a name="l01788"></a>01788                                 { 
<a name="l01789"></a>01789                                         <span class="keywordflow">return</span> 0; 
<a name="l01790"></a>01790                                 } 
<a name="l01791"></a>01791                                 <span class="keywordflow">else</span> ++s; 
<a name="l01792"></a>01792                         } 
<a name="l01793"></a>01793                 } 
<a name="l01794"></a>01794  
<a name="l01795"></a>01795                 <span class="keyword">static</span> char_t* ParseWconv(char_t* s, char_t end_quote) 
<a name="l01796"></a>01796                 { 
<a name="l01797"></a>01797                         gap g; 
<a name="l01798"></a>01798  
<a name="l01799"></a>01799                         <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l01800"></a>01800                         { 
<a name="l01801"></a>01801                                 <span class="keywordflow">while</span> (!IS_CHARTYPE(*s, ct_ParseAttrWs)) ++s; 
<a name="l01802"></a>01802                                  
<a name="l01803"></a>01803                                 <span class="keywordflow">if</span> (*s == end_quote) 
<a name="l01804"></a>01804                                 { 
<a name="l01805"></a>01805                                         *g.flush(s) = 0; 
<a name="l01806"></a>01806                                  
<a name="l01807"></a>01807                                         <span class="keywordflow">return</span> s + 1; 
<a name="l01808"></a>01808                                 } 
<a name="l01809"></a>01809                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_CHARTYPE(*s, ct_space)) 
<a name="l01810"></a>01810                                 { 
<a name="l01811"></a>01811                                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\r&#39;</span>) 
<a name="l01812"></a>01812                                         { 
<a name="l01813"></a>01813                                                 *s++ = <span class="charliteral">&#39; &#39;</span>; 
<a name="l01814"></a>01814                                  
<a name="l01815"></a>01815                                                 <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\n&#39;</span>) g.push(s, 1); 
<a name="l01816"></a>01816                                         } 
<a name="l01817"></a>01817                                         <span class="keywordflow">else</span> *s++ = <span class="charliteral">&#39; &#39;</span>; 
<a name="l01818"></a>01818                                 } 
<a name="l01819"></a>01819                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt_escape::Value &amp;&amp; *s == <span class="charliteral">&#39;&amp;&#39;</span>) 
<a name="l01820"></a>01820                                 { 
<a name="l01821"></a>01821                                         s = strconv_escape(s, g); 
<a name="l01822"></a>01822                                 } 
<a name="l01823"></a>01823                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!*s) 
<a name="l01824"></a>01824                                 { 
<a name="l01825"></a>01825                                         <span class="keywordflow">return</span> 0; 
<a name="l01826"></a>01826                                 } 
<a name="l01827"></a>01827                                 <span class="keywordflow">else</span> ++s; 
<a name="l01828"></a>01828                         } 
<a name="l01829"></a>01829                 } 
<a name="l01830"></a>01830  
<a name="l01831"></a>01831                 <span class="keyword">static</span> char_t* <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a52af747730d2b3a313eebed4cf49a333" title="This flag determines if EOL characters are normalized (converted to xA) during parsing. This flag is on by default.">ParseEol</a>(char_t* s, char_t end_quote) 
<a name="l01832"></a>01832                 { 
<a name="l01833"></a>01833                         gap g; 
<a name="l01834"></a>01834  
<a name="l01835"></a>01835                         <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l01836"></a>01836                         { 
<a name="l01837"></a>01837                                 <span class="keywordflow">while</span> (!IS_CHARTYPE(*s, ct_ParseAttr)) ++s; 
<a name="l01838"></a>01838                                  
<a name="l01839"></a>01839                                 <span class="keywordflow">if</span> (*s == end_quote) 
<a name="l01840"></a>01840                                 { 
<a name="l01841"></a>01841                                         *g.flush(s) = 0; 
<a name="l01842"></a>01842                                  
<a name="l01843"></a>01843                                         <span class="keywordflow">return</span> s + 1; 
<a name="l01844"></a>01844                                 } 
<a name="l01845"></a>01845                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\r&#39;</span>) 
<a name="l01846"></a>01846                                 { 
<a name="l01847"></a>01847                                         *s++ = <span class="charliteral">&#39;\n&#39;</span>; 
<a name="l01848"></a>01848                                          
<a name="l01849"></a>01849                                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;\n&#39;</span>) g.push(s, 1); 
<a name="l01850"></a>01850                                 } 
<a name="l01851"></a>01851                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt_escape::Value &amp;&amp; *s == <span class="charliteral">&#39;&amp;&#39;</span>) 
<a name="l01852"></a>01852                                 { 
<a name="l01853"></a>01853                                         s = strconv_escape(s, g); 
<a name="l01854"></a>01854                                 } 
<a name="l01855"></a>01855                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!*s) 
<a name="l01856"></a>01856                                 { 
<a name="l01857"></a>01857                                         <span class="keywordflow">return</span> 0; 
<a name="l01858"></a>01858                                 } 
<a name="l01859"></a>01859                                 <span class="keywordflow">else</span> ++s; 
<a name="l01860"></a>01860                         } 
<a name="l01861"></a>01861                 } 
<a name="l01862"></a>01862  
<a name="l01863"></a>01863                 <span class="keyword">static</span> char_t* ParseSimple(char_t* s, char_t end_quote) 
<a name="l01864"></a>01864                 { 
<a name="l01865"></a>01865                         gap g; 
<a name="l01866"></a>01866  
<a name="l01867"></a>01867                         <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l01868"></a>01868                         { 
<a name="l01869"></a>01869                                 <span class="keywordflow">while</span> (!IS_CHARTYPE(*s, ct_ParseAttr)) ++s; 
<a name="l01870"></a>01870                                  
<a name="l01871"></a>01871                                 <span class="keywordflow">if</span> (*s == end_quote) 
<a name="l01872"></a>01872                                 { 
<a name="l01873"></a>01873                                         *g.flush(s) = 0; 
<a name="l01874"></a>01874                                  
<a name="l01875"></a>01875                                         <span class="keywordflow">return</span> s + 1; 
<a name="l01876"></a>01876                                 } 
<a name="l01877"></a>01877                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt_escape::Value &amp;&amp; *s == <span class="charliteral">&#39;&amp;&#39;</span>) 
<a name="l01878"></a>01878                                 { 
<a name="l01879"></a>01879                                         s = strconv_escape(s, g); 
<a name="l01880"></a>01880                                 } 
<a name="l01881"></a>01881                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!*s) 
<a name="l01882"></a>01882                                 { 
<a name="l01883"></a>01883                                         <span class="keywordflow">return</span> 0; 
<a name="l01884"></a>01884                                 } 
<a name="l01885"></a>01885                                 <span class="keywordflow">else</span> ++s; 
<a name="l01886"></a>01886                         } 
<a name="l01887"></a>01887                 } 
<a name="l01888"></a>01888         }; 
<a name="l01889"></a>01889  
<a name="l01890"></a>01890         strconv_attribute_t GetStrconv_attribute(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> optmask) 
<a name="l01891"></a>01891         { 
<a name="l01892"></a>01892                 STATIC_ASSERT(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a6463412ba9e404b6890e4721255cd8ed" title="This flag determines if character and entity references are expanded during parsing. This flag is on by default.">ParseEscapes</a> == 0x10 &amp;&amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a52af747730d2b3a313eebed4cf49a333" title="This flag determines if EOL characters are normalized (converted to xA) during parsing. This flag is on by default.">ParseEol</a> == 0x20 &amp;&amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#af9f7575e3cb8a0d8ad9a7ceee5e26983" title="This flag determines if attribute values are normalized using CDATA normalization rules during parsin...">ParseWconvAttribute</a> == 0x40 &amp;&amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#acddcc88320f06c933c67cdd77704c838" title="This flag determines if attribute values are normalized using NMTOKENS normalization rules during par...">ParseWnormAttribute</a> == 0x80); 
<a name="l01893"></a>01893                  
<a name="l01894"></a>01894                 <span class="keywordflow">switch</span> ((optmask &gt;&gt; 4) &amp; 15) <span class="comment">// get bitmask for flags (wconv wnorm eol escapes) </span>
<a name="l01895"></a>01895                 { 
<a name="l01896"></a>01896                 <span class="keywordflow">case</span> 0:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_false&gt;::ParseSimple; 
<a name="l01897"></a>01897                 <span class="keywordflow">case</span> 1:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_true&gt;::ParseSimple; 
<a name="l01898"></a>01898                 <span class="keywordflow">case</span> 2:  <span class="keywordflow">return</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a52af747730d2b3a313eebed4cf49a333" title="This flag determines if EOL characters are normalized (converted to xA) during parsing. This flag is on by default.">strconv_attribute_impl&lt;opt_false&gt;::ParseEol</a>; 
<a name="l01899"></a>01899                 <span class="keywordflow">case</span> 3:  <span class="keywordflow">return</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a52af747730d2b3a313eebed4cf49a333" title="This flag determines if EOL characters are normalized (converted to xA) during parsing. This flag is on by default.">strconv_attribute_impl&lt;opt_true&gt;::ParseEol</a>; 
<a name="l01900"></a>01900                 <span class="keywordflow">case</span> 4:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_false&gt;::ParseWconv; 
<a name="l01901"></a>01901                 <span class="keywordflow">case</span> 5:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_true&gt;::ParseWconv; 
<a name="l01902"></a>01902                 <span class="keywordflow">case</span> 6:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_false&gt;::ParseWconv; 
<a name="l01903"></a>01903                 <span class="keywordflow">case</span> 7:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_true&gt;::ParseWconv; 
<a name="l01904"></a>01904                 <span class="keywordflow">case</span> 8:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_false&gt;::ParseWnorm; 
<a name="l01905"></a>01905                 <span class="keywordflow">case</span> 9:  <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_true&gt;::ParseWnorm; 
<a name="l01906"></a>01906                 <span class="keywordflow">case</span> 10: <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_false&gt;::ParseWnorm; 
<a name="l01907"></a>01907                 <span class="keywordflow">case</span> 11: <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_true&gt;::ParseWnorm; 
<a name="l01908"></a>01908                 <span class="keywordflow">case</span> 12: <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_false&gt;::ParseWnorm; 
<a name="l01909"></a>01909                 <span class="keywordflow">case</span> 13: <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_true&gt;::ParseWnorm; 
<a name="l01910"></a>01910                 <span class="keywordflow">case</span> 14: <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_false&gt;::ParseWnorm; 
<a name="l01911"></a>01911                 <span class="keywordflow">case</span> 15: <span class="keywordflow">return</span> strconv_attribute_impl&lt;opt_true&gt;::ParseWnorm; 
<a name="l01912"></a>01912                 <span class="keywordflow">default</span>: <span class="keywordflow">return</span> 0; <span class="comment">// should not get here </span>
<a name="l01913"></a>01913                 } 
<a name="l01914"></a>01914         } 
<a name="l01915"></a>01915  
<a name="l01916"></a>01916         <span class="keyword">inline</span> <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917f" title="These statuses are used to help determine what issues, if any the parser had. the XML parser had...">ParseStatus</a> Status, ptrdiff_t Offset = 0) 
<a name="l01917"></a>01917         { 
<a name="l01918"></a>01918                 <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> Result; 
<a name="l01919"></a>01919                 Result.<a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a1bf9dfeebdb07656723bbaf18ab612b5" title="Parsing status ( see ParseStatus ).">Status</a> = Status; 
<a name="l01920"></a>01920                 Result.<a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a30b2a5fa6ceae01ab30c6ff48273ce41" title="Last parsed offset (in char_t units from start of input data).">Offset</a> = Offset; 
<a name="l01921"></a>01921  
<a name="l01922"></a>01922                 <span class="keywordflow">return</span> Result; 
<a name="l01923"></a>01923         } 
<a name="l01924"></a>01924  
<a name="l01925"></a>01925         <span class="keyword">struct </span>Parser 
<a name="l01926"></a>01926         { 
<a name="l01927"></a>01927                 Allocator alloc; 
<a name="l01928"></a>01928                 char_t* error_Offset; 
<a name="l01929"></a>01929                 jmp_buf error_handler; 
<a name="l01930"></a>01930                  
<a name="l01931"></a>01931                 <span class="comment">// Parser utilities. </span>
<a name="l01932"></a>01932 <span class="preprocessor">                #define SKIPWS()                        { while (IS_CHARTYPE(*s, ct_space)) ++s; } </span>
<a name="l01933"></a>01933 <span class="preprocessor"></span><span class="preprocessor">                #define OPTSET(OPT)                     ( optmsk &amp; OPT ) </span>
<a name="l01934"></a>01934 <span class="preprocessor"></span><span class="preprocessor">                #define PUSHNODE(TYPE)          { cursor = AppendNode(cursor, alloc, TYPE); if (!cursor) THROW_ERROR(StatusOutOfMemory, s); } </span>
<a name="l01935"></a>01935 <span class="preprocessor"></span><span class="preprocessor">                #define POPNODE()                       { cursor = cursor-&gt;GetParent; } </span>
<a name="l01936"></a>01936 <span class="preprocessor"></span><span class="preprocessor">                #define SCANFOR(X)                      { while (*s != 0 &amp;&amp; !(X)) ++s; } </span>
<a name="l01937"></a>01937 <span class="preprocessor"></span><span class="preprocessor">                #define SCANWHILE(X)            { while ((X)) ++s; } </span>
<a name="l01938"></a>01938 <span class="preprocessor"></span><span class="preprocessor">                #define ENDSEG()                        { ch = *s; *s = 0; ++s; } </span>
<a name="l01939"></a>01939 <span class="preprocessor"></span><span class="preprocessor">                #define THROW_ERROR(err, m)     error_Offset = m, longjmp(error_handler, err) </span>
<a name="l01940"></a>01940 <span class="preprocessor"></span><span class="preprocessor">                #define CHECK_ERROR(err, m)     { if (*s == 0) THROW_ERROR(err, m); } </span>
<a name="l01941"></a>01941 <span class="preprocessor"></span>                 
<a name="l01942"></a>01942                 Parser(<span class="keyword">const</span> Allocator&amp; alloc): alloc(alloc), error_Offset(0) 
<a name="l01943"></a>01943                 { 
<a name="l01944"></a>01944                 } 
<a name="l01945"></a>01945  
<a name="l01946"></a>01946                 <span class="comment">// DOCTYPE consists of nested sections of the following possible Types: </span>
<a name="l01947"></a>01947                 <span class="comment">// &lt;!-- ... --&gt;, &lt;? ... ?&gt;, &quot;...&quot;, &#39;...&#39; </span>
<a name="l01948"></a>01948                 <span class="comment">// &lt;![...]]&gt; </span>
<a name="l01949"></a>01949                 <span class="comment">// &lt;!...&gt; </span>
<a name="l01950"></a>01950                 <span class="comment">// First group can not contain nested groups </span>
<a name="l01951"></a>01951                 <span class="comment">// Second group can contain nested groups of the same Type </span>
<a name="l01952"></a>01952                 <span class="comment">// Third group can contain all other groups </span>
<a name="l01953"></a>01953                 char_t* ParseDocTypePrimitive(char_t* s) 
<a name="l01954"></a>01954                 { 
<a name="l01955"></a>01955                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;&quot;&#39;</span> || *s == <span class="charliteral">&#39;\&#39;&#39;</span>) 
<a name="l01956"></a>01956                         { 
<a name="l01957"></a>01957                                 <span class="comment">// quoted string </span>
<a name="l01958"></a>01958                                 char_t ch = *s++; 
<a name="l01959"></a>01959                                 SCANFOR(*s == ch); 
<a name="l01960"></a>01960                                 <span class="keywordflow">if</span> (!*s) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>, s); 
<a name="l01961"></a>01961  
<a name="l01962"></a>01962                                 s++; 
<a name="l01963"></a>01963                         } 
<a name="l01964"></a>01964                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;&lt;&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;?&#39;</span>) 
<a name="l01965"></a>01965                         { 
<a name="l01966"></a>01966                                 <span class="comment">// &lt;? ... ?&gt; </span>
<a name="l01967"></a>01967                                 s += 2; 
<a name="l01968"></a>01968                                 SCANFOR(s[0] == <span class="charliteral">&#39;?&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;&gt;&#39;</span>); <span class="comment">// no need for ENDSWITH because ?&gt; can&#39;t terminate proper docType </span>
<a name="l01969"></a>01969                                 <span class="keywordflow">if</span> (!*s) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>, s); 
<a name="l01970"></a>01970  
<a name="l01971"></a>01971                                 s += 2; 
<a name="l01972"></a>01972                         } 
<a name="l01973"></a>01973                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;&lt;&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;!&#39;</span> &amp;&amp; s[2] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; s[3] == <span class="charliteral">&#39;-&#39;</span>) 
<a name="l01974"></a>01974                         { 
<a name="l01975"></a>01975                                 s += 4; 
<a name="l01976"></a>01976                                 SCANFOR(s[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; s[2] == <span class="charliteral">&#39;&gt;&#39;</span>); <span class="comment">// no need for ENDSWITH because --&gt; can&#39;t terminate proper docType </span>
<a name="l01977"></a>01977                                 <span class="keywordflow">if</span> (!*s) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>, s); 
<a name="l01978"></a>01978  
<a name="l01979"></a>01979                                 s += 4; 
<a name="l01980"></a>01980                         } 
<a name="l01981"></a>01981                         <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>, s); 
<a name="l01982"></a>01982  
<a name="l01983"></a>01983                         <span class="keywordflow">return</span> s; 
<a name="l01984"></a>01984                 } 
<a name="l01985"></a>01985  
<a name="l01986"></a>01986                 char_t* ParseDocTypeIgnore(char_t* s) 
<a name="l01987"></a>01987                 { 
<a name="l01988"></a>01988                         assert(s[0] == <span class="charliteral">&#39;&lt;&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;!&#39;</span> &amp;&amp; s[2] == <span class="charliteral">&#39;[&#39;</span>); 
<a name="l01989"></a>01989                         s++; 
<a name="l01990"></a>01990  
<a name="l01991"></a>01991                         <span class="keywordflow">while</span> (*s) 
<a name="l01992"></a>01992                         { 
<a name="l01993"></a>01993                                 <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;&lt;&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;!&#39;</span> &amp;&amp; s[2] == <span class="charliteral">&#39;[&#39;</span>) 
<a name="l01994"></a>01994                                 { 
<a name="l01995"></a>01995                                         <span class="comment">// nested ignore section </span>
<a name="l01996"></a>01996                                         s = ParseDocTypeIgnore(s); 
<a name="l01997"></a>01997                                 } 
<a name="l01998"></a>01998                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; s[2] == <span class="charliteral">&#39;&gt;&#39;</span>) 
<a name="l01999"></a>01999                                 { 
<a name="l02000"></a>02000                                         <span class="comment">// ignore section end </span>
<a name="l02001"></a>02001                                         s += 3; 
<a name="l02002"></a>02002  
<a name="l02003"></a>02003                                         <span class="keywordflow">return</span> s; 
<a name="l02004"></a>02004                                 } 
<a name="l02005"></a>02005                                 <span class="keywordflow">else</span> s++; 
<a name="l02006"></a>02006                         } 
<a name="l02007"></a>02007  
<a name="l02008"></a>02008                         THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>, s); 
<a name="l02009"></a>02009  
<a name="l02010"></a>02010                         <span class="keywordflow">return</span> s; 
<a name="l02011"></a>02011                 } 
<a name="l02012"></a>02012  
<a name="l02013"></a>02013                 char_t* ParseDocTypeGroup(char_t* s, char_t endch, <span class="keywordtype">bool</span> toplevel) 
<a name="l02014"></a>02014                 { 
<a name="l02015"></a>02015                         assert(s[0] == <span class="charliteral">&#39;&lt;&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;!&#39;</span>); 
<a name="l02016"></a>02016                         s++; 
<a name="l02017"></a>02017  
<a name="l02018"></a>02018                         <span class="keywordflow">while</span> (*s) 
<a name="l02019"></a>02019                         { 
<a name="l02020"></a>02020                                 <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;&lt;&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;!&#39;</span> &amp;&amp; s[2] != <span class="charliteral">&#39;-&#39;</span>) 
<a name="l02021"></a>02021                                 { 
<a name="l02022"></a>02022                                         <span class="keywordflow">if</span> (s[2] == <span class="charliteral">&#39;[&#39;</span>) 
<a name="l02023"></a>02023                                         { 
<a name="l02024"></a>02024                                                 <span class="comment">// ignore </span>
<a name="l02025"></a>02025                                                 s = ParseDocTypeIgnore(s); 
<a name="l02026"></a>02026                                         } 
<a name="l02027"></a>02027                                         <span class="keywordflow">else</span> 
<a name="l02028"></a>02028                                         { 
<a name="l02029"></a>02029                                                 <span class="comment">// some control group </span>
<a name="l02030"></a>02030                                                 s = ParseDocTypeGroup(s, endch, <span class="keyword">false</span>); 
<a name="l02031"></a>02031                                         } 
<a name="l02032"></a>02032                                 } 
<a name="l02033"></a>02033                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;&lt;&#39;</span> || s[0] == <span class="charliteral">&#39;&quot;&#39;</span> || s[0] == <span class="charliteral">&#39;\&#39;&#39;</span>) 
<a name="l02034"></a>02034                                 { 
<a name="l02035"></a>02035                                         <span class="comment">// unknown tag (forbidden), or some primitive group </span>
<a name="l02036"></a>02036                                         s = ParseDocTypePrimitive(s); 
<a name="l02037"></a>02037                                 } 
<a name="l02038"></a>02038                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;&gt;&#39;</span>) 
<a name="l02039"></a>02039                                 { 
<a name="l02040"></a>02040                                         s++; 
<a name="l02041"></a>02041  
<a name="l02042"></a>02042                                         <span class="keywordflow">return</span> s; 
<a name="l02043"></a>02043                                 } 
<a name="l02044"></a>02044                                 <span class="keywordflow">else</span> s++; 
<a name="l02045"></a>02045                         } 
<a name="l02046"></a>02046  
<a name="l02047"></a>02047                         <span class="keywordflow">if</span> (!toplevel || endch != <span class="charliteral">&#39;&gt;&#39;</span>) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>, s); 
<a name="l02048"></a>02048  
<a name="l02049"></a>02049                         <span class="keywordflow">return</span> s; 
<a name="l02050"></a>02050                 } 
<a name="l02051"></a>02051  
<a name="l02052"></a>02052                 char_t* ParseExclamation(char_t* s, <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* cursor, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> optmsk, char_t endch) 
<a name="l02053"></a>02053                 { 
<a name="l02054"></a>02054                         <span class="comment">// parse node contents, starting with exclamation mark </span>
<a name="l02055"></a>02055                         ++s; 
<a name="l02056"></a>02056  
<a name="l02057"></a>02057                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;-&#39;</span>) <span class="comment">// &#39;&lt;!-...&#39; </span>
<a name="l02058"></a>02058                         { 
<a name="l02059"></a>02059                                 ++s; 
<a name="l02060"></a>02060  
<a name="l02061"></a>02061                                 <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;-&#39;</span>) <span class="comment">// &#39;&lt;!--...&#39; </span>
<a name="l02062"></a>02062                                 { 
<a name="l02063"></a>02063                                         ++s; 
<a name="l02064"></a>02064  
<a name="l02065"></a>02065                                         <span class="keywordflow">if</span> (OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a83ba30a7bee5a0fd4aa2f6136c8793fc" title="This flag determines if comments (NodeComment) are added to the DOM tree. This flag is off by default...">ParseComments</a>)) 
<a name="l02066"></a>02066                                         { 
<a name="l02067"></a>02067                                                 PUSHNODE(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a25b778cb61ae0a9f15590cad5e0120d2" title="Comment tag, i.e. &amp;#39;&amp;#39;.">NodeComment</a>); <span class="comment">// Append a new node on the tree. </span>
<a name="l02068"></a>02068                                                 cursor-&gt;Value = s; <span class="comment">// Save the Offset. </span>
<a name="l02069"></a>02069                                         } 
<a name="l02070"></a>02070  
<a name="l02071"></a>02071                                         <span class="keywordflow">if</span> (OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a52af747730d2b3a313eebed4cf49a333" title="This flag determines if EOL characters are normalized (converted to xA) during parsing. This flag is on by default.">ParseEol</a>) &amp;&amp; OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a83ba30a7bee5a0fd4aa2f6136c8793fc" title="This flag determines if comments (NodeComment) are added to the DOM tree. This flag is off by default...">ParseComments</a>)) 
<a name="l02072"></a>02072                                         { 
<a name="l02073"></a>02073                                                 s = strconv_comment(s, endch); 
<a name="l02074"></a>02074  
<a name="l02075"></a>02075                                                 <span class="keywordflow">if</span> (!s) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8f3864efd7b684ae57a8a7886a23f19a" title="Parsing error occurred while parsing comment.">StatusBadComment</a>, cursor-&gt;Value); 
<a name="l02076"></a>02076                                         } 
<a name="l02077"></a>02077                                         <span class="keywordflow">else</span> 
<a name="l02078"></a>02078                                         { 
<a name="l02079"></a>02079                                                 <span class="comment">// Scan for terminating &#39;--&gt;&#39;. </span>
<a name="l02080"></a>02080                                                 SCANFOR(s[0] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;-&#39;</span> &amp;&amp; ENDSWITH(s[2], <span class="charliteral">&#39;&gt;&#39;</span>)); 
<a name="l02081"></a>02081                                                 CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8f3864efd7b684ae57a8a7886a23f19a" title="Parsing error occurred while parsing comment.">StatusBadComment</a>, s); 
<a name="l02082"></a>02082  
<a name="l02083"></a>02083                                                 <span class="keywordflow">if</span> (OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a83ba30a7bee5a0fd4aa2f6136c8793fc" title="This flag determines if comments (NodeComment) are added to the DOM tree. This flag is off by default...">ParseComments</a>)) 
<a name="l02084"></a>02084                                                         *s = 0; <span class="comment">// Zero-terminate this segment at the first terminating &#39;-&#39;. </span>
<a name="l02085"></a>02085  
<a name="l02086"></a>02086                                                 s += (s[2] == <span class="charliteral">&#39;&gt;&#39;</span> ? 3 : 2); <span class="comment">// Step over the &#39;\0-&gt;&#39;. </span>
<a name="l02087"></a>02087                                         } 
<a name="l02088"></a>02088                                 } 
<a name="l02089"></a>02089                                 <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8f3864efd7b684ae57a8a7886a23f19a" title="Parsing error occurred while parsing comment.">StatusBadComment</a>, s); 
<a name="l02090"></a>02090                         } 
<a name="l02091"></a>02091                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;[&#39;</span>) 
<a name="l02092"></a>02092                         { 
<a name="l02093"></a>02093                                 <span class="comment">// &#39;&lt;![CDATA[...&#39; </span>
<a name="l02094"></a>02094                                 <span class="keywordflow">if</span> (*++s==<span class="charliteral">&#39;C&#39;</span> &amp;&amp; *++s==<span class="charliteral">&#39;D&#39;</span> &amp;&amp; *++s==<span class="charliteral">&#39;A&#39;</span> &amp;&amp; *++s==<span class="charliteral">&#39;T&#39;</span> &amp;&amp; *++s==<span class="charliteral">&#39;A&#39;</span> &amp;&amp; *++s == <span class="charliteral">&#39;[&#39;</span>) 
<a name="l02095"></a>02095                                 { 
<a name="l02096"></a>02096                                         ++s; 
<a name="l02097"></a>02097  
<a name="l02098"></a>02098                                         <span class="keywordflow">if</span> (OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#aec00a2a16700dfd76f8f3c776bd000ac" title="This flag determines if CDATA sections (NodeCdata) are added to the DOM tree. This flag is on by defa...">ParseCdata</a>)) 
<a name="l02099"></a>02099                                         { 
<a name="l02100"></a>02100                                                 PUSHNODE(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a353968e806a751a6da4f7ac115b4ab55" title="Character data, i.e. &amp;#39;&amp;lt;![CDATA[text]]&amp;gt;&amp;#39;.">NodeCdata</a>); <span class="comment">// Append a new node on the tree. </span>
<a name="l02101"></a>02101                                                 cursor-&gt;Value = s; <span class="comment">// Save the Offset. </span>
<a name="l02102"></a>02102  
<a name="l02103"></a>02103                                                 <span class="keywordflow">if</span> (OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a52af747730d2b3a313eebed4cf49a333" title="This flag determines if EOL characters are normalized (converted to xA) during parsing. This flag is on by default.">ParseEol</a>)) 
<a name="l02104"></a>02104                                                 { 
<a name="l02105"></a>02105                                                         s = strconv_cdata(s, endch); 
<a name="l02106"></a>02106  
<a name="l02107"></a>02107                                                         <span class="keywordflow">if</span> (!s) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa18f36b8d712a6bbc716f90af8659df22" title="Parsing error occurred while parsing CDATA section.">StatusBadCdata</a>, cursor-&gt;Value); 
<a name="l02108"></a>02108                                                 } 
<a name="l02109"></a>02109                                                 <span class="keywordflow">else</span> 
<a name="l02110"></a>02110                                                 { 
<a name="l02111"></a>02111                                                         <span class="comment">// Scan for terminating &#39;]]&gt;&#39;. </span>
<a name="l02112"></a>02112                                                         SCANFOR(s[0] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; ENDSWITH(s[2], <span class="charliteral">&#39;&gt;&#39;</span>)); 
<a name="l02113"></a>02113                                                         CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa18f36b8d712a6bbc716f90af8659df22" title="Parsing error occurred while parsing CDATA section.">StatusBadCdata</a>, s); 
<a name="l02114"></a>02114  
<a name="l02115"></a>02115                                                         *s++ = 0; <span class="comment">// Zero-terminate this segment. </span>
<a name="l02116"></a>02116                                                 } 
<a name="l02117"></a>02117                                         } 
<a name="l02118"></a>02118                                         <span class="keywordflow">else</span> <span class="comment">// Flagged for discard, but we still have to scan for the terminator. </span>
<a name="l02119"></a>02119                                         { 
<a name="l02120"></a>02120                                                 <span class="comment">// Scan for terminating &#39;]]&gt;&#39;. </span>
<a name="l02121"></a>02121                                                 SCANFOR(s[0] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; ENDSWITH(s[2], <span class="charliteral">&#39;&gt;&#39;</span>)); 
<a name="l02122"></a>02122                                                 CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa18f36b8d712a6bbc716f90af8659df22" title="Parsing error occurred while parsing CDATA section.">StatusBadCdata</a>, s); 
<a name="l02123"></a>02123  
<a name="l02124"></a>02124                                                 ++s; 
<a name="l02125"></a>02125                                         } 
<a name="l02126"></a>02126  
<a name="l02127"></a>02127                                         s += (s[1] == <span class="charliteral">&#39;&gt;&#39;</span> ? 2 : 1); <span class="comment">// Step over the last &#39;]&gt;&#39;. </span>
<a name="l02128"></a>02128                                 } 
<a name="l02129"></a>02129                                 <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa18f36b8d712a6bbc716f90af8659df22" title="Parsing error occurred while parsing CDATA section.">StatusBadCdata</a>, s); 
<a name="l02130"></a>02130                         } 
<a name="l02131"></a>02131                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s[0] == <span class="charliteral">&#39;D&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;O&#39;</span> &amp;&amp; s[2] == <span class="charliteral">&#39;C&#39;</span> &amp;&amp; s[3] == <span class="charliteral">&#39;T&#39;</span> &amp;&amp; s[4] == <span class="charliteral">&#39;Y&#39;</span> &amp;&amp; s[5] == <span class="charliteral">&#39;P&#39;</span> &amp;&amp; ENDSWITH(s[6], <span class="charliteral">&#39;E&#39;</span>)) 
<a name="l02132"></a>02132                         { 
<a name="l02133"></a>02133                                 s -= 2; 
<a name="l02134"></a>02134  
<a name="l02135"></a>02135                                 <span class="keywordflow">if</span> (cursor-&gt;GetParent) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>, s); 
<a name="l02136"></a>02136  
<a name="l02137"></a>02137                                 char_t* mark = s + 9; 
<a name="l02138"></a>02138  
<a name="l02139"></a>02139                                 s = ParseDocTypeGroup(s, endch, <span class="keyword">true</span>); 
<a name="l02140"></a>02140  
<a name="l02141"></a>02141                                 <span class="keywordflow">if</span> (OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#adf5ee79dc4c200ad85b64a8308b0c805" title="This flag determines if document type declaration (NodeDoctype) is added to the DOM tree...">ParseDocType</a>)) 
<a name="l02142"></a>02142                                 { 
<a name="l02143"></a>02143                                         <span class="keywordflow">while</span> (IS_CHARTYPE(*mark, ct_space)) ++mark; 
<a name="l02144"></a>02144  
<a name="l02145"></a>02145                                         PUSHNODE(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3aca750034b7e4a34d53cfd3399b2bcd99" title="Document type declaration, i.e. &amp;#39;&amp;lt;!DOCTYPE doc&amp;gt;&amp;#39;.">NodeDocType</a>); 
<a name="l02146"></a>02146  
<a name="l02147"></a>02147                                         cursor-&gt;Value = mark; 
<a name="l02148"></a>02148  
<a name="l02149"></a>02149                                         assert((s[0] == 0 &amp;&amp; endch == <span class="charliteral">&#39;&gt;&#39;</span>) || s[-1] == <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02150"></a>02150                                         s[*s == 0 ? 0 : -1] = 0; 
<a name="l02151"></a>02151  
<a name="l02152"></a>02152                                         POPNODE(); 
<a name="l02153"></a>02153                                 } 
<a name="l02154"></a>02154                         } 
<a name="l02155"></a>02155                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0 &amp;&amp; endch == <span class="charliteral">&#39;-&#39;</span>) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8f3864efd7b684ae57a8a7886a23f19a" title="Parsing error occurred while parsing comment.">StatusBadComment</a>, s); 
<a name="l02156"></a>02156                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0 &amp;&amp; endch == <span class="charliteral">&#39;[&#39;</span>) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa18f36b8d712a6bbc716f90af8659df22" title="Parsing error occurred while parsing CDATA section.">StatusBadCdata</a>, s); 
<a name="l02157"></a>02157                         <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fabe0f4590debfa56c7e3a4c8da261b106" title="The parser could not determine type of tag.">StatusUnrecognizedTag</a>, s); 
<a name="l02158"></a>02158  
<a name="l02159"></a>02159                         <span class="keywordflow">return</span> s; 
<a name="l02160"></a>02160                 } 
<a name="l02161"></a>02161  
<a name="l02162"></a>02162                 char_t* ParseQuestion(char_t* s, <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>*&amp; ref_cursor, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> optmsk, char_t endch) 
<a name="l02163"></a>02163                 { 
<a name="l02164"></a>02164                         <span class="comment">// Load into registers </span>
<a name="l02165"></a>02165                         <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* cursor = ref_cursor; 
<a name="l02166"></a>02166                         char_t ch = 0; 
<a name="l02167"></a>02167  
<a name="l02168"></a>02168                         <span class="comment">// parse node contents, starting with question mark </span>
<a name="l02169"></a>02169                         ++s; 
<a name="l02170"></a>02170  
<a name="l02171"></a>02171                         <span class="comment">// read PI target </span>
<a name="l02172"></a>02172                         char_t* target = s; 
<a name="l02173"></a>02173  
<a name="l02174"></a>02174                         <span class="keywordflow">if</span> (!IS_CHARTYPE(*s, ct_start_symbol)) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02175"></a>02175  
<a name="l02176"></a>02176                         SCANWHILE(IS_CHARTYPE(*s, ct_symbol)); 
<a name="l02177"></a>02177                         CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02178"></a>02178  
<a name="l02179"></a>02179                         <span class="comment">// determine node Type; stricmp / strcasecmp is not portable </span>
<a name="l02180"></a>02180                         <span class="keywordtype">bool</span> declaration = (target[0] | <span class="charliteral">&#39; &#39;</span>) == <span class="charliteral">&#39;x&#39;</span> &amp;&amp; (target[1] | <span class="charliteral">&#39; &#39;</span>) == <span class="charliteral">&#39;m&#39;</span> &amp;&amp; (target[2] | <span class="charliteral">&#39; &#39;</span>) == <span class="charliteral">&#39;l&#39;</span> &amp;&amp; target + 3 == s; 
<a name="l02181"></a>02181  
<a name="l02182"></a>02182                         <span class="keywordflow">if</span> (declaration ? OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a463f15fc43d69ab835c8598826f65646" title="This flag determines if document declaration (NodeDeclaration) is added to the DOM tree...">ParseDeclaration</a>) : OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a4d324954fc33d50155bae04587da13e2" title="This flag determines if processing instructions (NodePi) are added to the DOM tree. This flag is off by default.">ParsePi</a>)) 
<a name="l02183"></a>02183                         { 
<a name="l02184"></a>02184                                 <span class="keywordflow">if</span> (declaration) 
<a name="l02185"></a>02185                                 { 
<a name="l02186"></a>02186                                         <span class="comment">// disallow non top-level declarations </span>
<a name="l02187"></a>02187                                         <span class="keywordflow">if</span> (cursor-&gt;GetParent) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02188"></a>02188  
<a name="l02189"></a>02189                                         PUSHNODE(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>); 
<a name="l02190"></a>02190                                 } 
<a name="l02191"></a>02191                                 <span class="keywordflow">else</span> 
<a name="l02192"></a>02192                                 { 
<a name="l02193"></a>02193                                         PUSHNODE(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a>); 
<a name="l02194"></a>02194                                 } 
<a name="l02195"></a>02195  
<a name="l02196"></a>02196                                 cursor-&gt;Name = target; 
<a name="l02197"></a>02197  
<a name="l02198"></a>02198                                 ENDSEG(); 
<a name="l02199"></a>02199  
<a name="l02200"></a>02200                                 <span class="comment">// parse Value/attributes </span>
<a name="l02201"></a>02201                                 <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;?&#39;</span>) 
<a name="l02202"></a>02202                                 { 
<a name="l02203"></a>02203                                         <span class="comment">// empty node </span>
<a name="l02204"></a>02204                                         <span class="keywordflow">if</span> (!ENDSWITH(*s, <span class="charliteral">&#39;&gt;&#39;</span>)) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02205"></a>02205                                         s += (*s == <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02206"></a>02206  
<a name="l02207"></a>02207                                         POPNODE(); 
<a name="l02208"></a>02208                                 } 
<a name="l02209"></a>02209                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_CHARTYPE(ch, ct_space)) 
<a name="l02210"></a>02210                                 { 
<a name="l02211"></a>02211                                         SKIPWS(); 
<a name="l02212"></a>02212  
<a name="l02213"></a>02213                                         <span class="comment">// scan for tag end </span>
<a name="l02214"></a>02214                                         char_t* Value = s; 
<a name="l02215"></a>02215  
<a name="l02216"></a>02216                                         SCANFOR(s[0] == <span class="charliteral">&#39;?&#39;</span> &amp;&amp; ENDSWITH(s[1], <span class="charliteral">&#39;&gt;&#39;</span>)); 
<a name="l02217"></a>02217                                         CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02218"></a>02218  
<a name="l02219"></a>02219                                         <span class="keywordflow">if</span> (declaration) 
<a name="l02220"></a>02220                                         { 
<a name="l02221"></a>02221                                                 <span class="comment">// replace ending ? with / so that &#39;element&#39; terminates properly </span>
<a name="l02222"></a>02222                                                 *s = <span class="charliteral">&#39;/&#39;</span>; 
<a name="l02223"></a>02223  
<a name="l02224"></a>02224                                                 <span class="comment">// we exit from this function with cursor at NodeDeclaration, which is a signal to parse() to go to LOC_ATTRIBUTES </span>
<a name="l02225"></a>02225                                                 s = Value; 
<a name="l02226"></a>02226                                         } 
<a name="l02227"></a>02227                                         <span class="keywordflow">else</span> 
<a name="l02228"></a>02228                                         { 
<a name="l02229"></a>02229                                                 <span class="comment">// store Value and step over &gt; </span>
<a name="l02230"></a>02230                                                 cursor-&gt;Value = Value; 
<a name="l02231"></a>02231                                                 POPNODE(); 
<a name="l02232"></a>02232  
<a name="l02233"></a>02233                                                 ENDSEG(); 
<a name="l02234"></a>02234  
<a name="l02235"></a>02235                                                 s += (*s == <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02236"></a>02236                                         } 
<a name="l02237"></a>02237                                 } 
<a name="l02238"></a>02238                                 <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02239"></a>02239                         } 
<a name="l02240"></a>02240                         <span class="keywordflow">else</span> 
<a name="l02241"></a>02241                         { 
<a name="l02242"></a>02242                                 <span class="comment">// scan for tag end </span>
<a name="l02243"></a>02243                                 SCANFOR(s[0] == <span class="charliteral">&#39;?&#39;</span> &amp;&amp; ENDSWITH(s[1], <span class="charliteral">&#39;&gt;&#39;</span>)); 
<a name="l02244"></a>02244                                 CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02245"></a>02245  
<a name="l02246"></a>02246                                 s += (s[1] == <span class="charliteral">&#39;&gt;&#39;</span> ? 2 : 1); 
<a name="l02247"></a>02247                         } 
<a name="l02248"></a>02248  
<a name="l02249"></a>02249                         <span class="comment">// store from registers </span>
<a name="l02250"></a>02250                         ref_cursor = cursor; 
<a name="l02251"></a>02251  
<a name="l02252"></a>02252                         <span class="keywordflow">return</span> s; 
<a name="l02253"></a>02253                 } 
<a name="l02254"></a>02254  
<a name="l02255"></a>02255                 <span class="keywordtype">void</span> parse(char_t* s, <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* xmldoc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> optmsk, char_t endch) 
<a name="l02256"></a>02256                 { 
<a name="l02257"></a>02257                         strconv_attribute_t strconv_attribute = GetStrconv_attribute(optmsk); 
<a name="l02258"></a>02258                         strconv_pcdata_t strconv_pcdata = GetStrconv_pcdata(optmsk); 
<a name="l02259"></a>02259                          
<a name="l02260"></a>02260                         char_t ch = 0; 
<a name="l02261"></a>02261                         <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* cursor = xmldoc; 
<a name="l02262"></a>02262                         char_t* mark = s; 
<a name="l02263"></a>02263  
<a name="l02264"></a>02264                         <span class="keywordflow">while</span> (*s != 0) 
<a name="l02265"></a>02265                         { 
<a name="l02266"></a>02266                                 <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;&lt;&#39;</span>) 
<a name="l02267"></a>02267                                 { 
<a name="l02268"></a>02268                                         ++s; 
<a name="l02269"></a>02269  
<a name="l02270"></a>02270                                 LOC_TAG: 
<a name="l02271"></a>02271                                         <span class="keywordflow">if</span> (IS_CHARTYPE(*s, ct_start_symbol)) <span class="comment">// &#39;&lt;#...&#39; </span>
<a name="l02272"></a>02272                                         { 
<a name="l02273"></a>02273                                                 PUSHNODE(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>); <span class="comment">// Append a new node to the tree. </span>
<a name="l02274"></a>02274  
<a name="l02275"></a>02275                                                 cursor-&gt;Name = s; 
<a name="l02276"></a>02276  
<a name="l02277"></a>02277                                                 SCANWHILE(IS_CHARTYPE(*s, ct_symbol)); <span class="comment">// Scan for a terminator. </span>
<a name="l02278"></a>02278                                                 ENDSEG(); <span class="comment">// Save char in &#39;ch&#39;, terminate &amp; step over. </span>
<a name="l02279"></a>02279  
<a name="l02280"></a>02280                                                 <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;&gt;&#39;</span>) 
<a name="l02281"></a>02281                                                 { 
<a name="l02282"></a>02282                                                         <span class="comment">// end of tag </span>
<a name="l02283"></a>02283                                                 } 
<a name="l02284"></a>02284                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_CHARTYPE(ch, ct_space)) 
<a name="l02285"></a>02285                                                 { 
<a name="l02286"></a>02286                                                 LOC_ATTRIBUTES: 
<a name="l02287"></a>02287                                                         <span class="keywordflow">while</span> (<span class="keyword">true</span>) 
<a name="l02288"></a>02288                                                         { 
<a name="l02289"></a>02289                                                                 SKIPWS(); <span class="comment">// Eat any whitespace. </span>
<a name="l02290"></a>02290                                                  
<a name="l02291"></a>02291                                                                 <span class="keywordflow">if</span> (IS_CHARTYPE(*s, ct_start_symbol)) <span class="comment">// &lt;... #... </span>
<a name="l02292"></a>02292                                                                 { 
<a name="l02293"></a>02293                                                                         <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* a = AppendAttribute_ll(cursor, alloc); <span class="comment">// Make space for this GetAttribute. </span>
<a name="l02294"></a>02294                                                                         <span class="keywordflow">if</span> (!a) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac2a8163c9a8e285153d2a96b011bd49f" title="Could not allocate memory.">StatusOutOfMemory</a>, s); 
<a name="l02295"></a>02295  
<a name="l02296"></a>02296                                                                         a-&gt;Name = s; <span class="comment">// Save the Offset. </span>
<a name="l02297"></a>02297  
<a name="l02298"></a>02298                                                                         SCANWHILE(IS_CHARTYPE(*s, ct_symbol)); <span class="comment">// Scan for a terminator. </span>
<a name="l02299"></a>02299                                                                         CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>, s); <span class="comment">//$ redundant, left for performance </span>
<a name="l02300"></a>02300  
<a name="l02301"></a>02301                                                                         ENDSEG(); <span class="comment">// Save char in &#39;ch&#39;, terminate &amp; step over. </span>
<a name="l02302"></a>02302                                                                         CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>, s); <span class="comment">//$ redundant, left for performance </span>
<a name="l02303"></a>02303  
<a name="l02304"></a>02304                                                                         <span class="keywordflow">if</span> (IS_CHARTYPE(ch, ct_space)) 
<a name="l02305"></a>02305                                                                         { 
<a name="l02306"></a>02306                                                                                 SKIPWS(); <span class="comment">// Eat any whitespace. </span>
<a name="l02307"></a>02307                                                                                 CHECK_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>, s); <span class="comment">//$ redundant, left for performance </span>
<a name="l02308"></a>02308  
<a name="l02309"></a>02309                                                                                 ch = *s; 
<a name="l02310"></a>02310                                                                                 ++s; 
<a name="l02311"></a>02311                                                                         } 
<a name="l02312"></a>02312                                                                          
<a name="l02313"></a>02313                                                                         <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;=&#39;</span>) <span class="comment">// &#39;&lt;... #=...&#39; </span>
<a name="l02314"></a>02314                                                                         { 
<a name="l02315"></a>02315                                                                                 SKIPWS(); <span class="comment">// Eat any whitespace. </span>
<a name="l02316"></a>02316  
<a name="l02317"></a>02317                                                                                 <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;&quot;&#39;</span> || *s == <span class="charliteral">&#39;\&#39;&#39;</span>) <span class="comment">// &#39;&lt;... #=&quot;...&#39; </span>
<a name="l02318"></a>02318                                                                                 { 
<a name="l02319"></a>02319                                                                                         ch = *s; <span class="comment">// Save quote char to avoid breaking on &quot;&#39;&#39;&quot; -or- &#39;&quot;&quot;&#39;. </span>
<a name="l02320"></a>02320                                                                                         ++s; <span class="comment">// Step over the quote. </span>
<a name="l02321"></a>02321                                                                                         a-&gt;Value = s; <span class="comment">// Save the Offset. </span>
<a name="l02322"></a>02322  
<a name="l02323"></a>02323                                                                                         s = strconv_attribute(s, ch); 
<a name="l02324"></a>02324                                                                                  
<a name="l02325"></a>02325                                                                                         <span class="keywordflow">if</span> (!s) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>, a-&gt;Value); 
<a name="l02326"></a>02326  
<a name="l02327"></a>02327                                                                                         <span class="comment">// After this line the loop continues from the start; </span>
<a name="l02328"></a>02328                                                                                         <span class="comment">// Whitespaces, / and &gt; are ok, symbols and EOF are wrong, </span>
<a name="l02329"></a>02329                                                                                         <span class="comment">// everything else will be detected </span>
<a name="l02330"></a>02330                                                                                         <span class="keywordflow">if</span> (IS_CHARTYPE(*s, ct_start_symbol)) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>, s); 
<a name="l02331"></a>02331                                                                                 } 
<a name="l02332"></a>02332                                                                                 <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>, s); 
<a name="l02333"></a>02333                                                                         } 
<a name="l02334"></a>02334                                                                         <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>, s); 
<a name="l02335"></a>02335                                                                 } 
<a name="l02336"></a>02336                                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;/&#39;</span>) 
<a name="l02337"></a>02337                                                                 { 
<a name="l02338"></a>02338                                                                         ++s; 
<a name="l02339"></a>02339                                                                          
<a name="l02340"></a>02340                                                                         <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;&gt;&#39;</span>) 
<a name="l02341"></a>02341                                                                         { 
<a name="l02342"></a>02342                                                                                 POPNODE(); 
<a name="l02343"></a>02343                                                                                 s++; 
<a name="l02344"></a>02344                                                                                 <span class="keywordflow">break</span>; 
<a name="l02345"></a>02345                                                                         } 
<a name="l02346"></a>02346                                                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0 &amp;&amp; endch == <span class="charliteral">&#39;&gt;&#39;</span>) 
<a name="l02347"></a>02347                                                                         { 
<a name="l02348"></a>02348                                                                                 POPNODE(); 
<a name="l02349"></a>02349                                                                                 <span class="keywordflow">break</span>; 
<a name="l02350"></a>02350                                                                         } 
<a name="l02351"></a>02351                                                                         <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fadbc5b334b4215ce2332073de46c58155" title="Parsing error occurred while parsing start element tag .">StatusBadStartElement</a>, s); 
<a name="l02352"></a>02352                                                                 } 
<a name="l02353"></a>02353                                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;&gt;&#39;</span>) 
<a name="l02354"></a>02354                                                                 { 
<a name="l02355"></a>02355                                                                         ++s; 
<a name="l02356"></a>02356  
<a name="l02357"></a>02357                                                                         <span class="keywordflow">break</span>; 
<a name="l02358"></a>02358                                                                 } 
<a name="l02359"></a>02359                                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0 &amp;&amp; endch == <span class="charliteral">&#39;&gt;&#39;</span>) 
<a name="l02360"></a>02360                                                                 { 
<a name="l02361"></a>02361                                                                         <span class="keywordflow">break</span>; 
<a name="l02362"></a>02362                                                                 } 
<a name="l02363"></a>02363                                                                 <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fadbc5b334b4215ce2332073de46c58155" title="Parsing error occurred while parsing start element tag .">StatusBadStartElement</a>, s); 
<a name="l02364"></a>02364                                                         } 
<a name="l02365"></a>02365  
<a name="l02366"></a>02366                                                         <span class="comment">// !!! </span>
<a name="l02367"></a>02367                                                 } 
<a name="l02368"></a>02368                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == <span class="charliteral">&#39;/&#39;</span>) <span class="comment">// &#39;&lt;#.../&#39; </span>
<a name="l02369"></a>02369                                                 { 
<a name="l02370"></a>02370                                                         <span class="keywordflow">if</span> (!ENDSWITH(*s, <span class="charliteral">&#39;&gt;&#39;</span>)) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fadbc5b334b4215ce2332073de46c58155" title="Parsing error occurred while parsing start element tag .">StatusBadStartElement</a>, s); 
<a name="l02371"></a>02371  
<a name="l02372"></a>02372                                                         POPNODE(); <span class="comment">// Pop. </span>
<a name="l02373"></a>02373  
<a name="l02374"></a>02374                                                         s += (*s == <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02375"></a>02375                                                 } 
<a name="l02376"></a>02376                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ch == 0) 
<a name="l02377"></a>02377                                                 { 
<a name="l02378"></a>02378                                                         <span class="comment">// we stepped over null terminator, backtrack &amp; handle closing tag </span>
<a name="l02379"></a>02379                                                         --s; 
<a name="l02380"></a>02380                                                          
<a name="l02381"></a>02381                                                         <span class="keywordflow">if</span> (endch != <span class="charliteral">&#39;&gt;&#39;</span>) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fadbc5b334b4215ce2332073de46c58155" title="Parsing error occurred while parsing start element tag .">StatusBadStartElement</a>, s); 
<a name="l02382"></a>02382                                                 } 
<a name="l02383"></a>02383                                                 <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fadbc5b334b4215ce2332073de46c58155" title="Parsing error occurred while parsing start element tag .">StatusBadStartElement</a>, s); 
<a name="l02384"></a>02384                                         } 
<a name="l02385"></a>02385                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;/&#39;</span>) 
<a name="l02386"></a>02386                                         { 
<a name="l02387"></a>02387                                                 ++s; 
<a name="l02388"></a>02388  
<a name="l02389"></a>02389                                                 char_t* Name = cursor-&gt;Name; 
<a name="l02390"></a>02390                                                 <span class="keywordflow">if</span> (!Name) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa6b8d817142e0898ad9b1c61cfa54b8ea" title="There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or th...">StatusEndElementMismatch</a>, s); 
<a name="l02391"></a>02391                                                  
<a name="l02392"></a>02392                                                 <span class="keywordflow">while</span> (IS_CHARTYPE(*s, ct_symbol)) 
<a name="l02393"></a>02393                                                 { 
<a name="l02394"></a>02394                                                         <span class="keywordflow">if</span> (*s++ != *Name++) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa6b8d817142e0898ad9b1c61cfa54b8ea" title="There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or th...">StatusEndElementMismatch</a>, s); 
<a name="l02395"></a>02395                                                 } 
<a name="l02396"></a>02396  
<a name="l02397"></a>02397                                                 <span class="keywordflow">if</span> (*Name) 
<a name="l02398"></a>02398                                                 { 
<a name="l02399"></a>02399                                                         <span class="keywordflow">if</span> (*s == 0 &amp;&amp; Name[0] == endch &amp;&amp; Name[1] == 0) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa72532447020c081f343c4a719add7450" title="Parsing error occurred while parsing end element tag.">StatusBadEndElement</a>, s); 
<a name="l02400"></a>02400                                                         <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa6b8d817142e0898ad9b1c61cfa54b8ea" title="There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or th...">StatusEndElementMismatch</a>, s); 
<a name="l02401"></a>02401                                                 } 
<a name="l02402"></a>02402                                                          
<a name="l02403"></a>02403                                                 POPNODE(); <span class="comment">// Pop. </span>
<a name="l02404"></a>02404  
<a name="l02405"></a>02405                                                 SKIPWS(); 
<a name="l02406"></a>02406  
<a name="l02407"></a>02407                                                 <span class="keywordflow">if</span> (*s == 0) 
<a name="l02408"></a>02408                                                 { 
<a name="l02409"></a>02409                                                         <span class="keywordflow">if</span> (endch != <span class="charliteral">&#39;&gt;&#39;</span>) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa72532447020c081f343c4a719add7450" title="Parsing error occurred while parsing end element tag.">StatusBadEndElement</a>, s); 
<a name="l02410"></a>02410                                                 } 
<a name="l02411"></a>02411                                                 <span class="keywordflow">else</span> 
<a name="l02412"></a>02412                                                 { 
<a name="l02413"></a>02413                                                         <span class="keywordflow">if</span> (*s != <span class="charliteral">&#39;&gt;&#39;</span>) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa72532447020c081f343c4a719add7450" title="Parsing error occurred while parsing end element tag.">StatusBadEndElement</a>, s); 
<a name="l02414"></a>02414                                                         ++s; 
<a name="l02415"></a>02415                                                 } 
<a name="l02416"></a>02416                                         } 
<a name="l02417"></a>02417                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;?&#39;</span>) <span class="comment">// &#39;&lt;?...&#39; </span>
<a name="l02418"></a>02418                                         { 
<a name="l02419"></a>02419                                                 s = ParseQuestion(s, cursor, optmsk, endch); 
<a name="l02420"></a>02420  
<a name="l02421"></a>02421                                                 assert(cursor); 
<a name="l02422"></a>02422                                                 <span class="keywordflow">if</span> ((cursor-&gt;header &amp; MemoryPage_type_mask) + 1 == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) <span class="keywordflow">goto</span> LOC_ATTRIBUTES; 
<a name="l02423"></a>02423                                         } 
<a name="l02424"></a>02424                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == <span class="charliteral">&#39;!&#39;</span>) <span class="comment">// &#39;&lt;!...&#39; </span>
<a name="l02425"></a>02425                                         { 
<a name="l02426"></a>02426                                                 s = ParseExclamation(s, cursor, optmsk, endch); 
<a name="l02427"></a>02427                                         } 
<a name="l02428"></a>02428                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*s == 0 &amp;&amp; endch == <span class="charliteral">&#39;?&#39;</span>) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>, s); 
<a name="l02429"></a>02429                                         <span class="keywordflow">else</span> THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fabe0f4590debfa56c7e3a4c8da261b106" title="The parser could not determine type of tag.">StatusUnrecognizedTag</a>, s); 
<a name="l02430"></a>02430                                 } 
<a name="l02431"></a>02431                                 <span class="keywordflow">else</span> 
<a name="l02432"></a>02432                                 { 
<a name="l02433"></a>02433                                         mark = s; <span class="comment">// Save this Offset while searching for a terminator. </span>
<a name="l02434"></a>02434  
<a name="l02435"></a>02435                                         SKIPWS(); <span class="comment">// Eat whitespace if no genuine PCDATA here. </span>
<a name="l02436"></a>02436  
<a name="l02437"></a>02437                                         <span class="keywordflow">if</span> ((!OPTSET(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a48c0da99d1ed62b1a4984293e64828c6" title="This flag determines if plain character data (NodePcdata) that consist only of whitespace are added t...">ParseWsPcdata</a>) || mark == s) &amp;&amp; (*s == <span class="charliteral">&#39;&lt;&#39;</span> || !*s)) 
<a name="l02438"></a>02438                                         { 
<a name="l02439"></a>02439                                                 <span class="keywordflow">continue</span>; 
<a name="l02440"></a>02440                                         } 
<a name="l02441"></a>02441  
<a name="l02442"></a>02442                                         s = mark; 
<a name="l02443"></a>02443                                                          
<a name="l02444"></a>02444                                         <span class="keywordflow">if</span> (cursor-&gt;GetParent) 
<a name="l02445"></a>02445                                         { 
<a name="l02446"></a>02446                                                 PUSHNODE(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a>); <span class="comment">// Append a new node on the tree. </span>
<a name="l02447"></a>02447                                                 cursor-&gt;Value = s; <span class="comment">// Save the Offset. </span>
<a name="l02448"></a>02448  
<a name="l02449"></a>02449                                                 s = strconv_pcdata(s); 
<a name="l02450"></a>02450                                                                  
<a name="l02451"></a>02451                                                 POPNODE(); <span class="comment">// Pop since this is a standalone. </span>
<a name="l02452"></a>02452                                                  
<a name="l02453"></a>02453                                                 <span class="keywordflow">if</span> (!*s) <span class="keywordflow">break</span>; 
<a name="l02454"></a>02454                                         } 
<a name="l02455"></a>02455                                         <span class="keywordflow">else</span> 
<a name="l02456"></a>02456                                         { 
<a name="l02457"></a>02457                                                 SCANFOR(*s == <span class="charliteral">&#39;&lt;&#39;</span>); <span class="comment">// &#39;...&lt;&#39; </span>
<a name="l02458"></a>02458                                                 <span class="keywordflow">if</span> (!*s) <span class="keywordflow">break</span>; 
<a name="l02459"></a>02459                                                  
<a name="l02460"></a>02460                                                 ++s; 
<a name="l02461"></a>02461                                         } 
<a name="l02462"></a>02462  
<a name="l02463"></a>02463                                         <span class="comment">// We&#39;re after &#39;&lt;&#39; </span>
<a name="l02464"></a>02464                                         <span class="keywordflow">goto</span> LOC_TAG; 
<a name="l02465"></a>02465                                 } 
<a name="l02466"></a>02466                         } 
<a name="l02467"></a>02467  
<a name="l02468"></a>02468                         <span class="comment">// check that last tag is closed </span>
<a name="l02469"></a>02469                         <span class="keywordflow">if</span> (cursor != xmldoc) THROW_ERROR(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa6b8d817142e0898ad9b1c61cfa54b8ea" title="There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or th...">StatusEndElementMismatch</a>, s); 
<a name="l02470"></a>02470                 } 
<a name="l02471"></a>02471  
<a name="l02472"></a>02472                 <span class="keyword">static</span> <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> parse(char_t* buffer, <span class="keywordtype">size_t</span> length, <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* GetRoot, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> optmsk) 
<a name="l02473"></a>02473                 { 
<a name="l02474"></a>02474                         DocumentStruct* xmldoc = <span class="keyword">static_cast&lt;</span>DocumentStruct*<span class="keyword">&gt;</span>(GetRoot); 
<a name="l02475"></a>02475  
<a name="l02476"></a>02476                         <span class="comment">// store buffer for OffSetDebug </span>
<a name="l02477"></a>02477                         xmldoc-&gt;buffer = buffer; 
<a name="l02478"></a>02478  
<a name="l02479"></a>02479                         <span class="comment">// early-out for empty documents </span>
<a name="l02480"></a>02480                         <span class="keywordflow">if</span> (length == 0) <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa9ea9b3eecb4bb9f01745c94150982560" title="This is returned to indicated there where no issues parsing the XML document.">StatusOk</a>); 
<a name="l02481"></a>02481  
<a name="l02482"></a>02482                         <span class="comment">// create parser on stack </span>
<a name="l02483"></a>02483                         Parser parser(*xmldoc); 
<a name="l02484"></a>02484  
<a name="l02485"></a>02485                         <span class="comment">// Save last character and make buffer zero-terminated (speeds up parsing) </span>
<a name="l02486"></a>02486                         char_t endch = buffer[length - 1]; 
<a name="l02487"></a>02487                         buffer[length - 1] = 0; 
<a name="l02488"></a>02488                          
<a name="l02489"></a>02489                         <span class="comment">// perform actual parsing </span>
<a name="l02490"></a>02490                         <span class="keywordtype">int</span> error = setjmp(parser.error_handler); 
<a name="l02491"></a>02491  
<a name="l02492"></a>02492                         <span class="keywordflow">if</span> (error == 0) 
<a name="l02493"></a>02493                         { 
<a name="l02494"></a>02494                                 parser.parse(buffer, xmldoc, optmsk, endch); 
<a name="l02495"></a>02495                         } 
<a name="l02496"></a>02496  
<a name="l02497"></a>02497                         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> Result = make_ParseResult(static_cast&lt;ParseStatus&gt;(error), parser.error_Offset ? parser.error_Offset - buffer : 0); 
<a name="l02498"></a>02498                         assert(Result.<a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a30b2a5fa6ceae01ab30c6ff48273ce41" title="Last parsed offset (in char_t units from start of input data).">Offset</a> &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(Result.<a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a30b2a5fa6ceae01ab30c6ff48273ce41" title="Last parsed offset (in char_t units from start of input data).">Offset</a>) &lt;= length); 
<a name="l02499"></a>02499  
<a name="l02500"></a>02500                         <span class="comment">// update allocator state </span>
<a name="l02501"></a>02501                         *<span class="keyword">static_cast&lt;</span>Allocator*<span class="keyword">&gt;</span>(xmldoc) = parser.alloc; 
<a name="l02502"></a>02502  
<a name="l02503"></a>02503                         <span class="comment">// since we removed last character, we have to handle the only possible false positive </span>
<a name="l02504"></a>02504                         if (Result &amp;&amp; endch == <span class="charliteral">&#39;&lt;&#39;</span>) 
<a name="l02505"></a>02505                         { 
<a name="l02506"></a>02506                                 <span class="comment">// there&#39;s no possible well-formed document with &lt; at the end </span>
<a name="l02507"></a>02507                                 <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fabe0f4590debfa56c7e3a4c8da261b106" title="The parser could not determine type of tag.">StatusUnrecognizedTag</a>, length); 
<a name="l02508"></a>02508                         } 
<a name="l02509"></a>02509  
<a name="l02510"></a>02510                         <span class="keywordflow">return</span> Result; 
<a name="l02511"></a>02511                 } 
<a name="l02512"></a>02512         }; 
<a name="l02513"></a>02513  
<a name="l02514"></a>02514         <span class="comment">// Output facilities </span>
<a name="l02515"></a>02515         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> GetWrite_native_DocumentEncoding() 
<a name="l02516"></a>02516         { 
<a name="l02517"></a>02517 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l02518"></a>02518 <span class="preprocessor"></span>                <span class="keywordflow">return</span> GetWchar_DocumentEncoding(); 
<a name="l02519"></a>02519 <span class="preprocessor">        #else </span>
<a name="l02520"></a>02520 <span class="preprocessor"></span>                <span class="keywordflow">return</span> EncodingUTF8; 
<a name="l02521"></a>02521 <span class="preprocessor">        #endif </span>
<a name="l02522"></a>02522 <span class="preprocessor"></span>        } 
<a name="l02523"></a>02523  
<a name="l02524"></a>02524         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> GetWrite_DocumentEncoding(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l02525"></a>02525         { 
<a name="l02526"></a>02526                 <span class="comment">// replace wchar DocumentEncoding with utf implementation </span>
<a name="l02527"></a>02527                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2bc9c8d42796901c8feaa25e17c56cef" title="The same document encoding wchar_t has (usually either UTF16 or UTF32).">Encodingwchar_t</a>) <span class="keywordflow">return</span> GetWchar_DocumentEncoding(); 
<a name="l02528"></a>02528  
<a name="l02529"></a>02529                 <span class="comment">// replace utf16 DocumentEncoding with utf16 with specific endianness </span>
<a name="l02530"></a>02530                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015ac19070aaf7044426b0fe8fa5af956130" title="UTF16 with native endianness.">EncodingUTF16</a>) <span class="keywordflow">return</span> is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> : EncodingUTF16BE; 
<a name="l02531"></a>02531  
<a name="l02532"></a>02532                 <span class="comment">// replace utf32 DocumentEncoding with utf32 with specific endianness </span>
<a name="l02533"></a>02533                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015ac61c2f632bd66c2466c29783beb33f8a" title="UTF32 with native endianness.">EncodingUTF32</a>) <span class="keywordflow">return</span> is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> : EncodingUTF32BE; 
<a name="l02534"></a>02534  
<a name="l02535"></a>02535                 <span class="comment">// only do autodetection if no explicit DocumentEncoding is requested </span>
<a name="l02536"></a>02536                 <span class="keywordflow">if</span> (DocumentEncoding != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2792ef334e1061e7ad177df463256d85" title="Auto-detect input document encoding using Byte Order Mark (BOM) or &amp;lt; / &amp;lt;? detection; use UTF8 i...">EncodingAuto</a>) <span class="keywordflow">return</span> DocumentEncoding; 
<a name="l02537"></a>02537  
<a name="l02538"></a>02538                 <span class="comment">// assume utf8 DocumentEncoding </span>
<a name="l02539"></a>02539                 <span class="keywordflow">return</span> EncodingUTF8; 
<a name="l02540"></a>02540         } 
<a name="l02541"></a>02541  
<a name="l02542"></a>02542 <span class="preprocessor">#ifdef XML_WCHAR_MODE </span>
<a name="l02543"></a>02543 <span class="preprocessor"></span>        <span class="keywordtype">size_t</span> GetValid_length(<span class="keyword">const</span> char_t* data, <span class="keywordtype">size_t</span> length) 
<a name="l02544"></a>02544         { 
<a name="l02545"></a>02545                 assert(length &gt; 0); 
<a name="l02546"></a>02546  
<a name="l02547"></a>02547                 <span class="comment">// discard last character if it&#39;s the lead of a surrogate pair  </span>
<a name="l02548"></a>02548                 <span class="keywordflow">return</span> (<span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 2 &amp;&amp; (<span class="keywordtype">unsigned</span>)(static_cast&lt;uint16_t&gt;(data[length - 1]) - 0xD800) &lt; 0x400) ? length - 1 : length; 
<a name="l02549"></a>02549         } 
<a name="l02550"></a>02550  
<a name="l02551"></a>02551         <span class="keywordtype">size_t</span> convert_buffer(<span class="keywordtype">char</span>* Result, <span class="keyword">const</span> char_t* data, <span class="keywordtype">size_t</span> length, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l02552"></a>02552         { 
<a name="l02553"></a>02553                 <span class="comment">// only endian-swapping is required </span>
<a name="l02554"></a>02554                 <span class="keywordflow">if</span> (need_endian_swap_utf(DocumentEncoding, GetWchar_DocumentEncoding())) 
<a name="l02555"></a>02555                 { 
<a name="l02556"></a>02556                         convert_wchar_endian_swap(reinterpret_cast&lt;char_t*&gt;(Result), data, length); 
<a name="l02557"></a>02557  
<a name="l02558"></a>02558                         <span class="keywordflow">return</span> length * <span class="keyword">sizeof</span>(char_t); 
<a name="l02559"></a>02559                 } 
<a name="l02560"></a>02560          
<a name="l02561"></a>02561                 <span class="comment">// convert to utf8 </span>
<a name="l02562"></a>02562                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a7793b4cde174342c9450abbeab675743" title="UTF8 document encoding.">EncodingUTF8</a>) 
<a name="l02563"></a>02563                 { 
<a name="l02564"></a>02564                         uint8_t* dest = <span class="keyword">reinterpret_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(Result); 
<a name="l02565"></a>02565  
<a name="l02566"></a>02566                         uint8_t* end = <span class="keyword">sizeof</span>(wchar_t) == 2 ? 
<a name="l02567"></a>02567                                 utf_decoder&lt;utf8_WriterInstance&gt;::decode_utf16_block(reinterpret_cast&lt;const uint16_t*&gt;(data), length, dest) : 
<a name="l02568"></a>02568                                 utf_decoder&lt;utf8_WriterInstance&gt;::decode_utf32_block(reinterpret_cast&lt;const uint32_t*&gt;(data), length, dest); 
<a name="l02569"></a>02569  
<a name="l02570"></a>02570                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - dest); 
<a name="l02571"></a>02571                 } 
<a name="l02572"></a>02572  
<a name="l02573"></a>02573                 <span class="comment">// convert to utf16 </span>
<a name="l02574"></a>02574                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a04fd7b1fef8d2dcc67a46b8fe4dbcaf4" title="Big-endian UTF16.">EncodingUTF16BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a>) 
<a name="l02575"></a>02575                 { 
<a name="l02576"></a>02576                         uint16_t* dest = <span class="keyword">reinterpret_cast&lt;</span>uint16_t*<span class="keyword">&gt;</span>(Result); 
<a name="l02577"></a>02577  
<a name="l02578"></a>02578                         <span class="comment">// convert to native utf16 </span>
<a name="l02579"></a>02579                         uint16_t* end = utf_decoder&lt;utf16_WriterInstance&gt;::decode_utf32_block(reinterpret_cast&lt;const uint32_t*&gt;(data), length, dest); 
<a name="l02580"></a>02580  
<a name="l02581"></a>02581                         <span class="comment">// swap if necessary </span>
<a name="l02582"></a>02582                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> : EncodingUTF16BE; 
<a name="l02583"></a>02583  
<a name="l02584"></a>02584                         <span class="keywordflow">if</span> (native_DocumentEncoding != DocumentEncoding) convert_utf_endian_swap(dest, dest, static_cast&lt;size_t&gt;(end - dest)); 
<a name="l02585"></a>02585  
<a name="l02586"></a>02586                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - dest) * <span class="keyword">sizeof</span>(uint16_t); 
<a name="l02587"></a>02587                 } 
<a name="l02588"></a>02588  
<a name="l02589"></a>02589                 <span class="comment">// convert to utf32 </span>
<a name="l02590"></a>02590                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a5fb13deaf1552b0f4c00e2b8cafce0b9" title="Big-endian UTF32.">EncodingUTF32BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a>) 
<a name="l02591"></a>02591                 { 
<a name="l02592"></a>02592                         uint32_t* dest = <span class="keyword">reinterpret_cast&lt;</span>uint32_t*<span class="keyword">&gt;</span>(Result); 
<a name="l02593"></a>02593  
<a name="l02594"></a>02594                         <span class="comment">// convert to native utf32 </span>
<a name="l02595"></a>02595                         uint32_t* end = utf_decoder&lt;utf32_WriterInstance&gt;::decode_utf16_block(reinterpret_cast&lt;const uint16_t*&gt;(data), length, dest); 
<a name="l02596"></a>02596  
<a name="l02597"></a>02597                         <span class="comment">// swap if necessary </span>
<a name="l02598"></a>02598                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> : EncodingUTF32BE; 
<a name="l02599"></a>02599  
<a name="l02600"></a>02600                         <span class="keywordflow">if</span> (native_DocumentEncoding != DocumentEncoding) convert_utf_endian_swap(dest, dest, static_cast&lt;size_t&gt;(end - dest)); 
<a name="l02601"></a>02601  
<a name="l02602"></a>02602                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - dest) * <span class="keyword">sizeof</span>(uint32_t); 
<a name="l02603"></a>02603                 } 
<a name="l02604"></a>02604  
<a name="l02605"></a>02605                 assert(!<span class="stringliteral">&quot;Invalid DocumentEncoding&quot;</span>); 
<a name="l02606"></a>02606                 <span class="keywordflow">return</span> 0; 
<a name="l02607"></a>02607         } 
<a name="l02608"></a>02608 <span class="preprocessor">#else </span>
<a name="l02609"></a>02609 <span class="preprocessor"></span>        <span class="keywordtype">size_t</span> GetValid_length(<span class="keyword">const</span> char_t* data, <span class="keywordtype">size_t</span> length) 
<a name="l02610"></a>02610         { 
<a name="l02611"></a>02611                 assert(length &gt; 4); 
<a name="l02612"></a>02612  
<a name="l02613"></a>02613                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;= 4; ++i) 
<a name="l02614"></a>02614                 { 
<a name="l02615"></a>02615                         uint8_t ch = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(data[length - i]); 
<a name="l02616"></a>02616  
<a name="l02617"></a>02617                         <span class="comment">// either a standalone character or a leading one </span>
<a name="l02618"></a>02618                         <span class="keywordflow">if</span> ((ch &amp; 0xc0) != 0x80) <span class="keywordflow">return</span> length - i; 
<a name="l02619"></a>02619                 } 
<a name="l02620"></a>02620  
<a name="l02621"></a>02621                 <span class="comment">// there are four non-leading characters at the end, sequence tail is broken so might as well process the whole chunk </span>
<a name="l02622"></a>02622                 <span class="keywordflow">return</span> length; 
<a name="l02623"></a>02623         } 
<a name="l02624"></a>02624  
<a name="l02625"></a>02625         <span class="keywordtype">size_t</span> convert_buffer(<span class="keywordtype">char</span>* Result, <span class="keyword">const</span> char_t* data, <span class="keywordtype">size_t</span> length, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l02626"></a>02626         { 
<a name="l02627"></a>02627                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a04fd7b1fef8d2dcc67a46b8fe4dbcaf4" title="Big-endian UTF16.">EncodingUTF16BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a>) 
<a name="l02628"></a>02628                 { 
<a name="l02629"></a>02629                         uint16_t* dest = <span class="keyword">reinterpret_cast&lt;</span>uint16_t*<span class="keyword">&gt;</span>(Result); 
<a name="l02630"></a>02630  
<a name="l02631"></a>02631                         <span class="comment">// convert to native utf16 </span>
<a name="l02632"></a>02632                         uint16_t* end = utf_decoder&lt;utf16_WriterInstance&gt;::decode_utf8_block(reinterpret_cast&lt;const uint8_t*&gt;(data), length, dest); 
<a name="l02633"></a>02633  
<a name="l02634"></a>02634                         <span class="comment">// swap if necessary </span>
<a name="l02635"></a>02635                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a> : EncodingUTF16BE; 
<a name="l02636"></a>02636  
<a name="l02637"></a>02637                         <span class="keywordflow">if</span> (native_DocumentEncoding != DocumentEncoding) convert_utf_endian_swap(dest, dest, static_cast&lt;size_t&gt;(end - dest)); 
<a name="l02638"></a>02638  
<a name="l02639"></a>02639                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - dest) * <span class="keyword">sizeof</span>(uint16_t); 
<a name="l02640"></a>02640                 } 
<a name="l02641"></a>02641  
<a name="l02642"></a>02642                 <span class="keywordflow">if</span> (DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a5fb13deaf1552b0f4c00e2b8cafce0b9" title="Big-endian UTF32.">EncodingUTF32BE</a> || DocumentEncoding == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a>) 
<a name="l02643"></a>02643                 { 
<a name="l02644"></a>02644                         uint32_t* dest = <span class="keyword">reinterpret_cast&lt;</span>uint32_t*<span class="keyword">&gt;</span>(Result); 
<a name="l02645"></a>02645  
<a name="l02646"></a>02646                         <span class="comment">// convert to native utf32 </span>
<a name="l02647"></a>02647                         uint32_t* end = utf_decoder&lt;utf32_WriterInstance&gt;::decode_utf8_block(reinterpret_cast&lt;const uint8_t*&gt;(data), length, dest); 
<a name="l02648"></a>02648  
<a name="l02649"></a>02649                         <span class="comment">// swap if necessary </span>
<a name="l02650"></a>02650                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> native_DocumentEncoding = is_little_endian() ? <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a> : EncodingUTF32BE; 
<a name="l02651"></a>02651  
<a name="l02652"></a>02652                         <span class="keywordflow">if</span> (native_DocumentEncoding != DocumentEncoding) convert_utf_endian_swap(dest, dest, static_cast&lt;size_t&gt;(end - dest)); 
<a name="l02653"></a>02653  
<a name="l02654"></a>02654                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - dest) * <span class="keyword">sizeof</span>(uint32_t); 
<a name="l02655"></a>02655                 } 
<a name="l02656"></a>02656  
<a name="l02657"></a>02657                 assert(!<span class="stringliteral">&quot;Invalid DocumentEncoding&quot;</span>); 
<a name="l02658"></a>02658                 <span class="keywordflow">return</span> 0; 
<a name="l02659"></a>02659         } 
<a name="l02660"></a>02660 <span class="preprocessor">#endif </span>
<a name="l02661"></a>02661 <span class="preprocessor"></span> 
<a name="l02662"></a>02662         <span class="keyword">class </span>BufferedWriter 
<a name="l02663"></a>02663         { 
<a name="l02664"></a>02664                 BufferedWriter(<span class="keyword">const</span> BufferedWriter&amp;); 
<a name="l02665"></a>02665                 BufferedWriter&amp; operator=(<span class="keyword">const</span> BufferedWriter&amp;); 
<a name="l02666"></a>02666  
<a name="l02667"></a>02667         <span class="keyword">public</span>: 
<a name="l02668"></a>02668                 BufferedWriter(<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html" title="Interface for node printing (see Node::print).">Writer</a>&amp; WriterInstance, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> user_DocumentEncoding): WriterInstance(WriterInstance), bufsize(0), DocumentEncoding(GetWrite_DocumentEncoding(user_DocumentEncoding)) 
<a name="l02669"></a>02669                 { 
<a name="l02670"></a>02670                 } 
<a name="l02671"></a>02671  
<a name="l02672"></a>02672                 ~BufferedWriter() 
<a name="l02673"></a>02673                 { 
<a name="l02674"></a>02674                         flush(); 
<a name="l02675"></a>02675                 } 
<a name="l02676"></a>02676  
<a name="l02677"></a>02677                 <span class="keywordtype">void</span> flush() 
<a name="l02678"></a>02678                 { 
<a name="l02679"></a>02679                         flush(buffer, bufsize); 
<a name="l02680"></a>02680                         bufsize = 0; 
<a name="l02681"></a>02681                 } 
<a name="l02682"></a>02682  
<a name="l02683"></a>02683                 <span class="keywordtype">void</span> flush(<span class="keyword">const</span> char_t* data, <span class="keywordtype">size_t</span> size) 
<a name="l02684"></a>02684                 { 
<a name="l02685"></a>02685                         <span class="keywordflow">if</span> (size == 0) <span class="keywordflow">return</span>; 
<a name="l02686"></a>02686  
<a name="l02687"></a>02687                         <span class="comment">// fast Path, just Write data </span>
<a name="l02688"></a>02688                         <span class="keywordflow">if</span> (DocumentEncoding == GetWrite_native_DocumentEncoding()) 
<a name="l02689"></a>02689                                 WriterInstance.Write(data, size * <span class="keyword">sizeof</span>(char_t)); 
<a name="l02690"></a>02690                         <span class="keywordflow">else</span> 
<a name="l02691"></a>02691                         { 
<a name="l02692"></a>02692                                 <span class="comment">// convert chunk </span>
<a name="l02693"></a>02693                                 <span class="keywordtype">size_t</span> Result = convert_buffer(scratch, data, size, DocumentEncoding); 
<a name="l02694"></a>02694                                 assert(Result &lt;= <span class="keyword">sizeof</span>(scratch)); 
<a name="l02695"></a>02695  
<a name="l02696"></a>02696                                 <span class="comment">// Write data </span>
<a name="l02697"></a>02697                                 WriterInstance.Write(scratch, Result); 
<a name="l02698"></a>02698                         } 
<a name="l02699"></a>02699                 } 
<a name="l02700"></a>02700  
<a name="l02701"></a>02701                 <span class="keywordtype">void</span> Write(<span class="keyword">const</span> char_t* data, <span class="keywordtype">size_t</span> length) 
<a name="l02702"></a>02702                 { 
<a name="l02703"></a>02703                         <span class="keywordflow">if</span> (bufsize + length &gt; bufcapacity) 
<a name="l02704"></a>02704                         { 
<a name="l02705"></a>02705                                 <span class="comment">// flush the remaining buffer contents </span>
<a name="l02706"></a>02706                                 flush(); 
<a name="l02707"></a>02707  
<a name="l02708"></a>02708                                 <span class="comment">// handle large chunks </span>
<a name="l02709"></a>02709                                 <span class="keywordflow">if</span> (length &gt; bufcapacity) 
<a name="l02710"></a>02710                                 { 
<a name="l02711"></a>02711                                         <span class="keywordflow">if</span> (DocumentEncoding == GetWrite_native_DocumentEncoding()) 
<a name="l02712"></a>02712                                         { 
<a name="l02713"></a>02713                                                 <span class="comment">// fast Path, can just Write data chunk </span>
<a name="l02714"></a>02714                                                 WriterInstance.Write(data, length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l02715"></a>02715                                                 <span class="keywordflow">return</span>; 
<a name="l02716"></a>02716                                         } 
<a name="l02717"></a>02717  
<a name="l02718"></a>02718                                         <span class="comment">// need to convert in suitable chunks </span>
<a name="l02719"></a>02719                                         <span class="keywordflow">while</span> (length &gt; bufcapacity) 
<a name="l02720"></a>02720                                         { 
<a name="l02721"></a>02721                                                 <span class="comment">// get chunk size by selecting such number of characters that are guaranteed to fit into scratch buffer </span>
<a name="l02722"></a>02722                                                 <span class="comment">// and form a complete codepoint sequence (i.e. discard start of last codepoint if necessary) </span>
<a name="l02723"></a>02723                                                 <span class="keywordtype">size_t</span> chunk_size = GetValid_length(data, bufcapacity); 
<a name="l02724"></a>02724  
<a name="l02725"></a>02725                                                 <span class="comment">// convert chunk and Write </span>
<a name="l02726"></a>02726                                                 flush(data, chunk_size); 
<a name="l02727"></a>02727  
<a name="l02728"></a>02728                                                 <span class="comment">// iterate </span>
<a name="l02729"></a>02729                                                 data += chunk_size; 
<a name="l02730"></a>02730                                                 length -= chunk_size; 
<a name="l02731"></a>02731                                         } 
<a name="l02732"></a>02732  
<a name="l02733"></a>02733                                         <span class="comment">// small tail is copied below </span>
<a name="l02734"></a>02734                                         bufsize = 0; 
<a name="l02735"></a>02735                                 } 
<a name="l02736"></a>02736                         } 
<a name="l02737"></a>02737  
<a name="l02738"></a>02738                         memcpy(buffer + bufsize, data, length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l02739"></a>02739                         bufsize += length; 
<a name="l02740"></a>02740                 } 
<a name="l02741"></a>02741  
<a name="l02742"></a>02742                 <span class="keywordtype">void</span> Write(<span class="keyword">const</span> char_t* data) 
<a name="l02743"></a>02743                 { 
<a name="l02744"></a>02744                         Write(data, strlength(data)); 
<a name="l02745"></a>02745                 } 
<a name="l02746"></a>02746  
<a name="l02747"></a>02747                 <span class="keywordtype">void</span> Write(char_t d0) 
<a name="l02748"></a>02748                 { 
<a name="l02749"></a>02749                         <span class="keywordflow">if</span> (bufsize + 1 &gt; bufcapacity) flush(); 
<a name="l02750"></a>02750  
<a name="l02751"></a>02751                         buffer[bufsize + 0] = d0; 
<a name="l02752"></a>02752                         bufsize += 1; 
<a name="l02753"></a>02753                 } 
<a name="l02754"></a>02754  
<a name="l02755"></a>02755                 <span class="keywordtype">void</span> Write(char_t d0, char_t d1) 
<a name="l02756"></a>02756                 { 
<a name="l02757"></a>02757                         <span class="keywordflow">if</span> (bufsize + 2 &gt; bufcapacity) flush(); 
<a name="l02758"></a>02758  
<a name="l02759"></a>02759                         buffer[bufsize + 0] = d0; 
<a name="l02760"></a>02760                         buffer[bufsize + 1] = d1; 
<a name="l02761"></a>02761                         bufsize += 2; 
<a name="l02762"></a>02762                 } 
<a name="l02763"></a>02763  
<a name="l02764"></a>02764                 <span class="keywordtype">void</span> Write(char_t d0, char_t d1, char_t d2) 
<a name="l02765"></a>02765                 { 
<a name="l02766"></a>02766                         <span class="keywordflow">if</span> (bufsize + 3 &gt; bufcapacity) flush(); 
<a name="l02767"></a>02767  
<a name="l02768"></a>02768                         buffer[bufsize + 0] = d0; 
<a name="l02769"></a>02769                         buffer[bufsize + 1] = d1; 
<a name="l02770"></a>02770                         buffer[bufsize + 2] = d2; 
<a name="l02771"></a>02771                         bufsize += 3; 
<a name="l02772"></a>02772                 } 
<a name="l02773"></a>02773  
<a name="l02774"></a>02774                 <span class="keywordtype">void</span> Write(char_t d0, char_t d1, char_t d2, char_t d3) 
<a name="l02775"></a>02775                 { 
<a name="l02776"></a>02776                         <span class="keywordflow">if</span> (bufsize + 4 &gt; bufcapacity) flush(); 
<a name="l02777"></a>02777  
<a name="l02778"></a>02778                         buffer[bufsize + 0] = d0; 
<a name="l02779"></a>02779                         buffer[bufsize + 1] = d1; 
<a name="l02780"></a>02780                         buffer[bufsize + 2] = d2; 
<a name="l02781"></a>02781                         buffer[bufsize + 3] = d3; 
<a name="l02782"></a>02782                         bufsize += 4; 
<a name="l02783"></a>02783                 } 
<a name="l02784"></a>02784  
<a name="l02785"></a>02785                 <span class="keywordtype">void</span> Write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4) 
<a name="l02786"></a>02786                 { 
<a name="l02787"></a>02787                         <span class="keywordflow">if</span> (bufsize + 5 &gt; bufcapacity) flush(); 
<a name="l02788"></a>02788  
<a name="l02789"></a>02789                         buffer[bufsize + 0] = d0; 
<a name="l02790"></a>02790                         buffer[bufsize + 1] = d1; 
<a name="l02791"></a>02791                         buffer[bufsize + 2] = d2; 
<a name="l02792"></a>02792                         buffer[bufsize + 3] = d3; 
<a name="l02793"></a>02793                         buffer[bufsize + 4] = d4; 
<a name="l02794"></a>02794                         bufsize += 5; 
<a name="l02795"></a>02795                 } 
<a name="l02796"></a>02796  
<a name="l02797"></a>02797                 <span class="keywordtype">void</span> Write(char_t d0, char_t d1, char_t d2, char_t d3, char_t d4, char_t d5) 
<a name="l02798"></a>02798                 { 
<a name="l02799"></a>02799                         <span class="keywordflow">if</span> (bufsize + 6 &gt; bufcapacity) flush(); 
<a name="l02800"></a>02800  
<a name="l02801"></a>02801                         buffer[bufsize + 0] = d0; 
<a name="l02802"></a>02802                         buffer[bufsize + 1] = d1; 
<a name="l02803"></a>02803                         buffer[bufsize + 2] = d2; 
<a name="l02804"></a>02804                         buffer[bufsize + 3] = d3; 
<a name="l02805"></a>02805                         buffer[bufsize + 4] = d4; 
<a name="l02806"></a>02806                         buffer[bufsize + 5] = d5; 
<a name="l02807"></a>02807                         bufsize += 6; 
<a name="l02808"></a>02808                 } 
<a name="l02809"></a>02809  
<a name="l02810"></a>02810                 <span class="comment">// utf8 maximum expansion: x4 (-&gt; utf32) </span>
<a name="l02811"></a>02811                 <span class="comment">// utf16 maximum expansion: x2 (-&gt; utf32) </span>
<a name="l02812"></a>02812                 <span class="comment">// utf32 maximum expansion: x1 </span>
<a name="l02813"></a>02813                 <span class="keyword">enum</span> { bufcapacity = 2048 }; 
<a name="l02814"></a>02814  
<a name="l02815"></a>02815                 char_t buffer[bufcapacity]; 
<a name="l02816"></a>02816                 <span class="keywordtype">char</span> scratch[4 * bufcapacity]; 
<a name="l02817"></a>02817  
<a name="l02818"></a>02818                 <a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html" title="Interface for node printing (see Node::print).">Writer</a>&amp; WriterInstance; 
<a name="l02819"></a>02819                 <span class="keywordtype">size_t</span> bufsize; 
<a name="l02820"></a>02820                 <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding; 
<a name="l02821"></a>02821         }; 
<a name="l02822"></a>02822  
<a name="l02823"></a>02823         <span class="keywordtype">void</span> Write_bom(<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html" title="Interface for node printing (see Node::print).">Writer</a>&amp; WriterInstance, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l02824"></a>02824         { 
<a name="l02825"></a>02825                 <span class="keywordflow">switch</span> (DocumentEncoding) 
<a name="l02826"></a>02826                 { 
<a name="l02827"></a>02827                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a7793b4cde174342c9450abbeab675743" title="UTF8 document encoding.">EncodingUTF8</a>: 
<a name="l02828"></a>02828                         WriterInstance.<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html#ab6d4758ab53743f236eb64d5b2dd7e9e" title="This will be used to output xml to an external source such as a file or stream.">Write</a>(<span class="stringliteral">&quot;\xef\xbb\xbf&quot;</span>, 3); 
<a name="l02829"></a>02829                         <span class="keywordflow">break</span>; 
<a name="l02830"></a>02830  
<a name="l02831"></a>02831                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a04fd7b1fef8d2dcc67a46b8fe4dbcaf4" title="Big-endian UTF16.">EncodingUTF16BE</a>: 
<a name="l02832"></a>02832                         WriterInstance.<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html#ab6d4758ab53743f236eb64d5b2dd7e9e" title="This will be used to output xml to an external source such as a file or stream.">Write</a>(<span class="stringliteral">&quot;\xfe\xff&quot;</span>, 2); 
<a name="l02833"></a>02833                         <span class="keywordflow">break</span>; 
<a name="l02834"></a>02834  
<a name="l02835"></a>02835                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015aa5e6a756e80683f376d1ef0a03b21d56" title="Little-endian UTF16.">EncodingUTF16LE</a>: 
<a name="l02836"></a>02836                         WriterInstance.<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html#ab6d4758ab53743f236eb64d5b2dd7e9e" title="This will be used to output xml to an external source such as a file or stream.">Write</a>(<span class="stringliteral">&quot;\xff\xfe&quot;</span>, 2); 
<a name="l02837"></a>02837                         <span class="keywordflow">break</span>; 
<a name="l02838"></a>02838  
<a name="l02839"></a>02839                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a5fb13deaf1552b0f4c00e2b8cafce0b9" title="Big-endian UTF32.">EncodingUTF32BE</a>: 
<a name="l02840"></a>02840                         WriterInstance.<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html#ab6d4758ab53743f236eb64d5b2dd7e9e" title="This will be used to output xml to an external source such as a file or stream.">Write</a>(<span class="stringliteral">&quot;\x00\x00\xfe\xff&quot;</span>, 4); 
<a name="l02841"></a>02841                         <span class="keywordflow">break</span>; 
<a name="l02842"></a>02842  
<a name="l02843"></a>02843                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a127752883aaf8c9bdb5f66ec725211fc" title="Little-endian UTF32.">EncodingUTF32LE</a>: 
<a name="l02844"></a>02844                         WriterInstance.<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html#ab6d4758ab53743f236eb64d5b2dd7e9e" title="This will be used to output xml to an external source such as a file or stream.">Write</a>(<span class="stringliteral">&quot;\xff\xfe\x00\x00&quot;</span>, 4); 
<a name="l02845"></a>02845                         <span class="keywordflow">break</span>; 
<a name="l02846"></a>02846  
<a name="l02847"></a>02847                 <span class="keywordflow">default</span>: 
<a name="l02848"></a>02848                         assert(!<span class="stringliteral">&quot;Invalid DocumentEncoding&quot;</span>); 
<a name="l02849"></a>02849                 } 
<a name="l02850"></a>02850         } 
<a name="l02851"></a>02851  
<a name="l02852"></a>02852         <span class="keywordtype">void</span> text_output_escaped(BufferedWriter&amp; WriterInstance, <span class="keyword">const</span> char_t* s, charTypex_t Type) 
<a name="l02853"></a>02853         { 
<a name="l02854"></a>02854                 <span class="keywordflow">while</span> (*s) 
<a name="l02855"></a>02855                 { 
<a name="l02856"></a>02856                         <span class="keyword">const</span> char_t* prev = s; 
<a name="l02857"></a>02857                          
<a name="l02858"></a>02858                         <span class="comment">// While *s is a usual symbol </span>
<a name="l02859"></a>02859                         <span class="keywordflow">while</span> (!IS_CHARTYPEX(*s, Type)) ++s; 
<a name="l02860"></a>02860                  
<a name="l02861"></a>02861                         WriterInstance.Write(prev, static_cast&lt;size_t&gt;(s - prev)); 
<a name="l02862"></a>02862  
<a name="l02863"></a>02863                         <span class="keywordflow">switch</span> (*s) 
<a name="l02864"></a>02864                         { 
<a name="l02865"></a>02865                                 <span class="keywordflow">case</span> 0: <span class="keywordflow">break</span>; 
<a name="l02866"></a>02866                                 <span class="keywordflow">case</span> <span class="charliteral">&#39;&amp;&#39;</span>: 
<a name="l02867"></a>02867                                         WriterInstance.Write(<span class="charliteral">&#39;&amp;&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="charliteral">&#39;;&#39;</span>); 
<a name="l02868"></a>02868                                         ++s; 
<a name="l02869"></a>02869                                         <span class="keywordflow">break</span>; 
<a name="l02870"></a>02870                                 <span class="keywordflow">case</span> <span class="charliteral">&#39;&lt;&#39;</span>: 
<a name="l02871"></a>02871                                         WriterInstance.Write(<span class="charliteral">&#39;&amp;&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;;&#39;</span>); 
<a name="l02872"></a>02872                                         ++s; 
<a name="l02873"></a>02873                                         <span class="keywordflow">break</span>; 
<a name="l02874"></a>02874                                 <span class="keywordflow">case</span> <span class="charliteral">&#39;&gt;&#39;</span>: 
<a name="l02875"></a>02875                                         WriterInstance.Write(<span class="charliteral">&#39;&amp;&#39;</span>, <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;;&#39;</span>); 
<a name="l02876"></a>02876                                         ++s; 
<a name="l02877"></a>02877                                         <span class="keywordflow">break</span>; 
<a name="l02878"></a>02878                                 <span class="keywordflow">case</span> <span class="charliteral">&#39;&quot;&#39;</span>: 
<a name="l02879"></a>02879                                         WriterInstance.Write(<span class="charliteral">&#39;&amp;&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;;&#39;</span>); 
<a name="l02880"></a>02880                                         ++s; 
<a name="l02881"></a>02881                                         <span class="keywordflow">break</span>; 
<a name="l02882"></a>02882                                 <span class="keywordflow">default</span>: <span class="comment">// s is not a usual symbol </span>
<a name="l02883"></a>02883                                 { 
<a name="l02884"></a>02884                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ch = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(*s++); 
<a name="l02885"></a>02885                                         assert(ch &lt; 32); 
<a name="l02886"></a>02886  
<a name="l02887"></a>02887                                         WriterInstance.Write(<span class="charliteral">&#39;&amp;&#39;</span>, <span class="charliteral">&#39;#&#39;</span>, static_cast&lt;char_t&gt;((ch / 10) + <span class="charliteral">&#39;0&#39;</span>), static_cast&lt;char_t&gt;((ch % 10) + <span class="charliteral">&#39;0&#39;</span>), <span class="charliteral">&#39;;&#39;</span>); 
<a name="l02888"></a>02888                                 } 
<a name="l02889"></a>02889                         } 
<a name="l02890"></a>02890                 } 
<a name="l02891"></a>02891         } 
<a name="l02892"></a>02892  
<a name="l02893"></a>02893         <span class="keywordtype">void</span> text_output_cdata(BufferedWriter&amp; WriterInstance, <span class="keyword">const</span> char_t* s) 
<a name="l02894"></a>02894         { 
<a name="l02895"></a>02895                 <span class="keywordflow">do</span> 
<a name="l02896"></a>02896                 { 
<a name="l02897"></a>02897                         WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;!&#39;</span>, <span class="charliteral">&#39;[&#39;</span>, <span class="charliteral">&#39;C&#39;</span>, <span class="charliteral">&#39;D&#39;</span>); 
<a name="l02898"></a>02898                         WriterInstance.Write(<span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;T&#39;</span>, <span class="charliteral">&#39;A&#39;</span>, <span class="charliteral">&#39;[&#39;</span>); 
<a name="l02899"></a>02899  
<a name="l02900"></a>02900                         <span class="keyword">const</span> char_t* prev = s; 
<a name="l02901"></a>02901  
<a name="l02902"></a>02902                         <span class="comment">// look for ]]&gt; sequence - we can&#39;t output it as is since it terminates CDATA </span>
<a name="l02903"></a>02903                         <span class="keywordflow">while</span> (*s &amp;&amp; !(s[0] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; s[1] == <span class="charliteral">&#39;]&#39;</span> &amp;&amp; s[2] == <span class="charliteral">&#39;&gt;&#39;</span>)) ++s; 
<a name="l02904"></a>02904  
<a name="l02905"></a>02905                         <span class="comment">// skip ]] if we stopped at ]]&gt;, &gt; will go to the next CDATA section </span>
<a name="l02906"></a>02906                         <span class="keywordflow">if</span> (*s) s += 2; 
<a name="l02907"></a>02907  
<a name="l02908"></a>02908                         WriterInstance.Write(prev, static_cast&lt;size_t&gt;(s - prev)); 
<a name="l02909"></a>02909  
<a name="l02910"></a>02910                         WriterInstance.Write(<span class="charliteral">&#39;]&#39;</span>, <span class="charliteral">&#39;]&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02911"></a>02911                 } 
<a name="l02912"></a>02912                 <span class="keywordflow">while</span> (*s); 
<a name="l02913"></a>02913         } 
<a name="l02914"></a>02914  
<a name="l02915"></a>02915         <span class="keywordtype">void</span> NodeOutput_attributes(BufferedWriter&amp; WriterInstance, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l02916"></a>02916         { 
<a name="l02917"></a>02917                 <span class="keyword">const</span> char_t* default_Name = <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;:anonymous&quot;</span>); 
<a name="l02918"></a>02918  
<a name="l02919"></a>02919                 <span class="keywordflow">for</span> (<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae484caac4f1fb2a4b7767ddfed28bf0c" title="Get the First Attribute in this Node.">GetFirstAttribute</a>(); a; a = a.GetNextAttribute()) 
<a name="l02920"></a>02920                 { 
<a name="l02921"></a>02921                         WriterInstance.Write(<span class="charliteral">&#39; &#39;</span>); 
<a name="l02922"></a>02922                         WriterInstance.Write(a.Name()[0] ? a.Name() : default_Name); 
<a name="l02923"></a>02923                         WriterInstance.Write(<span class="charliteral">&#39;=&#39;</span>, <span class="charliteral">&#39;&quot;&#39;</span>); 
<a name="l02924"></a>02924  
<a name="l02925"></a>02925                         text_output_escaped(WriterInstance, a.Value(), ctx_special_attr); 
<a name="l02926"></a>02926  
<a name="l02927"></a>02927                         WriterInstance.Write(<span class="charliteral">&#39;&quot;&#39;</span>); 
<a name="l02928"></a>02928                 } 
<a name="l02929"></a>02929         } 
<a name="l02930"></a>02930  
<a name="l02931"></a>02931         <span class="keywordtype">void</span> NodeOutput(BufferedWriter&amp; WriterInstance, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Depth) 
<a name="l02932"></a>02932         { 
<a name="l02933"></a>02933                 <span class="keyword">const</span> char_t* default_Name = <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;:anonymous&quot;</span>); 
<a name="l02934"></a>02934  
<a name="l02935"></a>02935                 <span class="keywordflow">if</span> ((flags &amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#afaad0b8f59b5f103218ed5cb39b1bbde" title="Indent the nodes that are written to output stream with as many indentation strings as deep the node ...">FormatIndent</a>) != 0 &amp;&amp; (flags &amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a6f6696cbdc48011817adad7978e83976" title="Use raw output mode (no indentation and no line breaks are written). This flag is off by default...">FormatRaw</a>) == 0) 
<a name="l02936"></a>02936                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; Depth; ++i) WriterInstance.Write(indent); 
<a name="l02937"></a>02937  
<a name="l02938"></a>02938                 <span class="keywordflow">switch</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()) 
<a name="l02939"></a>02939                 { 
<a name="l02940"></a>02940                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3acfe92e6bd275972917b95f08bd46e09f" title="A document tree&amp;#39;s absolute root.">NodeDocument</a>: 
<a name="l02941"></a>02941                 { 
<a name="l02942"></a>02942                         <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); n; n = n.GetNextSibling()) 
<a name="l02943"></a>02943                                 NodeOutput(WriterInstance, n, indent, flags, Depth); 
<a name="l02944"></a>02944                         <span class="keywordflow">break</span>; 
<a name="l02945"></a>02945                 } 
<a name="l02946"></a>02946                          
<a name="l02947"></a>02947                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>: 
<a name="l02948"></a>02948                 { 
<a name="l02949"></a>02949                         <span class="keyword">const</span> char_t* Name = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>()[0] ? node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>() : default_Name; 
<a name="l02950"></a>02950  
<a name="l02951"></a>02951                         WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>); 
<a name="l02952"></a>02952                         WriterInstance.Write(Name); 
<a name="l02953"></a>02953  
<a name="l02954"></a>02954                         NodeOutput_attributes(WriterInstance, node); 
<a name="l02955"></a>02955  
<a name="l02956"></a>02956                         <span class="keywordflow">if</span> (flags &amp; FormatRaw) 
<a name="l02957"></a>02957                         { 
<a name="l02958"></a>02958                                 <span class="keywordflow">if</span> (!node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>()) 
<a name="l02959"></a>02959                                         WriterInstance.Write(<span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;/&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02960"></a>02960                                 <span class="keywordflow">else</span> 
<a name="l02961"></a>02961                                 { 
<a name="l02962"></a>02962                                         WriterInstance.Write(<span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02963"></a>02963  
<a name="l02964"></a>02964                                         <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); n; n = n.GetNextSibling()) 
<a name="l02965"></a>02965                                                 NodeOutput(WriterInstance, n, indent, flags, Depth + 1); 
<a name="l02966"></a>02966  
<a name="l02967"></a>02967                                         WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;/&#39;</span>); 
<a name="l02968"></a>02968                                         WriterInstance.Write(Name); 
<a name="l02969"></a>02969                                         WriterInstance.Write(<span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02970"></a>02970                                 } 
<a name="l02971"></a>02971                         } 
<a name="l02972"></a>02972                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>()) 
<a name="l02973"></a>02973                                 WriterInstance.Write(<span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;/&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>); 
<a name="l02974"></a>02974                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>() == node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a10f1a568c8c2c691126f1a9ed2afb922" title="Get the last child Node of this Node.">GetLastChild</a>() &amp;&amp; (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>().<a class="code" href="../../d0/ddc/classphys_1_1Node.html#a25ef0ab80e0dc257ecc3d3ce38f3236d" title="Enum value storing the type of node this class is.">Type</a>() == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a> || node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>().<a class="code" href="../../d0/ddc/classphys_1_1Node.html#a25ef0ab80e0dc257ecc3d3ce38f3236d" title="Enum value storing the type of node this class is.">Type</a>() == NodeCdata)) 
<a name="l02975"></a>02975                         { 
<a name="l02976"></a>02976                                 WriterInstance.Write(<span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l02977"></a>02977  
<a name="l02978"></a>02978                                 <span class="keywordflow">if</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>().<a class="code" href="../../d0/ddc/classphys_1_1Node.html#a25ef0ab80e0dc257ecc3d3ce38f3236d" title="Enum value storing the type of node this class is.">Type</a>() == NodePcdata) 
<a name="l02979"></a>02979                                         text_output_escaped(WriterInstance, node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>().Value(), ctx_special_pcdata); 
<a name="l02980"></a>02980                                 <span class="keywordflow">else</span> 
<a name="l02981"></a>02981                                         text_output_cdata(WriterInstance, node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>().Value()); 
<a name="l02982"></a>02982  
<a name="l02983"></a>02983                                 WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;/&#39;</span>); 
<a name="l02984"></a>02984                                 WriterInstance.Write(Name); 
<a name="l02985"></a>02985                                 WriterInstance.Write(<span class="charliteral">&#39;&gt;&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>); 
<a name="l02986"></a>02986                         } 
<a name="l02987"></a>02987                         <span class="keywordflow">else</span> 
<a name="l02988"></a>02988                         { 
<a name="l02989"></a>02989                                 WriterInstance.Write(<span class="charliteral">&#39;&gt;&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>); 
<a name="l02990"></a>02990                                  
<a name="l02991"></a>02991                                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); n; n = n.GetNextSibling()) 
<a name="l02992"></a>02992                                         NodeOutput(WriterInstance, n, indent, flags, Depth + 1); 
<a name="l02993"></a>02993  
<a name="l02994"></a>02994                                 <span class="keywordflow">if</span> ((flags &amp; FormatIndent) != 0 &amp;&amp; (flags &amp; FormatRaw) == 0) 
<a name="l02995"></a>02995                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; Depth; ++i) WriterInstance.Write(indent); 
<a name="l02996"></a>02996                                  
<a name="l02997"></a>02997                                 WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;/&#39;</span>); 
<a name="l02998"></a>02998                                 WriterInstance.Write(Name); 
<a name="l02999"></a>02999                                 WriterInstance.Write(<span class="charliteral">&#39;&gt;&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>); 
<a name="l03000"></a>03000                         } 
<a name="l03001"></a>03001  
<a name="l03002"></a>03002                         <span class="keywordflow">break</span>; 
<a name="l03003"></a>03003                 } 
<a name="l03004"></a>03004                  
<a name="l03005"></a>03005                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a>: 
<a name="l03006"></a>03006                         text_output_escaped(WriterInstance, node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>(), ctx_special_pcdata); 
<a name="l03007"></a>03007                         <span class="keywordflow">if</span> ((flags &amp; FormatRaw) == 0) WriterInstance.Write(<span class="charliteral">&#39;\n&#39;</span>); 
<a name="l03008"></a>03008                         <span class="keywordflow">break</span>; 
<a name="l03009"></a>03009  
<a name="l03010"></a>03010                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a353968e806a751a6da4f7ac115b4ab55" title="Character data, i.e. &amp;#39;&amp;lt;![CDATA[text]]&amp;gt;&amp;#39;.">NodeCdata</a>: 
<a name="l03011"></a>03011                         text_output_cdata(WriterInstance, node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()); 
<a name="l03012"></a>03012                         <span class="keywordflow">if</span> ((flags &amp; FormatRaw) == 0) WriterInstance.Write(<span class="charliteral">&#39;\n&#39;</span>); 
<a name="l03013"></a>03013                         <span class="keywordflow">break</span>; 
<a name="l03014"></a>03014  
<a name="l03015"></a>03015                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a25b778cb61ae0a9f15590cad5e0120d2" title="Comment tag, i.e. &amp;#39;&amp;#39;.">NodeComment</a>: 
<a name="l03016"></a>03016                         WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;!&#39;</span>, <span class="charliteral">&#39;-&#39;</span>, <span class="charliteral">&#39;-&#39;</span>); 
<a name="l03017"></a>03017                         WriterInstance.Write(node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()); 
<a name="l03018"></a>03018                         WriterInstance.Write(<span class="charliteral">&#39;-&#39;</span>, <span class="charliteral">&#39;-&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l03019"></a>03019                         <span class="keywordflow">if</span> ((flags &amp; FormatRaw) == 0) WriterInstance.Write(<span class="charliteral">&#39;\n&#39;</span>); 
<a name="l03020"></a>03020                         <span class="keywordflow">break</span>; 
<a name="l03021"></a>03021  
<a name="l03022"></a>03022                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a>: 
<a name="l03023"></a>03023                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>: 
<a name="l03024"></a>03024                         WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;?&#39;</span>); 
<a name="l03025"></a>03025                         WriterInstance.Write(node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>()[0] ? node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>() : default_Name); 
<a name="l03026"></a>03026  
<a name="l03027"></a>03027                         <span class="keywordflow">if</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == NodeDeclaration) 
<a name="l03028"></a>03028                         { 
<a name="l03029"></a>03029                                 NodeOutput_attributes(WriterInstance, node); 
<a name="l03030"></a>03030                         } 
<a name="l03031"></a>03031                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()[0]) 
<a name="l03032"></a>03032                         { 
<a name="l03033"></a>03033                                 WriterInstance.Write(<span class="charliteral">&#39; &#39;</span>); 
<a name="l03034"></a>03034                                 WriterInstance.Write(node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()); 
<a name="l03035"></a>03035                         } 
<a name="l03036"></a>03036  
<a name="l03037"></a>03037                         WriterInstance.Write(<span class="charliteral">&#39;?&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l03038"></a>03038                         <span class="keywordflow">if</span> ((flags &amp; FormatRaw) == 0) WriterInstance.Write(<span class="charliteral">&#39;\n&#39;</span>); 
<a name="l03039"></a>03039                         <span class="keywordflow">break</span>; 
<a name="l03040"></a>03040  
<a name="l03041"></a>03041                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3aca750034b7e4a34d53cfd3399b2bcd99" title="Document type declaration, i.e. &amp;#39;&amp;lt;!DOCTYPE doc&amp;gt;&amp;#39;.">NodeDocType</a>: 
<a name="l03042"></a>03042                         WriterInstance.Write(<span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;!&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;O&#39;</span>, <span class="charliteral">&#39;C&#39;</span>); 
<a name="l03043"></a>03043                         WriterInstance.Write(<span class="charliteral">&#39;T&#39;</span>, <span class="charliteral">&#39;Y&#39;</span>, <span class="charliteral">&#39;P&#39;</span>, <span class="charliteral">&#39;E&#39;</span>); 
<a name="l03044"></a>03044  
<a name="l03045"></a>03045                         <span class="keywordflow">if</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()[0]) 
<a name="l03046"></a>03046                         { 
<a name="l03047"></a>03047                                 WriterInstance.Write(<span class="charliteral">&#39; &#39;</span>); 
<a name="l03048"></a>03048                                 WriterInstance.Write(node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()); 
<a name="l03049"></a>03049                         } 
<a name="l03050"></a>03050  
<a name="l03051"></a>03051                         WriterInstance.Write(<span class="charliteral">&#39;&gt;&#39;</span>); 
<a name="l03052"></a>03052                         <span class="keywordflow">if</span> ((flags &amp; FormatRaw) == 0) WriterInstance.Write(<span class="charliteral">&#39;\n&#39;</span>); 
<a name="l03053"></a>03053                         <span class="keywordflow">break</span>; 
<a name="l03054"></a>03054  
<a name="l03055"></a>03055                 <span class="keywordflow">default</span>: 
<a name="l03056"></a>03056                         assert(!<span class="stringliteral">&quot;Invalid node Type&quot;</span>); 
<a name="l03057"></a>03057                 } 
<a name="l03058"></a>03058         } 
<a name="l03059"></a>03059  
<a name="l03060"></a>03060         <span class="keyword">inline</span> <span class="keywordtype">bool</span> hAsDeclaration(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l03061"></a>03061         { 
<a name="l03062"></a>03062                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> GetChild = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); GetChild; GetChild = GetChild.GetNextSibling()) 
<a name="l03063"></a>03063                 { 
<a name="l03064"></a>03064                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type = GetChild.Type(); 
<a name="l03065"></a>03065  
<a name="l03066"></a>03066                         <span class="keywordflow">if</span> (Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l03067"></a>03067                         <span class="keywordflow">if</span> (Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03068"></a>03068                 } 
<a name="l03069"></a>03069  
<a name="l03070"></a>03070                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03071"></a>03071         } 
<a name="l03072"></a>03072  
<a name="l03073"></a>03073         <span class="keyword">inline</span> <span class="keywordtype">bool</span> allow_InsertChild(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> GetParent, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> GetChild) 
<a name="l03074"></a>03074         { 
<a name="l03075"></a>03075                 <span class="keywordflow">if</span> (GetParent != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3acfe92e6bd275972917b95f08bd46e09f" title="A document tree&amp;#39;s absolute root.">NodeDocument</a> &amp;&amp; GetParent != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03076"></a>03076                 <span class="keywordflow">if</span> (GetChild == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3acfe92e6bd275972917b95f08bd46e09f" title="A document tree&amp;#39;s absolute root.">NodeDocument</a> || GetChild == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3af6e95d4a0b6115c76b339961bc58d742" title="Empty (null) node handle.">NodeNull</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03077"></a>03077                 <span class="keywordflow">if</span> (GetParent != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3acfe92e6bd275972917b95f08bd46e09f" title="A document tree&amp;#39;s absolute root.">NodeDocument</a> &amp;&amp; (GetChild == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a> || GetChild == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3aca750034b7e4a34d53cfd3399b2bcd99" title="Document type declaration, i.e. &amp;#39;&amp;lt;!DOCTYPE doc&amp;gt;&amp;#39;.">NodeDocType</a>)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03078"></a>03078  
<a name="l03079"></a>03079                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l03080"></a>03080         } 
<a name="l03081"></a>03081  
<a name="l03082"></a>03082         <span class="keywordtype">void</span> recursive_copy_skip(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; dest, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; source, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; skip) 
<a name="l03083"></a>03083         { 
<a name="l03084"></a>03084                 assert(dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()); 
<a name="l03085"></a>03085  
<a name="l03086"></a>03086                 <span class="keywordflow">switch</span> (source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()) 
<a name="l03087"></a>03087                 { 
<a name="l03088"></a>03088                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>: 
<a name="l03089"></a>03089                 { 
<a name="l03090"></a>03090                         dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>()); 
<a name="l03091"></a>03091  
<a name="l03092"></a>03092                         <span class="keywordflow">for</span> (<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae484caac4f1fb2a4b7767ddfed28bf0c" title="Get the First Attribute in this Node.">GetFirstAttribute</a>(); a; a = a.GetNextAttribute()) 
<a name="l03093"></a>03093                                 dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a09ae0a1499b13de2db447fc95dd3b747" title="Creates an Attribute and puts it at the end of this Nodes attributes.">AppendAttribute</a>(a.Name()).SetValue(a.Value()); 
<a name="l03094"></a>03094  
<a name="l03095"></a>03095                         <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> c = source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); c; c = c.GetNextSibling()) 
<a name="l03096"></a>03096                         { 
<a name="l03097"></a>03097                                 <span class="keywordflow">if</span> (c == skip) <span class="keywordflow">continue</span>; 
<a name="l03098"></a>03098  
<a name="l03099"></a>03099                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cc = dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4971850b72467fcdcf1b3beeb09f26cf" title="Creates a Node and makes it a child of this one.">AppendChild</a>(c.Type()); 
<a name="l03100"></a>03100                                 assert(cc); 
<a name="l03101"></a>03101  
<a name="l03102"></a>03102                                 recursive_copy_skip(cc, c, skip); 
<a name="l03103"></a>03103                         } 
<a name="l03104"></a>03104  
<a name="l03105"></a>03105                         <span class="keywordflow">break</span>; 
<a name="l03106"></a>03106                 } 
<a name="l03107"></a>03107  
<a name="l03108"></a>03108                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a>: 
<a name="l03109"></a>03109                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a353968e806a751a6da4f7ac115b4ab55" title="Character data, i.e. &amp;#39;&amp;lt;![CDATA[text]]&amp;gt;&amp;#39;.">NodeCdata</a>: 
<a name="l03110"></a>03110                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a25b778cb61ae0a9f15590cad5e0120d2" title="Comment tag, i.e. &amp;#39;&amp;#39;.">NodeComment</a>: 
<a name="l03111"></a>03111                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3aca750034b7e4a34d53cfd3399b2bcd99" title="Document type declaration, i.e. &amp;#39;&amp;lt;!DOCTYPE doc&amp;gt;&amp;#39;.">NodeDocType</a>: 
<a name="l03112"></a>03112                         dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a50ff9948dac721339561ed3442fb7034" title="Set the value of this.">SetValue</a>(source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()); 
<a name="l03113"></a>03113                         <span class="keywordflow">break</span>; 
<a name="l03114"></a>03114  
<a name="l03115"></a>03115                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a>: 
<a name="l03116"></a>03116                         dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>()); 
<a name="l03117"></a>03117                         dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a50ff9948dac721339561ed3442fb7034" title="Set the value of this.">SetValue</a>(source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()); 
<a name="l03118"></a>03118                         <span class="keywordflow">break</span>; 
<a name="l03119"></a>03119  
<a name="l03120"></a>03120                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>: 
<a name="l03121"></a>03121                 { 
<a name="l03122"></a>03122                         dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>()); 
<a name="l03123"></a>03123  
<a name="l03124"></a>03124                         <span class="keywordflow">for</span> (<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = source.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae484caac4f1fb2a4b7767ddfed28bf0c" title="Get the First Attribute in this Node.">GetFirstAttribute</a>(); a; a = a.GetNextAttribute()) 
<a name="l03125"></a>03125                                 dest.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a09ae0a1499b13de2db447fc95dd3b747" title="Creates an Attribute and puts it at the end of this Nodes attributes.">AppendAttribute</a>(a.Name()).SetValue(a.Value()); 
<a name="l03126"></a>03126  
<a name="l03127"></a>03127                         <span class="keywordflow">break</span>; 
<a name="l03128"></a>03128                 } 
<a name="l03129"></a>03129  
<a name="l03130"></a>03130                 <span class="keywordflow">default</span>: 
<a name="l03131"></a>03131                         assert(!<span class="stringliteral">&quot;Invalid node Type&quot;</span>); 
<a name="l03132"></a>03132                 } 
<a name="l03133"></a>03133         } 
<a name="l03134"></a>03134  
<a name="l03135"></a>03135         <span class="comment">// we need to get length of entire file to Load it in memory; the only (relatively) sane way to do it is via seek/tell trick </span>
<a name="l03136"></a>03136         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917f" title="These statuses are used to help determine what issues, if any the parser had. the XML parser had...">ParseStatus</a> GetFile_size(FILE* file, <span class="keywordtype">size_t</span>&amp; out_Result) 
<a name="l03137"></a>03137         { 
<a name="l03138"></a>03138 <span class="preprocessor">        #if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400 </span>
<a name="l03139"></a>03139 <span class="preprocessor"></span>                <span class="comment">// there are 64-bit versions of fseek/ftell, let&#39;s use them </span>
<a name="l03140"></a>03140                 <span class="keyword">typedef</span> __int64 length_type; 
<a name="l03141"></a>03141  
<a name="l03142"></a>03142                 _fseeki64(file, 0, SEEK_END); 
<a name="l03143"></a>03143                 length_type length = _ftelli64(file); 
<a name="l03144"></a>03144                 _fseeki64(file, 0, SEEK_SET); 
<a name="l03145"></a>03145 <span class="preprocessor">        #elif defined(__MINGW32__) &amp;&amp; !defined(__NO_MINGW_LFS) &amp;&amp; !defined(__STRICT_ANSI__) </span>
<a name="l03146"></a>03146 <span class="preprocessor"></span>                <span class="comment">// there are 64-bit versions of fseek/ftell, let&#39;s use them </span>
<a name="l03147"></a>03147                 <span class="keyword">typedef</span> off64_t length_type; 
<a name="l03148"></a>03148  
<a name="l03149"></a>03149                 fseeko64(file, 0, SEEK_END); 
<a name="l03150"></a>03150                 length_type length = ftello64(file); 
<a name="l03151"></a>03151                 fseeko64(file, 0, SEEK_SET); 
<a name="l03152"></a>03152 <span class="preprocessor">        #else </span>
<a name="l03153"></a>03153 <span class="preprocessor"></span>                <span class="comment">// if this is a 32-bit OS, long is enough; if this is a unix system, long is 64-bit, which is enough; otherwise we can&#39;t do anything anyway. </span>
<a name="l03154"></a>03154                 <span class="keyword">typedef</span> <span class="keywordtype">long</span> length_type; 
<a name="l03155"></a>03155  
<a name="l03156"></a>03156                 fseek(file, 0, SEEK_END); 
<a name="l03157"></a>03157                 length_type length = ftell(file); 
<a name="l03158"></a>03158                 fseek(file, 0, SEEK_SET); 
<a name="l03159"></a>03159 <span class="preprocessor">        #endif </span>
<a name="l03160"></a>03160 <span class="preprocessor"></span> 
<a name="l03161"></a>03161                 <span class="comment">// check for I/O errors </span>
<a name="l03162"></a>03162                 <span class="keywordflow">if</span> (length &lt; 0) <span class="keywordflow">return</span> StatusIOError; 
<a name="l03163"></a>03163                  
<a name="l03164"></a>03164                 <span class="comment">// check for overflow </span>
<a name="l03165"></a>03165                 <span class="keywordtype">size_t</span> Result = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(length); 
<a name="l03166"></a>03166  
<a name="l03167"></a>03167                 <span class="keywordflow">if</span> (static_cast&lt;length_type&gt;(Result) != length) <span class="keywordflow">return</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac2a8163c9a8e285153d2a96b011bd49f" title="Could not allocate memory.">StatusOutOfMemory</a>; 
<a name="l03168"></a>03168  
<a name="l03169"></a>03169                 <span class="comment">// finalize </span>
<a name="l03170"></a>03170                 out_Result = Result; 
<a name="l03171"></a>03171  
<a name="l03172"></a>03172                 <span class="keywordflow">return</span> StatusOk; 
<a name="l03173"></a>03173         } 
<a name="l03174"></a>03174  
<a name="l03175"></a>03175         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> LoadFileImpl(<a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">Document</a>&amp; doc, FILE* file, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l03176"></a>03176         { 
<a name="l03177"></a>03177                 <span class="keywordflow">if</span> (!file) <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa6f0279c8ce0103b77edcf3ce91fa64b4" title="File was not found during a loading from filename attempt.">StatusFileNotFound</a>); 
<a name="l03178"></a>03178  
<a name="l03179"></a>03179                 <span class="comment">// get file size (can Result in I/O errors) </span>
<a name="l03180"></a>03180                 <span class="keywordtype">size_t</span> size = 0; 
<a name="l03181"></a>03181                 <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917f" title="These statuses are used to help determine what issues, if any the parser had. the XML parser had...">ParseStatus</a> size_Status = GetFile_size(file, size); 
<a name="l03182"></a>03182  
<a name="l03183"></a>03183                 <span class="keywordflow">if</span> (size_Status != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa9ea9b3eecb4bb9f01745c94150982560" title="This is returned to indicated there where no issues parsing the XML document.">StatusOk</a>) 
<a name="l03184"></a>03184                 { 
<a name="l03185"></a>03185                         fclose(file); 
<a name="l03186"></a>03186                         <span class="keywordflow">return</span> make_ParseResult(size_Status); 
<a name="l03187"></a>03187                 } 
<a name="l03188"></a>03188                  
<a name="l03189"></a>03189                 <span class="comment">// allocate buffer for the whole file </span>
<a name="l03190"></a>03190                 <span class="keywordtype">char</span>* contents = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(global_allocate(size &gt; 0 ? size : 1)); 
<a name="l03191"></a>03191  
<a name="l03192"></a>03192                 <span class="keywordflow">if</span> (!contents) 
<a name="l03193"></a>03193                 { 
<a name="l03194"></a>03194                         fclose(file); 
<a name="l03195"></a>03195                         <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac2a8163c9a8e285153d2a96b011bd49f" title="Could not allocate memory.">StatusOutOfMemory</a>); 
<a name="l03196"></a>03196                 } 
<a name="l03197"></a>03197  
<a name="l03198"></a>03198                 <span class="comment">// read file in memory </span>
<a name="l03199"></a>03199                 <span class="keywordtype">size_t</span> read_size = fread(contents, 1, size, file); 
<a name="l03200"></a>03200                 fclose(file); 
<a name="l03201"></a>03201  
<a name="l03202"></a>03202                 <span class="keywordflow">if</span> (read_size != size) 
<a name="l03203"></a>03203                 { 
<a name="l03204"></a>03204                         global_deallocate(contents); 
<a name="l03205"></a>03205                         <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa63f6d040311f50c1234a8eb873a0a95c" title="Error reading from file or stream.">StatusIOError</a>); 
<a name="l03206"></a>03206                 } 
<a name="l03207"></a>03207                  
<a name="l03208"></a>03208                 <span class="keywordflow">return</span> doc.<a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a712ff68748c616d5bca8bd6ead8c5799" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">LoadBufferInplaceOwn</a>(contents, size, options, DocumentEncoding); 
<a name="l03209"></a>03209         } 
<a name="l03210"></a>03210  
<a name="l03211"></a>03211 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l03212"></a>03212 <span class="preprocessor"></span>        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> LoadStreamImpl(<a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">Document</a>&amp; doc, std::basic_istream&lt;T&gt;&amp; stream, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l03213"></a>03213         { 
<a name="l03214"></a>03214                 <span class="comment">// get length of remaining data in stream </span>
<a name="l03215"></a>03215                 <span class="keyword">typename</span> std::basic_istream&lt;T&gt;::pos_type pos = stream.tellg(); 
<a name="l03216"></a>03216                 stream.seekg(0, std::ios::end); 
<a name="l03217"></a>03217                 std::streamoff length = stream.tellg() - pos; 
<a name="l03218"></a>03218                 stream.seekg(pos); 
<a name="l03219"></a>03219  
<a name="l03220"></a>03220                 <span class="keywordflow">if</span> (stream.fail() || pos &lt; 0) <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa63f6d040311f50c1234a8eb873a0a95c" title="Error reading from file or stream.">StatusIOError</a>); 
<a name="l03221"></a>03221  
<a name="l03222"></a>03222                 <span class="comment">// guard against huge files </span>
<a name="l03223"></a>03223                 <span class="keywordtype">size_t</span> read_length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(length); 
<a name="l03224"></a>03224  
<a name="l03225"></a>03225                 <span class="keywordflow">if</span> (static_cast&lt;std::streamsize&gt;(read_length) != length || length &lt; 0) <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac2a8163c9a8e285153d2a96b011bd49f" title="Could not allocate memory.">StatusOutOfMemory</a>); 
<a name="l03226"></a>03226  
<a name="l03227"></a>03227                 <span class="comment">// read stream data into memory (guard against stream exceptions with buffer holder) </span>
<a name="l03228"></a>03228                 buffer_holder buffer(global_allocate((read_length &gt; 0 ? read_length : 1) * <span class="keyword">sizeof</span>(T)), global_deallocate); 
<a name="l03229"></a>03229                 <span class="keywordflow">if</span> (!buffer.data) <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac2a8163c9a8e285153d2a96b011bd49f" title="Could not allocate memory.">StatusOutOfMemory</a>); 
<a name="l03230"></a>03230  
<a name="l03231"></a>03231                 stream.read(static_cast&lt;T*&gt;(buffer.data), static_cast&lt;std::streamsize&gt;(read_length)); 
<a name="l03232"></a>03232  
<a name="l03233"></a>03233                 <span class="comment">// read may set failbit | eofbit in case gcount() is less than read_length (i.e. line ending conversion), so check for other I/O errors </span>
<a name="l03234"></a>03234                 <span class="keywordflow">if</span> (stream.bad()) <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa63f6d040311f50c1234a8eb873a0a95c" title="Error reading from file or stream.">StatusIOError</a>); 
<a name="l03235"></a>03235  
<a name="l03236"></a>03236                 <span class="comment">// Load data from buffer </span>
<a name="l03237"></a>03237                 <span class="keywordtype">size_t</span> actual_length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stream.gcount()); 
<a name="l03238"></a>03238                 assert(actual_length &lt;= read_length); 
<a name="l03239"></a>03239  
<a name="l03240"></a>03240                 <span class="keywordflow">return</span> doc.<a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a712ff68748c616d5bca8bd6ead8c5799" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">LoadBufferInplaceOwn</a>(buffer.release(), actual_length * <span class="keyword">sizeof</span>(T), options, DocumentEncoding); 
<a name="l03241"></a>03241         } 
<a name="l03242"></a>03242 <span class="preprocessor">#endif </span>
<a name="l03243"></a>03243 <span class="preprocessor"></span> 
<a name="l03244"></a>03244 <span class="preprocessor">#if defined(_MSC_VER) || defined(__BORLANDC__) || defined(__MINGW32__) </span>
<a name="l03245"></a>03245 <span class="preprocessor"></span>        FILE* open_file_wide(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* Path, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* mode) 
<a name="l03246"></a>03246         { 
<a name="l03247"></a>03247                 <span class="keywordflow">return</span> _wfopen(Path, mode); 
<a name="l03248"></a>03248         } 
<a name="l03249"></a>03249 <span class="preprocessor">#else </span>
<a name="l03250"></a>03250 <span class="preprocessor"></span>        <span class="keywordtype">char</span>* convert_Path_heap(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* str) 
<a name="l03251"></a>03251         { 
<a name="l03252"></a>03252                 assert(str); 
<a name="l03253"></a>03253  
<a name="l03254"></a>03254                 <span class="comment">// first pass: get length in utf8 characters </span>
<a name="l03255"></a>03255                 <span class="keywordtype">size_t</span> length = wcslen(str); 
<a name="l03256"></a>03256                 <span class="keywordtype">size_t</span> size = AsUtf8_begin(str, length); 
<a name="l03257"></a>03257  
<a name="l03258"></a>03258                 <span class="comment">// allocate Resulting string </span>
<a name="l03259"></a>03259                 <span class="keywordtype">char</span>* Result = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(global_allocate(size + 1)); 
<a name="l03260"></a>03260                 <span class="keywordflow">if</span> (!Result) <span class="keywordflow">return</span> 0; 
<a name="l03261"></a>03261  
<a name="l03262"></a>03262                 <span class="comment">// second pass: convert to utf8 </span>
<a name="l03263"></a>03263                 AsUtf8_end(Result, size, str, length); 
<a name="l03264"></a>03264  
<a name="l03265"></a>03265                 <span class="keywordflow">return</span> Result; 
<a name="l03266"></a>03266         } 
<a name="l03267"></a>03267  
<a name="l03268"></a>03268         FILE* open_file_wide(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* Path, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* mode) 
<a name="l03269"></a>03269         { 
<a name="l03270"></a>03270                 <span class="comment">// there is no standard function to open wide Paths, so our best bet is to try utf8 Path </span>
<a name="l03271"></a>03271                 <span class="keywordtype">char</span>* Path_utf8 = convert_Path_heap(Path); 
<a name="l03272"></a>03272                 <span class="keywordflow">if</span> (!Path_utf8) <span class="keywordflow">return</span> 0; 
<a name="l03273"></a>03273  
<a name="l03274"></a>03274                 <span class="comment">// convert mode to ASCII (we mirror _wfopen interface) </span>
<a name="l03275"></a>03275                 <span class="keywordtype">char</span> mode_ascii[4] = {0}; 
<a name="l03276"></a>03276                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; mode[i]; ++i) mode_ascii[i] = static_cast&lt;char&gt;(mode[i]); 
<a name="l03277"></a>03277  
<a name="l03278"></a>03278                 <span class="comment">// try to open the utf8 Path </span>
<a name="l03279"></a>03279                 FILE* Result = fopen(Path_utf8, mode_ascii); 
<a name="l03280"></a>03280  
<a name="l03281"></a>03281                 <span class="comment">// free dummy buffer </span>
<a name="l03282"></a>03282                 global_deallocate(Path_utf8); 
<a name="l03283"></a>03283  
<a name="l03284"></a>03284                 <span class="keywordflow">return</span> Result; 
<a name="l03285"></a>03285         } 
<a name="l03286"></a>03286 <span class="preprocessor">#endif </span>
<a name="l03287"></a>03287 <span class="preprocessor"></span>} 
<a name="l03288"></a>03288  
<a name="l03289"></a>03289 
<a name="l03290"></a>03290 <span class="keyword">namespace </span>phys
<a name="l03291"></a>03291 { <span class="keyword">namespace </span>xml
<a name="l03292"></a>03292 { 
<a name="l03293"></a><a class="code" href="../../dc/d53/classphys_1_1xml_1_1WriterFile.html#aba665d4dc17c956798a80cb4e8c2774d">03293</a>         WriterFile::WriterFile(<span class="keywordtype">void</span>* file): file(file) 
<a name="l03294"></a>03294         { 
<a name="l03295"></a>03295         } 
<a name="l03296"></a>03296  
<a name="l03297"></a><a class="code" href="../../dc/d53/classphys_1_1xml_1_1WriterFile.html#a4c4348e30dc03b22f7d4ee15bd386ab2">03297</a>         <span class="keywordtype">void</span> <a class="code" href="../../dc/d53/classphys_1_1xml_1_1WriterFile.html#a4c4348e30dc03b22f7d4ee15bd386ab2" title="This will be used to output xml to an external source such as a file or stream.">WriterFile::Write</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> size) 
<a name="l03298"></a>03298         { 
<a name="l03299"></a>03299                 fwrite(data, size, 1, static_cast&lt;FILE*&gt;(file)); 
<a name="l03300"></a>03300         } 
<a name="l03301"></a>03301  
<a name="l03302"></a>03302 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l03303"></a><a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html#ae170ab7c429b6f7149d3540243329dfa">03303</a> <span class="preprocessor"></span>        <a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html#ae170ab7c429b6f7149d3540243329dfa" title="A constructor that accepts a stream of characters.">WriterStream::WriterStream</a>(std::basic_ostream&lt;<span class="keywordtype">char</span>, std::char_traits&lt;char&gt; &gt;&amp; stream): narrow_stream(&amp;stream), wide_stream(0) 
<a name="l03304"></a>03304         { 
<a name="l03305"></a>03305         } 
<a name="l03306"></a>03306  
<a name="l03307"></a><a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html#aaebcd545af8e44cf6556a46077f0a366">03307</a>         <a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html#ae170ab7c429b6f7149d3540243329dfa" title="A constructor that accepts a stream of characters.">WriterStream::WriterStream</a>(std::basic_ostream&lt;<span class="keywordtype">wchar_t</span>, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream): narrow_stream(0), wide_stream(&amp;stream) 
<a name="l03308"></a>03308         { 
<a name="l03309"></a>03309         } 
<a name="l03310"></a>03310  
<a name="l03311"></a><a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html#a74242c8abe03f6244d3464a663f75de9">03311</a>         <span class="keywordtype">void</span> <a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html#a74242c8abe03f6244d3464a663f75de9" title="This will be used to output xml to an external source such as a file or stream.">WriterStream::Write</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> size) 
<a name="l03312"></a>03312         { 
<a name="l03313"></a>03313                 <span class="keywordflow">if</span> (narrow_stream) 
<a name="l03314"></a>03314                 { 
<a name="l03315"></a>03315                         assert(!wide_stream); 
<a name="l03316"></a>03316                         narrow_stream-&gt;write(reinterpret_cast&lt;const char*&gt;(data), static_cast&lt;std::streamsize&gt;(size)); 
<a name="l03317"></a>03317                 } 
<a name="l03318"></a>03318                 <span class="keywordflow">else</span> 
<a name="l03319"></a>03319                 { 
<a name="l03320"></a>03320                         assert(wide_stream); 
<a name="l03321"></a>03321                         assert(size % <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>) == 0); 
<a name="l03322"></a>03322  
<a name="l03323"></a>03323                         wide_stream-&gt;write(reinterpret_cast&lt;const wchar_t*&gt;(data), static_cast&lt;std::streamsize&gt;(size / <span class="keyword">sizeof</span>(<span class="keywordtype">wchar_t</span>))); 
<a name="l03324"></a>03324                 } 
<a name="l03325"></a>03325         } 
<a name="l03326"></a>03326 <span class="preprocessor">#endif </span>
<a name="l03327"></a>03327 <span class="preprocessor"></span> 
<a name="l03328"></a><a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a5b4e97d7a0b433770431f8ebd8fc6489">03328</a>         <a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a5b4e97d7a0b433770431f8ebd8fc6489" title="Default constructor, initializes depth, and can do little else without a fully implemented treewalker...">TreeWalker::TreeWalker</a>(): _Depth(0) 
<a name="l03329"></a>03329         { 
<a name="l03330"></a>03330         } 
<a name="l03331"></a>03331          
<a name="l03332"></a><a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a84d0c68cf364a81e29f0cc321098ae28">03332</a>         <a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a84d0c68cf364a81e29f0cc321098ae28" title="Virtual deconstructor. Tears down a TreeWalker.">TreeWalker::~TreeWalker</a>() 
<a name="l03333"></a>03333         { 
<a name="l03334"></a>03334         } 
<a name="l03335"></a>03335  
<a name="l03336"></a><a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a90fdd705ae4d5e8e3b931bb8896e4397">03336</a>         <span class="keywordtype">int</span> <a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a90fdd705ae4d5e8e3b931bb8896e4397" title="How many descendants deep are we during traversal.">TreeWalker::Depth</a>()<span class="keyword"> const </span>
<a name="l03337"></a>03337 <span class="keyword">        </span>{ 
<a name="l03338"></a>03338                 <span class="keywordflow">return</span> _Depth; 
<a name="l03339"></a>03339         } 
<a name="l03340"></a>03340  
<a name="l03341"></a><a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a649d9e5a06542be0282d3d20994a62fc">03341</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a649d9e5a06542be0282d3d20994a62fc" title="Called on the root Node of the xml subtree when traversal begins.  By default this simply returns tru...">TreeWalker::begin</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp;) 
<a name="l03342"></a>03342         { 
<a name="l03343"></a>03343                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l03344"></a>03344         } 
<a name="l03345"></a>03345  
<a name="l03346"></a><a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a210f6d60579a152f89e651be797885b9">03346</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a210f6d60579a152f89e651be797885b9" title="Called on the root Node of the xml subtree when traversal ends.  By default this simply returns true...">TreeWalker::end</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp;) 
<a name="l03347"></a>03347         { 
<a name="l03348"></a>03348                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l03349"></a>03349         } 
<a name="l03350"></a>03350  
<a name="l03351"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a962ad273e447bb714925c331e00cc3e7">03351</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a962ad273e447bb714925c331e00cc3e7" title="Constructs an empty Attribute.">Attribute::Attribute</a>(): _attr(0) 
<a name="l03352"></a>03352         { 
<a name="l03353"></a>03353         } 
<a name="l03354"></a>03354  
<a name="l03355"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6786df9d66c675c5a55761a7d3d512a5">03355</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a962ad273e447bb714925c331e00cc3e7" title="Constructs an empty Attribute.">Attribute::Attribute</a>(<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* attr): _attr(attr) 
<a name="l03356"></a>03356         { 
<a name="l03357"></a>03357         } 
<a name="l03358"></a>03358  
<a name="l03359"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab2cf442667b8ad1b443f0512ccaedcf9">03359</a>         Attribute::operator Attribute::unspecified_bool_type()<span class="keyword"> const </span>
<a name="l03360"></a>03360 <span class="keyword">        </span>{ 
<a name="l03361"></a>03361                 <span class="keywordflow">return</span> _attr ? &amp;Attribute::_attr : 0; 
<a name="l03362"></a>03362         } 
<a name="l03363"></a>03363  
<a name="l03364"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a18cb9f6900b0fc9e246b36d90e5bea5b">03364</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a18cb9f6900b0fc9e246b36d90e5bea5b" title="Used to convert this attribute the opposite of it&amp;#39;s normal boolean value.">Attribute::operator!</a>()<span class="keyword"> const </span>
<a name="l03365"></a>03365 <span class="keyword">        </span>{ 
<a name="l03366"></a>03366                 <span class="keywordflow">return</span> !_attr; 
<a name="l03367"></a>03367         } 
<a name="l03368"></a>03368  
<a name="l03369"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a68b6ba1299cc9a2019ec97b10bb8978b">03369</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a68b6ba1299cc9a2019ec97b10bb8978b" title="Compares the internal values to check equality.">Attribute::operator==</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; r)<span class="keyword"> const </span>
<a name="l03370"></a>03370 <span class="keyword">        </span>{ 
<a name="l03371"></a>03371                 <span class="keywordflow">return</span> (_attr == r._attr); 
<a name="l03372"></a>03372         } 
<a name="l03373"></a>03373          
<a name="l03374"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ae2371203e07dd781d2b38ba403b00816">03374</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ae2371203e07dd781d2b38ba403b00816" title="Compares the internal values to check inequality.">Attribute::operator!=</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; r)<span class="keyword"> const </span>
<a name="l03375"></a>03375 <span class="keyword">        </span>{ 
<a name="l03376"></a>03376                 <span class="keywordflow">return</span> (_attr != r._attr); 
<a name="l03377"></a>03377         } 
<a name="l03378"></a>03378  
<a name="l03379"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac383f0c514e550fe992b1c0a0f3cbd7a">03379</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac383f0c514e550fe992b1c0a0f3cbd7a" title="Compares the internal values to check for inequality.">Attribute::operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; r)<span class="keyword"> const </span>
<a name="l03380"></a>03380 <span class="keyword">        </span>{ 
<a name="l03381"></a>03381                 <span class="keywordflow">return</span> (_attr &lt; r._attr); 
<a name="l03382"></a>03382         } 
<a name="l03383"></a>03383          
<a name="l03384"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac778ad4d7aa3a179217de1425e220848">03384</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac778ad4d7aa3a179217de1425e220848" title="Compares the internal values to check for inequality.">Attribute::operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; r)<span class="keyword"> const </span>
<a name="l03385"></a>03385 <span class="keyword">        </span>{ 
<a name="l03386"></a>03386                 <span class="keywordflow">return</span> (_attr &gt; r._attr); 
<a name="l03387"></a>03387         } 
<a name="l03388"></a>03388          
<a name="l03389"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a3b73bd409a2b6b9a7d72c3affc96bae1">03389</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a3b73bd409a2b6b9a7d72c3affc96bae1" title="Compares the internal values to check for inequality.">Attribute::operator&lt;=</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; r)<span class="keyword"> const </span>
<a name="l03390"></a>03390 <span class="keyword">        </span>{ 
<a name="l03391"></a>03391                 <span class="keywordflow">return</span> (_attr &lt;= r._attr); 
<a name="l03392"></a>03392         } 
<a name="l03393"></a>03393          
<a name="l03394"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab1d63c57891107848492dc3316c95455">03394</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab1d63c57891107848492dc3316c95455" title="Compares the internal values to check for inequality.">Attribute::operator&gt;=</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; r)<span class="keyword"> const </span>
<a name="l03395"></a>03395 <span class="keyword">        </span>{ 
<a name="l03396"></a>03396                 <span class="keywordflow">return</span> (_attr &gt;= r._attr); 
<a name="l03397"></a>03397         } 
<a name="l03398"></a>03398  
<a name="l03399"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a602c51cb79ed0cc33bd898aefe77da70">03399</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a602c51cb79ed0cc33bd898aefe77da70" title="Get the next attribute.">Attribute::GetNextAttribute</a>()<span class="keyword"> const </span>
<a name="l03400"></a>03400 <span class="keyword">        </span>{ 
<a name="l03401"></a>03401                 <span class="keywordflow">return</span> _attr ? <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a962ad273e447bb714925c331e00cc3e7" title="Constructs an empty Attribute.">Attribute</a>(_attr-&gt;GetNextAttribute) : <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a962ad273e447bb714925c331e00cc3e7" title="Constructs an empty Attribute.">Attribute</a>(); 
<a name="l03402"></a>03402         } 
<a name="l03403"></a>03403  
<a name="l03404"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ae1c2320961faca954e7e34acc166f8d0">03404</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ae1c2320961faca954e7e34acc166f8d0" title="Get the previous attribute.">Attribute::GetPreviousAttribute</a>()<span class="keyword"> const </span>
<a name="l03405"></a>03405 <span class="keyword">        </span>{ 
<a name="l03406"></a>03406                 <span class="keywordflow">return</span> _attr &amp;&amp; _attr-&gt;prev_attribute_c-&gt;GetNextAttribute ? <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a962ad273e447bb714925c331e00cc3e7" title="Constructs an empty Attribute.">Attribute</a>(_attr-&gt;prev_attribute_c) : <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a962ad273e447bb714925c331e00cc3e7" title="Constructs an empty Attribute.">Attribute</a>(); 
<a name="l03407"></a>03407         } 
<a name="l03408"></a>03408  
<a name="l03409"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ada1f2e45ce636ad8482972263364e7fa">03409</a>         <span class="keywordtype">int</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ada1f2e45ce636ad8482972263364e7fa" title="Attempts to convert the value of the attribute to an int and returns the results.">Attribute::AsInt</a>()<span class="keyword"> const </span>
<a name="l03410"></a>03410 <span class="keyword">        </span>{ 
<a name="l03411"></a>03411                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0; 
<a name="l03412"></a>03412  
<a name="l03413"></a>03413 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l03414"></a>03414 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)wcstol(_attr-&gt;Value, 0, 10); 
<a name="l03415"></a>03415 <span class="preprocessor">        #else </span>
<a name="l03416"></a>03416 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)strtol(_attr-&gt;Value, 0, 10); 
<a name="l03417"></a>03417 <span class="preprocessor">        #endif </span>
<a name="l03418"></a>03418 <span class="preprocessor"></span>        } 
<a name="l03419"></a>03419  
<a name="l03420"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ad00ec5857fc4afcda892a0057419a9a0">03420</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ad00ec5857fc4afcda892a0057419a9a0" title="Attempts to convert the value of the attribute to an unsigned int and returns the results...">Attribute::AsUint</a>()<span class="keyword"> const </span>
<a name="l03421"></a>03421 <span class="keyword">        </span>{ 
<a name="l03422"></a>03422                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0; 
<a name="l03423"></a>03423  
<a name="l03424"></a>03424 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l03425"></a>03425 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)wcstoul(_attr-&gt;Value, 0, 10); 
<a name="l03426"></a>03426 <span class="preprocessor">        #else </span>
<a name="l03427"></a>03427 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)strtoul(_attr-&gt;Value, 0, 10); 
<a name="l03428"></a>03428 <span class="preprocessor">        #endif </span>
<a name="l03429"></a>03429 <span class="preprocessor"></span>        } 
<a name="l03430"></a>03430  
<a name="l03431"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a467ae167d5407ae3293a22b8873cb43a">03431</a>         <span class="keywordtype">double</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a467ae167d5407ae3293a22b8873cb43a" title="Attempts to convert the value of the attribute to a double and returns the results.">Attribute::AsDouble</a>()<span class="keyword"> const </span>
<a name="l03432"></a>03432 <span class="keyword">        </span>{ 
<a name="l03433"></a>03433                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0; 
<a name="l03434"></a>03434  
<a name="l03435"></a>03435 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l03436"></a>03436 <span class="preprocessor"></span>                <span class="keywordflow">return</span> wcstod(_attr-&gt;Value, 0); 
<a name="l03437"></a>03437 <span class="preprocessor">        #else </span>
<a name="l03438"></a>03438 <span class="preprocessor"></span>                <span class="keywordflow">return</span> strtod(_attr-&gt;Value, 0); 
<a name="l03439"></a>03439 <span class="preprocessor">        #endif </span>
<a name="l03440"></a>03440 <span class="preprocessor"></span>        } 
<a name="l03441"></a>03441  
<a name="l03442"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac40df65f4914609554d99e72624eb8d2">03442</a>         <a class="code" href="../../df/dec/namespacephys.html#a460f6bc24c8dd347b05e0366ae34f34a" title="A Datatype used to represent an postive integer numbers.">Whole</a> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac40df65f4914609554d99e72624eb8d2" title="Attempts to convert the value of the attribute to a Whole and returns the results.">Attribute::AsWhole</a>()<span class="keyword"> const</span>
<a name="l03443"></a>03443 <span class="keyword">        </span>{
<a name="l03444"></a>03444                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0;
<a name="l03445"></a>03445                 <span class="keywordflow">return</span> <a class="code" href="../../df/dec/namespacephys.html#a53d44a46cab542ef86a541af5f1a7b62" title="Converts whatever to a Whole as long as the proper streaming operators are available for it...">ToWhole</a>(_attr-&gt;Value);
<a name="l03446"></a>03446         }
<a name="l03447"></a>03447 
<a name="l03448"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6f7ae9a3fe3ad8d88823d97e8fa04973">03448</a>         <a class="code" href="../../df/dec/namespacephys.html#a7f09bf5585b2bb97613cd9aad4273a81" title="A datatype use to represent any integer close to.">Integer</a> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6f7ae9a3fe3ad8d88823d97e8fa04973" title="Attempts to convert the value of the attribute to a Integer and returns the results.">Attribute::AsInteger</a>()<span class="keyword"> const</span>
<a name="l03449"></a>03449 <span class="keyword">        </span>{
<a name="l03450"></a>03450                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0;
<a name="l03451"></a>03451                 <span class="keywordflow">return</span> <a class="code" href="../../df/dec/namespacephys.html#a7fe8a4cf645e000483652f26ef8d6e47" title="Converts whatever to an Integer as long as the proper streaming operators are available for it...">ToInteger</a>(_attr-&gt;Value);
<a name="l03452"></a>03452         }
<a name="l03453"></a>03453 
<a name="l03454"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a7b6b2e3e8c8f262dfca1b97d904c638a">03454</a>         String <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a7b6b2e3e8c8f262dfca1b97d904c638a" title="Attempts to convert the value of the attribute to a String and returns the results.">Attribute::AsString</a>()<span class="keyword"> const</span>
<a name="l03455"></a>03455 <span class="keyword">        </span>{
<a name="l03456"></a>03456                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0;
<a name="l03457"></a>03457                 <span class="keywordflow">return</span> <a class="code" href="../../df/dec/namespacephys.html#ae81e34843c6c569026b9a7d9d54c4f04" title="Converts whatever to a String as long as a streaming operator is available for it.">ToString</a>(_attr-&gt;Value);
<a name="l03458"></a>03458         }
<a name="l03459"></a>03459 
<a name="l03460"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a1ed9ffa5461223647168309ae4c86809">03460</a>         <a class="code" href="../../df/dec/namespacephys.html#af7eb897198d265b8e868f45240230d5f" title="A Datatype used to represent a real floating point number.">Real</a> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a1ed9ffa5461223647168309ae4c86809" title="Attempts to convert the value of the attribute to a Real and returns the results.">Attribute::AsReal</a>()<span class="keyword"> const</span>
<a name="l03461"></a>03461 <span class="keyword">        </span>{
<a name="l03462"></a>03462                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0;
<a name="l03463"></a>03463                 <span class="keywordflow">return</span> <a class="code" href="../../df/dec/namespacephys.html#ac5ff9d58be770f2fe8c4928eb160c88a" title="Converts whatever to a Real as long as the proper streaming operators are available for it...">ToReal</a>(_attr-&gt;Value);
<a name="l03464"></a>03464         }
<a name="l03465"></a>03465 
<a name="l03466"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#aad74f805b9318735011d698ee39113aa">03466</a>         <span class="keywordtype">float</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#aad74f805b9318735011d698ee39113aa" title="Attempts to convert the value of the attribute to a float and returns the results.">Attribute::AsFloat</a>()<span class="keyword"> const </span>
<a name="l03467"></a>03467 <span class="keyword">        </span>{ 
<a name="l03468"></a>03468                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> 0; 
<a name="l03469"></a>03469  
<a name="l03470"></a>03470 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l03471"></a>03471 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)wcstod(_attr-&gt;Value, 0); 
<a name="l03472"></a>03472 <span class="preprocessor">        #else </span>
<a name="l03473"></a>03473 <span class="preprocessor"></span>                <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)strtod(_attr-&gt;Value, 0); 
<a name="l03474"></a>03474 <span class="preprocessor">        #endif </span>
<a name="l03475"></a>03475 <span class="preprocessor"></span>        } 
<a name="l03476"></a>03476  
<a name="l03477"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a1c3e0f3a1722aac6a43daa135fdf622e">03477</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a1c3e0f3a1722aac6a43daa135fdf622e" title="Attempts to convert the value of the attribute to a float and returns the results.">Attribute::AsBool</a>()<span class="keyword"> const </span>
<a name="l03478"></a>03478 <span class="keyword">        </span>{ 
<a name="l03479"></a>03479                 <span class="keywordflow">if</span> (!_attr || !_attr-&gt;Value) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03480"></a>03480  
<a name="l03481"></a>03481                 <span class="comment">// only look at first char </span>
<a name="l03482"></a>03482                 char_t first = *_attr-&gt;Value; 
<a name="l03483"></a>03483  
<a name="l03484"></a>03484                 <span class="comment">// 1*, t* (true), T* (True), y* (yes), Y* (YES) </span>
<a name="l03485"></a>03485                 <span class="keywordflow">return</span> (first == <span class="charliteral">&#39;1&#39;</span> || first == <span class="charliteral">&#39;t&#39;</span> || first == <span class="charliteral">&#39;T&#39;</span> || first == <span class="charliteral">&#39;y&#39;</span> || first == <span class="charliteral">&#39;Y&#39;</span>); 
<a name="l03486"></a>03486         } 
<a name="l03487"></a>03487  
<a name="l03488"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6d0157a562f283e9c87d1cc46b3405cc">03488</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6d0157a562f283e9c87d1cc46b3405cc" title="Is this storing anything at all?">Attribute::Empty</a>()<span class="keyword"> const </span>
<a name="l03489"></a>03489 <span class="keyword">        </span>{ 
<a name="l03490"></a>03490                 <span class="keywordflow">return</span> !_attr; 
<a name="l03491"></a>03491         } 
<a name="l03492"></a>03492  
<a name="l03493"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135">03493</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Attribute::Name</a>()<span class="keyword"> const </span>
<a name="l03494"></a>03494 <span class="keyword">        </span>{ 
<a name="l03495"></a>03495                 <span class="keywordflow">return</span> (_attr &amp;&amp; _attr-&gt;Name) ? _attr-&gt;Name : <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l03496"></a>03496         } 
<a name="l03497"></a>03497  
<a name="l03498"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451">03498</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Attribute::Value</a>()<span class="keyword"> const </span>
<a name="l03499"></a>03499 <span class="keyword">        </span>{ 
<a name="l03500"></a>03500                 <span class="keywordflow">return</span> (_attr &amp;&amp; _attr-&gt;Value) ? _attr-&gt;Value : <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l03501"></a>03501         } 
<a name="l03502"></a>03502  
<a name="l03503"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac0c27e07b705c41670a0903f4fe18378">03503</a>         <span class="keywordtype">size_t</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac0c27e07b705c41670a0903f4fe18378" title="Get a unique identifying value for the Attribute this represents.">Attribute::HashValue</a>()<span class="keyword"> const </span>
<a name="l03504"></a>03504 <span class="keyword">        </span>{ 
<a name="l03505"></a>03505                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(_attr) / <span class="keyword">sizeof</span>(<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>)); 
<a name="l03506"></a>03506         } 
<a name="l03507"></a>03507  
<a name="l03508"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a1354d5f93309a999651e11b1cd4c2f62">03508</a>         <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a1354d5f93309a999651e11b1cd4c2f62" title="Retrieve a pointer to the internal data.">Attribute::InternalObject</a>()<span class="keyword"> const </span>
<a name="l03509"></a>03509 <span class="keyword">        </span>{ 
<a name="l03510"></a>03510                 <span class="keywordflow">return</span> _attr; 
<a name="l03511"></a>03511         } 
<a name="l03512"></a>03512  
<a name="l03513"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a78d7a0436d386040e2d1f8954304b25b">03513</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a78d7a0436d386040e2d1f8954304b25b" title="The same as Attribute::SetValue(const char_t* rhs); without the error return.">Attribute::operator=</a>(<span class="keyword">const</span> char_t* rhs) 
<a name="l03514"></a>03514         { 
<a name="l03515"></a>03515                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(rhs); 
<a name="l03516"></a>03516                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l03517"></a>03517         } 
<a name="l03518"></a>03518          
<a name="l03519"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac9a18c2b6c4bfc0cdfe4eede938a91fe">03519</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a78d7a0436d386040e2d1f8954304b25b" title="The same as Attribute::SetValue(const char_t* rhs); without the error return.">Attribute::operator=</a>(<span class="keywordtype">int</span> rhs) 
<a name="l03520"></a>03520         { 
<a name="l03521"></a>03521                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(rhs); 
<a name="l03522"></a>03522                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l03523"></a>03523         } 
<a name="l03524"></a>03524  
<a name="l03525"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#af6b6e5202b23be948b986cb0bcdf5da8">03525</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a78d7a0436d386040e2d1f8954304b25b" title="The same as Attribute::SetValue(const char_t* rhs); without the error return.">Attribute::operator=</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rhs) 
<a name="l03526"></a>03526         { 
<a name="l03527"></a>03527                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(rhs); 
<a name="l03528"></a>03528                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l03529"></a>03529         } 
<a name="l03530"></a>03530  
<a name="l03531"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ac92a92492d624984a52b64bc4fabf355">03531</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a78d7a0436d386040e2d1f8954304b25b" title="The same as Attribute::SetValue(const char_t* rhs); without the error return.">Attribute::operator=</a>(<span class="keywordtype">double</span> rhs) 
<a name="l03532"></a>03532         { 
<a name="l03533"></a>03533                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(rhs); 
<a name="l03534"></a>03534                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l03535"></a>03535         } 
<a name="l03536"></a>03536          
<a name="l03537"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a008397ad3c9c63bf27a4dca4b68e5efd">03537</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a78d7a0436d386040e2d1f8954304b25b" title="The same as Attribute::SetValue(const char_t* rhs); without the error return.">Attribute::operator=</a>(<span class="keywordtype">bool</span> rhs) 
<a name="l03538"></a>03538         { 
<a name="l03539"></a>03539                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(rhs); 
<a name="l03540"></a>03540                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l03541"></a>03541         } 
<a name="l03542"></a>03542  
<a name="l03543"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#af669654308122897f98858563375bf4c">03543</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#af669654308122897f98858563375bf4c" title="Set the name of this attribute.">Attribute::SetName</a>(<span class="keyword">const</span> char_t* rhs) 
<a name="l03544"></a>03544         { 
<a name="l03545"></a>03545                 <span class="keywordflow">if</span> (!_attr) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03546"></a>03546                  
<a name="l03547"></a>03547                 <span class="keywordflow">return</span> strcpy_insitu(_attr-&gt;Name, _attr-&gt;header, MemoryPage_Name_allocated_mask, rhs); 
<a name="l03548"></a>03548         } 
<a name="l03549"></a>03549                  
<a name="l03550"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa">03550</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">Attribute::SetValue</a>(<span class="keyword">const</span> char_t* rhs) 
<a name="l03551"></a>03551         { 
<a name="l03552"></a>03552                 <span class="keywordflow">if</span> (!_attr) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03553"></a>03553  
<a name="l03554"></a>03554                 <span class="keywordflow">return</span> strcpy_insitu(_attr-&gt;Value, _attr-&gt;header, MemoryPage_Value_allocated_mask, rhs); 
<a name="l03555"></a>03555         } 
<a name="l03556"></a>03556  
<a name="l03557"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a693f7bd8015866c3c4979101c343ce50">03557</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">Attribute::SetValue</a>(<span class="keywordtype">int</span> rhs) 
<a name="l03558"></a>03558         { 
<a name="l03559"></a>03559                 <span class="keywordtype">char</span> buf[128]; 
<a name="l03560"></a>03560                 sprintf(buf, <span class="stringliteral">&quot;%d&quot;</span>, rhs); 
<a name="l03561"></a>03561          
<a name="l03562"></a>03562 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l03563"></a>03563 <span class="preprocessor"></span>                char_t wbuf[128]; 
<a name="l03564"></a>03564                 widen_ascii(wbuf, buf); 
<a name="l03565"></a>03565  
<a name="l03566"></a>03566                 <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(wbuf); 
<a name="l03567"></a>03567 <span class="preprocessor">        #else </span>
<a name="l03568"></a>03568 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(buf); 
<a name="l03569"></a>03569 <span class="preprocessor">        #endif </span>
<a name="l03570"></a>03570 <span class="preprocessor"></span>        } 
<a name="l03571"></a>03571  
<a name="l03572"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a289ac36b218f3912224fd904ccade1ed">03572</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">Attribute::SetValue</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rhs) 
<a name="l03573"></a>03573         { 
<a name="l03574"></a>03574                 <span class="keywordtype">char</span> buf[128]; 
<a name="l03575"></a>03575                 sprintf(buf, <span class="stringliteral">&quot;%u&quot;</span>, rhs); 
<a name="l03576"></a>03576  
<a name="l03577"></a>03577 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l03578"></a>03578 <span class="preprocessor"></span>                char_t wbuf[128]; 
<a name="l03579"></a>03579                 widen_ascii(wbuf, buf); 
<a name="l03580"></a>03580  
<a name="l03581"></a>03581                 <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(wbuf); 
<a name="l03582"></a>03582 <span class="preprocessor">        #else </span>
<a name="l03583"></a>03583 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(buf); 
<a name="l03584"></a>03584 <span class="preprocessor">        #endif </span>
<a name="l03585"></a>03585 <span class="preprocessor"></span>        } 
<a name="l03586"></a>03586  
<a name="l03587"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a919034671f61ee408d616409a49dafca">03587</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">Attribute::SetValue</a>(<span class="keywordtype">double</span> rhs) 
<a name="l03588"></a>03588         { 
<a name="l03589"></a>03589                 <span class="keywordtype">char</span> buf[128]; 
<a name="l03590"></a>03590                 sprintf(buf, <span class="stringliteral">&quot;%g&quot;</span>, rhs); 
<a name="l03591"></a>03591  
<a name="l03592"></a>03592 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l03593"></a>03593 <span class="preprocessor"></span>                char_t wbuf[128]; 
<a name="l03594"></a>03594                 widen_ascii(wbuf, buf); 
<a name="l03595"></a>03595  
<a name="l03596"></a>03596                 <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(wbuf); 
<a name="l03597"></a>03597 <span class="preprocessor">        #else </span>
<a name="l03598"></a>03598 <span class="preprocessor"></span>                <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(buf); 
<a name="l03599"></a>03599 <span class="preprocessor">        #endif </span>
<a name="l03600"></a>03600 <span class="preprocessor"></span>        } 
<a name="l03601"></a>03601          
<a name="l03602"></a><a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6df4cf0f083482e69e4e6e94599a1d82">03602</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">Attribute::SetValue</a>(<span class="keywordtype">bool</span> rhs) 
<a name="l03603"></a>03603         { 
<a name="l03604"></a>03604                 <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(rhs ? <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;true&quot;</span>) : <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;false&quot;</span>)); 
<a name="l03605"></a>03605         } 
<a name="l03606"></a>03606  
<a name="l03607"></a>03607 <span class="preprocessor">#ifdef __BORLANDC__ </span>
<a name="l03608"></a>03608 <span class="preprocessor"></span>        <span class="keywordtype">bool</span> operator&amp;&amp;(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; lhs, <span class="keywordtype">bool</span> rhs) 
<a name="l03609"></a>03609         { 
<a name="l03610"></a>03610                 <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)lhs &amp;&amp; rhs; 
<a name="l03611"></a>03611         } 
<a name="l03612"></a>03612  
<a name="l03613"></a>03613         <span class="keywordtype">bool</span> operator||(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; lhs, <span class="keywordtype">bool</span> rhs) 
<a name="l03614"></a>03614         { 
<a name="l03615"></a>03615                 <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)lhs || rhs; 
<a name="l03616"></a>03616         } 
<a name="l03617"></a>03617 <span class="preprocessor">#endif </span>
<a name="l03618"></a>03618 <span class="preprocessor"></span> 
<a name="l03619"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9">03619</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node::Node</a>(): _GetRoot(0) 
<a name="l03620"></a>03620         { 
<a name="l03621"></a>03621         } 
<a name="l03622"></a>03622  
<a name="l03623"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aaefbe98a05a7bf304612c3e7f7556f42">03623</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node::Node</a>(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* p): _GetRoot(p) 
<a name="l03624"></a>03624         { 
<a name="l03625"></a>03625         } 
<a name="l03626"></a>03626          
<a name="l03627"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1a3af56736ef4dd39596bb71607ebbc7">03627</a>         Node::operator Node::unspecified_bool_type()<span class="keyword"> const </span>
<a name="l03628"></a>03628 <span class="keyword">        </span>{ 
<a name="l03629"></a>03629                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? &amp;<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">Node::_GetRoot</a> : 0; 
<a name="l03630"></a>03630         } 
<a name="l03631"></a>03631  
<a name="l03632"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11c8e41002682a2742bd168a9318b6e8">03632</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11c8e41002682a2742bd168a9318b6e8" title="Used to convert this node the opposite of it&amp;#39;s normal boolean value.">Node::operator!</a>()<span class="keyword"> const </span>
<a name="l03633"></a>03633 <span class="keyword">        </span>{ 
<a name="l03634"></a>03634                 <span class="keywordflow">return</span> !<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l03635"></a>03635         } 
<a name="l03636"></a>03636  
<a name="l03637"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a39a71c0c078f648de0e716ed59a0446a">03637</a>         <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">Node::iterator</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a39a71c0c078f648de0e716ed59a0446a" title="Get a Child node iterator that references the first child Node.">Node::begin</a>()<span class="keyword"> const </span>
<a name="l03638"></a>03638 <span class="keyword">        </span>{ 
<a name="l03639"></a>03639                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1b84d9f01a7c786aae85bf365aa5fd7a" title="An iterator for child Nodes.">iterator</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild : 0, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03640"></a>03640         } 
<a name="l03641"></a>03641  
<a name="l03642"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1f083209c52d7af4a354db2b3f198cf8">03642</a>         <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">Node::iterator</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1f083209c52d7af4a354db2b3f198cf8" title="Get a Child node iterator that references one past the last child Node.">Node::end</a>()<span class="keyword"> const </span>
<a name="l03643"></a>03643 <span class="keyword">        </span>{ 
<a name="l03644"></a>03644                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1b84d9f01a7c786aae85bf365aa5fd7a" title="An iterator for child Nodes.">iterator</a>(0, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03645"></a>03645         } 
<a name="l03646"></a>03646          
<a name="l03647"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9ede8da51d334d31167a6740e233c103">03647</a>         <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">Node::attribute_iterator</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9ede8da51d334d31167a6740e233c103" title="Get an Attribute iterator that references the first Attribute on this Node.">Node::attributes_begin</a>()<span class="keyword"> const </span>
<a name="l03648"></a>03648 <span class="keyword">        </span>{ 
<a name="l03649"></a>03649                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80e590c48449971c999e50a371a3b504" title="An iterator for Attribute members on this Node.">attribute_iterator</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute : 0, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03650"></a>03650         } 
<a name="l03651"></a>03651  
<a name="l03652"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ac2535dd3ebc22454993f09fb66ace134">03652</a>         <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">Node::attribute_iterator</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ac2535dd3ebc22454993f09fb66ace134" title="Get an Attribute iterator that references the one past the last Attribute on this Node...">Node::attributes_end</a>()<span class="keyword"> const </span>
<a name="l03653"></a>03653 <span class="keyword">        </span>{ 
<a name="l03654"></a>03654                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80e590c48449971c999e50a371a3b504" title="An iterator for Attribute members on this Node.">attribute_iterator</a>(0, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03655"></a>03655         } 
<a name="l03656"></a>03656  
<a name="l03657"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a5ae85504c26f8494c0ba048dc2370ac2">03657</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a5ae85504c26f8494c0ba048dc2370ac2" title="Compares the internal values to check equality.">Node::operator==</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; r)<span class="keyword"> const </span>
<a name="l03658"></a>03658 <span class="keyword">        </span>{ 
<a name="l03659"></a>03659                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> == r.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03660"></a>03660         } 
<a name="l03661"></a>03661  
<a name="l03662"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a2fdcc611f72c98bc18ef25c9be5dc8ef">03662</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a2fdcc611f72c98bc18ef25c9be5dc8ef" title="Compares the internal values to check inequality.">Node::operator!=</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; r)<span class="keyword"> const </span>
<a name="l03663"></a>03663 <span class="keyword">        </span>{ 
<a name="l03664"></a>03664                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> != r.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03665"></a>03665         } 
<a name="l03666"></a>03666  
<a name="l03667"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a509304b9bcc6e7891c6b4daa16168f94">03667</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a509304b9bcc6e7891c6b4daa16168f94" title="Compares the internal values to check for inequality.">Node::operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; r)<span class="keyword"> const </span>
<a name="l03668"></a>03668 <span class="keyword">        </span>{ 
<a name="l03669"></a>03669                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &lt; r.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03670"></a>03670         } 
<a name="l03671"></a>03671          
<a name="l03672"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a7fc3bf84e390269a115e546babf89dfd">03672</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a7fc3bf84e390269a115e546babf89dfd" title="Compares the internal values to check for inequality.">Node::operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; r)<span class="keyword"> const </span>
<a name="l03673"></a>03673 <span class="keyword">        </span>{ 
<a name="l03674"></a>03674                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &gt; r.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03675"></a>03675         } 
<a name="l03676"></a>03676          
<a name="l03677"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a01986a425fb67bb6157aea7f861f8729">03677</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a01986a425fb67bb6157aea7f861f8729" title="Compares the internal values to check for inequality.">Node::operator&lt;=</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; r)<span class="keyword"> const </span>
<a name="l03678"></a>03678 <span class="keyword">        </span>{ 
<a name="l03679"></a>03679                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &lt;= r.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03680"></a>03680         } 
<a name="l03681"></a>03681          
<a name="l03682"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a444f80194136237ebc7c971b1c837155">03682</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a444f80194136237ebc7c971b1c837155" title="Compares the internal values to check for inequality.">Node::operator&gt;=</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; r)<span class="keyword"> const </span>
<a name="l03683"></a>03683 <span class="keyword">        </span>{ 
<a name="l03684"></a>03684                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &gt;= r.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l03685"></a>03685         } 
<a name="l03686"></a>03686  
<a name="l03687"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a22c00132e42702d16468489ff0bd01d8">03687</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a22c00132e42702d16468489ff0bd01d8" title="Is this storing anything at all?">Node::Empty</a>()<span class="keyword"> const </span>
<a name="l03688"></a>03688 <span class="keyword">        </span>{ 
<a name="l03689"></a>03689                 <span class="keywordflow">return</span> !<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l03690"></a>03690         } 
<a name="l03691"></a>03691          
<a name="l03692"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24">03692</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Node::Name</a>()<span class="keyword"> const </span>
<a name="l03693"></a>03693 <span class="keyword">        </span>{ 
<a name="l03694"></a>03694                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Name) ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Name : <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l03695"></a>03695         } 
<a name="l03696"></a>03696  
<a name="l03697"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f">03697</a>         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Node::Type</a>()<span class="keyword"> const </span>
<a name="l03698"></a>03698 <span class="keyword">        </span>{ 
<a name="l03699"></a>03699                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? <span class="keyword">static_cast&lt;</span><a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a><span class="keyword">&gt;</span>((<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;header &amp; MemoryPage_type_mask) + 1) : NodeNull; 
<a name="l03700"></a>03700         } 
<a name="l03701"></a>03701          
<a name="l03702"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f">03702</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Node::Value</a>()<span class="keyword"> const </span>
<a name="l03703"></a>03703 <span class="keyword">        </span>{ 
<a name="l03704"></a>03704                 <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Value) ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Value : <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l03705"></a>03705         } 
<a name="l03706"></a>03706          
<a name="l03707"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4d3f74c2c2613c84376b1ab6f3ed19c9">03707</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4d3f74c2c2613c84376b1ab6f3ed19c9" title="Attempt to get a child Node with a given name.">Node::GetChild</a>(<span class="keyword">const</span> char_t* Name)<span class="keyword"> const </span>
<a name="l03708"></a>03708 <span class="keyword">        </span>{ 
<a name="l03709"></a>03709                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03710"></a>03710  
<a name="l03711"></a>03711                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild; i; i = i-&gt;GetNextSibling) 
<a name="l03712"></a>03712                         <span class="keywordflow">if</span> (i-&gt;Name &amp;&amp; strequal(Name, i-&gt;Name)) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(i); 
<a name="l03713"></a>03713  
<a name="l03714"></a>03714                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03715"></a>03715         } 
<a name="l03716"></a>03716  
<a name="l03717"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a338eeb27d2a0cf39823f228abb5d936c">03717</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a338eeb27d2a0cf39823f228abb5d936c" title="Attempt to get an Attribute on this Node with a given name.">Node::GetAttribute</a>(<span class="keyword">const</span> char_t* Name)<span class="keyword"> const </span>
<a name="l03718"></a>03718 <span class="keyword">        </span>{ 
<a name="l03719"></a>03719                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03720"></a>03720  
<a name="l03721"></a>03721                 <span class="keywordflow">for</span> (<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute; i; i = i-&gt;GetNextAttribute) 
<a name="l03722"></a>03722                         <span class="keywordflow">if</span> (i-&gt;Name &amp;&amp; strequal(Name, i-&gt;Name)) 
<a name="l03723"></a>03723                                 <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(i); 
<a name="l03724"></a>03724                  
<a name="l03725"></a>03725                 <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03726"></a>03726         } 
<a name="l03727"></a>03727          
<a name="l03728"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#abd5e18e840cbfc2f8336c20782bec488">03728</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">Node::GetNextSibling</a>(<span class="keyword">const</span> char_t* Name)<span class="keyword"> const </span>
<a name="l03729"></a>03729 <span class="keyword">        </span>{ 
<a name="l03730"></a>03730                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03731"></a>03731                  
<a name="l03732"></a>03732                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling; i; i = i-&gt;GetNextSibling) 
<a name="l03733"></a>03733                         <span class="keywordflow">if</span> (i-&gt;Name &amp;&amp; strequal(Name, i-&gt;Name)) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(i); 
<a name="l03734"></a>03734  
<a name="l03735"></a>03735                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03736"></a>03736         } 
<a name="l03737"></a>03737  
<a name="l03738"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb">03738</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">Node::GetNextSibling</a>()<span class="keyword"> const </span>
<a name="l03739"></a>03739 <span class="keyword">        </span>{ 
<a name="l03740"></a>03740                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03741"></a>03741                  
<a name="l03742"></a>03742                 <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling); 
<a name="l03743"></a>03743                 <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03744"></a>03744         } 
<a name="l03745"></a>03745  
<a name="l03746"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#adaf337574156c86bbdb76264c5451c8d">03746</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">Node::GetPreviousSibling</a>(<span class="keyword">const</span> char_t* Name)<span class="keyword"> const </span>
<a name="l03747"></a>03747 <span class="keyword">        </span>{ 
<a name="l03748"></a>03748                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03749"></a>03749                  
<a name="l03750"></a>03750                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c; i-&gt;GetNextSibling; i = i-&gt;prev_sibling_c) 
<a name="l03751"></a>03751                         <span class="keywordflow">if</span> (i-&gt;Name &amp;&amp; strequal(Name, i-&gt;Name)) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(i); 
<a name="l03752"></a>03752  
<a name="l03753"></a>03753                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03754"></a>03754         } 
<a name="l03755"></a>03755  
<a name="l03756"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3">03756</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">Node::GetPreviousSibling</a>()<span class="keyword"> const </span>
<a name="l03757"></a>03757 <span class="keyword">        </span>{ 
<a name="l03758"></a>03758                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03759"></a>03759                  
<a name="l03760"></a>03760                 <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c-&gt;GetNextSibling) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c); 
<a name="l03761"></a>03761                 <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03762"></a>03762         } 
<a name="l03763"></a>03763  
<a name="l03764"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d">03764</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">Node::GetParent</a>()<span class="keyword"> const </span>
<a name="l03765"></a>03765 <span class="keyword">        </span>{ 
<a name="l03766"></a>03766                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetParent) : <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03767"></a>03767         } 
<a name="l03768"></a>03768  
<a name="l03769"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a19eeb7427a38ea7d8543ed0ae8508b2c">03769</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a19eeb7427a38ea7d8543ed0ae8508b2c" title="Attempt to retrieve the root Node, or the most base Node containing this Node.">Node::GetRoot</a>()<span class="keyword"> const </span>
<a name="l03770"></a>03770 <span class="keyword">        </span>{ 
<a name="l03771"></a>03771                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03772"></a>03772  
<a name="l03773"></a>03773                 MemoryPage* page = <span class="keyword">reinterpret_cast&lt;</span>MemoryPage*<span class="keyword">&gt;</span>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;header &amp; MemoryPage_pointer_mask); 
<a name="l03774"></a>03774  
<a name="l03775"></a>03775                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(static_cast&lt;DocumentStruct*&gt;(page-&gt;allocator)); 
<a name="l03776"></a>03776         } 
<a name="l03777"></a>03777  
<a name="l03778"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a97363b63a1963e28bf7503c32b0702e5">03778</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a97363b63a1963e28bf7503c32b0702e5" title="Retrieve the value of this(or a child&amp;#39;s) Nodes PCDATA child Node.">Node::ChildValue</a>()<span class="keyword"> const </span>
<a name="l03779"></a>03779 <span class="keyword">        </span>{ 
<a name="l03780"></a>03780                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l03781"></a>03781                  
<a name="l03782"></a>03782                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild; i; i = i-&gt;GetNextSibling) 
<a name="l03783"></a>03783                 { 
<a name="l03784"></a>03784                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type = <span class="keyword">static_cast&lt;</span><a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a><span class="keyword">&gt;</span>((i-&gt;header &amp; MemoryPage_type_mask) + 1); 
<a name="l03785"></a>03785  
<a name="l03786"></a>03786                         <span class="keywordflow">if</span> (i-&gt;Value &amp;&amp; (Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a> || Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a353968e806a751a6da4f7ac115b4ab55" title="Character data, i.e. &amp;#39;&amp;lt;![CDATA[text]]&amp;gt;&amp;#39;.">NodeCdata</a>)) 
<a name="l03787"></a>03787                                 <span class="keywordflow">return</span> i-&gt;Value; 
<a name="l03788"></a>03788                 } 
<a name="l03789"></a>03789  
<a name="l03790"></a>03790                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l03791"></a>03791         } 
<a name="l03792"></a>03792  
<a name="l03793"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aa8ce075bf47cb586b586800576569744">03793</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a97363b63a1963e28bf7503c32b0702e5" title="Retrieve the value of this(or a child&amp;#39;s) Nodes PCDATA child Node.">Node::ChildValue</a>(<span class="keyword">const</span> char_t* Name)<span class="keyword"> const </span>
<a name="l03794"></a>03794 <span class="keyword">        </span>{ 
<a name="l03795"></a>03795                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4d3f74c2c2613c84376b1ab6f3ed19c9" title="Attempt to get a child Node with a given name.">GetChild</a>(Name).<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a97363b63a1963e28bf7503c32b0702e5" title="Retrieve the value of this(or a child&amp;#39;s) Nodes PCDATA child Node.">ChildValue</a>(); 
<a name="l03796"></a>03796         } 
<a name="l03797"></a>03797  
<a name="l03798"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae484caac4f1fb2a4b7767ddfed28bf0c">03798</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae484caac4f1fb2a4b7767ddfed28bf0c" title="Get the First Attribute in this Node.">Node::GetFirstAttribute</a>()<span class="keyword"> const </span>
<a name="l03799"></a>03799 <span class="keyword">        </span>{ 
<a name="l03800"></a>03800                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute) : Attribute(); 
<a name="l03801"></a>03801         } 
<a name="l03802"></a>03802  
<a name="l03803"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9c5ff28c5d1a04ca38da1d7df118ed5f">03803</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9c5ff28c5d1a04ca38da1d7df118ed5f" title="Get the Last Attribute in this Node.">Node::GetLastAttribute</a>()<span class="keyword"> const </span>
<a name="l03804"></a>03804 <span class="keyword">        </span>{ 
<a name="l03805"></a>03805                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute ? <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute-&gt;prev_attribute_c) : <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03806"></a>03806         } 
<a name="l03807"></a>03807  
<a name="l03808"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6">03808</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">Node::GetFirstChild</a>()<span class="keyword"> const </span>
<a name="l03809"></a>03809 <span class="keyword">        </span>{ 
<a name="l03810"></a>03810                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild) : <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03811"></a>03811         } 
<a name="l03812"></a>03812  
<a name="l03813"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a10f1a568c8c2c691126f1a9ed2afb922">03813</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a10f1a568c8c2c691126f1a9ed2afb922" title="Get the last child Node of this Node.">Node::GetLastChild</a>()<span class="keyword"> const </span>
<a name="l03814"></a>03814 <span class="keyword">        </span>{ 
<a name="l03815"></a>03815                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild-&gt;prev_sibling_c) : <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03816"></a>03816         } 
<a name="l03817"></a>03817  
<a name="l03818"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f">03818</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">Node::SetName</a>(<span class="keyword">const</span> char_t* rhs) 
<a name="l03819"></a>03819         { 
<a name="l03820"></a>03820                 <span class="keywordflow">switch</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()) 
<a name="l03821"></a>03821                 { 
<a name="l03822"></a>03822                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a>: 
<a name="l03823"></a>03823                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>: 
<a name="l03824"></a>03824                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>: 
<a name="l03825"></a>03825                         <span class="keywordflow">return</span> strcpy_insitu(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Name, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;header, MemoryPage_Name_allocated_mask, rhs); 
<a name="l03826"></a>03826  
<a name="l03827"></a>03827                 <span class="keywordflow">default</span>: 
<a name="l03828"></a>03828                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03829"></a>03829                 } 
<a name="l03830"></a>03830         } 
<a name="l03831"></a>03831                  
<a name="l03832"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a50ff9948dac721339561ed3442fb7034">03832</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a50ff9948dac721339561ed3442fb7034" title="Set the value of this.">Node::SetValue</a>(<span class="keyword">const</span> char_t* rhs) 
<a name="l03833"></a>03833         { 
<a name="l03834"></a>03834                 <span class="keywordflow">switch</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()) 
<a name="l03835"></a>03835                 { 
<a name="l03836"></a>03836                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a>: 
<a name="l03837"></a>03837                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a353968e806a751a6da4f7ac115b4ab55" title="Character data, i.e. &amp;#39;&amp;lt;![CDATA[text]]&amp;gt;&amp;#39;.">NodeCdata</a>: 
<a name="l03838"></a>03838                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a>: 
<a name="l03839"></a>03839                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a25b778cb61ae0a9f15590cad5e0120d2" title="Comment tag, i.e. &amp;#39;&amp;#39;.">NodeComment</a>: 
<a name="l03840"></a>03840                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3aca750034b7e4a34d53cfd3399b2bcd99" title="Document type declaration, i.e. &amp;#39;&amp;lt;!DOCTYPE doc&amp;gt;&amp;#39;.">NodeDocType</a>: 
<a name="l03841"></a>03841                         <span class="keywordflow">return</span> strcpy_insitu(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Value, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;header, MemoryPage_Value_allocated_mask, rhs); 
<a name="l03842"></a>03842  
<a name="l03843"></a>03843                 <span class="keywordflow">default</span>: 
<a name="l03844"></a>03844                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l03845"></a>03845                 } 
<a name="l03846"></a>03846         } 
<a name="l03847"></a>03847  
<a name="l03848"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a09ae0a1499b13de2db447fc95dd3b747">03848</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a09ae0a1499b13de2db447fc95dd3b747" title="Creates an Attribute and puts it at the end of this Nodes attributes.">Node::AppendAttribute</a>(<span class="keyword">const</span> char_t* Name) 
<a name="l03849"></a>03849         { 
<a name="l03850"></a>03850                 <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03851"></a>03851                  
<a name="l03852"></a>03852                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a(AppendAttribute_ll(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>, GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>))); 
<a name="l03853"></a>03853                 a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#af669654308122897f98858563375bf4c" title="Set the name of this attribute.">SetName</a>(Name); 
<a name="l03854"></a>03854                  
<a name="l03855"></a>03855                 <span class="keywordflow">return</span> a; 
<a name="l03856"></a>03856         } 
<a name="l03857"></a>03857  
<a name="l03858"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aa64f2de951032177731e8cba7282529d">03858</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aa64f2de951032177731e8cba7282529d" title="Creates an Attribute and puts it at the begining of this Nodes attributes.">Node::PrependAttribute</a>(<span class="keyword">const</span> char_t* Name) 
<a name="l03859"></a>03859         { 
<a name="l03860"></a>03860                 <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03861"></a>03861                  
<a name="l03862"></a>03862                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a(allocate_attribute(GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>))); 
<a name="l03863"></a>03863                 <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03864"></a>03864  
<a name="l03865"></a>03865                 a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#af669654308122897f98858563375bf4c" title="Set the name of this attribute.">SetName</a>(Name); 
<a name="l03866"></a>03866                  
<a name="l03867"></a>03867                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* head = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute; 
<a name="l03868"></a>03868  
<a name="l03869"></a>03869                 <span class="keywordflow">if</span> (head) 
<a name="l03870"></a>03870                 { 
<a name="l03871"></a>03871                         a._attr-&gt;prev_attribute_c = head-&gt;prev_attribute_c; 
<a name="l03872"></a>03872                         head-&gt;prev_attribute_c = a._attr; 
<a name="l03873"></a>03873                 } 
<a name="l03874"></a>03874                 <span class="keywordflow">else</span> 
<a name="l03875"></a>03875                         a._attr-&gt;prev_attribute_c = a._attr; 
<a name="l03876"></a>03876                  
<a name="l03877"></a>03877                 a._attr-&gt;GetNextAttribute = head; 
<a name="l03878"></a>03878                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute = a._attr; 
<a name="l03879"></a>03879                                  
<a name="l03880"></a>03880                 <span class="keywordflow">return</span> a; 
<a name="l03881"></a>03881         } 
<a name="l03882"></a>03882  
<a name="l03883"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0e4f1d13d8fb9c29068c01d8a0ac4217">03883</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0e4f1d13d8fb9c29068c01d8a0ac4217" title="Creates an Attribute and puts it into the list of this Nodes attributes.">Node::InsertAttributeBefore</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; attr) 
<a name="l03884"></a>03884         { 
<a name="l03885"></a>03885                 <span class="keywordflow">if</span> ((<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) || attr.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6d0157a562f283e9c87d1cc46b3405cc" title="Is this storing anything at all?">Empty</a>()) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03886"></a>03886                  
<a name="l03887"></a>03887                 <span class="comment">// check that GetAttribute belongs to *this </span>
<a name="l03888"></a>03888                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* cur = attr._attr; 
<a name="l03889"></a>03889  
<a name="l03890"></a>03890                 <span class="keywordflow">while</span> (cur-&gt;prev_attribute_c-&gt;GetNextAttribute) cur = cur-&gt;prev_attribute_c; 
<a name="l03891"></a>03891  
<a name="l03892"></a>03892                 <span class="keywordflow">if</span> (cur != <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03893"></a>03893  
<a name="l03894"></a>03894                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a(allocate_attribute(GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>))); 
<a name="l03895"></a>03895                 <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03896"></a>03896  
<a name="l03897"></a>03897                 a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#af669654308122897f98858563375bf4c" title="Set the name of this attribute.">SetName</a>(Name); 
<a name="l03898"></a>03898  
<a name="l03899"></a>03899                 <span class="keywordflow">if</span> (attr._attr-&gt;prev_attribute_c-&gt;GetNextAttribute) 
<a name="l03900"></a>03900                         attr._attr-&gt;prev_attribute_c-&gt;GetNextAttribute = a._attr; 
<a name="l03901"></a>03901                 <span class="keywordflow">else</span> 
<a name="l03902"></a>03902                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute = a._attr; 
<a name="l03903"></a>03903                  
<a name="l03904"></a>03904                 a._attr-&gt;prev_attribute_c = attr._attr-&gt;prev_attribute_c; 
<a name="l03905"></a>03905                 a._attr-&gt;GetNextAttribute = attr._attr; 
<a name="l03906"></a>03906                 attr._attr-&gt;prev_attribute_c = a._attr; 
<a name="l03907"></a>03907                                  
<a name="l03908"></a>03908                 <span class="keywordflow">return</span> a; 
<a name="l03909"></a>03909         } 
<a name="l03910"></a>03910  
<a name="l03911"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a8444ca5b7b7411fb9fc4c002ea7beb9e">03911</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a8444ca5b7b7411fb9fc4c002ea7beb9e" title="Creates an Attribute and puts it into the list of this Nodes attributes.">Node::InsertAttributeAfter</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; attr) 
<a name="l03912"></a>03912         { 
<a name="l03913"></a>03913                 <span class="keywordflow">if</span> ((<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a> &amp;&amp; <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) || attr.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a6d0157a562f283e9c87d1cc46b3405cc" title="Is this storing anything at all?">Empty</a>()) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03914"></a>03914                  
<a name="l03915"></a>03915                 <span class="comment">// check that GetAttribute belongs to *this </span>
<a name="l03916"></a>03916                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* cur = attr._attr; 
<a name="l03917"></a>03917  
<a name="l03918"></a>03918                 <span class="keywordflow">while</span> (cur-&gt;prev_attribute_c-&gt;GetNextAttribute) cur = cur-&gt;prev_attribute_c; 
<a name="l03919"></a>03919  
<a name="l03920"></a>03920                 <span class="keywordflow">if</span> (cur != <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03921"></a>03921  
<a name="l03922"></a>03922                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a(allocate_attribute(GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>))); 
<a name="l03923"></a>03923                 <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03924"></a>03924  
<a name="l03925"></a>03925                 a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#af669654308122897f98858563375bf4c" title="Set the name of this attribute.">SetName</a>(Name); 
<a name="l03926"></a>03926  
<a name="l03927"></a>03927                 <span class="keywordflow">if</span> (attr._attr-&gt;GetNextAttribute) 
<a name="l03928"></a>03928                         attr._attr-&gt;GetNextAttribute-&gt;prev_attribute_c = a._attr; 
<a name="l03929"></a>03929                 <span class="keywordflow">else</span> 
<a name="l03930"></a>03930                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute-&gt;prev_attribute_c = a._attr; 
<a name="l03931"></a>03931                  
<a name="l03932"></a>03932                 a._attr-&gt;GetNextAttribute = attr._attr-&gt;GetNextAttribute; 
<a name="l03933"></a>03933                 a._attr-&gt;prev_attribute_c = attr._attr; 
<a name="l03934"></a>03934                 attr._attr-&gt;GetNextAttribute = a._attr; 
<a name="l03935"></a>03935  
<a name="l03936"></a>03936                 <span class="keywordflow">return</span> a; 
<a name="l03937"></a>03937         } 
<a name="l03938"></a>03938  
<a name="l03939"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33de8cdb7ed8694acac79aedc81523c9">03939</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33de8cdb7ed8694acac79aedc81523c9" title="Copies an Attribute and puts the copy at the end of this Nodes attributes.">Node::AppendCopy</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; proto) 
<a name="l03940"></a>03940         { 
<a name="l03941"></a>03941                 <span class="keywordflow">if</span> (!proto) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03942"></a>03942  
<a name="l03943"></a>03943                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a09ae0a1499b13de2db447fc95dd3b747" title="Creates an Attribute and puts it at the end of this Nodes attributes.">AppendAttribute</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>()); 
<a name="l03944"></a>03944                 Result.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>()); 
<a name="l03945"></a>03945  
<a name="l03946"></a>03946                 <span class="keywordflow">return</span> Result; 
<a name="l03947"></a>03947         } 
<a name="l03948"></a>03948  
<a name="l03949"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae5bd358ec34b0c49c6e8caea073bcde6">03949</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae5bd358ec34b0c49c6e8caea073bcde6" title="Copies an Attribute and puts the copy at the beginning of this Nodes attributes.">Node::PrependCopy</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; proto) 
<a name="l03950"></a>03950         { 
<a name="l03951"></a>03951                 <span class="keywordflow">if</span> (!proto) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03952"></a>03952  
<a name="l03953"></a>03953                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aa64f2de951032177731e8cba7282529d" title="Creates an Attribute and puts it at the begining of this Nodes attributes.">PrependAttribute</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>()); 
<a name="l03954"></a>03954                 Result.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>()); 
<a name="l03955"></a>03955  
<a name="l03956"></a>03956                 <span class="keywordflow">return</span> Result; 
<a name="l03957"></a>03957         } 
<a name="l03958"></a>03958  
<a name="l03959"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae866210535227753bcd02aac8bac9e9e">03959</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae866210535227753bcd02aac8bac9e9e" title="Copies an Attribute and puts the copy into the list of this Nodes attributes.">Node::InsertCopyAfter</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; attr) 
<a name="l03960"></a>03960         { 
<a name="l03961"></a>03961                 <span class="keywordflow">if</span> (!proto) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03962"></a>03962  
<a name="l03963"></a>03963                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a8444ca5b7b7411fb9fc4c002ea7beb9e" title="Creates an Attribute and puts it into the list of this Nodes attributes.">InsertAttributeAfter</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>(), attr); 
<a name="l03964"></a>03964                 Result.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>()); 
<a name="l03965"></a>03965  
<a name="l03966"></a>03966                 <span class="keywordflow">return</span> Result; 
<a name="l03967"></a>03967         } 
<a name="l03968"></a>03968  
<a name="l03969"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1491dda93107e3b3ea095e717698e587">03969</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1491dda93107e3b3ea095e717698e587" title="Copies an Attribute and puts the copy into the list of this Nodes attributes.">Node::InsertCopyBefore</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; attr) 
<a name="l03970"></a>03970         { 
<a name="l03971"></a>03971                 <span class="keywordflow">if</span> (!proto) <span class="keywordflow">return</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>(); 
<a name="l03972"></a>03972  
<a name="l03973"></a>03973                 <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0e4f1d13d8fb9c29068c01d8a0ac4217" title="Creates an Attribute and puts it into the list of this Nodes attributes.">InsertAttributeBefore</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>(), attr); 
<a name="l03974"></a>03974                 Result.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a470512fcd8b4f7609319bf85df100aaa" title="Set the value of this.">SetValue</a>(proto.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>()); 
<a name="l03975"></a>03975  
<a name="l03976"></a>03976                 <span class="keywordflow">return</span> Result; 
<a name="l03977"></a>03977         } 
<a name="l03978"></a>03978  
<a name="l03979"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4971850b72467fcdcf1b3beeb09f26cf">03979</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4971850b72467fcdcf1b3beeb09f26cf" title="Creates a Node and makes it a child of this one.">Node::AppendChild</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type) 
<a name="l03980"></a>03980         { 
<a name="l03981"></a>03981                 <span class="keywordflow">if</span> (!allow_InsertChild(this-&gt;<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>(), Type)) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03982"></a>03982                  
<a name="l03983"></a>03983                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n(AppendNode(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>, GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>), Type)); 
<a name="l03984"></a>03984  
<a name="l03985"></a>03985                 <span class="keywordflow">if</span> (Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(<a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;xml&quot;</span>)); 
<a name="l03986"></a>03986  
<a name="l03987"></a>03987                 <span class="keywordflow">return</span> n; 
<a name="l03988"></a>03988         } 
<a name="l03989"></a>03989  
<a name="l03990"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a959da20ad42a837b64889008247a5c21">03990</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a959da20ad42a837b64889008247a5c21" title="Creates a Node and makes it a child of this one, and puts at the beginning of the Child Nodes...">Node::PrependChild</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type) 
<a name="l03991"></a>03991         { 
<a name="l03992"></a>03992                 <span class="keywordflow">if</span> (!allow_InsertChild(this-&gt;<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>(), Type)) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03993"></a>03993                  
<a name="l03994"></a>03994                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n(allocate_node(GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>), Type)); 
<a name="l03995"></a>03995                 <span class="keywordflow">if</span> (!n) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l03996"></a>03996  
<a name="l03997"></a>03997                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetParent = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l03998"></a>03998  
<a name="l03999"></a>03999                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* head = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild; 
<a name="l04000"></a>04000  
<a name="l04001"></a>04001                 <span class="keywordflow">if</span> (head) 
<a name="l04002"></a>04002                 { 
<a name="l04003"></a>04003                         n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c = head-&gt;prev_sibling_c; 
<a name="l04004"></a>04004                         head-&gt;prev_sibling_c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04005"></a>04005                 } 
<a name="l04006"></a>04006                 <span class="keywordflow">else</span> 
<a name="l04007"></a>04007                         n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04008"></a>04008                  
<a name="l04009"></a>04009                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling = head; 
<a name="l04010"></a>04010                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04011"></a>04011                                  
<a name="l04012"></a>04012                 <span class="keywordflow">if</span> (Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(<a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;xml&quot;</span>)); 
<a name="l04013"></a>04013  
<a name="l04014"></a>04014                 <span class="keywordflow">return</span> n; 
<a name="l04015"></a>04015         } 
<a name="l04016"></a>04016  
<a name="l04017"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11be362cee3fc88c276076c8642189ab">04017</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11be362cee3fc88c276076c8642189ab" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">Node::InsertChildBefore</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l04018"></a>04018         { 
<a name="l04019"></a>04019                 <span class="keywordflow">if</span> (!allow_InsertChild(this-&gt;<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>(), Type)) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04020"></a>04020                 <span class="keywordflow">if</span> (!node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> || node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetParent != <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04021"></a>04021          
<a name="l04022"></a>04022                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n(allocate_node(GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>), Type)); 
<a name="l04023"></a>04023                 <span class="keywordflow">if</span> (!n) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04024"></a>04024  
<a name="l04025"></a>04025                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetParent = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04026"></a>04026                  
<a name="l04027"></a>04027                 <span class="keywordflow">if</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c-&gt;GetNextSibling) 
<a name="l04028"></a>04028                         node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c-&gt;GetNextSibling = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04029"></a>04029                 <span class="keywordflow">else</span> 
<a name="l04030"></a>04030                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04031"></a>04031                  
<a name="l04032"></a>04032                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c; 
<a name="l04033"></a>04033                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04034"></a>04034                 node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04035"></a>04035  
<a name="l04036"></a>04036                 <span class="keywordflow">if</span> (Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(<a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;xml&quot;</span>)); 
<a name="l04037"></a>04037  
<a name="l04038"></a>04038                 <span class="keywordflow">return</span> n; 
<a name="l04039"></a>04039         } 
<a name="l04040"></a>04040  
<a name="l04041"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#affc4d9cc0ea7c89bac58d91a432af2ef">04041</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#affc4d9cc0ea7c89bac58d91a432af2ef" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">Node::InsertChildAfter</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">NodeType</a> Type, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l04042"></a>04042         { 
<a name="l04043"></a>04043                 <span class="keywordflow">if</span> (!allow_InsertChild(this-&gt;<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>(), Type)) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04044"></a>04044                 <span class="keywordflow">if</span> (!node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> || node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetParent != <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04045"></a>04045          
<a name="l04046"></a>04046                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n(allocate_node(GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>), Type)); 
<a name="l04047"></a>04047                 <span class="keywordflow">if</span> (!n) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04048"></a>04048  
<a name="l04049"></a>04049                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetParent = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04050"></a>04050          
<a name="l04051"></a>04051                 <span class="keywordflow">if</span> (node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling) 
<a name="l04052"></a>04052                         node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling-&gt;prev_sibling_c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04053"></a>04053                 <span class="keywordflow">else</span> 
<a name="l04054"></a>04054                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild-&gt;prev_sibling_c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04055"></a>04055                  
<a name="l04056"></a>04056                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling; 
<a name="l04057"></a>04057                 n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04058"></a>04058                 node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04059"></a>04059  
<a name="l04060"></a>04060                 <span class="keywordflow">if</span> (Type == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>) n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(<a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;xml&quot;</span>)); 
<a name="l04061"></a>04061  
<a name="l04062"></a>04062                 <span class="keywordflow">return</span> n; 
<a name="l04063"></a>04063         } 
<a name="l04064"></a>04064  
<a name="l04065"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a7e9b4518e4d12517bc5ff756054e7395">04065</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4971850b72467fcdcf1b3beeb09f26cf" title="Creates a Node and makes it a child of this one.">Node::AppendChild</a>(<span class="keyword">const</span> char_t* Name) 
<a name="l04066"></a>04066         { 
<a name="l04067"></a>04067                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4971850b72467fcdcf1b3beeb09f26cf" title="Creates a Node and makes it a child of this one.">AppendChild</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>); 
<a name="l04068"></a>04068  
<a name="l04069"></a>04069                 Result.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(Name); 
<a name="l04070"></a>04070  
<a name="l04071"></a>04071                 <span class="keywordflow">return</span> Result; 
<a name="l04072"></a>04072         } 
<a name="l04073"></a>04073  
<a name="l04074"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a643a7e8d8cbee41647e4e1121660b5d0">04074</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a959da20ad42a837b64889008247a5c21" title="Creates a Node and makes it a child of this one, and puts at the beginning of the Child Nodes...">Node::PrependChild</a>(<span class="keyword">const</span> char_t* Name) 
<a name="l04075"></a>04075         { 
<a name="l04076"></a>04076                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a959da20ad42a837b64889008247a5c21" title="Creates a Node and makes it a child of this one, and puts at the beginning of the Child Nodes...">PrependChild</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>); 
<a name="l04077"></a>04077  
<a name="l04078"></a>04078                 Result.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(Name); 
<a name="l04079"></a>04079  
<a name="l04080"></a>04080                 <span class="keywordflow">return</span> Result; 
<a name="l04081"></a>04081         } 
<a name="l04082"></a>04082  
<a name="l04083"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a3a2bfe2c267c3ceb96dc4bdae6651a33">04083</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#affc4d9cc0ea7c89bac58d91a432af2ef" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">Node::InsertChildAfter</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l04084"></a>04084         { 
<a name="l04085"></a>04085                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#affc4d9cc0ea7c89bac58d91a432af2ef" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">InsertChildAfter</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>, node); 
<a name="l04086"></a>04086  
<a name="l04087"></a>04087                 Result.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(Name); 
<a name="l04088"></a>04088  
<a name="l04089"></a>04089                 <span class="keywordflow">return</span> Result; 
<a name="l04090"></a>04090         } 
<a name="l04091"></a>04091  
<a name="l04092"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a8602cbfd1272b3c42c0ca1675076f3b2">04092</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11be362cee3fc88c276076c8642189ab" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">Node::InsertChildBefore</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l04093"></a>04093         { 
<a name="l04094"></a>04094                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11be362cee3fc88c276076c8642189ab" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">InsertChildBefore</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>, node); 
<a name="l04095"></a>04095  
<a name="l04096"></a>04096                 Result.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">SetName</a>(Name); 
<a name="l04097"></a>04097  
<a name="l04098"></a>04098                 <span class="keywordflow">return</span> Result; 
<a name="l04099"></a>04099         } 
<a name="l04100"></a>04100  
<a name="l04101"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aa187049e72e1d7c8e055ba60b4946dd3">04101</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33de8cdb7ed8694acac79aedc81523c9" title="Copies an Attribute and puts the copy at the end of this Nodes attributes.">Node::AppendCopy</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; proto) 
<a name="l04102"></a>04102         { 
<a name="l04103"></a>04103                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4971850b72467fcdcf1b3beeb09f26cf" title="Creates a Node and makes it a child of this one.">AppendChild</a>(proto.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()); 
<a name="l04104"></a>04104  
<a name="l04105"></a>04105                 <span class="keywordflow">if</span> (Result) recursive_copy_skip(Result, proto, Result); 
<a name="l04106"></a>04106  
<a name="l04107"></a>04107                 <span class="keywordflow">return</span> Result; 
<a name="l04108"></a>04108         } 
<a name="l04109"></a>04109  
<a name="l04110"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a39b55aafd5a79bcd8dc5fdaed1a0ef10">04110</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae5bd358ec34b0c49c6e8caea073bcde6" title="Copies an Attribute and puts the copy at the beginning of this Nodes attributes.">Node::PrependCopy</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; proto) 
<a name="l04111"></a>04111         { 
<a name="l04112"></a>04112                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a959da20ad42a837b64889008247a5c21" title="Creates a Node and makes it a child of this one, and puts at the beginning of the Child Nodes...">PrependChild</a>(proto.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()); 
<a name="l04113"></a>04113  
<a name="l04114"></a>04114                 <span class="keywordflow">if</span> (Result) recursive_copy_skip(Result, proto, Result); 
<a name="l04115"></a>04115  
<a name="l04116"></a>04116                 <span class="keywordflow">return</span> Result; 
<a name="l04117"></a>04117         } 
<a name="l04118"></a>04118  
<a name="l04119"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#addb6e4bcd5a5c11e1275c01209b841ec">04119</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae866210535227753bcd02aac8bac9e9e" title="Copies an Attribute and puts the copy into the list of this Nodes attributes.">Node::InsertCopyAfter</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l04120"></a>04120         { 
<a name="l04121"></a>04121                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#affc4d9cc0ea7c89bac58d91a432af2ef" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">InsertChildAfter</a>(proto.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>(), node); 
<a name="l04122"></a>04122  
<a name="l04123"></a>04123                 <span class="keywordflow">if</span> (Result) recursive_copy_skip(Result, proto, Result); 
<a name="l04124"></a>04124  
<a name="l04125"></a>04125                 <span class="keywordflow">return</span> Result; 
<a name="l04126"></a>04126         } 
<a name="l04127"></a>04127  
<a name="l04128"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a14076565b03bb093d3a8ebf919f5fc6c">04128</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a1491dda93107e3b3ea095e717698e587" title="Copies an Attribute and puts the copy into the list of this Nodes attributes.">Node::InsertCopyBefore</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; proto, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l04129"></a>04129         { 
<a name="l04130"></a>04130                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> Result = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11be362cee3fc88c276076c8642189ab" title="Creates a Node and makes it a child of this one, and puts at the middle of the Child Nodes...">InsertChildBefore</a>(proto.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>(), node); 
<a name="l04131"></a>04131  
<a name="l04132"></a>04132                 <span class="keywordflow">if</span> (Result) recursive_copy_skip(Result, proto, Result); 
<a name="l04133"></a>04133  
<a name="l04134"></a>04134                 <span class="keywordflow">return</span> Result; 
<a name="l04135"></a>04135         } 
<a name="l04136"></a>04136  
<a name="l04137"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ab166876c5dd5a43a16eb0a4c110be7ca">04137</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9a0bec16ad12b7e0f7ed4cfd7c05a1f4" title="Remove specified Attribute.">Node::RemoveAttribute</a>(<span class="keyword">const</span> char_t* Name) 
<a name="l04138"></a>04138         { 
<a name="l04139"></a>04139                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9a0bec16ad12b7e0f7ed4cfd7c05a1f4" title="Remove specified Attribute.">RemoveAttribute</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a338eeb27d2a0cf39823f228abb5d936c" title="Attempt to get an Attribute on this Node with a given name.">GetAttribute</a>(Name)); 
<a name="l04140"></a>04140         } 
<a name="l04141"></a>04141  
<a name="l04142"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9a0bec16ad12b7e0f7ed4cfd7c05a1f4">04142</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9a0bec16ad12b7e0f7ed4cfd7c05a1f4" title="Remove specified Attribute.">Node::RemoveAttribute</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; a) 
<a name="l04143"></a>04143         { 
<a name="l04144"></a>04144                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> || !a._attr) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l04145"></a>04145  
<a name="l04146"></a>04146                 <span class="comment">// check that GetAttribute belongs to *this </span>
<a name="l04147"></a>04147                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* attr = a._attr; 
<a name="l04148"></a>04148  
<a name="l04149"></a>04149                 <span class="keywordflow">while</span> (attr-&gt;prev_attribute_c-&gt;GetNextAttribute) attr = attr-&gt;prev_attribute_c; 
<a name="l04150"></a>04150  
<a name="l04151"></a>04151                 <span class="keywordflow">if</span> (attr != <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l04152"></a>04152  
<a name="l04153"></a>04153                 <span class="keywordflow">if</span> (a._attr-&gt;GetNextAttribute) a._attr-&gt;GetNextAttribute-&gt;prev_attribute_c = a._attr-&gt;prev_attribute_c; 
<a name="l04154"></a>04154                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute) <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute-&gt;prev_attribute_c = a._attr-&gt;prev_attribute_c; 
<a name="l04155"></a>04155                  
<a name="l04156"></a>04156                 <span class="keywordflow">if</span> (a._attr-&gt;prev_attribute_c-&gt;GetNextAttribute) a._attr-&gt;prev_attribute_c-&gt;GetNextAttribute = a._attr-&gt;GetNextAttribute; 
<a name="l04157"></a>04157                 <span class="keywordflow">else</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstAttribute = a._attr-&gt;GetNextAttribute; 
<a name="l04158"></a>04158  
<a name="l04159"></a>04159                 destroy_attribute(a._attr, GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>)); 
<a name="l04160"></a>04160  
<a name="l04161"></a>04161                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l04162"></a>04162         } 
<a name="l04163"></a>04163  
<a name="l04164"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a2612e301caa54ac6af135b8fb11b2e25">04164</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a946bb656b94c9d3a561200cd2cd3ee11" title="Remove specified child element.">Node::RemoveChild</a>(<span class="keyword">const</span> char_t* Name) 
<a name="l04165"></a>04165         { 
<a name="l04166"></a>04166                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a946bb656b94c9d3a561200cd2cd3ee11" title="Remove specified child element.">RemoveChild</a>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a4d3f74c2c2613c84376b1ab6f3ed19c9" title="Attempt to get a child Node with a given name.">GetChild</a>(Name)); 
<a name="l04167"></a>04167         } 
<a name="l04168"></a>04168  
<a name="l04169"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a946bb656b94c9d3a561200cd2cd3ee11">04169</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a946bb656b94c9d3a561200cd2cd3ee11" title="Remove specified child element.">Node::RemoveChild</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; n) 
<a name="l04170"></a>04170         { 
<a name="l04171"></a>04171                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> || !n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> || n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetParent != <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l04172"></a>04172  
<a name="l04173"></a>04173                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling) n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling-&gt;prev_sibling_c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c; 
<a name="l04174"></a>04174                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild) <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild-&gt;prev_sibling_c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c; 
<a name="l04175"></a>04175                  
<a name="l04176"></a>04176                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c-&gt;GetNextSibling) n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c-&gt;GetNextSibling = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling; 
<a name="l04177"></a>04177                 <span class="keywordflow">else</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling; 
<a name="l04178"></a>04178                  
<a name="l04179"></a>04179                 destroy_node(n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>, GetAllocator(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>)); 
<a name="l04180"></a>04180  
<a name="l04181"></a>04181                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l04182"></a>04182         } 
<a name="l04183"></a>04183  
<a name="l04184"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a8a362455b50e54454f145f9109a85e49">04184</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a8a362455b50e54454f145f9109a85e49" title="Find a Node by an Attribute it has.">Node::FindChildbyAttribute</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> char_t* AttrName, <span class="keyword">const</span> char_t* AttrValue)<span class="keyword"> const </span>
<a name="l04185"></a>04185 <span class="keyword">        </span>{ 
<a name="l04186"></a>04186                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04187"></a>04187                  
<a name="l04188"></a>04188                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild; i; i = i-&gt;GetNextSibling) 
<a name="l04189"></a>04189                         <span class="keywordflow">if</span> (i-&gt;Name &amp;&amp; strequal(Name, i-&gt;Name)) 
<a name="l04190"></a>04190                         { 
<a name="l04191"></a>04191                                 <span class="keywordflow">for</span> (<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* a = i-&gt;GetFirstAttribute; a; a = a-&gt;GetNextAttribute) 
<a name="l04192"></a>04192                                         <span class="keywordflow">if</span> (strequal(AttrName, a-&gt;Name) &amp;&amp; strequal(AttrValue, a-&gt;Value)) 
<a name="l04193"></a>04193                                                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(i); 
<a name="l04194"></a>04194                         } 
<a name="l04195"></a>04195  
<a name="l04196"></a>04196                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04197"></a>04197         } 
<a name="l04198"></a>04198  
<a name="l04199"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#af6f0c0656e2a5cc7c79e032236b2b3b1">04199</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a8a362455b50e54454f145f9109a85e49" title="Find a Node by an Attribute it has.">Node::FindChildbyAttribute</a>(<span class="keyword">const</span> char_t* AttrName, <span class="keyword">const</span> char_t* AttrValue)<span class="keyword"> const </span>
<a name="l04200"></a>04200 <span class="keyword">        </span>{ 
<a name="l04201"></a>04201                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04202"></a>04202                  
<a name="l04203"></a>04203                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild; i; i = i-&gt;GetNextSibling) 
<a name="l04204"></a>04204                         <span class="keywordflow">for</span> (<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* a = i-&gt;GetFirstAttribute; a; a = a-&gt;GetNextAttribute) 
<a name="l04205"></a>04205                                 <span class="keywordflow">if</span> (strequal(AttrName, a-&gt;Name) &amp;&amp; strequal(AttrValue, a-&gt;Value)) 
<a name="l04206"></a>04206                                         <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(i); 
<a name="l04207"></a>04207  
<a name="l04208"></a>04208                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04209"></a>04209         } 
<a name="l04210"></a>04210  
<a name="l04211"></a>04211 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l04212"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0bf85dc0820ba204e7c9498c6651aec8">04212</a> <span class="preprocessor"></span>        String <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0bf85dc0820ba204e7c9498c6651aec8" title="Get the absolute path to this Node.">Node::Path</a>(char_t delimiter)<span class="keyword"> const </span>
<a name="l04213"></a>04213 <span class="keyword">        </span>{ 
<a name="l04214"></a>04214                 String Path; 
<a name="l04215"></a>04215  
<a name="l04216"></a>04216                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cursor = *<span class="keyword">this</span>; <span class="comment">// Make a copy. </span>
<a name="l04217"></a>04217                  
<a name="l04218"></a>04218                 Path = cursor.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>(); 
<a name="l04219"></a>04219  
<a name="l04220"></a>04220                 <span class="keywordflow">while</span> (cursor.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>()) 
<a name="l04221"></a>04221                 { 
<a name="l04222"></a>04222                         cursor = cursor.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l04223"></a>04223                          
<a name="l04224"></a>04224                         String temp = cursor.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>(); 
<a name="l04225"></a>04225                         temp += delimiter; 
<a name="l04226"></a>04226                         temp += Path; 
<a name="l04227"></a>04227                         Path.swap(temp); 
<a name="l04228"></a>04228                 } 
<a name="l04229"></a>04229  
<a name="l04230"></a>04230                 <span class="keywordflow">return</span> Path; 
<a name="l04231"></a>04231         } 
<a name="l04232"></a>04232 <span class="preprocessor">#endif </span>
<a name="l04233"></a>04233 <span class="preprocessor"></span> 
<a name="l04234"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#af2a9ac5c4e3252dca0e17720de093a9a">04234</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#af2a9ac5c4e3252dca0e17720de093a9a" title="Search for a node by Path consisting of node names and . or .. elements.">Node::FirstElementByPath</a>(<span class="keyword">const</span> char_t* Path, char_t delimiter)<span class="keyword"> const </span>
<a name="l04235"></a>04235 <span class="keyword">        </span>{ 
<a name="l04236"></a>04236                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> found = *<span class="keyword">this</span>; <span class="comment">// Current search context. </span>
<a name="l04237"></a>04237  
<a name="l04238"></a>04238                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> || !Path || !Path[0]) <span class="keywordflow">return</span> found; 
<a name="l04239"></a>04239  
<a name="l04240"></a>04240                 <span class="keywordflow">if</span> (Path[0] == delimiter) 
<a name="l04241"></a>04241                 { 
<a name="l04242"></a>04242                         <span class="comment">// Absolute Path; e.g. &#39;/foo/bar&#39; </span>
<a name="l04243"></a>04243                         found = found.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a19eeb7427a38ea7d8543ed0ae8508b2c" title="Attempt to retrieve the root Node, or the most base Node containing this Node.">GetRoot</a>(); 
<a name="l04244"></a>04244                         ++Path; 
<a name="l04245"></a>04245                 } 
<a name="l04246"></a>04246  
<a name="l04247"></a>04247                 <span class="keyword">const</span> char_t* Path_segment = Path; 
<a name="l04248"></a>04248  
<a name="l04249"></a>04249                 <span class="keywordflow">while</span> (*Path_segment == delimiter) ++Path_segment; 
<a name="l04250"></a>04250  
<a name="l04251"></a>04251                 <span class="keyword">const</span> char_t* Path_segment_end = Path_segment; 
<a name="l04252"></a>04252  
<a name="l04253"></a>04253                 <span class="keywordflow">while</span> (*Path_segment_end &amp;&amp; *Path_segment_end != delimiter) ++Path_segment_end; 
<a name="l04254"></a>04254  
<a name="l04255"></a>04255                 <span class="keywordflow">if</span> (Path_segment == Path_segment_end) <span class="keywordflow">return</span> found; 
<a name="l04256"></a>04256  
<a name="l04257"></a>04257                 <span class="keyword">const</span> char_t* NextSegment = Path_segment_end; 
<a name="l04258"></a>04258  
<a name="l04259"></a>04259                 <span class="keywordflow">while</span> (*NextSegment == delimiter) ++NextSegment; 
<a name="l04260"></a>04260  
<a name="l04261"></a>04261                 <span class="keywordflow">if</span> (*Path_segment == <span class="charliteral">&#39;.&#39;</span> &amp;&amp; Path_segment + 1 == Path_segment_end) 
<a name="l04262"></a>04262                         <span class="keywordflow">return</span> found.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#af2a9ac5c4e3252dca0e17720de093a9a" title="Search for a node by Path consisting of node names and . or .. elements.">FirstElementByPath</a>(NextSegment, delimiter); 
<a name="l04263"></a>04263                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*Path_segment == <span class="charliteral">&#39;.&#39;</span> &amp;&amp; *(Path_segment+1) == <span class="charliteral">&#39;.&#39;</span> &amp;&amp; Path_segment + 2 == Path_segment_end) 
<a name="l04264"></a>04264                         <span class="keywordflow">return</span> found.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>().<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#af2a9ac5c4e3252dca0e17720de093a9a" title="Search for a node by Path consisting of node names and . or .. elements.">FirstElementByPath</a>(NextSegment, delimiter); 
<a name="l04265"></a>04265                 <span class="keywordflow">else</span> 
<a name="l04266"></a>04266                 { 
<a name="l04267"></a>04267                         <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* j = found.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild; j; j = j-&gt;GetNextSibling) 
<a name="l04268"></a>04268                         { 
<a name="l04269"></a>04269                                 <span class="keywordflow">if</span> (j-&gt;Name &amp;&amp; strequalrange(j-&gt;Name, Path_segment, static_cast&lt;size_t&gt;(Path_segment_end - Path_segment))) 
<a name="l04270"></a>04270                                 { 
<a name="l04271"></a>04271                                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> subsearch = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(j).FirstElementByPath(NextSegment, delimiter); 
<a name="l04272"></a>04272  
<a name="l04273"></a>04273                                         <span class="keywordflow">if</span> (subsearch) <span class="keywordflow">return</span> subsearch; 
<a name="l04274"></a>04274                                 } 
<a name="l04275"></a>04275                         } 
<a name="l04276"></a>04276  
<a name="l04277"></a>04277                         <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04278"></a>04278                 } 
<a name="l04279"></a>04279         } 
<a name="l04280"></a>04280  
<a name="l04281"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0029d08d3689c36d882ada0c0c9cf6e9">04281</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0029d08d3689c36d882ada0c0c9cf6e9" title="Perform sophisticated (or whatever) algorithms on this and all descendant Nodes in the XML tree...">Node::Traverse</a>(<a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html" title="Used to call a function for_each member of the subtree of nodes descended from a specific node...">TreeWalker</a>&amp; walker) 
<a name="l04282"></a>04282         { 
<a name="l04283"></a>04283                 walker._Depth = -1; 
<a name="l04284"></a>04284                  
<a name="l04285"></a>04285                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> arg_begin = *<span class="keyword">this</span>; 
<a name="l04286"></a>04286                 <span class="keywordflow">if</span> (!walker.<a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a649d9e5a06542be0282d3d20994a62fc" title="Called on the root Node of the xml subtree when traversal begins.  By default this simply returns tru...">begin</a>(arg_begin)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l04287"></a>04287  
<a name="l04288"></a>04288                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l04289"></a>04289                                  
<a name="l04290"></a>04290                 <span class="keywordflow">if</span> (cur) 
<a name="l04291"></a>04291                 { 
<a name="l04292"></a>04292                         ++walker._Depth; 
<a name="l04293"></a>04293  
<a name="l04294"></a>04294                         <span class="keywordflow">do</span>  
<a name="l04295"></a>04295                         { 
<a name="l04296"></a>04296                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> arg_for_each = cur; 
<a name="l04297"></a>04297                                 <span class="keywordflow">if</span> (!walker.<a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a03267e73acac44809f16739fd00a536d" title="A Pure Virtual function that is expected to be implemented to create the desired behavior.  This is called on every Node that is traversed except the root node of the traversed subtree. Can be used to perform sophisticated searches of a portion of the xml document, alter the document on a large scale, gather statistics, or just about any other behavior that requires touching many nodes.">for_each</a>(arg_for_each)) 
<a name="l04298"></a>04298                                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l04299"></a>04299                                                  
<a name="l04300"></a>04300                                 <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>()) 
<a name="l04301"></a>04301                                 { 
<a name="l04302"></a>04302                                         ++walker._Depth; 
<a name="l04303"></a>04303                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l04304"></a>04304                                 } 
<a name="l04305"></a>04305                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) 
<a name="l04306"></a>04306                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l04307"></a>04307                                 <span class="keywordflow">else</span> 
<a name="l04308"></a>04308                                 { 
<a name="l04309"></a>04309                                         <span class="comment">// Borland C++ workaround </span>
<a name="l04310"></a>04310                                         <span class="keywordflow">while</span> (!cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>() &amp;&amp; cur != *<span class="keyword">this</span> &amp;&amp; (bool)cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>()) 
<a name="l04311"></a>04311                                         { 
<a name="l04312"></a>04312                                                 --walker._Depth; 
<a name="l04313"></a>04313                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l04314"></a>04314                                         } 
<a name="l04315"></a>04315                                                  
<a name="l04316"></a>04316                                         <span class="keywordflow">if</span> (cur != *<span class="keyword">this</span>) 
<a name="l04317"></a>04317                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l04318"></a>04318                                 } 
<a name="l04319"></a>04319                         } 
<a name="l04320"></a>04320                         <span class="keywordflow">while</span> (cur &amp;&amp; cur != *<span class="keyword">this</span>); 
<a name="l04321"></a>04321                 } 
<a name="l04322"></a>04322  
<a name="l04323"></a>04323                 assert(walker._Depth == -1); 
<a name="l04324"></a>04324  
<a name="l04325"></a>04325                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> arg_end = *<span class="keyword">this</span>; 
<a name="l04326"></a>04326                 <span class="keywordflow">return</span> walker.<a class="code" href="../../d5/d8d/classphys_1_1xml_1_1TreeWalker.html#a210f6d60579a152f89e651be797885b9" title="Called on the root Node of the xml subtree when traversal ends.  By default this simply returns true...">end</a>(arg_end); 
<a name="l04327"></a>04327         } 
<a name="l04328"></a>04328  
<a name="l04329"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a830a1833c4b4b012f1b4481e91ccb1ca">04329</a>         <span class="keywordtype">size_t</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a830a1833c4b4b012f1b4481e91ccb1ca" title="Get hash Value (unique for handles to the same object).">Node::HashValue</a>()<span class="keyword"> const </span>
<a name="l04330"></a>04330 <span class="keyword">        </span>{ 
<a name="l04331"></a>04331                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) / <span class="keyword">sizeof</span>(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>)); 
<a name="l04332"></a>04332         } 
<a name="l04333"></a>04333  
<a name="l04334"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0d2c64c909e7545d01b586fe9d0bd9d4">04334</a>         <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0d2c64c909e7545d01b586fe9d0bd9d4" title="Get internal pointer.">Node::InternalObject</a>()<span class="keyword"> const </span>
<a name="l04335"></a>04335 <span class="keyword">        </span>{ 
<a name="l04336"></a>04336                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04337"></a>04337         } 
<a name="l04338"></a>04338  
<a name="l04339"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#adbe10968a804a94552e1dc8223744406">04339</a>         <span class="keywordtype">void</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#adbe10968a804a94552e1dc8223744406" title="Output the XML document using a Writer.">Node::Print</a>(<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html" title="Interface for node printing (see Node::print).">Writer</a>&amp; WriterInstance, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Depth)<span class="keyword"> const </span>
<a name="l04340"></a>04340 <span class="keyword">        </span>{ 
<a name="l04341"></a>04341                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) <span class="keywordflow">return</span>; 
<a name="l04342"></a>04342  
<a name="l04343"></a>04343                 BufferedWriter buffered_WriterInstance(WriterInstance, DocumentEncoding); 
<a name="l04344"></a>04344  
<a name="l04345"></a>04345                 NodeOutput(buffered_WriterInstance, *<span class="keyword">this</span>, indent, flags, Depth); 
<a name="l04346"></a>04346         } 
<a name="l04347"></a>04347  
<a name="l04348"></a>04348 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l04349"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aa4076d6ea0db2e5f5c720770bf02349e">04349</a> <span class="preprocessor"></span>        <span class="keywordtype">void</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#adbe10968a804a94552e1dc8223744406" title="Output the XML document using a Writer.">Node::Print</a>(std::basic_ostream&lt;<span class="keywordtype">char</span>, std::char_traits&lt;char&gt; &gt;&amp; stream, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Depth)<span class="keyword"> const </span>
<a name="l04350"></a>04350 <span class="keyword">        </span>{ 
<a name="l04351"></a>04351                 <a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html" title="An implementation of Writer intended for writing std::ostreams.">WriterStream</a> WriterInstance(stream); 
<a name="l04352"></a>04352  
<a name="l04353"></a>04353                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#adbe10968a804a94552e1dc8223744406" title="Output the XML document using a Writer.">Print</a>(WriterInstance, indent, flags, DocumentEncoding, Depth); 
<a name="l04354"></a>04354         } 
<a name="l04355"></a>04355  
<a name="l04356"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ac705b62114dbc65a204ed2197891322c">04356</a>         <span class="keywordtype">void</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#adbe10968a804a94552e1dc8223744406" title="Output the XML document using a Writer.">Node::Print</a>(std::basic_ostream&lt;<span class="keywordtype">wchar_t</span>, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Depth)<span class="keyword"> const </span>
<a name="l04357"></a>04357 <span class="keyword">        </span>{ 
<a name="l04358"></a>04358                 <a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html" title="An implementation of Writer intended for writing std::ostreams.">WriterStream</a> WriterInstance(stream); 
<a name="l04359"></a>04359  
<a name="l04360"></a>04360                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#adbe10968a804a94552e1dc8223744406" title="Output the XML document using a Writer.">Print</a>(WriterInstance, indent, flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2bc9c8d42796901c8feaa25e17c56cef" title="The same document encoding wchar_t has (usually either UTF16 or UTF32).">Encodingwchar_t</a>, Depth); 
<a name="l04361"></a>04361         } 
<a name="l04362"></a>04362 <span class="preprocessor">#endif </span>
<a name="l04363"></a>04363 <span class="preprocessor"></span> 
<a name="l04364"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#add5c56d3e9bef050c774b9aa97240e98">04364</a>         ptrdiff_t <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#add5c56d3e9bef050c774b9aa97240e98" title="Get node Offset in parsed file/string (in char_t units) for debugging purposes.">Node::OffSetDebug</a>()<span class="keyword"> const </span>
<a name="l04365"></a>04365 <span class="keyword">        </span>{ 
<a name="l04366"></a>04366                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* r = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a19eeb7427a38ea7d8543ed0ae8508b2c" title="Attempt to retrieve the root Node, or the most base Node containing this Node.">GetRoot</a>().<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04367"></a>04367  
<a name="l04368"></a>04368                 <span class="keywordflow">if</span> (!r) <span class="keywordflow">return</span> -1; 
<a name="l04369"></a>04369  
<a name="l04370"></a>04370                 <span class="keyword">const</span> char_t* buffer = <span class="keyword">static_cast&lt;</span>DocumentStruct*<span class="keyword">&gt;</span>(r)-&gt;buffer; 
<a name="l04371"></a>04371  
<a name="l04372"></a>04372                 <span class="keywordflow">if</span> (!buffer) <span class="keywordflow">return</span> -1; 
<a name="l04373"></a>04373  
<a name="l04374"></a>04374                 <span class="keywordflow">switch</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()) 
<a name="l04375"></a>04375                 { 
<a name="l04376"></a>04376                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3acfe92e6bd275972917b95f08bd46e09f" title="A document tree&amp;#39;s absolute root.">NodeDocument</a>: 
<a name="l04377"></a>04377                         <span class="keywordflow">return</span> 0; 
<a name="l04378"></a>04378  
<a name="l04379"></a>04379                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>: 
<a name="l04380"></a>04380                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a1e3789aa995b7bf563ca8c43553ac035" title="Document declaration, i.e. &amp;#39;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;&amp;#39;.">NodeDeclaration</a>: 
<a name="l04381"></a>04381                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a>: 
<a name="l04382"></a>04382                         <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;header &amp; MemoryPage_Name_allocated_mask) ? -1 : <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Name - buffer; 
<a name="l04383"></a>04383  
<a name="l04384"></a>04384                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a>: 
<a name="l04385"></a>04385                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a353968e806a751a6da4f7ac115b4ab55" title="Character data, i.e. &amp;#39;&amp;lt;![CDATA[text]]&amp;gt;&amp;#39;.">NodeCdata</a>: 
<a name="l04386"></a>04386                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a25b778cb61ae0a9f15590cad5e0120d2" title="Comment tag, i.e. &amp;#39;&amp;#39;.">NodeComment</a>: 
<a name="l04387"></a>04387                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3aca750034b7e4a34d53cfd3399b2bcd99" title="Document type declaration, i.e. &amp;#39;&amp;lt;!DOCTYPE doc&amp;gt;&amp;#39;.">NodeDocType</a>: 
<a name="l04388"></a>04388                         <span class="keywordflow">return</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;header &amp; MemoryPage_Value_allocated_mask) ? -1 : <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;Value - buffer; 
<a name="l04389"></a>04389  
<a name="l04390"></a>04390                 <span class="keywordflow">default</span>: 
<a name="l04391"></a>04391                         <span class="keywordflow">return</span> -1; 
<a name="l04392"></a>04392                 } 
<a name="l04393"></a>04393         } 
<a name="l04394"></a>04394  
<a name="l04395"></a>04395 <span class="preprocessor">#ifdef __BORLANDC__ </span>
<a name="l04396"></a>04396 <span class="preprocessor"></span>        <span class="keywordtype">bool</span> operator&amp;&amp;(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; lhs, <span class="keywordtype">bool</span> rhs) 
<a name="l04397"></a>04397         { 
<a name="l04398"></a>04398                 <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)lhs &amp;&amp; rhs; 
<a name="l04399"></a>04399         } 
<a name="l04400"></a>04400  
<a name="l04401"></a>04401         <span class="keywordtype">bool</span> operator||(<span class="keyword">const</span> <a class="code" href="../../d0/ddc/classphys_1_1Node.html" title="This is a helper class which non-physics objects, such as lights, cameras, ribbon trails...">Node</a>&amp; lhs, <span class="keywordtype">bool</span> rhs) 
<a name="l04402"></a>04402         { 
<a name="l04403"></a>04403                 <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)lhs || rhs; 
<a name="l04404"></a>04404         } 
<a name="l04405"></a>04405 <span class="preprocessor">#endif </span>
<a name="l04406"></a>04406 <span class="preprocessor"></span> 
<a name="l04407"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#af4558d54684f8ff49b88396f2d0fecd6">04407</a>         <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#af4558d54684f8ff49b88396f2d0fecd6" title="Default Constructor, makes a blank iterator.">NodeIterator::NodeIterator</a>() 
<a name="l04408"></a>04408         { 
<a name="l04409"></a>04409         } 
<a name="l04410"></a>04410  
<a name="l04411"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#abb8a4e6882e921fa57e309c28a5f7fe9">04411</a>         <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#af4558d54684f8ff49b88396f2d0fecd6" title="Default Constructor, makes a blank iterator.">NodeIterator::NodeIterator</a>(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node): _wrap(node), _GetParent(node.GetParent()) 
<a name="l04412"></a>04412         { 
<a name="l04413"></a>04413         } 
<a name="l04414"></a>04414  
<a name="l04415"></a>04415         <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#af4558d54684f8ff49b88396f2d0fecd6" title="Default Constructor, makes a blank iterator.">NodeIterator::NodeIterator</a>(<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* ref, <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* GetParent): _wrap(ref), _GetParent(GetParent) 
<a name="l04416"></a>04416         { 
<a name="l04417"></a>04417         } 
<a name="l04418"></a>04418  
<a name="l04419"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a5c8ad72fbdbf0ae621fb041fef422a5e">04419</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a5c8ad72fbdbf0ae621fb041fef422a5e" title="Compares this NodeIterator to another NodeIterator for equality.">NodeIterator::operator==</a>(<span class="keyword">const</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a>&amp; rhs)<span class="keyword"> const </span>
<a name="l04420"></a>04420 <span class="keyword">        </span>{ 
<a name="l04421"></a>04421                 <span class="keywordflow">return</span> _wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> == rhs._wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> &amp;&amp; _GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> == rhs._GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04422"></a>04422         } 
<a name="l04423"></a>04423          
<a name="l04424"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a357923a57edc54937743fb865be7c3b3">04424</a>         <span class="keywordtype">bool</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a357923a57edc54937743fb865be7c3b3" title="Compares this NodeIterator to another NodeIterator for inequality.">NodeIterator::operator!=</a>(<span class="keyword">const</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a>&amp; rhs)<span class="keyword"> const </span>
<a name="l04425"></a>04425 <span class="keyword">        </span>{ 
<a name="l04426"></a>04426                 <span class="keywordflow">return</span> _wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> != rhs._wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> || _GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> != rhs._GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04427"></a>04427         } 
<a name="l04428"></a>04428  
<a name="l04429"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a3af8dd5a0b7b4c42cad57589ae3feb48">04429</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a3af8dd5a0b7b4c42cad57589ae3feb48" title="Deferences this Iterator.">NodeIterator::operator*</a>() 
<a name="l04430"></a>04430         { 
<a name="l04431"></a>04431                 assert(_wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l04432"></a>04432                 <span class="keywordflow">return</span> _wrap; 
<a name="l04433"></a>04433         } 
<a name="l04434"></a>04434  
<a name="l04435"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a32b9af9cfa38f9ffe5d9243b9c0565cb">04435</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>* <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a32b9af9cfa38f9ffe5d9243b9c0565cb" title="Get the pointer the Node this points to.">NodeIterator::operator-&gt;</a>() 
<a name="l04436"></a>04436         { 
<a name="l04437"></a>04437                 assert(_wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l04438"></a>04438                 <span class="keywordflow">return</span> &amp;_wrap; 
<a name="l04439"></a>04439         } 
<a name="l04440"></a>04440  
<a name="l04441"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#afeef29c3850b37585507873a2a076d8c">04441</a>         <span class="keyword">const</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a>&amp; <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#afeef29c3850b37585507873a2a076d8c" title="Increment the iterator to the next member of the container.">NodeIterator::operator++</a>() 
<a name="l04442"></a>04442         { 
<a name="l04443"></a>04443                 assert(_wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l04444"></a>04444                 _wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> = _wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetNextSibling; 
<a name="l04445"></a>04445                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l04446"></a>04446         } 
<a name="l04447"></a>04447  
<a name="l04448"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a3c0b341d6b90e9607bb6b3ae8f6dbfbf">04448</a>         <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#afeef29c3850b37585507873a2a076d8c" title="Increment the iterator to the next member of the container.">NodeIterator::operator++</a>(<span class="keywordtype">int</span>) 
<a name="l04449"></a>04449         { 
<a name="l04450"></a>04450                 <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a> temp = *<span class="keyword">this</span>; 
<a name="l04451"></a>04451                 ++*<span class="keyword">this</span>; 
<a name="l04452"></a>04452                 <span class="keywordflow">return</span> temp; 
<a name="l04453"></a>04453         } 
<a name="l04454"></a>04454  
<a name="l04455"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a97d315fce355d0c48322172d248a5138">04455</a>         <span class="keyword">const</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a>&amp; <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a97d315fce355d0c48322172d248a5138" title="Decrement the iterator to the next member of the container.">NodeIterator::operator--</a>() 
<a name="l04456"></a>04456         { 
<a name="l04457"></a>04457                 _wrap = _wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> ? _wrap.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>() : _GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a10f1a568c8c2c691126f1a9ed2afb922" title="Get the last child Node of this Node.">GetLastChild</a>(); 
<a name="l04458"></a>04458                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l04459"></a>04459         } 
<a name="l04460"></a>04460  
<a name="l04461"></a><a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a331a62c9765a66cc9659c75fb58f7ad8">04461</a>         <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html#a97d315fce355d0c48322172d248a5138" title="Decrement the iterator to the next member of the container.">NodeIterator::operator--</a>(<span class="keywordtype">int</span>) 
<a name="l04462"></a>04462         { 
<a name="l04463"></a>04463                 <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a> temp = *<span class="keyword">this</span>; 
<a name="l04464"></a>04464                 --*<span class="keyword">this</span>; 
<a name="l04465"></a>04465                 <span class="keywordflow">return</span> temp; 
<a name="l04466"></a>04466         } 
<a name="l04467"></a>04467  
<a name="l04468"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#af2804899f79a9982466acf69b5dd0cab">04468</a>         <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#af2804899f79a9982466acf69b5dd0cab" title="Default Constructor, makes a blank iterator.">AttributeIterator::AttributeIterator</a>() 
<a name="l04469"></a>04469         { 
<a name="l04470"></a>04470         } 
<a name="l04471"></a>04471  
<a name="l04472"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a175551035493cea0c9a56e36adcbac23">04472</a>         <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#af2804899f79a9982466acf69b5dd0cab" title="Default Constructor, makes a blank iterator.">AttributeIterator::AttributeIterator</a>(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; attr, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; GetParent): _wrap(attr), _GetParent(GetParent) 
<a name="l04473"></a>04473         { 
<a name="l04474"></a>04474         } 
<a name="l04475"></a>04475  
<a name="l04476"></a>04476         <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#af2804899f79a9982466acf69b5dd0cab" title="Default Constructor, makes a blank iterator.">AttributeIterator::AttributeIterator</a>(<a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* ref, <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* GetParent): _wrap(ref), _GetParent(GetParent) 
<a name="l04477"></a>04477         { 
<a name="l04478"></a>04478         } 
<a name="l04479"></a>04479  
<a name="l04480"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a0eb472612438f4541ad27390ce74f6f4">04480</a>         <span class="keywordtype">bool</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a0eb472612438f4541ad27390ce74f6f4" title="Compares this AttributeIterator to another AttributeIterator for equality.">AttributeIterator::operator==</a>(<span class="keyword">const</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a>&amp; rhs)<span class="keyword"> const </span>
<a name="l04481"></a>04481 <span class="keyword">        </span>{ 
<a name="l04482"></a>04482                 <span class="keywordflow">return</span> _wrap._attr == rhs._wrap._attr &amp;&amp; _GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> == rhs._GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04483"></a>04483         } 
<a name="l04484"></a>04484          
<a name="l04485"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a600802085aa88e41bcb2611f8044af59">04485</a>         <span class="keywordtype">bool</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a600802085aa88e41bcb2611f8044af59" title="Compares this AttributeIterator to another AttributeIterator for inequality.">AttributeIterator::operator!=</a>(<span class="keyword">const</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a>&amp; rhs)<span class="keyword"> const </span>
<a name="l04486"></a>04486 <span class="keyword">        </span>{ 
<a name="l04487"></a>04487                 <span class="keywordflow">return</span> _wrap._attr != rhs._wrap._attr || _GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> != rhs._GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04488"></a>04488         } 
<a name="l04489"></a>04489  
<a name="l04490"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#afe43d9e4a66adadf8eedc3fbcb883bcd">04490</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#afe43d9e4a66adadf8eedc3fbcb883bcd" title="Deferences this Iterator.">AttributeIterator::operator*</a>() 
<a name="l04491"></a>04491         { 
<a name="l04492"></a>04492                 assert(_wrap._attr); 
<a name="l04493"></a>04493                 <span class="keywordflow">return</span> _wrap; 
<a name="l04494"></a>04494         } 
<a name="l04495"></a>04495  
<a name="l04496"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a77fb7dfd9b834d6663201870e8550217">04496</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>* <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a77fb7dfd9b834d6663201870e8550217" title="Get the pointer the Attribute this points to.">AttributeIterator::operator-&gt;</a>() 
<a name="l04497"></a>04497         { 
<a name="l04498"></a>04498                 assert(_wrap._attr); 
<a name="l04499"></a>04499                 <span class="keywordflow">return</span> &amp;_wrap; 
<a name="l04500"></a>04500         } 
<a name="l04501"></a>04501  
<a name="l04502"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#ad09623beef0359e64bc6b5a2635cd34a">04502</a>         <span class="keyword">const</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a>&amp; <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#ad09623beef0359e64bc6b5a2635cd34a" title="Increment the iterator to the next member of the container.">AttributeIterator::operator++</a>() 
<a name="l04503"></a>04503         { 
<a name="l04504"></a>04504                 assert(_wrap._attr); 
<a name="l04505"></a>04505                 _wrap._attr = _wrap._attr-&gt;GetNextAttribute; 
<a name="l04506"></a>04506                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l04507"></a>04507         } 
<a name="l04508"></a>04508  
<a name="l04509"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a2109817056f299a9f2b132ade6901800">04509</a>         <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#ad09623beef0359e64bc6b5a2635cd34a" title="Increment the iterator to the next member of the container.">AttributeIterator::operator++</a>(<span class="keywordtype">int</span>) 
<a name="l04510"></a>04510         { 
<a name="l04511"></a>04511                 <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a> temp = *<span class="keyword">this</span>; 
<a name="l04512"></a>04512                 ++*<span class="keyword">this</span>; 
<a name="l04513"></a>04513                 <span class="keywordflow">return</span> temp; 
<a name="l04514"></a>04514         } 
<a name="l04515"></a>04515  
<a name="l04516"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a76a060aab7cc7666cd5016035de714b0">04516</a>         <span class="keyword">const</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a>&amp; <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a76a060aab7cc7666cd5016035de714b0" title="Decrement the iterator to the next member of the container.">AttributeIterator::operator--</a>() 
<a name="l04517"></a>04517         { 
<a name="l04518"></a>04518                 _wrap = _wrap._attr ? _wrap.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ae1c2320961faca954e7e34acc166f8d0" title="Get the previous attribute.">GetPreviousAttribute</a>() : _GetParent.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a9c5ff28c5d1a04ca38da1d7df118ed5f" title="Get the Last Attribute in this Node.">GetLastAttribute</a>(); 
<a name="l04519"></a>04519                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l04520"></a>04520         } 
<a name="l04521"></a>04521  
<a name="l04522"></a><a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#ab8b0d4867b14816c80cf74ac7a0a1561">04522</a>         <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html#a76a060aab7cc7666cd5016035de714b0" title="Decrement the iterator to the next member of the container.">AttributeIterator::operator--</a>(<span class="keywordtype">int</span>) 
<a name="l04523"></a>04523         { 
<a name="l04524"></a>04524                 <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a> temp = *<span class="keyword">this</span>; 
<a name="l04525"></a>04525                 --*<span class="keyword">this</span>; 
<a name="l04526"></a>04526                 <span class="keywordflow">return</span> temp; 
<a name="l04527"></a>04527         } 
<a name="l04528"></a>04528  
<a name="l04529"></a><a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#aa7520df050e866122a0cf67bf306e323">04529</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#aa7520df050e866122a0cf67bf306e323" title="Default constructor, initializes object to failed state.">ParseResult::ParseResult</a>(): Status(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa458daab0a01f8dd3d0d85b4e41b9e187" title="An unkown error, currently nothing should be able to return this status.">StatusInternalError</a>), Offset(0), DocumentEncoding(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2792ef334e1061e7ad177df463256d85" title="Auto-detect input document encoding using Byte Order Mark (BOM) or &amp;lt; / &amp;lt;? detection; use UTF8 i...">EncodingAuto</a>) 
<a name="l04530"></a>04530         { 
<a name="l04531"></a>04531         } 
<a name="l04532"></a>04532  
<a name="l04533"></a><a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a95c9989865c1bace7846995166a13e31">04533</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a95c9989865c1bace7846995166a13e31" title="Cast to bool operator.">ParseResult::operator bool</a>()<span class="keyword"> const </span>
<a name="l04534"></a>04534 <span class="keyword">        </span>{ 
<a name="l04535"></a>04535                 <span class="keywordflow">return</span> <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a1bf9dfeebdb07656723bbaf18ab612b5" title="Parsing status ( see ParseStatus ).">Status</a> == StatusOk; 
<a name="l04536"></a>04536         } 
<a name="l04537"></a>04537  
<a name="l04538"></a><a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#aeda9dd881b93496c5500cb810b2e937d">04538</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#aeda9dd881b93496c5500cb810b2e937d" title="Creates a text description of the error situation, if any exists.">ParseResult::Description</a>()<span class="keyword"> const </span>
<a name="l04539"></a>04539 <span class="keyword">        </span>{ 
<a name="l04540"></a>04540                 <span class="keywordflow">switch</span> (<a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a1bf9dfeebdb07656723bbaf18ab612b5" title="Parsing status ( see ParseStatus ).">Status</a>) 
<a name="l04541"></a>04541                 { 
<a name="l04542"></a>04542                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa9ea9b3eecb4bb9f01745c94150982560" title="This is returned to indicated there where no issues parsing the XML document.">StatusOk</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;No error&quot;</span>; 
<a name="l04543"></a>04543  
<a name="l04544"></a>04544                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa6f0279c8ce0103b77edcf3ce91fa64b4" title="File was not found during a loading from filename attempt.">StatusFileNotFound</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;File was not found&quot;</span>; 
<a name="l04545"></a>04545                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa63f6d040311f50c1234a8eb873a0a95c" title="Error reading from file or stream.">StatusIOError</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error reading from file/stream&quot;</span>; 
<a name="l04546"></a>04546                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac2a8163c9a8e285153d2a96b011bd49f" title="Could not allocate memory.">StatusOutOfMemory</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Could not allocate memory&quot;</span>; 
<a name="l04547"></a>04547                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa458daab0a01f8dd3d0d85b4e41b9e187" title="An unkown error, currently nothing should be able to return this status.">StatusInternalError</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Internal error occurred&quot;</span>; 
<a name="l04548"></a>04548  
<a name="l04549"></a>04549                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fabe0f4590debfa56c7e3a4c8da261b106" title="The parser could not determine type of tag.">StatusUnrecognizedTag</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Could not determine tag Type&quot;</span>; 
<a name="l04550"></a>04550  
<a name="l04551"></a>04551                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa55afc9de133574f5c9376493c8e6fe09" title="Parsing error occurred while parsing document declaration/processing instruction.">StatusBadPi</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing document declaration/processing instruction&quot;</span>; 
<a name="l04552"></a>04552                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8f3864efd7b684ae57a8a7886a23f19a" title="Parsing error occurred while parsing comment.">StatusBadComment</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing comment&quot;</span>; 
<a name="l04553"></a>04553                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa18f36b8d712a6bbc716f90af8659df22" title="Parsing error occurred while parsing CDATA section.">StatusBadCdata</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing CDATA section&quot;</span>; 
<a name="l04554"></a>04554                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa8fb41bcdb73615156e9a031fa4c5db4f" title="Parsing error occurred while parsing document type declaration.">StatusBadDocType</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing document Type declaration&quot;</span>; 
<a name="l04555"></a>04555                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fab30b3a432145b0e9c6595e75da773628" title="Parsing error occurred while parsing PCDATA section.">StatusBadPcdata</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing PCDATA section&quot;</span>; 
<a name="l04556"></a>04556                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fadbc5b334b4215ce2332073de46c58155" title="Parsing error occurred while parsing start element tag .">StatusBadStartElement</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing start element tag&quot;</span>; 
<a name="l04557"></a>04557                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac5fdddc5cc4d127aa5c53efb85846ccf" title="Parsing error occurred while parsing element attribute.">StatusBadAttribute</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing element GetAttribute&quot;</span>; 
<a name="l04558"></a>04558                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa72532447020c081f343c4a719add7450" title="Parsing error occurred while parsing end element tag.">StatusBadEndElement</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error parsing end element tag&quot;</span>; 
<a name="l04559"></a>04559                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fa6b8d817142e0898ad9b1c61cfa54b8ea" title="There was a mismatch of start-end tags (closing tag had incorrect name, some tag was not closed or th...">StatusEndElementMismatch</a>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Start-end tags mismatch&quot;</span>; 
<a name="l04560"></a>04560  
<a name="l04561"></a>04561                 <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Unknown error&quot;</span>; 
<a name="l04562"></a>04562                 } 
<a name="l04563"></a>04563         } 
<a name="l04564"></a>04564  
<a name="l04565"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#ae1e779f0826bf3357ff77846155aad7d">04565</a>         <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#ae1e779f0826bf3357ff77846155aad7d" title="Creates an empty document with just a root Node.">Document::Document</a>(): _buffer(0) 
<a name="l04566"></a>04566         { 
<a name="l04567"></a>04567                 create(); 
<a name="l04568"></a>04568         } 
<a name="l04569"></a>04569  
<a name="l04570"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a70013c2b670c4d4b5ee55d12e7c50be4">04570</a>         <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a70013c2b670c4d4b5ee55d12e7c50be4" title="Tears down a document, and incidentally invalidates all Node and Attribute handles to this document...">Document::~Document</a>() 
<a name="l04571"></a>04571         { 
<a name="l04572"></a>04572                 destroy(); 
<a name="l04573"></a>04573         } 
<a name="l04574"></a>04574  
<a name="l04575"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4">04575</a>         <span class="keywordtype">void</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Document::Reset</a>() 
<a name="l04576"></a>04576         { 
<a name="l04577"></a>04577                 destroy(); 
<a name="l04578"></a>04578                 create(); 
<a name="l04579"></a>04579         } 
<a name="l04580"></a>04580  
<a name="l04581"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#aba87e21330118fb43b2aab2c36486b03">04581</a>         <span class="keywordtype">void</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Document::Reset</a>(<span class="keyword">const</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">Document</a>&amp; proto) 
<a name="l04582"></a>04582         { 
<a name="l04583"></a>04583                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Reset</a>(); 
<a name="l04584"></a>04584  
<a name="l04585"></a>04585                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = proto.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); cur; cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) 
<a name="l04586"></a>04586                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33de8cdb7ed8694acac79aedc81523c9" title="Copies an Attribute and puts the copy at the end of this Nodes attributes.">AppendCopy</a>(cur); 
<a name="l04587"></a>04587         } 
<a name="l04588"></a>04588  
<a name="l04589"></a>04589         <span class="keywordtype">void</span> Document::create() 
<a name="l04590"></a>04590         { 
<a name="l04591"></a>04591                 <span class="comment">// initialize sentinel page </span>
<a name="l04592"></a>04592                 STATIC_ASSERT(offsetof(MemoryPage, data) + <span class="keyword">sizeof</span>(DocumentStruct) + MemoryPage_alignment &lt;= <span class="keyword">sizeof</span>(_memory)); 
<a name="l04593"></a>04593  
<a name="l04594"></a>04594                 <span class="comment">// align upwards to page boundary </span>
<a name="l04595"></a>04595                 <span class="keywordtype">void</span>* page_memory = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>((<span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(_memory) + (MemoryPage_alignment - 1)) &amp; ~(MemoryPage_alignment - 1)); 
<a name="l04596"></a>04596  
<a name="l04597"></a>04597                 <span class="comment">// prepare page structure </span>
<a name="l04598"></a>04598                 MemoryPage* page = MemoryPage::construct(page_memory); 
<a name="l04599"></a>04599  
<a name="l04600"></a>04600                 page-&gt;busy_size = MemoryPage_size; 
<a name="l04601"></a>04601  
<a name="l04602"></a>04602                 <span class="comment">// allocate new GetRoot </span>
<a name="l04603"></a>04603                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> = <span class="keyword">new</span> (page-&gt;data) DocumentStruct(page); 
<a name="l04604"></a>04604                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;prev_sibling_c = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>; 
<a name="l04605"></a>04605  
<a name="l04606"></a>04606                 <span class="comment">// setup sentinel page </span>
<a name="l04607"></a>04607                 page-&gt;allocator = <span class="keyword">static_cast&lt;</span>DocumentStruct*<span class="keyword">&gt;</span>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>); 
<a name="l04608"></a>04608         } 
<a name="l04609"></a>04609  
<a name="l04610"></a>04610         <span class="keywordtype">void</span> Document::destroy() 
<a name="l04611"></a>04611         { 
<a name="l04612"></a>04612                 <span class="comment">// destroy static storage </span>
<a name="l04613"></a>04613                 <span class="keywordflow">if</span> (_buffer) 
<a name="l04614"></a>04614                 { 
<a name="l04615"></a>04615                         global_deallocate(_buffer); 
<a name="l04616"></a>04616                         _buffer = 0; 
<a name="l04617"></a>04617                 } 
<a name="l04618"></a>04618  
<a name="l04619"></a>04619                 <span class="comment">// destroy dynamic storage, leave sentinel page (it&#39;s in static memory) </span>
<a name="l04620"></a>04620                 <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>) 
<a name="l04621"></a>04621                 { 
<a name="l04622"></a>04622                         MemoryPage* GetRoot_page = <span class="keyword">reinterpret_cast&lt;</span>MemoryPage*<span class="keyword">&gt;</span>(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;header &amp; MemoryPage_pointer_mask); 
<a name="l04623"></a>04623                         assert(GetRoot_page &amp;&amp; !GetRoot_page-&gt;prev &amp;&amp; !GetRoot_page-&gt;memory); 
<a name="l04624"></a>04624  
<a name="l04625"></a>04625                         <span class="comment">// destroy all pages </span>
<a name="l04626"></a>04626                         <span class="keywordflow">for</span> (MemoryPage* page = GetRoot_page-&gt;next; page; ) 
<a name="l04627"></a>04627                         { 
<a name="l04628"></a>04628                                 MemoryPage* next = page-&gt;next; 
<a name="l04629"></a>04629  
<a name="l04630"></a>04630                                 Allocator::deallocate_page(page); 
<a name="l04631"></a>04631  
<a name="l04632"></a>04632                                 page = next; 
<a name="l04633"></a>04633                         } 
<a name="l04634"></a>04634  
<a name="l04635"></a>04635                         <span class="comment">// cleanup GetRoot page </span>
<a name="l04636"></a>04636                         GetRoot_page-&gt;allocator = 0; 
<a name="l04637"></a>04637                         GetRoot_page-&gt;next = 0; 
<a name="l04638"></a>04638                         GetRoot_page-&gt;busy_size = GetRoot_page-&gt;freed_size = 0; 
<a name="l04639"></a>04639  
<a name="l04640"></a>04640                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a> = 0; 
<a name="l04641"></a>04641                 } 
<a name="l04642"></a>04642         } 
<a name="l04643"></a>04643  
<a name="l04644"></a>04644 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l04645"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9d4ddfd3b987fa3d31d41c06d06a001e">04645</a> <span class="preprocessor"></span>        <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9d4ddfd3b987fa3d31d41c06d06a001e" title="Load XML from a stream.">Document::Load</a>(std::basic_istream&lt;<span class="keywordtype">char</span>, std::char_traits&lt;char&gt; &gt;&amp; stream, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l04646"></a>04646         { 
<a name="l04647"></a>04647                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Reset</a>(); 
<a name="l04648"></a>04648  
<a name="l04649"></a>04649                 <span class="keywordflow">return</span> LoadStreamImpl(*<span class="keyword">this</span>, stream, options, DocumentEncoding); 
<a name="l04650"></a>04650         } 
<a name="l04651"></a>04651  
<a name="l04652"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a5c31cda427eeeb61cd40932f7bec6376">04652</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9d4ddfd3b987fa3d31d41c06d06a001e" title="Load XML from a stream.">Document::Load</a>(std::basic_istream&lt;<span class="keywordtype">wchar_t</span>, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options) 
<a name="l04653"></a>04653         { 
<a name="l04654"></a>04654                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Reset</a>(); 
<a name="l04655"></a>04655  
<a name="l04656"></a>04656                 <span class="keywordflow">return</span> LoadStreamImpl(*<span class="keyword">this</span>, stream, options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2bc9c8d42796901c8feaa25e17c56cef" title="The same document encoding wchar_t has (usually either UTF16 or UTF32).">Encodingwchar_t</a>); 
<a name="l04657"></a>04657         } 
<a name="l04658"></a>04658 <span class="preprocessor">#endif </span>
<a name="l04659"></a>04659 <span class="preprocessor"></span> 
<a name="l04660"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a7ae98719610eefc5c05255e305c75e56">04660</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9d4ddfd3b987fa3d31d41c06d06a001e" title="Load XML from a stream.">Document::Load</a>(<span class="keyword">const</span> char_t* contents, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options) 
<a name="l04661"></a>04661         { 
<a name="l04662"></a>04662                 <span class="comment">// Force native DocumentEncoding (skip autodetection) </span>
<a name="l04663"></a>04663 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l04664"></a>04664 <span class="preprocessor"></span>                <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding = Encodingwchar_t; 
<a name="l04665"></a>04665 <span class="preprocessor">        #else </span>
<a name="l04666"></a>04666 <span class="preprocessor"></span>                <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding = EncodingUTF8; 
<a name="l04667"></a>04667 <span class="preprocessor">        #endif </span>
<a name="l04668"></a>04668 <span class="preprocessor"></span> 
<a name="l04669"></a>04669                 <span class="keywordflow">return</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a31c36783e033d6d43d51e31a6dd4099f" title="Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the func...">LoadBuffer</a>(contents, strlength(contents) * <span class="keyword">sizeof</span>(char_t), options, DocumentEncoding); 
<a name="l04670"></a>04670         } 
<a name="l04671"></a>04671  
<a name="l04672"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a2e832250addde2f928b8ef659dd7d50c">04672</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a2e832250addde2f928b8ef659dd7d50c" title="Load document from file.">Document::LoadFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* Path, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l04673"></a>04673         { 
<a name="l04674"></a>04674                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Reset</a>(); 
<a name="l04675"></a>04675  
<a name="l04676"></a>04676                 FILE* file = fopen(Path, <span class="stringliteral">&quot;rb&quot;</span>); 
<a name="l04677"></a>04677  
<a name="l04678"></a>04678                 <span class="keywordflow">return</span> LoadFileImpl(*<span class="keyword">this</span>, file, options, DocumentEncoding); 
<a name="l04679"></a>04679         } 
<a name="l04680"></a>04680  
<a name="l04681"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#afbbadfa6c7ff3e2eeb5bcc962a29874e">04681</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a2e832250addde2f928b8ef659dd7d50c" title="Load document from file.">Document::LoadFile</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* Path, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l04682"></a>04682         { 
<a name="l04683"></a>04683                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Reset</a>(); 
<a name="l04684"></a>04684  
<a name="l04685"></a>04685                 FILE* file = open_file_wide(Path, L<span class="stringliteral">&quot;rb&quot;</span>); 
<a name="l04686"></a>04686  
<a name="l04687"></a>04687                 <span class="keywordflow">return</span> LoadFileImpl(*<span class="keyword">this</span>, file, options, DocumentEncoding); 
<a name="l04688"></a>04688         } 
<a name="l04689"></a>04689  
<a name="l04690"></a>04690         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> Document::LoadBufferImpl(<span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding, <span class="keywordtype">bool</span> is_mutable, <span class="keywordtype">bool</span> own) 
<a name="l04691"></a>04691         { 
<a name="l04692"></a>04692                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">Reset</a>(); 
<a name="l04693"></a>04693  
<a name="l04694"></a>04694                 <span class="comment">// check input buffer </span>
<a name="l04695"></a>04695                 assert(contents || size == 0); 
<a name="l04696"></a>04696  
<a name="l04697"></a>04697                 <span class="comment">// get actual DocumentEncoding </span>
<a name="l04698"></a>04698                 <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> buffer_DocumentEncoding = GetBuffer_DocumentEncoding(DocumentEncoding, contents, size); 
<a name="l04699"></a>04699  
<a name="l04700"></a>04700                 <span class="comment">// get private buffer </span>
<a name="l04701"></a>04701                 char_t* buffer = 0; 
<a name="l04702"></a>04702                 <span class="keywordtype">size_t</span> length = 0; 
<a name="l04703"></a>04703  
<a name="l04704"></a>04704                 <span class="keywordflow">if</span> (!convert_buffer(buffer, length, buffer_DocumentEncoding, contents, size, is_mutable)) <span class="keywordflow">return</span> make_ParseResult(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#ae7aabb879b21c73d8183a54470f8917fac2a8163c9a8e285153d2a96b011bd49f" title="Could not allocate memory.">StatusOutOfMemory</a>); 
<a name="l04705"></a>04705                  
<a name="l04706"></a>04706                 <span class="comment">// delete original buffer if we performed a conversion </span>
<a name="l04707"></a>04707                 <span class="keywordflow">if</span> (own &amp;&amp; buffer != contents &amp;&amp; contents) global_deallocate(contents); 
<a name="l04708"></a>04708  
<a name="l04709"></a>04709                 <span class="comment">// parse </span>
<a name="l04710"></a>04710                 <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> res = Parser::parse(buffer, length, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>, options); 
<a name="l04711"></a>04711  
<a name="l04712"></a>04712                 <span class="comment">// remember DocumentEncoding </span>
<a name="l04713"></a>04713                 res.<a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html#a95c39cf7a95875a4cd9708656a976dfc" title="Source document encoding ( see Encoding ).">DocumentEncoding</a> = buffer_DocumentEncoding; 
<a name="l04714"></a>04714  
<a name="l04715"></a>04715                 <span class="comment">// grab onto buffer if it&#39;s our buffer, user is responsible for deallocating contens himself </span>
<a name="l04716"></a>04716                 <span class="keywordflow">if</span> (own || buffer != contents) _buffer = buffer; 
<a name="l04717"></a>04717  
<a name="l04718"></a>04718                 <span class="keywordflow">return</span> res; 
<a name="l04719"></a>04719         } 
<a name="l04720"></a>04720  
<a name="l04721"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a31c36783e033d6d43d51e31a6dd4099f">04721</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a31c36783e033d6d43d51e31a6dd4099f" title="Load document from buffer. Copies/converts the buffer, so it may be deleted or changed after the func...">Document::LoadBuffer</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l04722"></a>04722         { 
<a name="l04723"></a>04723                 <span class="keywordflow">return</span> LoadBufferImpl(const_cast&lt;void*&gt;(contents), size, options, DocumentEncoding, <span class="keyword">false</span>, <span class="keyword">false</span>); 
<a name="l04724"></a>04724         } 
<a name="l04725"></a>04725  
<a name="l04726"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#afaf92d3a52dcdbbff46c2ebe02bd93f6">04726</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#afaf92d3a52dcdbbff46c2ebe02bd93f6" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Document::LoadBufferInplace</a>(<span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l04727"></a>04727         { 
<a name="l04728"></a>04728                 <span class="keywordflow">return</span> LoadBufferImpl(contents, size, options, DocumentEncoding, <span class="keyword">true</span>, <span class="keyword">false</span>); 
<a name="l04729"></a>04729         } 
<a name="l04730"></a>04730                  
<a name="l04731"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a712ff68748c616d5bca8bd6ead8c5799">04731</a>         <a class="code" href="../../d5/dea/structphys_1_1xml_1_1ParseResult.html" title="All the information needed to troubleshoot a Parsing error.">ParseResult</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a712ff68748c616d5bca8bd6ead8c5799" title="Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for...">Document::LoadBufferInplaceOwn</a>(<span class="keywordtype">void</span>* contents, <span class="keywordtype">size_t</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> options, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding) 
<a name="l04732"></a>04732         { 
<a name="l04733"></a>04733                 <span class="keywordflow">return</span> LoadBufferImpl(contents, size, options, DocumentEncoding, <span class="keyword">true</span>, <span class="keyword">true</span>); 
<a name="l04734"></a>04734         } 
<a name="l04735"></a>04735  
<a name="l04736"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d">04736</a>         <span class="keywordtype">void</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d" title="Save XML document to WriterInstance.">Document::Save</a>(<a class="code" href="../../d2/d28/classphys_1_1xml_1_1Writer.html" title="Interface for node printing (see Node::print).">Writer</a>&amp; WriterInstance, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding)<span class="keyword"> const </span>
<a name="l04737"></a>04737 <span class="keyword">        </span>{ 
<a name="l04738"></a>04738                 <span class="keywordflow">if</span> (flags &amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a76a253f60deb94ef39c255064afb6040" title="Write encoding-specific Byte Order Mark (BOM) to the output stream. This flag is off by default...">FormatWriteBom</a>) Write_bom(WriterInstance, GetWrite_DocumentEncoding(DocumentEncoding)); 
<a name="l04739"></a>04739  
<a name="l04740"></a>04740                 BufferedWriter buffered_WriterInstance(WriterInstance, DocumentEncoding); 
<a name="l04741"></a>04741  
<a name="l04742"></a>04742                 <span class="keywordflow">if</span> (!(flags &amp; <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#aee4ccb3535945d4808a0cf6abe4cb050" title="Omit default XML declaration even if there is no declaration in the document. This flag is off by def...">FormatNoDeclaration</a>) &amp;&amp; !hAsDeclaration(*<span class="keyword">this</span>)) 
<a name="l04743"></a>04743                 { 
<a name="l04744"></a>04744                         buffered_WriterInstance.Write(<a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&quot;</span>)); 
<a name="l04745"></a>04745                         <span class="keywordflow">if</span> (!(flags &amp; FormatRaw)) buffered_WriterInstance.Write(<span class="charliteral">&#39;\n&#39;</span>); 
<a name="l04746"></a>04746                 } 
<a name="l04747"></a>04747  
<a name="l04748"></a>04748                 NodeOutput(buffered_WriterInstance, *<span class="keyword">this</span>, indent, flags, 0); 
<a name="l04749"></a>04749         } 
<a name="l04750"></a>04750  
<a name="l04751"></a>04751 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l04752"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#aa9f44d46ec6139680ebde26122cc6281">04752</a> <span class="preprocessor"></span>        <span class="keywordtype">void</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d" title="Save XML document to WriterInstance.">Document::Save</a>(std::basic_ostream&lt;<span class="keywordtype">char</span>, std::char_traits&lt;char&gt; &gt;&amp; stream, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding)<span class="keyword"> const </span>
<a name="l04753"></a>04753 <span class="keyword">        </span>{ 
<a name="l04754"></a>04754                 <a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html" title="An implementation of Writer intended for writing std::ostreams.">WriterStream</a> WriterInstance(stream); 
<a name="l04755"></a>04755  
<a name="l04756"></a>04756                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d" title="Save XML document to WriterInstance.">Save</a>(WriterInstance, indent, flags, DocumentEncoding); 
<a name="l04757"></a>04757         } 
<a name="l04758"></a>04758  
<a name="l04759"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a034a5497b68d8531886fdc7a6a67bd7d">04759</a>         <span class="keywordtype">void</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d" title="Save XML document to WriterInstance.">Document::Save</a>(std::basic_ostream&lt;<span class="keywordtype">wchar_t</span>, std::char_traits&lt;wchar_t&gt; &gt;&amp; stream, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)<span class="keyword"> const </span>
<a name="l04760"></a>04760 <span class="keyword">        </span>{ 
<a name="l04761"></a>04761                 <a class="code" href="../../d5/d6f/classphys_1_1xml_1_1WriterStream.html" title="An implementation of Writer intended for writing std::ostreams.">WriterStream</a> WriterInstance(stream); 
<a name="l04762"></a>04762  
<a name="l04763"></a>04763                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d" title="Save XML document to WriterInstance.">Save</a>(WriterInstance, indent, flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015a2bc9c8d42796901c8feaa25e17c56cef" title="The same document encoding wchar_t has (usually either UTF16 or UTF32).">Encodingwchar_t</a>); 
<a name="l04764"></a>04764         } 
<a name="l04765"></a>04765 <span class="preprocessor">#endif </span>
<a name="l04766"></a>04766 <span class="preprocessor"></span> 
<a name="l04767"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a888042e75f6dafe4d79107a8b53ae31e">04767</a>         <span class="keywordtype">bool</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a888042e75f6dafe4d79107a8b53ae31e" title="Save XML to file.">Document::SaveFile</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* Path, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding)<span class="keyword"> const </span>
<a name="l04768"></a>04768 <span class="keyword">        </span>{ 
<a name="l04769"></a>04769                 FILE* file = fopen(Path, <span class="stringliteral">&quot;wb&quot;</span>); 
<a name="l04770"></a>04770                 <span class="keywordflow">if</span> (!file) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l04771"></a>04771  
<a name="l04772"></a>04772                 <a class="code" href="../../dc/d53/classphys_1_1xml_1_1WriterFile.html" title="An implementation of Writer intended for writing to FILEs as defined in stdio.">WriterFile</a> WriterInstance(file); 
<a name="l04773"></a>04773                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d" title="Save XML document to WriterInstance.">Save</a>(WriterInstance, indent, flags, DocumentEncoding); 
<a name="l04774"></a>04774  
<a name="l04775"></a>04775                 fclose(file); 
<a name="l04776"></a>04776  
<a name="l04777"></a>04777                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l04778"></a>04778         } 
<a name="l04779"></a>04779  
<a name="l04780"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a56b9dc49e83adfd09f35e8e99d8c0ca0">04780</a>         <span class="keywordtype">bool</span> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a888042e75f6dafe4d79107a8b53ae31e" title="Save XML to file.">Document::SaveFile</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* Path, <span class="keyword">const</span> char_t* indent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a420f5de782438f88160321385bea2015" title="These flags determine the encoding of input data for an XML document.">Encoding</a> DocumentEncoding)<span class="keyword"> const </span>
<a name="l04781"></a>04781 <span class="keyword">        </span>{ 
<a name="l04782"></a>04782                 FILE* file = open_file_wide(Path, L<span class="stringliteral">&quot;wb&quot;</span>); 
<a name="l04783"></a>04783                 <span class="keywordflow">if</span> (!file) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l04784"></a>04784  
<a name="l04785"></a>04785                 <a class="code" href="../../dc/d53/classphys_1_1xml_1_1WriterFile.html" title="An implementation of Writer intended for writing to FILEs as defined in stdio.">WriterFile</a> WriterInstance(file); 
<a name="l04786"></a>04786                 <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a1e3761e11294b3d526ff13d76ee8be0d" title="Save XML document to WriterInstance.">Save</a>(WriterInstance, indent, flags, DocumentEncoding); 
<a name="l04787"></a>04787  
<a name="l04788"></a>04788                 fclose(file); 
<a name="l04789"></a>04789  
<a name="l04790"></a>04790                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l04791"></a>04791         } 
<a name="l04792"></a>04792  
<a name="l04793"></a><a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a93d8521e3241281e15f77cf7568d5754">04793</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../dd/d44/classphys_1_1xml_1_1Document.html#a93d8521e3241281e15f77cf7568d5754" title="Get document element.">Document::DocumentElement</a>()<span class="keyword"> const </span>
<a name="l04794"></a>04794 <span class="keyword">        </span>{ 
<a name="l04795"></a>04795                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* i = <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#acfef549b712d4599e579ed5495037acd" title="Stores pointers to the Node data and some metadata.">_GetRoot</a>-&gt;GetFirstChild; i; i = i-&gt;GetNextSibling) 
<a name="l04796"></a>04796                         <span class="keywordflow">if</span> ((i-&gt;header &amp; MemoryPage_type_mask) + 1 == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>) 
<a name="l04797"></a>04797                                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(i); 
<a name="l04798"></a>04798  
<a name="l04799"></a>04799                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a82203e57f13363aee523feb696f64bb9" title="Default constructor. Constructs an empty node.">Node</a>(); 
<a name="l04800"></a>04800         } 
<a name="l04801"></a>04801  
<a name="l04802"></a>04802 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l04803"></a>04803 <span class="preprocessor"></span>        std::string PHYS_LIB <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a2d4bf28045544dc7350827f568cad46f" title="Convert a c-style string of wchar_t to std::string containing UTF8.">AsUtf8</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* str) 
<a name="l04804"></a>04804         { 
<a name="l04805"></a>04805                 assert(str); 
<a name="l04806"></a>04806  
<a name="l04807"></a>04807                 <span class="keywordflow">return</span> AsUtf8_impl(str, wcslen(str)); 
<a name="l04808"></a>04808         } 
<a name="l04809"></a>04809  
<a name="l04810"></a>04810         std::string PHYS_LIB <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a2d4bf28045544dc7350827f568cad46f" title="Convert a c-style string of wchar_t to std::string containing UTF8.">AsUtf8</a>(<span class="keyword">const</span> std::wstring&amp; str) 
<a name="l04811"></a>04811         { 
<a name="l04812"></a>04812                 <span class="keywordflow">return</span> AsUtf8_impl(str.c_str(), str.size()); 
<a name="l04813"></a>04813         } 
<a name="l04814"></a>04814          
<a name="l04815"></a>04815         std::wstring PHYS_LIB <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a0a57ef612f499a03733ca18d0e4f0c4f" title="Convert a Convert a c-style string to std::wstring containing native encoding (Usually UCS2 on window...">AsWide</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str) 
<a name="l04816"></a>04816         { 
<a name="l04817"></a>04817                 assert(str); 
<a name="l04818"></a>04818  
<a name="l04819"></a>04819                 <span class="keywordflow">return</span> AsWide_impl(str, strlen(str)); 
<a name="l04820"></a>04820         } 
<a name="l04821"></a>04821          
<a name="l04822"></a>04822         std::wstring PHYS_LIB <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a0a57ef612f499a03733ca18d0e4f0c4f" title="Convert a Convert a c-style string to std::wstring containing native encoding (Usually UCS2 on window...">AsWide</a>(<span class="keyword">const</span> std::string&amp; str) 
<a name="l04823"></a>04823         { 
<a name="l04824"></a>04824                 <span class="keywordflow">return</span> AsWide_impl(str.c_str(), str.size()); 
<a name="l04825"></a>04825         } 
<a name="l04826"></a>04826 <span class="preprocessor">#endif </span>
<a name="l04827"></a>04827 <span class="preprocessor"></span> 
<a name="l04828"></a>04828         <span class="keywordtype">void</span> PHYS_LIB <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a2ad88e4331ac29a86c99d5e40b31f983" title="Override default memory management functions. All subsequent allocations/deallocations will be perfor...">SetMemory_management_functions</a>(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a6d772c4cf52d017d4d6ad68ddcbd493f" title="Memory allocation function interface; returns pointer to allocated memory or NULL on failure...">AllocationFunction</a> allocate, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#af98b1cb6640aa712180aad89a1c776d8" title="Memory deallocation function interface.">deAllocationFunction</a> deallocate) 
<a name="l04829"></a>04829         { 
<a name="l04830"></a>04830                 global_allocate = allocate; 
<a name="l04831"></a>04831                 global_deallocate = deallocate; 
<a name="l04832"></a>04832         } 
<a name="l04833"></a>04833  
<a name="l04834"></a>04834         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a6d772c4cf52d017d4d6ad68ddcbd493f" title="Memory allocation function interface; returns pointer to allocated memory or NULL on failure...">AllocationFunction</a> PHYS_LIB <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a0537fb34f1fa41afd138deead1455a5b" title="Get the current allocation funciton.">GetMemoryAllocationFunction</a>() 
<a name="l04835"></a>04835         { 
<a name="l04836"></a>04836                 <span class="keywordflow">return</span> global_allocate; 
<a name="l04837"></a>04837         } 
<a name="l04838"></a>04838  
<a name="l04839"></a>04839         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#af98b1cb6640aa712180aad89a1c776d8" title="Memory deallocation function interface.">deAllocationFunction</a> PHYS_LIB <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a1a2ff3e010e4627424a65a2e584e441e" title="Get the current allocation funciton.">GetMemoryDeallocationFunction</a>() 
<a name="l04840"></a>04840         { 
<a name="l04841"></a>04841                 <span class="keywordflow">return</span> global_deallocate; 
<a name="l04842"></a>04842         } 
<a name="l04843"></a>04843 } 
<a name="l04844"></a>04844 } <span class="comment">// \phys</span>
<a name="l04845"></a>04845  
<a name="l04846"></a>04846 <span class="preprocessor">#if !defined(XML_NO_STL) &amp;&amp; (defined(_MSC_VER) || defined(__ICC)) </span>
<a name="l04847"></a>04847 <span class="preprocessor"></span><span class="keyword">namespace </span>std 
<a name="l04848"></a>04848 { 
<a name="l04849"></a>04849         <span class="comment">// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier) </span>
<a name="l04850"></a>04850         std::bidirectional_iterator_tag _Iter_cat(<span class="keyword">const</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a>&amp;) 
<a name="l04851"></a>04851         { 
<a name="l04852"></a>04852                 <span class="keywordflow">return</span> std::bidirectional_iterator_tag(); 
<a name="l04853"></a>04853         } 
<a name="l04854"></a>04854  
<a name="l04855"></a>04855         std::bidirectional_iterator_tag _Iter_cat(<span class="keyword">const</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a>&amp;) 
<a name="l04856"></a>04856         { 
<a name="l04857"></a>04857                 <span class="keywordflow">return</span> std::bidirectional_iterator_tag(); 
<a name="l04858"></a>04858         } 
<a name="l04859"></a>04859 } 
<a name="l04860"></a>04860 <span class="preprocessor">#endif </span>
<a name="l04861"></a>04861 <span class="preprocessor"></span> 
<a name="l04862"></a>04862 <span class="preprocessor">#if !defined(XML_NO_STL) &amp;&amp; defined(__SUNPRO_CC) </span>
<a name="l04863"></a>04863 <span class="preprocessor"></span><span class="keyword">namespace </span>std 
<a name="l04864"></a>04864 { 
<a name="l04865"></a>04865         <span class="comment">// Workarounds for (non-standard) iterator category detection </span>
<a name="l04866"></a>04866         std::bidirectional_iterator_tag __iterator_category(<span class="keyword">const</span> <a class="code" href="../../da/d4f/classphys_1_1xml_1_1NodeIterator.html" title="Child node iterator (a bidirectional iterator over a collection of Node).">NodeIterator</a>&amp;) 
<a name="l04867"></a>04867         { 
<a name="l04868"></a>04868                 <span class="keywordflow">return</span> std::bidirectional_iterator_tag(); 
<a name="l04869"></a>04869         } 
<a name="l04870"></a>04870  
<a name="l04871"></a>04871         std::bidirectional_iterator_tag __iterator_category(<span class="keyword">const</span> <a class="code" href="../../de/d78/classphys_1_1xml_1_1AttributeIterator.html" title="Attribute iterator (a bidirectional iterator over a collection of Attribute).">AttributeIterator</a>&amp;) 
<a name="l04872"></a>04872         { 
<a name="l04873"></a>04873                 <span class="keywordflow">return</span> std::bidirectional_iterator_tag(); 
<a name="l04874"></a>04874         } 
<a name="l04875"></a>04875 } 
<a name="l04876"></a>04876 <span class="preprocessor">#endif </span>
<a name="l04877"></a>04877 <span class="preprocessor"></span> 
<a name="l04878"></a>04878 <span class="preprocessor">#ifndef XML_NO_XPATH </span>
<a name="l04879"></a>04879 <span class="preprocessor"></span> 
<a name="l04880"></a>04880 <span class="comment">// STL replacements </span>
<a name="l04881"></a>04881 <span class="keyword">namespace </span>
<a name="l04882"></a>04882 { 
<a name="l04883"></a>04883         <span class="keyword">struct </span>equal_to 
<a name="l04884"></a>04884         { 
<a name="l04885"></a>04885                 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)<span class="keyword"> const </span>
<a name="l04886"></a>04886 <span class="keyword">                </span>{ 
<a name="l04887"></a>04887                         <span class="keywordflow">return</span> lhs == rhs; 
<a name="l04888"></a>04888                 } 
<a name="l04889"></a>04889         }; 
<a name="l04890"></a>04890  
<a name="l04891"></a>04891         <span class="keyword">struct </span>not_equal_to 
<a name="l04892"></a>04892         { 
<a name="l04893"></a>04893                 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)<span class="keyword"> const </span>
<a name="l04894"></a>04894 <span class="keyword">                </span>{ 
<a name="l04895"></a>04895                         <span class="keywordflow">return</span> lhs != rhs; 
<a name="l04896"></a>04896                 } 
<a name="l04897"></a>04897         }; 
<a name="l04898"></a>04898  
<a name="l04899"></a>04899         <span class="keyword">struct </span>less 
<a name="l04900"></a>04900         { 
<a name="l04901"></a>04901                 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)<span class="keyword"> const </span>
<a name="l04902"></a>04902 <span class="keyword">                </span>{ 
<a name="l04903"></a>04903                         <span class="keywordflow">return</span> lhs &lt; rhs; 
<a name="l04904"></a>04904                 } 
<a name="l04905"></a>04905         }; 
<a name="l04906"></a>04906  
<a name="l04907"></a>04907         <span class="keyword">struct </span>less_equal 
<a name="l04908"></a>04908         { 
<a name="l04909"></a>04909                 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> T&amp; lhs, <span class="keyword">const</span> T&amp; rhs)<span class="keyword"> const </span>
<a name="l04910"></a>04910 <span class="keyword">                </span>{ 
<a name="l04911"></a>04911                         <span class="keywordflow">return</span> lhs &lt;= rhs; 
<a name="l04912"></a>04912                 } 
<a name="l04913"></a>04913         }; 
<a name="l04914"></a>04914  
<a name="l04915"></a>04915         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> swap(T&amp; lhs, T&amp; rhs) 
<a name="l04916"></a>04916         { 
<a name="l04917"></a>04917                 T temp = lhs; 
<a name="l04918"></a>04918                 lhs = rhs; 
<a name="l04919"></a>04919                 rhs = temp; 
<a name="l04920"></a>04920         } 
<a name="l04921"></a>04921  
<a name="l04922"></a>04922         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="keyword">typename</span> Pred&gt; I min_element(I begin, I end, <span class="keyword">const</span> Pred&amp; pred) 
<a name="l04923"></a>04923         { 
<a name="l04924"></a>04924                 I Result = begin; 
<a name="l04925"></a>04925  
<a name="l04926"></a>04926                 <span class="keywordflow">for</span> (I it = begin + 1; it != end; ++it) 
<a name="l04927"></a>04927                         <span class="keywordflow">if</span> (pred(*it, *Result)) 
<a name="l04928"></a>04928                                 Result = it; 
<a name="l04929"></a>04929  
<a name="l04930"></a>04930                 <span class="keywordflow">return</span> Result; 
<a name="l04931"></a>04931         } 
<a name="l04932"></a>04932  
<a name="l04933"></a>04933         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="keywordtype">void</span> reverse(I begin, I end) 
<a name="l04934"></a>04934         { 
<a name="l04935"></a>04935                 <span class="keywordflow">while</span> (begin + 1 &lt; end) swap(*begin++, *--end); 
<a name="l04936"></a>04936         } 
<a name="l04937"></a>04937  
<a name="l04938"></a>04938         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; I unique(I begin, I end) 
<a name="l04939"></a>04939         { 
<a name="l04940"></a>04940                 <span class="comment">// fast skip head </span>
<a name="l04941"></a>04941                 <span class="keywordflow">while</span> (begin + 1 &lt; end &amp;&amp; *begin != *(begin + 1)) begin++; 
<a name="l04942"></a>04942  
<a name="l04943"></a>04943                 <span class="keywordflow">if</span> (begin == end) <span class="keywordflow">return</span> begin; 
<a name="l04944"></a>04944  
<a name="l04945"></a>04945                 <span class="comment">// last written element </span>
<a name="l04946"></a>04946                 I Write = begin++;  
<a name="l04947"></a>04947  
<a name="l04948"></a>04948                 <span class="comment">// merge unique elements </span>
<a name="l04949"></a>04949                 <span class="keywordflow">while</span> (begin != end) 
<a name="l04950"></a>04950                 { 
<a name="l04951"></a>04951                         <span class="keywordflow">if</span> (*begin != *Write) 
<a name="l04952"></a>04952                                 *++Write = *begin++; 
<a name="l04953"></a>04953                         <span class="keywordflow">else</span> 
<a name="l04954"></a>04954                                 begin++; 
<a name="l04955"></a>04955                 } 
<a name="l04956"></a>04956  
<a name="l04957"></a>04957                 <span class="comment">// past-the-end (Write points to live element) </span>
<a name="l04958"></a>04958                 <span class="keywordflow">return</span> Write + 1; 
<a name="l04959"></a>04959         } 
<a name="l04960"></a>04960  
<a name="l04961"></a>04961         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="keywordtype">void</span> copy_backwards(I begin, I end, I target) 
<a name="l04962"></a>04962         { 
<a name="l04963"></a>04963                 <span class="keywordflow">while</span> (begin != end) *--target = *--end; 
<a name="l04964"></a>04964         } 
<a name="l04965"></a>04965  
<a name="l04966"></a>04966         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="keyword">typename</span> Pred, <span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> insertion_sort(I begin, I end, <span class="keyword">const</span> Pred&amp; pred, T*) 
<a name="l04967"></a>04967         { 
<a name="l04968"></a>04968                 assert(begin != end); 
<a name="l04969"></a>04969  
<a name="l04970"></a>04970                 <span class="keywordflow">for</span> (I it = begin + 1; it != end; ++it) 
<a name="l04971"></a>04971                 { 
<a name="l04972"></a>04972                         T val = *it; 
<a name="l04973"></a>04973  
<a name="l04974"></a>04974                         <span class="keywordflow">if</span> (pred(val, *begin)) 
<a name="l04975"></a>04975                         { 
<a name="l04976"></a>04976                                 <span class="comment">// move to front </span>
<a name="l04977"></a>04977                                 copy_backwards(begin, it, it + 1); 
<a name="l04978"></a>04978                                 *begin = val; 
<a name="l04979"></a>04979                         } 
<a name="l04980"></a>04980                         <span class="keywordflow">else</span> 
<a name="l04981"></a>04981                         { 
<a name="l04982"></a>04982                                 I hole = it; 
<a name="l04983"></a>04983  
<a name="l04984"></a>04984                                 <span class="comment">// move hole backwards </span>
<a name="l04985"></a>04985                                 <span class="keywordflow">while</span> (pred(val, *(hole - 1))) 
<a name="l04986"></a>04986                                 { 
<a name="l04987"></a>04987                                         *hole = *(hole - 1); 
<a name="l04988"></a>04988                                         hole--; 
<a name="l04989"></a>04989                                 } 
<a name="l04990"></a>04990  
<a name="l04991"></a>04991                                 <span class="comment">// fill hole with element </span>
<a name="l04992"></a>04992                                 *hole = val; 
<a name="l04993"></a>04993                         } 
<a name="l04994"></a>04994                 } 
<a name="l04995"></a>04995         } 
<a name="l04996"></a>04996  
<a name="l04997"></a>04997         <span class="comment">// std variant for elements with == </span>
<a name="l04998"></a>04998         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="keyword">typename</span> Pred&gt; <span class="keywordtype">void</span> partition(I begin, I middle, I end, <span class="keyword">const</span> Pred&amp; pred, I* out_eqbeg, I* out_eqend) 
<a name="l04999"></a>04999         { 
<a name="l05000"></a>05000                 I eqbeg = middle, eqend = middle + 1; 
<a name="l05001"></a>05001  
<a name="l05002"></a>05002                 <span class="comment">// expand equal range </span>
<a name="l05003"></a>05003                 <span class="keywordflow">while</span> (eqbeg != begin &amp;&amp; *(eqbeg - 1) == *eqbeg) --eqbeg; 
<a name="l05004"></a>05004                 <span class="keywordflow">while</span> (eqend != end &amp;&amp; *eqend == *eqbeg) ++eqend; 
<a name="l05005"></a>05005  
<a name="l05006"></a>05006                 <span class="comment">// process outer elements </span>
<a name="l05007"></a>05007                 I ltend = eqbeg, gtbeg = eqend; 
<a name="l05008"></a>05008  
<a name="l05009"></a>05009                 <span class="keywordflow">for</span> (;;) 
<a name="l05010"></a>05010                 { 
<a name="l05011"></a>05011                         <span class="comment">// find the element from the right side that belongs to the left one </span>
<a name="l05012"></a>05012                         <span class="keywordflow">for</span> (; gtbeg != end; ++gtbeg) 
<a name="l05013"></a>05013                                 <span class="keywordflow">if</span> (!pred(*eqbeg, *gtbeg)) 
<a name="l05014"></a>05014                                 { 
<a name="l05015"></a>05015                                         <span class="keywordflow">if</span> (*gtbeg == *eqbeg) swap(*gtbeg, *eqend++); 
<a name="l05016"></a>05016                                         <span class="keywordflow">else</span> <span class="keywordflow">break</span>; 
<a name="l05017"></a>05017                                 } 
<a name="l05018"></a>05018  
<a name="l05019"></a>05019                         <span class="comment">// find the element from the left side that belongs to the right one </span>
<a name="l05020"></a>05020                         <span class="keywordflow">for</span> (; ltend != begin; --ltend) 
<a name="l05021"></a>05021                                 <span class="keywordflow">if</span> (!pred(*(ltend - 1), *eqbeg)) 
<a name="l05022"></a>05022                                 { 
<a name="l05023"></a>05023                                         <span class="keywordflow">if</span> (*eqbeg == *(ltend - 1)) swap(*(ltend - 1), *--eqbeg); 
<a name="l05024"></a>05024                                         <span class="keywordflow">else</span> <span class="keywordflow">break</span>; 
<a name="l05025"></a>05025                                 } 
<a name="l05026"></a>05026  
<a name="l05027"></a>05027                         <span class="comment">// scanned all elements </span>
<a name="l05028"></a>05028                         <span class="keywordflow">if</span> (gtbeg == end &amp;&amp; ltend == begin) 
<a name="l05029"></a>05029                         { 
<a name="l05030"></a>05030                                 *out_eqbeg = eqbeg; 
<a name="l05031"></a>05031                                 *out_eqend = eqend; 
<a name="l05032"></a>05032                                 <span class="keywordflow">return</span>; 
<a name="l05033"></a>05033                         } 
<a name="l05034"></a>05034  
<a name="l05035"></a>05035                         <span class="comment">// make room for elements by moving equal area </span>
<a name="l05036"></a>05036                         <span class="keywordflow">if</span> (gtbeg == end) 
<a name="l05037"></a>05037                         { 
<a name="l05038"></a>05038                                 <span class="keywordflow">if</span> (--ltend != --eqbeg) swap(*ltend, *eqbeg); 
<a name="l05039"></a>05039                                 swap(*eqbeg, *--eqend); 
<a name="l05040"></a>05040                         } 
<a name="l05041"></a>05041                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ltend == begin) 
<a name="l05042"></a>05042                         { 
<a name="l05043"></a>05043                                 <span class="keywordflow">if</span> (eqend != gtbeg) swap(*eqbeg, *eqend); 
<a name="l05044"></a>05044                                 ++eqend; 
<a name="l05045"></a>05045                                 swap(*gtbeg++, *eqbeg++); 
<a name="l05046"></a>05046                         } 
<a name="l05047"></a>05047                         <span class="keywordflow">else</span> swap(*gtbeg++, *--ltend); 
<a name="l05048"></a>05048                 } 
<a name="l05049"></a>05049         } 
<a name="l05050"></a>05050  
<a name="l05051"></a>05051         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="keyword">typename</span> Pred&gt; <span class="keywordtype">void</span> median3(I first, I middle, I last, <span class="keyword">const</span> Pred&amp; pred) 
<a name="l05052"></a>05052         { 
<a name="l05053"></a>05053                 <span class="keywordflow">if</span> (pred(*middle, *first)) swap(*middle, *first); 
<a name="l05054"></a>05054                 <span class="keywordflow">if</span> (pred(*last, *middle)) swap(*last, *middle); 
<a name="l05055"></a>05055                 <span class="keywordflow">if</span> (pred(*middle, *first)) swap(*middle, *first); 
<a name="l05056"></a>05056         } 
<a name="l05057"></a>05057  
<a name="l05058"></a>05058         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="keyword">typename</span> Pred&gt; <span class="keywordtype">void</span> median(I first, I middle, I last, <span class="keyword">const</span> Pred&amp; pred) 
<a name="l05059"></a>05059         { 
<a name="l05060"></a>05060                 <span class="keywordflow">if</span> (last - first &lt;= 40) 
<a name="l05061"></a>05061                 { 
<a name="l05062"></a>05062                         <span class="comment">// median of three for small chunks </span>
<a name="l05063"></a>05063                         median3(first, middle, last, pred); 
<a name="l05064"></a>05064                 } 
<a name="l05065"></a>05065                 <span class="keywordflow">else</span> 
<a name="l05066"></a>05066                 { 
<a name="l05067"></a>05067                         <span class="comment">// median of nine </span>
<a name="l05068"></a>05068                         <span class="keywordtype">size_t</span> step = (last - first + 1) / 8; 
<a name="l05069"></a>05069  
<a name="l05070"></a>05070                         median3(first, first + step, first + 2 * step, pred); 
<a name="l05071"></a>05071                         median3(middle - step, middle, middle + step, pred); 
<a name="l05072"></a>05072                         median3(last - 2 * step, last - step, last, pred); 
<a name="l05073"></a>05073                         median3(first + step, middle, last - step, pred); 
<a name="l05074"></a>05074                 } 
<a name="l05075"></a>05075         } 
<a name="l05076"></a>05076  
<a name="l05077"></a>05077         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I, <span class="keyword">typename</span> Pred&gt; <span class="keywordtype">void</span> sort(I begin, I end, <span class="keyword">const</span> Pred&amp; pred) 
<a name="l05078"></a>05078         { 
<a name="l05079"></a>05079                 <span class="comment">// sort large chunks </span>
<a name="l05080"></a>05080                 <span class="keywordflow">while</span> (end - begin &gt; 32) 
<a name="l05081"></a>05081                 { 
<a name="l05082"></a>05082                         <span class="comment">// find median element </span>
<a name="l05083"></a>05083                         I middle = begin + (end - begin) / 2; 
<a name="l05084"></a>05084                         median(begin, middle, end - 1, pred); 
<a name="l05085"></a>05085  
<a name="l05086"></a>05086                         <span class="comment">// partition in three chunks (&lt; = &gt;) </span>
<a name="l05087"></a>05087                         I eqbeg, eqend; 
<a name="l05088"></a>05088                         partition(begin, middle, end, pred, &amp;eqbeg, &amp;eqend); 
<a name="l05089"></a>05089  
<a name="l05090"></a>05090                         <span class="comment">// loop on larger half </span>
<a name="l05091"></a>05091                         <span class="keywordflow">if</span> (eqbeg - begin &gt; end - eqend) 
<a name="l05092"></a>05092                         { 
<a name="l05093"></a>05093                                 sort(eqend, end, pred); 
<a name="l05094"></a>05094                                 end = eqbeg; 
<a name="l05095"></a>05095                         } 
<a name="l05096"></a>05096                         <span class="keywordflow">else</span> 
<a name="l05097"></a>05097                         { 
<a name="l05098"></a>05098                                 sort(begin, eqbeg, pred); 
<a name="l05099"></a>05099                                 begin = eqend; 
<a name="l05100"></a>05100                         } 
<a name="l05101"></a>05101                 } 
<a name="l05102"></a>05102  
<a name="l05103"></a>05103                 <span class="comment">// insertion sort small chunk </span>
<a name="l05104"></a>05104                 <span class="keywordflow">if</span> (begin != end) insertion_sort(begin, end, pred, &amp;*begin); 
<a name="l05105"></a>05105         } 
<a name="l05106"></a>05106 } 
<a name="l05107"></a>05107  
<a name="l05108"></a>05108 <span class="comment">// Allocator used for AST and evaluation stacks </span>
<a name="l05109"></a>05109 <span class="keyword">namespace </span>
<a name="l05110"></a>05110 { 
<a name="l05111"></a>05111         <span class="keyword">struct </span>XPathMemoryBlock 
<a name="l05112"></a>05112         {        
<a name="l05113"></a>05113                 XPathMemoryBlock* next; 
<a name="l05114"></a>05114  
<a name="l05115"></a>05115                 <span class="keywordtype">char</span> data[4096]; 
<a name="l05116"></a>05116         }; 
<a name="l05117"></a>05117                  
<a name="l05118"></a>05118         <span class="keyword">class </span>XPathAllocator 
<a name="l05119"></a>05119         { 
<a name="l05120"></a>05120                 XPathMemoryBlock* _GetRoot; 
<a name="l05121"></a>05121                 <span class="keywordtype">size_t</span> _GetRoot_size; 
<a name="l05122"></a>05122  
<a name="l05123"></a>05123         <span class="keyword">public</span>: 
<a name="l05124"></a>05124 <span class="preprocessor">        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l05125"></a>05125 <span class="preprocessor"></span>                jmp_buf* error_handler; 
<a name="l05126"></a>05126 <span class="preprocessor">        #endif </span>
<a name="l05127"></a>05127 <span class="preprocessor"></span> 
<a name="l05128"></a>05128                 XPathAllocator(XPathMemoryBlock* GetRoot, <span class="keywordtype">size_t</span> GetRoot_size = 0): _GetRoot(GetRoot), _GetRoot_size(GetRoot_size) 
<a name="l05129"></a>05129                 { 
<a name="l05130"></a>05130 <span class="preprocessor">                #ifdef XML_NO_EXCEPTIONS </span>
<a name="l05131"></a>05131 <span class="preprocessor"></span>                        error_handler = 0; 
<a name="l05132"></a>05132 <span class="preprocessor">                #endif </span>
<a name="l05133"></a>05133 <span class="preprocessor"></span>                } 
<a name="l05134"></a>05134                  
<a name="l05135"></a>05135                 <span class="keywordtype">void</span>* allocate_nothrow(<span class="keywordtype">size_t</span> size) 
<a name="l05136"></a>05136                 { 
<a name="l05137"></a>05137                         <span class="keyword">const</span> <span class="keywordtype">size_t</span> block_capacity = <span class="keyword">sizeof</span>(_GetRoot-&gt;data); 
<a name="l05138"></a>05138  
<a name="l05139"></a>05139                         <span class="comment">// align size so that we&#39;re able to store pointers in subsequent blocks </span>
<a name="l05140"></a>05140                         size = (size + <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1) &amp; ~(<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1); 
<a name="l05141"></a>05141  
<a name="l05142"></a>05142                         <span class="keywordflow">if</span> (_GetRoot_size + size &lt;= block_capacity) 
<a name="l05143"></a>05143                         { 
<a name="l05144"></a>05144                                 <span class="keywordtype">void</span>* buf = _GetRoot-&gt;data + _GetRoot_size; 
<a name="l05145"></a>05145                                 _GetRoot_size += size; 
<a name="l05146"></a>05146                                 <span class="keywordflow">return</span> buf; 
<a name="l05147"></a>05147                         } 
<a name="l05148"></a>05148                         <span class="keywordflow">else</span> 
<a name="l05149"></a>05149                         { 
<a name="l05150"></a>05150                                 <span class="keywordtype">size_t</span> block_data_size = (size &gt; block_capacity) ? size : block_capacity; 
<a name="l05151"></a>05151                                 <span class="keywordtype">size_t</span> block_size = block_data_size + offsetof(XPathMemoryBlock, data); 
<a name="l05152"></a>05152  
<a name="l05153"></a>05153                                 XPathMemoryBlock* block = <span class="keyword">static_cast&lt;</span>XPathMemoryBlock*<span class="keyword">&gt;</span>(global_allocate(block_size)); 
<a name="l05154"></a>05154                                 <span class="keywordflow">if</span> (!block) <span class="keywordflow">return</span> 0; 
<a name="l05155"></a>05155                                  
<a name="l05156"></a>05156                                 block-&gt;next = _GetRoot; 
<a name="l05157"></a>05157                                  
<a name="l05158"></a>05158                                 _GetRoot = block; 
<a name="l05159"></a>05159                                 _GetRoot_size = size; 
<a name="l05160"></a>05160                                  
<a name="l05161"></a>05161                                 <span class="keywordflow">return</span> block-&gt;data; 
<a name="l05162"></a>05162                         } 
<a name="l05163"></a>05163                 } 
<a name="l05164"></a>05164  
<a name="l05165"></a>05165                 <span class="keywordtype">void</span>* allocate(<span class="keywordtype">size_t</span> size) 
<a name="l05166"></a>05166                 { 
<a name="l05167"></a>05167                         <span class="keywordtype">void</span>* Result = allocate_nothrow(size); 
<a name="l05168"></a>05168  
<a name="l05169"></a>05169                         <span class="keywordflow">if</span> (!Result) 
<a name="l05170"></a>05170                         { 
<a name="l05171"></a>05171 <span class="preprocessor">                        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l05172"></a>05172 <span class="preprocessor"></span>                                assert(error_handler); 
<a name="l05173"></a>05173                                 longjmp(*error_handler, 1); 
<a name="l05174"></a>05174 <span class="preprocessor">                        #else </span>
<a name="l05175"></a>05175 <span class="preprocessor"></span>                                <span class="keywordflow">throw</span> std::bad_alloc(); 
<a name="l05176"></a>05176 <span class="preprocessor">                        #endif </span>
<a name="l05177"></a>05177 <span class="preprocessor"></span>                        } 
<a name="l05178"></a>05178  
<a name="l05179"></a>05179                         <span class="keywordflow">return</span> Result; 
<a name="l05180"></a>05180                 } 
<a name="l05181"></a>05181  
<a name="l05182"></a>05182                 <span class="keywordtype">void</span>* reallocate(<span class="keywordtype">void</span>* ptr, <span class="keywordtype">size_t</span> old_size, <span class="keywordtype">size_t</span> new_size) 
<a name="l05183"></a>05183                 { 
<a name="l05184"></a>05184                         <span class="comment">// align size so that we&#39;re able to store pointers in subsequent blocks </span>
<a name="l05185"></a>05185                         old_size = (old_size + <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1) &amp; ~(<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1); 
<a name="l05186"></a>05186                         new_size = (new_size + <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1) &amp; ~(<span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) - 1); 
<a name="l05187"></a>05187  
<a name="l05188"></a>05188                         <span class="comment">// we can only reallocate the last object </span>
<a name="l05189"></a>05189                         assert(ptr == 0 || static_cast&lt;char*&gt;(ptr) + old_size == _GetRoot-&gt;data + _GetRoot_size); 
<a name="l05190"></a>05190  
<a name="l05191"></a>05191                         <span class="comment">// adjust GetRoot size so that we have not allocated the object at all </span>
<a name="l05192"></a>05192                         <span class="keywordtype">bool</span> only_object = (_GetRoot_size == old_size); 
<a name="l05193"></a>05193  
<a name="l05194"></a>05194                         <span class="keywordflow">if</span> (ptr) _GetRoot_size -= old_size; 
<a name="l05195"></a>05195  
<a name="l05196"></a>05196                         <span class="comment">// allocate a new version (this will obviously reuse the memory if possible) </span>
<a name="l05197"></a>05197                         <span class="keywordtype">void</span>* Result = allocate(new_size); 
<a name="l05198"></a>05198                         assert(Result); 
<a name="l05199"></a>05199  
<a name="l05200"></a>05200                         <span class="comment">// we have a new block </span>
<a name="l05201"></a>05201                         <span class="keywordflow">if</span> (Result != ptr &amp;&amp; ptr) 
<a name="l05202"></a>05202                         { 
<a name="l05203"></a>05203                                 <span class="comment">// copy old data </span>
<a name="l05204"></a>05204                                 assert(new_size &gt; old_size); 
<a name="l05205"></a>05205                                 memcpy(Result, ptr, old_size); 
<a name="l05206"></a>05206  
<a name="l05207"></a>05207                                 <span class="comment">// free the previous page if it had no other objects </span>
<a name="l05208"></a>05208                                 <span class="keywordflow">if</span> (only_object) 
<a name="l05209"></a>05209                                 { 
<a name="l05210"></a>05210                                         assert(_GetRoot-&gt;data == Result); 
<a name="l05211"></a>05211                                         assert(_GetRoot-&gt;next); 
<a name="l05212"></a>05212  
<a name="l05213"></a>05213                                         XPathMemoryBlock* next = _GetRoot-&gt;next-&gt;next; 
<a name="l05214"></a>05214  
<a name="l05215"></a>05215                                         <span class="keywordflow">if</span> (next) 
<a name="l05216"></a>05216                                         { 
<a name="l05217"></a>05217                                                 <span class="comment">// deallocate the whole page, unless it was the first one </span>
<a name="l05218"></a>05218                                                 global_deallocate(_GetRoot-&gt;next); 
<a name="l05219"></a>05219                                                 _GetRoot-&gt;next = next; 
<a name="l05220"></a>05220                                         } 
<a name="l05221"></a>05221                                 } 
<a name="l05222"></a>05222                         } 
<a name="l05223"></a>05223  
<a name="l05224"></a>05224                         <span class="keywordflow">return</span> Result; 
<a name="l05225"></a>05225                 } 
<a name="l05226"></a>05226  
<a name="l05227"></a>05227                 <span class="keywordtype">void</span> revert(<span class="keyword">const</span> XPathAllocator&amp; state) 
<a name="l05228"></a>05228                 { 
<a name="l05229"></a>05229                         <span class="comment">// free all new pages </span>
<a name="l05230"></a>05230                         XPathMemoryBlock* cur = _GetRoot; 
<a name="l05231"></a>05231  
<a name="l05232"></a>05232                         <span class="keywordflow">while</span> (cur != state._GetRoot) 
<a name="l05233"></a>05233                         { 
<a name="l05234"></a>05234                                 XPathMemoryBlock* next = cur-&gt;next; 
<a name="l05235"></a>05235  
<a name="l05236"></a>05236                                 global_deallocate(cur); 
<a name="l05237"></a>05237  
<a name="l05238"></a>05238                                 cur = next; 
<a name="l05239"></a>05239                         } 
<a name="l05240"></a>05240  
<a name="l05241"></a>05241                         <span class="comment">// restore state </span>
<a name="l05242"></a>05242                         _GetRoot = state._GetRoot; 
<a name="l05243"></a>05243                         _GetRoot_size = state._GetRoot_size; 
<a name="l05244"></a>05244                 } 
<a name="l05245"></a>05245  
<a name="l05246"></a>05246                 <span class="keywordtype">void</span> release() 
<a name="l05247"></a>05247                 { 
<a name="l05248"></a>05248                         XPathMemoryBlock* cur = _GetRoot; 
<a name="l05249"></a>05249                         assert(cur); 
<a name="l05250"></a>05250  
<a name="l05251"></a>05251                         <span class="keywordflow">while</span> (cur-&gt;next) 
<a name="l05252"></a>05252                         { 
<a name="l05253"></a>05253                                 XPathMemoryBlock* next = cur-&gt;next; 
<a name="l05254"></a>05254  
<a name="l05255"></a>05255                                 global_deallocate(cur); 
<a name="l05256"></a>05256  
<a name="l05257"></a>05257                                 cur = next; 
<a name="l05258"></a>05258                         } 
<a name="l05259"></a>05259                 } 
<a name="l05260"></a>05260         }; 
<a name="l05261"></a>05261  
<a name="l05262"></a>05262         <span class="keyword">struct </span>XPathAllocatorCapture 
<a name="l05263"></a>05263         { 
<a name="l05264"></a>05264                 XPathAllocatorCapture(XPathAllocator* alloc): _target(alloc), _state(*alloc) 
<a name="l05265"></a>05265                 { 
<a name="l05266"></a>05266                 } 
<a name="l05267"></a>05267  
<a name="l05268"></a>05268                 ~XPathAllocatorCapture() 
<a name="l05269"></a>05269                 { 
<a name="l05270"></a>05270                         _target-&gt;revert(_state); 
<a name="l05271"></a>05271                 } 
<a name="l05272"></a>05272  
<a name="l05273"></a>05273                 XPathAllocator* _target; 
<a name="l05274"></a>05274                 XPathAllocator _state; 
<a name="l05275"></a>05275         }; 
<a name="l05276"></a>05276  
<a name="l05277"></a>05277         <span class="keyword">struct </span>XPathStack 
<a name="l05278"></a>05278         { 
<a name="l05279"></a>05279                 XPathAllocator* Result; 
<a name="l05280"></a>05280                 XPathAllocator* temp; 
<a name="l05281"></a>05281         }; 
<a name="l05282"></a>05282  
<a name="l05283"></a>05283         <span class="keyword">struct </span>XPathStackData 
<a name="l05284"></a>05284         { 
<a name="l05285"></a>05285                 XPathMemoryBlock blocks[2]; 
<a name="l05286"></a>05286                 XPathAllocator Result; 
<a name="l05287"></a>05287                 XPathAllocator temp; 
<a name="l05288"></a>05288                 XPathStack stack; 
<a name="l05289"></a>05289  
<a name="l05290"></a>05290 <span class="preprocessor">        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l05291"></a>05291 <span class="preprocessor"></span>                jmp_buf error_handler; 
<a name="l05292"></a>05292 <span class="preprocessor">        #endif </span>
<a name="l05293"></a>05293 <span class="preprocessor"></span> 
<a name="l05294"></a>05294                 XPathStackData(): Result(blocks + 0), temp(blocks + 1) 
<a name="l05295"></a>05295                 { 
<a name="l05296"></a>05296                         blocks[0].next = blocks[1].next = 0; 
<a name="l05297"></a>05297  
<a name="l05298"></a>05298                         stack.Result = &amp;Result; 
<a name="l05299"></a>05299                         stack.temp = &amp;temp; 
<a name="l05300"></a>05300  
<a name="l05301"></a>05301 <span class="preprocessor">                #ifdef XML_NO_EXCEPTIONS </span>
<a name="l05302"></a>05302 <span class="preprocessor"></span>                        Result.error_handler = temp.error_handler = &amp;error_handler; 
<a name="l05303"></a>05303 <span class="preprocessor">                #endif </span>
<a name="l05304"></a>05304 <span class="preprocessor"></span>                } 
<a name="l05305"></a>05305  
<a name="l05306"></a>05306                 ~XPathStackData() 
<a name="l05307"></a>05307                 { 
<a name="l05308"></a>05308                         Result.release(); 
<a name="l05309"></a>05309                         temp.release(); 
<a name="l05310"></a>05310                 } 
<a name="l05311"></a>05311         }; 
<a name="l05312"></a>05312 } 
<a name="l05313"></a>05313  
<a name="l05314"></a>05314 <span class="comment">// String class </span>
<a name="l05315"></a>05315 <span class="keyword">namespace </span>
<a name="l05316"></a>05316 { 
<a name="l05317"></a>05317         <span class="keyword">class </span>XPathString 
<a name="l05318"></a>05318         { 
<a name="l05319"></a>05319                 <span class="keyword">const</span> char_t* _buffer; 
<a name="l05320"></a>05320                 <span class="keywordtype">bool</span> _uses_heap; 
<a name="l05321"></a>05321  
<a name="l05322"></a>05322                 <span class="keyword">static</span> char_t* duplicate_string(<span class="keyword">const</span> char_t* <span class="keywordtype">string</span>, <span class="keywordtype">size_t</span> length, XPathAllocator* alloc) 
<a name="l05323"></a>05323                 { 
<a name="l05324"></a>05324                         char_t* Result = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(alloc-&gt;allocate((length + 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l05325"></a>05325                         assert(Result); 
<a name="l05326"></a>05326  
<a name="l05327"></a>05327                         memcpy(Result, <span class="keywordtype">string</span>, length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l05328"></a>05328                         Result[length] = 0; 
<a name="l05329"></a>05329  
<a name="l05330"></a>05330                         <span class="keywordflow">return</span> Result; 
<a name="l05331"></a>05331                 } 
<a name="l05332"></a>05332  
<a name="l05333"></a>05333                 <span class="keyword">static</span> char_t* duplicate_string(<span class="keyword">const</span> char_t* <span class="keywordtype">string</span>, XPathAllocator* alloc) 
<a name="l05334"></a>05334                 { 
<a name="l05335"></a>05335                         <span class="keywordflow">return</span> duplicate_string(<span class="keywordtype">string</span>, strlength(<span class="keywordtype">string</span>), alloc); 
<a name="l05336"></a>05336                 } 
<a name="l05337"></a>05337  
<a name="l05338"></a>05338         <span class="keyword">public</span>: 
<a name="l05339"></a>05339                 XPathString(): _buffer(<a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>)), _uses_heap(false) 
<a name="l05340"></a>05340                 { 
<a name="l05341"></a>05341                 } 
<a name="l05342"></a>05342  
<a name="l05343"></a>05343                 <span class="keyword">explicit</span> XPathString(<span class="keyword">const</span> char_t* str, XPathAllocator* alloc) 
<a name="l05344"></a>05344                 { 
<a name="l05345"></a>05345                         <span class="keywordtype">bool</span> empty = (*str == 0); 
<a name="l05346"></a>05346  
<a name="l05347"></a>05347                         _buffer = empty ? <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>) : duplicate_string(str, alloc); 
<a name="l05348"></a>05348                         _uses_heap = !empty; 
<a name="l05349"></a>05349                 } 
<a name="l05350"></a>05350  
<a name="l05351"></a>05351                 <span class="keyword">explicit</span> XPathString(<span class="keyword">const</span> char_t* str, <span class="keywordtype">bool</span> use_heap): _buffer(str), _uses_heap(use_heap) 
<a name="l05352"></a>05352                 { 
<a name="l05353"></a>05353                 } 
<a name="l05354"></a>05354  
<a name="l05355"></a>05355                 XPathString(<span class="keyword">const</span> char_t* begin, <span class="keyword">const</span> char_t* end, XPathAllocator* alloc) 
<a name="l05356"></a>05356                 { 
<a name="l05357"></a>05357                         assert(begin &lt;= end); 
<a name="l05358"></a>05358  
<a name="l05359"></a>05359                         <span class="keywordtype">bool</span> empty = (begin == end); 
<a name="l05360"></a>05360  
<a name="l05361"></a>05361                         _buffer = empty ? <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>) : duplicate_string(begin, static_cast&lt;size_t&gt;(end - begin), alloc); 
<a name="l05362"></a>05362                         _uses_heap = !empty; 
<a name="l05363"></a>05363                 } 
<a name="l05364"></a>05364  
<a name="l05365"></a>05365                 <span class="keywordtype">void</span> append(<span class="keyword">const</span> XPathString&amp; o, XPathAllocator* alloc) 
<a name="l05366"></a>05366                 { 
<a name="l05367"></a>05367                         <span class="comment">// skip empty sources </span>
<a name="l05368"></a>05368                         <span class="keywordflow">if</span> (!*o._buffer) <span class="keywordflow">return</span>; 
<a name="l05369"></a>05369  
<a name="l05370"></a>05370                         <span class="comment">// fast append for constant empty target and constant source </span>
<a name="l05371"></a>05371                         <span class="keywordflow">if</span> (!*_buffer &amp;&amp; !_uses_heap &amp;&amp; !o._uses_heap) 
<a name="l05372"></a>05372                         { 
<a name="l05373"></a>05373                                 _buffer = o._buffer; 
<a name="l05374"></a>05374                         } 
<a name="l05375"></a>05375                         <span class="keywordflow">else</span> 
<a name="l05376"></a>05376                         { 
<a name="l05377"></a>05377                                 <span class="comment">// need to make heap copy </span>
<a name="l05378"></a>05378                                 <span class="keywordtype">size_t</span> tarGetLength = strlength(_buffer); 
<a name="l05379"></a>05379                                 <span class="keywordtype">size_t</span> source_length = strlength(o._buffer); 
<a name="l05380"></a>05380                                 <span class="keywordtype">size_t</span> length = tarGetLength + source_length; 
<a name="l05381"></a>05381  
<a name="l05382"></a>05382                                 <span class="comment">// allocate new buffer </span>
<a name="l05383"></a>05383                                 char_t* Result = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(alloc-&gt;reallocate(_uses_heap ? const_cast&lt;char_t*&gt;(_buffer) : 0, (tarGetLength + 1) * <span class="keyword">sizeof</span>(char_t), (length + 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l05384"></a>05384                                 assert(Result); 
<a name="l05385"></a>05385  
<a name="l05386"></a>05386                                 <span class="comment">// append first string to the new buffer in case there was no reallocation </span>
<a name="l05387"></a>05387                                 <span class="keywordflow">if</span> (!_uses_heap) memcpy(Result, _buffer, tarGetLength * <span class="keyword">sizeof</span>(char_t)); 
<a name="l05388"></a>05388  
<a name="l05389"></a>05389                                 <span class="comment">// append second string to the new buffer </span>
<a name="l05390"></a>05390                                 memcpy(Result + tarGetLength, o._buffer, source_length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l05391"></a>05391                                 Result[length] = 0; 
<a name="l05392"></a>05392  
<a name="l05393"></a>05393                                 <span class="comment">// finalize </span>
<a name="l05394"></a>05394                                 _buffer = Result; 
<a name="l05395"></a>05395                                 _uses_heap = <span class="keyword">true</span>; 
<a name="l05396"></a>05396                         } 
<a name="l05397"></a>05397                 } 
<a name="l05398"></a>05398  
<a name="l05399"></a>05399                 <span class="keyword">const</span> char_t* c_str()<span class="keyword"> const </span>
<a name="l05400"></a>05400 <span class="keyword">                </span>{ 
<a name="l05401"></a>05401                         <span class="keywordflow">return</span> _buffer; 
<a name="l05402"></a>05402                 } 
<a name="l05403"></a>05403  
<a name="l05404"></a>05404                 <span class="keywordtype">size_t</span> length()<span class="keyword"> const </span>
<a name="l05405"></a>05405 <span class="keyword">                </span>{ 
<a name="l05406"></a>05406                         <span class="keywordflow">return</span> strlength(_buffer); 
<a name="l05407"></a>05407                 } 
<a name="l05408"></a>05408                  
<a name="l05409"></a>05409                 char_t* data(XPathAllocator* alloc) 
<a name="l05410"></a>05410                 { 
<a name="l05411"></a>05411                         <span class="comment">// make private heap copy </span>
<a name="l05412"></a>05412                         <span class="keywordflow">if</span> (!_uses_heap) 
<a name="l05413"></a>05413                         { 
<a name="l05414"></a>05414                                 _buffer = duplicate_string(_buffer, alloc); 
<a name="l05415"></a>05415                                 _uses_heap = <span class="keyword">true</span>; 
<a name="l05416"></a>05416                         } 
<a name="l05417"></a>05417  
<a name="l05418"></a>05418                         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(_buffer); 
<a name="l05419"></a>05419                 } 
<a name="l05420"></a>05420  
<a name="l05421"></a>05421                 <span class="keywordtype">bool</span> Empty()<span class="keyword"> const </span>
<a name="l05422"></a>05422 <span class="keyword">                </span>{ 
<a name="l05423"></a>05423                         <span class="keywordflow">return</span> *_buffer == 0; 
<a name="l05424"></a>05424                 } 
<a name="l05425"></a>05425  
<a name="l05426"></a>05426                 <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> XPathString&amp; o)<span class="keyword"> const </span>
<a name="l05427"></a>05427 <span class="keyword">                </span>{ 
<a name="l05428"></a>05428                         <span class="keywordflow">return</span> strequal(_buffer, o._buffer); 
<a name="l05429"></a>05429                 } 
<a name="l05430"></a>05430  
<a name="l05431"></a>05431                 <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> XPathString&amp; o)<span class="keyword"> const </span>
<a name="l05432"></a>05432 <span class="keyword">                </span>{ 
<a name="l05433"></a>05433                         <span class="keywordflow">return</span> !strequal(_buffer, o._buffer); 
<a name="l05434"></a>05434                 } 
<a name="l05435"></a>05435  
<a name="l05436"></a>05436                 <span class="keywordtype">bool</span> uses_heap()<span class="keyword"> const </span>
<a name="l05437"></a>05437 <span class="keyword">                </span>{ 
<a name="l05438"></a>05438                         <span class="keywordflow">return</span> _uses_heap; 
<a name="l05439"></a>05439                 } 
<a name="l05440"></a>05440         }; 
<a name="l05441"></a>05441  
<a name="l05442"></a>05442         XPathString XPathStringConst(<span class="keyword">const</span> char_t* str) 
<a name="l05443"></a>05443         { 
<a name="l05444"></a>05444                 <span class="keywordflow">return</span> XPathString(str, <span class="keyword">false</span>); 
<a name="l05445"></a>05445         } 
<a name="l05446"></a>05446 } 
<a name="l05447"></a>05447  
<a name="l05448"></a>05448 <span class="keyword">namespace </span>
<a name="l05449"></a>05449 { 
<a name="l05450"></a>05450         <span class="keywordtype">bool</span> starts_with(<span class="keyword">const</span> char_t* <span class="keywordtype">string</span>, <span class="keyword">const</span> char_t* pattern) 
<a name="l05451"></a>05451         { 
<a name="l05452"></a>05452                 <span class="keywordflow">while</span> (*pattern &amp;&amp; *<span class="keywordtype">string</span> == *pattern) 
<a name="l05453"></a>05453                 { 
<a name="l05454"></a>05454                         <span class="keywordtype">string</span>++; 
<a name="l05455"></a>05455                         pattern++; 
<a name="l05456"></a>05456                 } 
<a name="l05457"></a>05457  
<a name="l05458"></a>05458                 <span class="keywordflow">return</span> *pattern == 0; 
<a name="l05459"></a>05459         } 
<a name="l05460"></a>05460  
<a name="l05461"></a>05461         <span class="keyword">const</span> char_t* FindChar(<span class="keyword">const</span> char_t* s, char_t c) 
<a name="l05462"></a>05462         { 
<a name="l05463"></a>05463 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l05464"></a>05464 <span class="preprocessor"></span>                <span class="keywordflow">return</span> wcschr(s, c); 
<a name="l05465"></a>05465 <span class="preprocessor">        #else </span>
<a name="l05466"></a>05466 <span class="preprocessor"></span>                <span class="keywordflow">return</span> strchr(s, c); 
<a name="l05467"></a>05467 <span class="preprocessor">        #endif </span>
<a name="l05468"></a>05468 <span class="preprocessor"></span>        } 
<a name="l05469"></a>05469  
<a name="l05470"></a>05470         <span class="keyword">const</span> char_t* FindSubstring(<span class="keyword">const</span> char_t* s, <span class="keyword">const</span> char_t* p) 
<a name="l05471"></a>05471         { 
<a name="l05472"></a>05472 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l05473"></a>05473 <span class="preprocessor"></span>                <span class="comment">// MSVC6 wcsstr bug workaround (if s is empty it always returns 0) </span>
<a name="l05474"></a>05474                 <span class="keywordflow">return</span> (*p == 0) ? s : wcsstr(s, p); 
<a name="l05475"></a>05475 <span class="preprocessor">        #else </span>
<a name="l05476"></a>05476 <span class="preprocessor"></span>                <span class="keywordflow">return</span> strstr(s, p); 
<a name="l05477"></a>05477 <span class="preprocessor">        #endif </span>
<a name="l05478"></a>05478 <span class="preprocessor"></span>        } 
<a name="l05479"></a>05479  
<a name="l05480"></a>05480         <span class="comment">// Converts symbol to lower case, if it is an ASCII one </span>
<a name="l05481"></a>05481         char_t tolower_ascii(char_t ch) 
<a name="l05482"></a>05482         { 
<a name="l05483"></a>05483                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(ch - <span class="charliteral">&#39;A&#39;</span>) &lt; 26 ? static_cast&lt;char_t&gt;(ch | <span class="charliteral">&#39; &#39;</span>) : ch; 
<a name="l05484"></a>05484         } 
<a name="l05485"></a>05485  
<a name="l05486"></a>05486         XPathString string_Value(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; na, XPathAllocator* alloc) 
<a name="l05487"></a>05487         { 
<a name="l05488"></a>05488                 <span class="keywordflow">if</span> (na.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>()) 
<a name="l05489"></a>05489                         <span class="keywordflow">return</span> XPathStringConst(na.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>().<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>()); 
<a name="l05490"></a>05490                 <span class="keywordflow">else</span> 
<a name="l05491"></a>05491                 { 
<a name="l05492"></a>05492                         <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; n = na.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>(); 
<a name="l05493"></a>05493  
<a name="l05494"></a>05494                         <span class="keywordflow">switch</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>()) 
<a name="l05495"></a>05495                         { 
<a name="l05496"></a>05496                         <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a>: 
<a name="l05497"></a>05497                         <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a353968e806a751a6da4f7ac115b4ab55" title="Character data, i.e. &amp;#39;&amp;lt;![CDATA[text]]&amp;gt;&amp;#39;.">NodeCdata</a>: 
<a name="l05498"></a>05498                         <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a25b778cb61ae0a9f15590cad5e0120d2" title="Comment tag, i.e. &amp;#39;&amp;#39;.">NodeComment</a>: 
<a name="l05499"></a>05499                         <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a>: 
<a name="l05500"></a>05500                                 <span class="keywordflow">return</span> XPathStringConst(n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()); 
<a name="l05501"></a>05501                          
<a name="l05502"></a>05502                         <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3acfe92e6bd275972917b95f08bd46e09f" title="A document tree&amp;#39;s absolute root.">NodeDocument</a>: 
<a name="l05503"></a>05503                         <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a>: 
<a name="l05504"></a>05504                         { 
<a name="l05505"></a>05505                                 XPathString Result; 
<a name="l05506"></a>05506  
<a name="l05507"></a>05507                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l05508"></a>05508                                  
<a name="l05509"></a>05509                                 <span class="keywordflow">while</span> (cur &amp;&amp; cur != n) 
<a name="l05510"></a>05510                                 { 
<a name="l05511"></a>05511                                         <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a> || cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == NodeCdata) 
<a name="l05512"></a>05512                                                 Result.append(XPathStringConst(cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a90e8efb31007ade54d62c1752979461f" title="Get the Value of this Node.">Value</a>()), alloc); 
<a name="l05513"></a>05513  
<a name="l05514"></a>05514                                         <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>()) 
<a name="l05515"></a>05515                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l05516"></a>05516                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) 
<a name="l05517"></a>05517                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l05518"></a>05518                                         <span class="keywordflow">else</span> 
<a name="l05519"></a>05519                                         { 
<a name="l05520"></a>05520                                                 <span class="keywordflow">while</span> (!cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>() &amp;&amp; cur != n) 
<a name="l05521"></a>05521                                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05522"></a>05522  
<a name="l05523"></a>05523                                                 <span class="keywordflow">if</span> (cur != n) cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l05524"></a>05524                                         } 
<a name="l05525"></a>05525                                 } 
<a name="l05526"></a>05526                                  
<a name="l05527"></a>05527                                 <span class="keywordflow">return</span> Result; 
<a name="l05528"></a>05528                         } 
<a name="l05529"></a>05529                          
<a name="l05530"></a>05530                         <span class="keywordflow">default</span>: 
<a name="l05531"></a>05531                                 <span class="keywordflow">return</span> XPathString(); 
<a name="l05532"></a>05532                         } 
<a name="l05533"></a>05533                 } 
<a name="l05534"></a>05534         } 
<a name="l05535"></a>05535          
<a name="l05536"></a>05536         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NodeHeight(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n) 
<a name="l05537"></a>05537         { 
<a name="l05538"></a>05538                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Result = 0; 
<a name="l05539"></a>05539                  
<a name="l05540"></a>05540                 <span class="keywordflow">while</span> (n) 
<a name="l05541"></a>05541                 { 
<a name="l05542"></a>05542                         ++Result; 
<a name="l05543"></a>05543                         n = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05544"></a>05544                 } 
<a name="l05545"></a>05545                  
<a name="l05546"></a>05546                 <span class="keywordflow">return</span> Result; 
<a name="l05547"></a>05547         } 
<a name="l05548"></a>05548          
<a name="l05549"></a>05549         <span class="keywordtype">bool</span> NodeIs_before(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> ln, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lh, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> rn, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rh) 
<a name="l05550"></a>05550         { 
<a name="l05551"></a>05551                 <span class="comment">// normalize heights </span>
<a name="l05552"></a>05552                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = rh; i &lt; lh; i++) ln = ln.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05553"></a>05553                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = lh; j &lt; rh; j++) rn = rn.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05554"></a>05554                  
<a name="l05555"></a>05555                 <span class="comment">// one node is the ancestor of the other </span>
<a name="l05556"></a>05556                 <span class="keywordflow">if</span> (ln == rn) <span class="keywordflow">return</span> lh &lt; rh; 
<a name="l05557"></a>05557                  
<a name="l05558"></a>05558                 <span class="comment">// find common ancestor </span>
<a name="l05559"></a>05559                 <span class="keywordflow">while</span> (ln.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>() != rn.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>()) 
<a name="l05560"></a>05560                 { 
<a name="l05561"></a>05561                         ln = ln.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05562"></a>05562                         rn = rn.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05563"></a>05563                 } 
<a name="l05564"></a>05564  
<a name="l05565"></a>05565                 <span class="comment">// there is no common ancestor (the shared GetParent is null), nodes are from different documents </span>
<a name="l05566"></a>05566                 <span class="keywordflow">if</span> (!ln.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>()) <span class="keywordflow">return</span> ln &lt; rn; 
<a name="l05567"></a>05567  
<a name="l05568"></a>05568                 <span class="comment">// determine sibling order </span>
<a name="l05569"></a>05569                 <span class="keywordflow">for</span> (; ln; ln = ln.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) 
<a name="l05570"></a>05570                         <span class="keywordflow">if</span> (ln == rn) 
<a name="l05571"></a>05571                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l05572"></a>05572                                  
<a name="l05573"></a>05573                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05574"></a>05574         } 
<a name="l05575"></a>05575  
<a name="l05576"></a>05576         <span class="keywordtype">bool</span> NodeIs_ancestor(<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> GetParent, <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> node) 
<a name="l05577"></a>05577         { 
<a name="l05578"></a>05578                 <span class="keywordflow">while</span> (node &amp;&amp; node != GetParent) node = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05579"></a>05579  
<a name="l05580"></a>05580                 <span class="keywordflow">return</span> GetParent &amp;&amp; node == GetParent; 
<a name="l05581"></a>05581         } 
<a name="l05582"></a>05582  
<a name="l05583"></a>05583         <span class="keyword">const</span> <span class="keywordtype">void</span>* document_order(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; xnode) 
<a name="l05584"></a>05584         { 
<a name="l05585"></a>05585                 <a class="code" href="../../d7/dd5/structphys_1_1xml_1_1NodeStruct.html" title="The internal data storage structure used in a Node.">NodeStruct</a>* node = xnode.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>().<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a0d2c64c909e7545d01b586fe9d0bd9d4" title="Get internal pointer.">InternalObject</a>(); 
<a name="l05586"></a>05586  
<a name="l05587"></a>05587                 <span class="keywordflow">if</span> (node) 
<a name="l05588"></a>05588                 { 
<a name="l05589"></a>05589                         <span class="keywordflow">if</span> (node-&gt;Name &amp;&amp; (node-&gt;header &amp; MemoryPage_Name_allocated_mask) == 0) <span class="keywordflow">return</span> node-&gt;Name; 
<a name="l05590"></a>05590                         <span class="keywordflow">if</span> (node-&gt;Value &amp;&amp; (node-&gt;header &amp; MemoryPage_Value_allocated_mask) == 0) <span class="keywordflow">return</span> node-&gt;Value; 
<a name="l05591"></a>05591                         <span class="keywordflow">return</span> 0; 
<a name="l05592"></a>05592                 } 
<a name="l05593"></a>05593  
<a name="l05594"></a>05594                 <a class="code" href="../../dd/dfe/structphys_1_1xml_1_1AttributeStruct.html" title="The internal data storage structure used in an Attribute.">AttributeStruct</a>* attr = xnode.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>().<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a1354d5f93309a999651e11b1cd4c2f62" title="Retrieve a pointer to the internal data.">InternalObject</a>(); 
<a name="l05595"></a>05595  
<a name="l05596"></a>05596                 <span class="keywordflow">if</span> (attr) 
<a name="l05597"></a>05597                 { 
<a name="l05598"></a>05598                         <span class="keywordflow">if</span> ((attr-&gt;header &amp; MemoryPage_Name_allocated_mask) == 0) <span class="keywordflow">return</span> attr-&gt;Name; 
<a name="l05599"></a>05599                         <span class="keywordflow">if</span> ((attr-&gt;header &amp; MemoryPage_Value_allocated_mask) == 0) <span class="keywordflow">return</span> attr-&gt;Value; 
<a name="l05600"></a>05600                         <span class="keywordflow">return</span> 0; 
<a name="l05601"></a>05601                 } 
<a name="l05602"></a>05602  
<a name="l05603"></a>05603                 <span class="keywordflow">return</span> 0; 
<a name="l05604"></a>05604         } 
<a name="l05605"></a>05605          
<a name="l05606"></a>05606         <span class="keyword">struct </span>document_order_comparator 
<a name="l05607"></a>05607         { 
<a name="l05608"></a>05608                 <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; rhs)<span class="keyword"> const </span>
<a name="l05609"></a>05609 <span class="keyword">                </span>{ 
<a name="l05610"></a>05610                         <span class="comment">// optimized document order based check </span>
<a name="l05611"></a>05611                         <span class="keyword">const</span> <span class="keywordtype">void</span>* lo = document_order(lhs); 
<a name="l05612"></a>05612                         <span class="keyword">const</span> <span class="keywordtype">void</span>* ro = document_order(rhs); 
<a name="l05613"></a>05613  
<a name="l05614"></a>05614                         <span class="keywordflow">if</span> (lo &amp;&amp; ro) <span class="keywordflow">return</span> lo &lt; ro; 
<a name="l05615"></a>05615  
<a name="l05616"></a>05616                         <span class="comment">// slow comparison </span>
<a name="l05617"></a>05617                         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> ln = lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>(), rn = rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>(); 
<a name="l05618"></a>05618  
<a name="l05619"></a>05619                         <span class="comment">// compare attributes </span>
<a name="l05620"></a>05620                         <span class="keywordflow">if</span> (lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>() &amp;&amp; rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>()) 
<a name="l05621"></a>05621                         { 
<a name="l05622"></a>05622                                 <span class="comment">// shared GetParent </span>
<a name="l05623"></a>05623                                 <span class="keywordflow">if</span> (lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>() == rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>()) 
<a name="l05624"></a>05624                                 { 
<a name="l05625"></a>05625                                         <span class="comment">// determine sibling order </span>
<a name="l05626"></a>05626                                         <span class="keywordflow">for</span> (<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>(); a; a = a.GetNextAttribute()) 
<a name="l05627"></a>05627                                                 <span class="keywordflow">if</span> (a == rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>()) 
<a name="l05628"></a>05628                                                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l05629"></a>05629                                          
<a name="l05630"></a>05630                                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05631"></a>05631                                 } 
<a name="l05632"></a>05632                                  
<a name="l05633"></a>05633                                 <span class="comment">// compare GetAttribute GetParents </span>
<a name="l05634"></a>05634                                 ln = lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>(); 
<a name="l05635"></a>05635                                 rn = rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>(); 
<a name="l05636"></a>05636                         } 
<a name="l05637"></a>05637                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>()) 
<a name="l05638"></a>05638                         { 
<a name="l05639"></a>05639                                 <span class="comment">// attributes go after the GetParent element </span>
<a name="l05640"></a>05640                                 <span class="keywordflow">if</span> (lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>() == rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05641"></a>05641                                  
<a name="l05642"></a>05642                                 ln = lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>(); 
<a name="l05643"></a>05643                         } 
<a name="l05644"></a>05644                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>()) 
<a name="l05645"></a>05645                         { 
<a name="l05646"></a>05646                                 <span class="comment">// attributes go after the GetParent element </span>
<a name="l05647"></a>05647                                 <span class="keywordflow">if</span> (rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>() == lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>()) <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l05648"></a>05648                                  
<a name="l05649"></a>05649                                 rn = rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>(); 
<a name="l05650"></a>05650                         } 
<a name="l05651"></a>05651  
<a name="l05652"></a>05652                         <span class="keywordflow">if</span> (ln == rn) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05653"></a>05653                          
<a name="l05654"></a>05654                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lh = NodeHeight(ln); 
<a name="l05655"></a>05655                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rh = NodeHeight(rn); 
<a name="l05656"></a>05656                          
<a name="l05657"></a>05657                         <span class="keywordflow">return</span> NodeIs_before(ln, lh, rn, rh); 
<a name="l05658"></a>05658                 } 
<a name="l05659"></a>05659         }; 
<a name="l05660"></a>05660  
<a name="l05661"></a>05661         <span class="keyword">struct </span>duplicate_comparator 
<a name="l05662"></a>05662         { 
<a name="l05663"></a>05663                 <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; rhs)<span class="keyword"> const </span>
<a name="l05664"></a>05664 <span class="keyword">                </span>{ 
<a name="l05665"></a>05665                         <span class="keywordflow">if</span> (lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>()) <span class="keywordflow">return</span> rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>() ? lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>() &lt; rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>() : <span class="keyword">true</span>; 
<a name="l05666"></a>05666                         <span class="keywordflow">else</span> <span class="keywordflow">return</span> rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>() ? <span class="keyword">false</span> : lhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>() &lt; rhs.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>(); 
<a name="l05667"></a>05667                 } 
<a name="l05668"></a>05668         }; 
<a name="l05669"></a>05669          
<a name="l05670"></a>05670         <span class="keywordtype">double</span> gen_nan() 
<a name="l05671"></a>05671         { 
<a name="l05672"></a>05672 <span class="preprocessor">        #if defined(__STDC_IEC_559__) || ((FLT_RADIX - 0 == 2) &amp;&amp; (FLT_MAX_EXP - 0 == 128) &amp;&amp; (FLT_MANT_DIG - 0 == 24)) </span>
<a name="l05673"></a>05673 <span class="preprocessor"></span>                <span class="keyword">union </span>{ <span class="keywordtype">float</span> f; int32_t i; } u[<span class="keyword">sizeof</span>(float) == <span class="keyword">sizeof</span>(int32_t) ? 1 : -1]; 
<a name="l05674"></a>05674                 u[0].i = 0x7fc00000; 
<a name="l05675"></a>05675                 <span class="keywordflow">return</span> u[0].f; 
<a name="l05676"></a>05676 <span class="preprocessor">        #else </span>
<a name="l05677"></a>05677 <span class="preprocessor"></span>                <span class="comment">// fallback </span>
<a name="l05678"></a>05678                 <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keywordtype">double</span> zero = 0.0; 
<a name="l05679"></a>05679                 <span class="keywordflow">return</span> zero / zero; 
<a name="l05680"></a>05680 <span class="preprocessor">        #endif </span>
<a name="l05681"></a>05681 <span class="preprocessor"></span>        } 
<a name="l05682"></a>05682          
<a name="l05683"></a>05683         <span class="keywordtype">bool</span> is_nan(<span class="keywordtype">double</span> Value) 
<a name="l05684"></a>05684         { 
<a name="l05685"></a>05685 <span class="preprocessor">        #if defined(_MSC_VER) || defined(__BORLANDC__) </span>
<a name="l05686"></a>05686 <span class="preprocessor"></span>                <span class="keywordflow">return</span> !!_isnan(Value); 
<a name="l05687"></a>05687 <span class="preprocessor">        #elif defined(fpclassify) &amp;&amp; defined(FP_NAN) </span>
<a name="l05688"></a>05688 <span class="preprocessor"></span>                <span class="keywordflow">return</span> fpclassify(Value) == FP_NAN; 
<a name="l05689"></a>05689 <span class="preprocessor">        #else </span>
<a name="l05690"></a>05690 <span class="preprocessor"></span>                <span class="comment">// fallback </span>
<a name="l05691"></a>05691                 <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keywordtype">double</span> v = Value; 
<a name="l05692"></a>05692                 <span class="keywordflow">return</span> v != v; 
<a name="l05693"></a>05693 <span class="preprocessor">        #endif </span>
<a name="l05694"></a>05694 <span class="preprocessor"></span>        } 
<a name="l05695"></a>05695          
<a name="l05696"></a>05696         <span class="keyword">const</span> char_t* convert_number_to_string_special(<span class="keywordtype">double</span> Value) 
<a name="l05697"></a>05697         { 
<a name="l05698"></a>05698 <span class="preprocessor">        #if defined(_MSC_VER) || defined(__BORLANDC__) </span>
<a name="l05699"></a>05699 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (_finite(Value)) <span class="keywordflow">return</span> (Value == 0) ? <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;0&quot;</span>) : 0; 
<a name="l05700"></a>05700                 <span class="keywordflow">if</span> (_isnan(Value)) <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;NaN&quot;</span>); 
<a name="l05701"></a>05701                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;-Infinity&quot;</span>) + (Value &gt; 0); 
<a name="l05702"></a>05702 <span class="preprocessor">        #elif defined(fpclassify) &amp;&amp; defined(FP_NAN) &amp;&amp; defined(FP_INFINITE) &amp;&amp; defined(FP_ZERO) </span>
<a name="l05703"></a>05703 <span class="preprocessor"></span>                <span class="keywordflow">switch</span> (fpclassify(Value)) 
<a name="l05704"></a>05704                 { 
<a name="l05705"></a>05705                 <span class="keywordflow">case</span> FP_NAN: 
<a name="l05706"></a>05706                         <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;NaN&quot;</span>); 
<a name="l05707"></a>05707  
<a name="l05708"></a>05708                 <span class="keywordflow">case</span> FP_INFINITE: 
<a name="l05709"></a>05709                         <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;-Infinity&quot;</span>) + (Value &gt; 0); 
<a name="l05710"></a>05710  
<a name="l05711"></a>05711                 <span class="keywordflow">case</span> FP_ZERO: 
<a name="l05712"></a>05712                         <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;0&quot;</span>); 
<a name="l05713"></a>05713  
<a name="l05714"></a>05714                 <span class="keywordflow">default</span>: 
<a name="l05715"></a>05715                         <span class="keywordflow">return</span> 0; 
<a name="l05716"></a>05716                 } 
<a name="l05717"></a>05717 <span class="preprocessor">        #else </span>
<a name="l05718"></a>05718 <span class="preprocessor"></span>                <span class="comment">// fallback </span>
<a name="l05719"></a>05719                 <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keywordtype">double</span> v = Value; 
<a name="l05720"></a>05720  
<a name="l05721"></a>05721                 <span class="keywordflow">if</span> (v == 0) <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;0&quot;</span>); 
<a name="l05722"></a>05722                 <span class="keywordflow">if</span> (v != v) <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;NaN&quot;</span>); 
<a name="l05723"></a>05723                 <span class="keywordflow">if</span> (v * 2 == v) <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;-Infinity&quot;</span>) + (Value &gt; 0); 
<a name="l05724"></a>05724                 <span class="keywordflow">return</span> 0; 
<a name="l05725"></a>05725 <span class="preprocessor">        #endif </span>
<a name="l05726"></a>05726 <span class="preprocessor"></span>        } 
<a name="l05727"></a>05727          
<a name="l05728"></a>05728         <span class="keywordtype">bool</span> convert_number_to_boolean(<span class="keywordtype">double</span> Value) 
<a name="l05729"></a>05729         { 
<a name="l05730"></a>05730                 <span class="keywordflow">return</span> (Value != 0 &amp;&amp; !is_nan(Value)); 
<a name="l05731"></a>05731         } 
<a name="l05732"></a>05732          
<a name="l05733"></a>05733         <span class="keywordtype">void</span> truncate_zeros(<span class="keywordtype">char</span>* begin, <span class="keywordtype">char</span>* end) 
<a name="l05734"></a>05734         { 
<a name="l05735"></a>05735                 <span class="keywordflow">while</span> (begin != end &amp;&amp; end[-1] == <span class="charliteral">&#39;0&#39;</span>) end--; 
<a name="l05736"></a>05736  
<a name="l05737"></a>05737                 *end = 0; 
<a name="l05738"></a>05738         } 
<a name="l05739"></a>05739  
<a name="l05740"></a>05740         <span class="comment">// gets mantissa digits in the form of 0.xxxxx with 0. implied and the exponent </span>
<a name="l05741"></a>05741 <span class="preprocessor">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1400 </span>
<a name="l05742"></a>05742 <span class="preprocessor"></span>        <span class="keywordtype">void</span> convert_number_to_mantissa_exponent(<span class="keywordtype">double</span> Value, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">char</span>** out_mantissa, <span class="keywordtype">int</span>* out_exponent) 
<a name="l05743"></a>05743         { 
<a name="l05744"></a>05744                 <span class="comment">// get base Values </span>
<a name="l05745"></a>05745                 <span class="keywordtype">int</span> sign, exponent; 
<a name="l05746"></a>05746                 _ecvt_s(buffer, buffer_size, Value, DBL_DIG + 1, &amp;exponent, &amp;sign); 
<a name="l05747"></a>05747  
<a name="l05748"></a>05748                 <span class="comment">// truncate redundant zeros </span>
<a name="l05749"></a>05749                 truncate_zeros(buffer, buffer + strlen(buffer)); 
<a name="l05750"></a>05750  
<a name="l05751"></a>05751                 <span class="comment">// fill Results </span>
<a name="l05752"></a>05752                 *out_mantissa = buffer; 
<a name="l05753"></a>05753                 *out_exponent = exponent; 
<a name="l05754"></a>05754         } 
<a name="l05755"></a>05755 <span class="preprocessor">#else </span>
<a name="l05756"></a>05756 <span class="preprocessor"></span>        <span class="keywordtype">void</span> convert_number_to_mantissa_exponent(<span class="keywordtype">double</span> Value, <span class="keywordtype">char</span>* buffer, <span class="keywordtype">size_t</span> buffer_size, <span class="keywordtype">char</span>** out_mantissa, <span class="keywordtype">int</span>* out_exponent) 
<a name="l05757"></a>05757         { 
<a name="l05758"></a>05758                 <span class="comment">// get a scientific notation Value with IEEE DBL_DIG decimals </span>
<a name="l05759"></a>05759                 sprintf(buffer, <span class="stringliteral">&quot;%.*e&quot;</span>, DBL_DIG, Value); 
<a name="l05760"></a>05760                 assert(strlen(buffer) &lt; buffer_size); 
<a name="l05761"></a>05761                 (void)!buffer_size; 
<a name="l05762"></a>05762  
<a name="l05763"></a>05763                 <span class="comment">// get the exponent (possibly negative) </span>
<a name="l05764"></a>05764                 <span class="keywordtype">char</span>* exponent_string = strchr(buffer, <span class="charliteral">&#39;e&#39;</span>); 
<a name="l05765"></a>05765                 assert(exponent_string); 
<a name="l05766"></a>05766  
<a name="l05767"></a>05767                 <span class="keywordtype">int</span> exponent = atoi(exponent_string + 1); 
<a name="l05768"></a>05768  
<a name="l05769"></a>05769                 <span class="comment">// extract mantissa string: skip sign </span>
<a name="l05770"></a>05770                 <span class="keywordtype">char</span>* mantissa = buffer[0] == <span class="charliteral">&#39;-&#39;</span> ? buffer + 1 : buffer; 
<a name="l05771"></a>05771                 assert(mantissa[0] != <span class="charliteral">&#39;0&#39;</span> &amp;&amp; mantissa[1] == <span class="charliteral">&#39;.&#39;</span>); 
<a name="l05772"></a>05772  
<a name="l05773"></a>05773                 <span class="comment">// divide mantissa by 10 to eliminate integer part </span>
<a name="l05774"></a>05774                 mantissa[1] = mantissa[0]; 
<a name="l05775"></a>05775                 mantissa++; 
<a name="l05776"></a>05776                 exponent++; 
<a name="l05777"></a>05777  
<a name="l05778"></a>05778                 <span class="comment">// remove extra mantissa digits and zero-terminate mantissa </span>
<a name="l05779"></a>05779                 truncate_zeros(mantissa, exponent_string); 
<a name="l05780"></a>05780  
<a name="l05781"></a>05781                 <span class="comment">// fill Results </span>
<a name="l05782"></a>05782                 *out_mantissa = mantissa; 
<a name="l05783"></a>05783                 *out_exponent = exponent; 
<a name="l05784"></a>05784         } 
<a name="l05785"></a>05785 <span class="preprocessor">#endif </span>
<a name="l05786"></a>05786 <span class="preprocessor"></span> 
<a name="l05787"></a>05787         XPathString convert_number_to_string(<span class="keywordtype">double</span> Value, XPathAllocator* alloc) 
<a name="l05788"></a>05788         { 
<a name="l05789"></a>05789                 <span class="comment">// try special number conversion </span>
<a name="l05790"></a>05790                 <span class="keyword">const</span> char_t* special = convert_number_to_string_special(Value); 
<a name="l05791"></a>05791                 <span class="keywordflow">if</span> (special) <span class="keywordflow">return</span> XPathStringConst(special); 
<a name="l05792"></a>05792  
<a name="l05793"></a>05793                 <span class="comment">// get mantissa + exponent form </span>
<a name="l05794"></a>05794                 <span class="keywordtype">char</span> mantissa_buffer[64]; 
<a name="l05795"></a>05795  
<a name="l05796"></a>05796                 <span class="keywordtype">char</span>* mantissa; 
<a name="l05797"></a>05797                 <span class="keywordtype">int</span> exponent; 
<a name="l05798"></a>05798                 convert_number_to_mantissa_exponent(Value, mantissa_buffer, <span class="keyword">sizeof</span>(mantissa_buffer), &amp;mantissa, &amp;exponent); 
<a name="l05799"></a>05799  
<a name="l05800"></a>05800                 <span class="comment">// make the number! </span>
<a name="l05801"></a>05801                 char_t Result[512]; 
<a name="l05802"></a>05802                 char_t* s = Result; 
<a name="l05803"></a>05803  
<a name="l05804"></a>05804                 <span class="comment">// sign </span>
<a name="l05805"></a>05805                 <span class="keywordflow">if</span> (Value &lt; 0) *s++ = <span class="charliteral">&#39;-&#39;</span>; 
<a name="l05806"></a>05806  
<a name="l05807"></a>05807                 <span class="comment">// integer part </span>
<a name="l05808"></a>05808                 <span class="keywordflow">if</span> (exponent &lt;= 0) 
<a name="l05809"></a>05809                 { 
<a name="l05810"></a>05810                         *s++ = <span class="charliteral">&#39;0&#39;</span>; 
<a name="l05811"></a>05811                 } 
<a name="l05812"></a>05812                 <span class="keywordflow">else</span> 
<a name="l05813"></a>05813                 { 
<a name="l05814"></a>05814                         <span class="keywordflow">while</span> (exponent &gt; 0) 
<a name="l05815"></a>05815                         { 
<a name="l05816"></a>05816                                 assert(*mantissa == 0 || (<span class="keywordtype">unsigned</span>)(*mantissa - <span class="charliteral">&#39;0&#39;</span>) &lt;= 9); 
<a name="l05817"></a>05817                                 *s++ = *mantissa ? *mantissa++ : <span class="charliteral">&#39;0&#39;</span>; 
<a name="l05818"></a>05818                                 exponent--; 
<a name="l05819"></a>05819                         } 
<a name="l05820"></a>05820                 } 
<a name="l05821"></a>05821  
<a name="l05822"></a>05822                 <span class="comment">// fractional part </span>
<a name="l05823"></a>05823                 <span class="keywordflow">if</span> (*mantissa) 
<a name="l05824"></a>05824                 { 
<a name="l05825"></a>05825                         <span class="comment">// decimal point </span>
<a name="l05826"></a>05826                         *s++ = <span class="charliteral">&#39;.&#39;</span>; 
<a name="l05827"></a>05827  
<a name="l05828"></a>05828                         <span class="comment">// extra zeroes from negative exponent </span>
<a name="l05829"></a>05829                         <span class="keywordflow">while</span> (exponent &lt; 0) 
<a name="l05830"></a>05830                         { 
<a name="l05831"></a>05831                                 *s++ = <span class="charliteral">&#39;0&#39;</span>; 
<a name="l05832"></a>05832                                 exponent++; 
<a name="l05833"></a>05833                         } 
<a name="l05834"></a>05834  
<a name="l05835"></a>05835                         <span class="comment">// extra mantissa digits </span>
<a name="l05836"></a>05836                         <span class="keywordflow">while</span> (*mantissa) 
<a name="l05837"></a>05837                         { 
<a name="l05838"></a>05838                                 assert((<span class="keywordtype">unsigned</span>)(*mantissa - <span class="charliteral">&#39;0&#39;</span>) &lt;= 9); 
<a name="l05839"></a>05839                                 *s++ = *mantissa++; 
<a name="l05840"></a>05840                         } 
<a name="l05841"></a>05841                 } 
<a name="l05842"></a>05842  
<a name="l05843"></a>05843                 <span class="comment">// zero-terminate </span>
<a name="l05844"></a>05844                 assert(s &lt; Result + <span class="keyword">sizeof</span>(Result) / <span class="keyword">sizeof</span>(Result[0])); 
<a name="l05845"></a>05845                 *s = 0; 
<a name="l05846"></a>05846  
<a name="l05847"></a>05847                 <span class="keywordflow">return</span> XPathString(Result, alloc); 
<a name="l05848"></a>05848         } 
<a name="l05849"></a>05849          
<a name="l05850"></a>05850         <span class="keywordtype">bool</span> check_Stringo_number_format(<span class="keyword">const</span> char_t* <span class="keywordtype">string</span>) 
<a name="l05851"></a>05851         { 
<a name="l05852"></a>05852                 <span class="comment">// parse leading whitespace </span>
<a name="l05853"></a>05853                 <span class="keywordflow">while</span> (IS_CHARTYPE(*<span class="keywordtype">string</span>, ct_space)) ++string; 
<a name="l05854"></a>05854  
<a name="l05855"></a>05855                 <span class="comment">// parse sign </span>
<a name="l05856"></a>05856                 <span class="keywordflow">if</span> (*<span class="keywordtype">string</span> == <span class="charliteral">&#39;-&#39;</span>) ++string; 
<a name="l05857"></a>05857  
<a name="l05858"></a>05858                 <span class="keywordflow">if</span> (!*<span class="keywordtype">string</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05859"></a>05859  
<a name="l05860"></a>05860                 <span class="comment">// if there is no integer part, there should be a decimal part with at least one digit </span>
<a name="l05861"></a>05861                 <span class="keywordflow">if</span> (!IS_CHARTYPEX(<span class="keywordtype">string</span>[0], ctx_digit) &amp;&amp; (<span class="keywordtype">string</span>[0] != <span class="charliteral">&#39;.&#39;</span> || !IS_CHARTYPEX(<span class="keywordtype">string</span>[1], ctx_digit))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05862"></a>05862  
<a name="l05863"></a>05863                 <span class="comment">// parse integer part </span>
<a name="l05864"></a>05864                 <span class="keywordflow">while</span> (IS_CHARTYPEX(*<span class="keywordtype">string</span>, ctx_digit)) ++string; 
<a name="l05865"></a>05865  
<a name="l05866"></a>05866                 <span class="comment">// parse decimal part </span>
<a name="l05867"></a>05867                 <span class="keywordflow">if</span> (*<span class="keywordtype">string</span> == <span class="charliteral">&#39;.&#39;</span>) 
<a name="l05868"></a>05868                 { 
<a name="l05869"></a>05869                         ++string; 
<a name="l05870"></a>05870  
<a name="l05871"></a>05871                         <span class="keywordflow">while</span> (IS_CHARTYPEX(*<span class="keywordtype">string</span>, ctx_digit)) ++string; 
<a name="l05872"></a>05872                 } 
<a name="l05873"></a>05873  
<a name="l05874"></a>05874                 <span class="comment">// parse trailing whitespace </span>
<a name="l05875"></a>05875                 <span class="keywordflow">while</span> (IS_CHARTYPE(*<span class="keywordtype">string</span>, ct_space)) ++string; 
<a name="l05876"></a>05876  
<a name="l05877"></a>05877                 <span class="keywordflow">return</span> *<span class="keywordtype">string</span> == 0; 
<a name="l05878"></a>05878         } 
<a name="l05879"></a>05879  
<a name="l05880"></a>05880         <span class="keywordtype">double</span> convert_Stringo_number(<span class="keyword">const</span> char_t* <span class="keywordtype">string</span>) 
<a name="l05881"></a>05881         { 
<a name="l05882"></a>05882                 <span class="comment">// check string format </span>
<a name="l05883"></a>05883                 <span class="keywordflow">if</span> (!check_Stringo_number_format(<span class="keywordtype">string</span>)) <span class="keywordflow">return</span> gen_nan(); 
<a name="l05884"></a>05884  
<a name="l05885"></a>05885                 <span class="comment">// parse string </span>
<a name="l05886"></a>05886 <span class="preprocessor">        #ifdef XML_WCHAR_MODE </span>
<a name="l05887"></a>05887 <span class="preprocessor"></span>                <span class="keywordflow">return</span> wcstod(<span class="keywordtype">string</span>, 0); 
<a name="l05888"></a>05888 <span class="preprocessor">        #else </span>
<a name="l05889"></a>05889 <span class="preprocessor"></span>                <span class="keywordflow">return</span> atof(<span class="keywordtype">string</span>); 
<a name="l05890"></a>05890 <span class="preprocessor">        #endif </span>
<a name="l05891"></a>05891 <span class="preprocessor"></span>        } 
<a name="l05892"></a>05892  
<a name="l05893"></a>05893         <span class="keywordtype">bool</span> convert_Stringo_number(<span class="keyword">const</span> char_t* begin, <span class="keyword">const</span> char_t* end, <span class="keywordtype">double</span>* out_Result) 
<a name="l05894"></a>05894         { 
<a name="l05895"></a>05895                 char_t buffer[32]; 
<a name="l05896"></a>05896  
<a name="l05897"></a>05897                 <span class="keywordtype">size_t</span> length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - begin); 
<a name="l05898"></a>05898                 char_t* scratch = buffer; 
<a name="l05899"></a>05899  
<a name="l05900"></a>05900                 <span class="keywordflow">if</span> (length &gt;= <span class="keyword">sizeof</span>(buffer) / <span class="keyword">sizeof</span>(buffer[0])) 
<a name="l05901"></a>05901                 { 
<a name="l05902"></a>05902                         <span class="comment">// need to make dummy on-heap copy </span>
<a name="l05903"></a>05903                         scratch = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate((length + 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l05904"></a>05904                         <span class="keywordflow">if</span> (!scratch) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05905"></a>05905                 } 
<a name="l05906"></a>05906  
<a name="l05907"></a>05907                 <span class="comment">// copy string to zero-terminated buffer and perform conversion </span>
<a name="l05908"></a>05908                 memcpy(scratch, begin, length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l05909"></a>05909                 scratch[length] = 0; 
<a name="l05910"></a>05910  
<a name="l05911"></a>05911                 *out_Result = convert_Stringo_number(scratch); 
<a name="l05912"></a>05912  
<a name="l05913"></a>05913                 <span class="comment">// free dummy buffer </span>
<a name="l05914"></a>05914                 <span class="keywordflow">if</span> (scratch != buffer) global_deallocate(scratch); 
<a name="l05915"></a>05915  
<a name="l05916"></a>05916                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l05917"></a>05917         } 
<a name="l05918"></a>05918          
<a name="l05919"></a>05919         <span class="keywordtype">double</span> round_nearest(<span class="keywordtype">double</span> Value) 
<a name="l05920"></a>05920         { 
<a name="l05921"></a>05921                 <span class="keywordflow">return</span> floor(Value + 0.5); 
<a name="l05922"></a>05922         } 
<a name="l05923"></a>05923  
<a name="l05924"></a>05924         <span class="keywordtype">double</span> round_nearest_nzero(<span class="keywordtype">double</span> Value) 
<a name="l05925"></a>05925         { 
<a name="l05926"></a>05926                 <span class="comment">// same as round_nearest, but returns -0 for [-0.5, -0] </span>
<a name="l05927"></a>05927                 <span class="comment">// ceil is used to differentiate between +0 and -0 (we return -0 for [-0.5, -0] and +0 for +0) </span>
<a name="l05928"></a>05928                 <span class="keywordflow">return</span> (Value &gt;= -0.5 &amp;&amp; Value &lt;= 0) ? ceil(Value) : floor(Value + 0.5); 
<a name="l05929"></a>05929         } 
<a name="l05930"></a>05930          
<a name="l05931"></a>05931         <span class="keyword">const</span> char_t* qualified_Name(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; node) 
<a name="l05932"></a>05932         { 
<a name="l05933"></a>05933                 <span class="keywordflow">return</span> node.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>() ? node.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>().<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>() : node.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>().<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>(); 
<a name="l05934"></a>05934         } 
<a name="l05935"></a>05935          
<a name="l05936"></a>05936         <span class="keyword">const</span> char_t* local_Name(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; node) 
<a name="l05937"></a>05937         { 
<a name="l05938"></a>05938                 <span class="keyword">const</span> char_t* Name = qualified_Name(node); 
<a name="l05939"></a>05939                 <span class="keyword">const</span> char_t* p = FindChar(Name, <span class="charliteral">&#39;:&#39;</span>); 
<a name="l05940"></a>05940                  
<a name="l05941"></a>05941                 <span class="keywordflow">return</span> p ? p + 1 : Name; 
<a name="l05942"></a>05942         } 
<a name="l05943"></a>05943  
<a name="l05944"></a>05944         <span class="keyword">struct </span>namespace_uri_predicate 
<a name="l05945"></a>05945         { 
<a name="l05946"></a>05946                 <span class="keyword">const</span> char_t* prefix; 
<a name="l05947"></a>05947                 <span class="keywordtype">size_t</span> prefix_length; 
<a name="l05948"></a>05948  
<a name="l05949"></a>05949                 namespace_uri_predicate(<span class="keyword">const</span> char_t* Name) 
<a name="l05950"></a>05950                 { 
<a name="l05951"></a>05951                         <span class="keyword">const</span> char_t* pos = FindChar(Name, <span class="charliteral">&#39;:&#39;</span>); 
<a name="l05952"></a>05952  
<a name="l05953"></a>05953                         prefix = pos ? Name : 0; 
<a name="l05954"></a>05954                         prefix_length = pos ? <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(pos - Name) : 0; 
<a name="l05955"></a>05955                 } 
<a name="l05956"></a>05956  
<a name="l05957"></a>05957                 <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; a)<span class="keyword"> const </span>
<a name="l05958"></a>05958 <span class="keyword">                </span>{ 
<a name="l05959"></a>05959                         <span class="keyword">const</span> char_t* Name = a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>(); 
<a name="l05960"></a>05960  
<a name="l05961"></a>05961                         <span class="keywordflow">if</span> (!starts_with(Name, <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;xmlns&quot;</span>))) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l05962"></a>05962  
<a name="l05963"></a>05963                         <span class="keywordflow">return</span> prefix ? Name[5] == <span class="charliteral">&#39;:&#39;</span> &amp;&amp; strequalrange(Name + 6, prefix, prefix_length) : Name[5] == 0; 
<a name="l05964"></a>05964                 } 
<a name="l05965"></a>05965         }; 
<a name="l05966"></a>05966  
<a name="l05967"></a>05967         <span class="keyword">const</span> char_t* namespace_uri(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node) 
<a name="l05968"></a>05968         { 
<a name="l05969"></a>05969                 namespace_uri_predicate pred = node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>(); 
<a name="l05970"></a>05970                  
<a name="l05971"></a>05971                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> p = node; 
<a name="l05972"></a>05972                  
<a name="l05973"></a>05973                 <span class="keywordflow">while</span> (p) 
<a name="l05974"></a>05974                 { 
<a name="l05975"></a>05975                         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = p.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#af6cf25d1823ccf0f9f123825ef8537bd" title="Search for an Attribute using a function to check each Attribute individually.">FindAttribute</a>(pred); 
<a name="l05976"></a>05976                          
<a name="l05977"></a>05977                         <span class="keywordflow">if</span> (a) <span class="keywordflow">return</span> a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>(); 
<a name="l05978"></a>05978                          
<a name="l05979"></a>05979                         p = p.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l05980"></a>05980                 } 
<a name="l05981"></a>05981                  
<a name="l05982"></a>05982                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l05983"></a>05983         } 
<a name="l05984"></a>05984  
<a name="l05985"></a>05985         <span class="keyword">const</span> char_t* namespace_uri(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; attr, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; GetParent) 
<a name="l05986"></a>05986         { 
<a name="l05987"></a>05987                 namespace_uri_predicate pred = attr.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>(); 
<a name="l05988"></a>05988                  
<a name="l05989"></a>05989                 <span class="comment">// Default namespace does not apply to attributes </span>
<a name="l05990"></a>05990                 <span class="keywordflow">if</span> (!pred.prefix) <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l05991"></a>05991                  
<a name="l05992"></a>05992                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> p = GetParent; 
<a name="l05993"></a>05993                  
<a name="l05994"></a>05994                 <span class="keywordflow">while</span> (p) 
<a name="l05995"></a>05995                 { 
<a name="l05996"></a>05996                         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = p.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#af6cf25d1823ccf0f9f123825ef8537bd" title="Search for an Attribute using a function to check each Attribute individually.">FindAttribute</a>(pred); 
<a name="l05997"></a>05997                          
<a name="l05998"></a>05998                         <span class="keywordflow">if</span> (a) <span class="keywordflow">return</span> a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>(); 
<a name="l05999"></a>05999                          
<a name="l06000"></a>06000                         p = p.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l06001"></a>06001                 } 
<a name="l06002"></a>06002                  
<a name="l06003"></a>06003                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l06004"></a>06004         } 
<a name="l06005"></a>06005  
<a name="l06006"></a>06006         <span class="keyword">const</span> char_t* namespace_uri(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; node) 
<a name="l06007"></a>06007         { 
<a name="l06008"></a>06008                 <span class="keywordflow">return</span> node.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>() ? namespace_uri(node.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">GetAttribute</a>(), node.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">GetParent</a>()) : namespace_uri(node.<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">GetNode</a>()); 
<a name="l06009"></a>06009         } 
<a name="l06010"></a>06010  
<a name="l06011"></a>06011         <span class="keywordtype">void</span> normalize_space(char_t* buffer) 
<a name="l06012"></a>06012         { 
<a name="l06013"></a>06013                 char_t* Write = buffer; 
<a name="l06014"></a>06014  
<a name="l06015"></a>06015                 <span class="keywordflow">for</span> (char_t* it = buffer; *it; ) 
<a name="l06016"></a>06016                 { 
<a name="l06017"></a>06017                         char_t ch = *it++; 
<a name="l06018"></a>06018  
<a name="l06019"></a>06019                         <span class="keywordflow">if</span> (IS_CHARTYPE(ch, ct_space)) 
<a name="l06020"></a>06020                         { 
<a name="l06021"></a>06021                                 <span class="comment">// replace whitespace sequence with single space </span>
<a name="l06022"></a>06022                                 <span class="keywordflow">while</span> (IS_CHARTYPE(*it, ct_space)) it++; 
<a name="l06023"></a>06023  
<a name="l06024"></a>06024                                 <span class="comment">// avoid leading spaces </span>
<a name="l06025"></a>06025                                 <span class="keywordflow">if</span> (Write != buffer) *Write++ = <span class="charliteral">&#39; &#39;</span>; 
<a name="l06026"></a>06026                         } 
<a name="l06027"></a>06027                         <span class="keywordflow">else</span> *Write++ = ch; 
<a name="l06028"></a>06028                 } 
<a name="l06029"></a>06029  
<a name="l06030"></a>06030                 <span class="comment">// remove trailing space </span>
<a name="l06031"></a>06031                 <span class="keywordflow">if</span> (Write != buffer &amp;&amp; IS_CHARTYPE(Write[-1], ct_space)) Write--; 
<a name="l06032"></a>06032  
<a name="l06033"></a>06033                 <span class="comment">// zero-terminate </span>
<a name="l06034"></a>06034                 *Write = 0; 
<a name="l06035"></a>06035         } 
<a name="l06036"></a>06036  
<a name="l06037"></a>06037         <span class="keywordtype">void</span> translate(char_t* buffer, <span class="keyword">const</span> char_t* from, <span class="keyword">const</span> char_t* to) 
<a name="l06038"></a>06038         { 
<a name="l06039"></a>06039                 <span class="keywordtype">size_t</span> to_length = strlength(to); 
<a name="l06040"></a>06040  
<a name="l06041"></a>06041                 char_t* Write = buffer; 
<a name="l06042"></a>06042  
<a name="l06043"></a>06043                 <span class="keywordflow">while</span> (*buffer) 
<a name="l06044"></a>06044                 { 
<a name="l06045"></a>06045                         DMC_VOLATILE char_t ch = *buffer++; 
<a name="l06046"></a>06046  
<a name="l06047"></a>06047                         <span class="keyword">const</span> char_t* pos = FindChar(from, ch); 
<a name="l06048"></a>06048  
<a name="l06049"></a>06049                         <span class="keywordflow">if</span> (!pos) 
<a name="l06050"></a>06050                                 *Write++ = ch; <span class="comment">// do not process </span>
<a name="l06051"></a>06051                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (static_cast&lt;size_t&gt;(pos - from) &lt; to_length) 
<a name="l06052"></a>06052                                 *Write++ = to[pos - from]; <span class="comment">// replace </span>
<a name="l06053"></a>06053                 } 
<a name="l06054"></a>06054  
<a name="l06055"></a>06055                 <span class="comment">// zero-terminate </span>
<a name="l06056"></a>06056                 *Write = 0; 
<a name="l06057"></a>06057         } 
<a name="l06058"></a>06058  
<a name="l06059"></a>06059         <span class="keyword">struct </span>XPathVariableBoolean: <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a> 
<a name="l06060"></a>06060         { 
<a name="l06061"></a>06061                 XPathVariableBoolean(): Value(false) 
<a name="l06062"></a>06062                 { 
<a name="l06063"></a>06063                 } 
<a name="l06064"></a>06064  
<a name="l06065"></a>06065                 <span class="keywordtype">bool</span> Value; 
<a name="l06066"></a>06066                 char_t Name[1]; 
<a name="l06067"></a>06067         }; 
<a name="l06068"></a>06068  
<a name="l06069"></a>06069         <span class="keyword">struct </span>XPathVariableNumber: <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a> 
<a name="l06070"></a>06070         { 
<a name="l06071"></a>06071                 XPathVariableNumber(): Value(0) 
<a name="l06072"></a>06072                 { 
<a name="l06073"></a>06073                 } 
<a name="l06074"></a>06074  
<a name="l06075"></a>06075                 <span class="keywordtype">double</span> Value; 
<a name="l06076"></a>06076                 char_t Name[1]; 
<a name="l06077"></a>06077         }; 
<a name="l06078"></a>06078  
<a name="l06079"></a>06079         <span class="keyword">struct </span>XPathVariableString: <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a> 
<a name="l06080"></a>06080         { 
<a name="l06081"></a>06081                 XPathVariableString(): Value(0) 
<a name="l06082"></a>06082                 { 
<a name="l06083"></a>06083                 } 
<a name="l06084"></a>06084  
<a name="l06085"></a>06085                 ~XPathVariableString() 
<a name="l06086"></a>06086                 { 
<a name="l06087"></a>06087                         <span class="keywordflow">if</span> (Value) global_deallocate(Value); 
<a name="l06088"></a>06088                 } 
<a name="l06089"></a>06089  
<a name="l06090"></a>06090                 char_t* Value; 
<a name="l06091"></a>06091                 char_t Name[1]; 
<a name="l06092"></a>06092         }; 
<a name="l06093"></a>06093  
<a name="l06094"></a>06094         <span class="keyword">struct </span>XPathVariableNodeSet: <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a> 
<a name="l06095"></a>06095         { 
<a name="l06096"></a>06096                 <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a> Value; 
<a name="l06097"></a>06097                 char_t Name[1]; 
<a name="l06098"></a>06098         }; 
<a name="l06099"></a>06099  
<a name="l06100"></a>06100         <span class="keyword">const</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a> dummy_NodeSet; 
<a name="l06101"></a>06101  
<a name="l06102"></a>06102         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash_string(<span class="keyword">const</span> char_t* str) 
<a name="l06103"></a>06103         { 
<a name="l06104"></a>06104                 <span class="comment">// Jenkins one-at-a-time hash (http://en.wikipedia.org/wiki/Jenkins_hash_function#one-at-a-time) </span>
<a name="l06105"></a>06105                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Result = 0; 
<a name="l06106"></a>06106  
<a name="l06107"></a>06107                 <span class="keywordflow">while</span> (*str) 
<a name="l06108"></a>06108                 { 
<a name="l06109"></a>06109                         Result += <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(*str++); 
<a name="l06110"></a>06110                         Result += Result &lt;&lt; 10; 
<a name="l06111"></a>06111                         Result ^= Result &gt;&gt; 6; 
<a name="l06112"></a>06112                 } 
<a name="l06113"></a>06113          
<a name="l06114"></a>06114                 Result += Result &lt;&lt; 3; 
<a name="l06115"></a>06115                 Result ^= Result &gt;&gt; 11; 
<a name="l06116"></a>06116                 Result += Result &lt;&lt; 15; 
<a name="l06117"></a>06117          
<a name="l06118"></a>06118                 <span class="keywordflow">return</span> Result; 
<a name="l06119"></a>06119         } 
<a name="l06120"></a>06120  
<a name="l06121"></a>06121         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T* new_XPathVariable(<span class="keyword">const</span> char_t* Name) 
<a name="l06122"></a>06122         { 
<a name="l06123"></a>06123                 <span class="keywordtype">size_t</span> length = strlength(Name); 
<a name="l06124"></a>06124                 <span class="keywordflow">if</span> (length == 0) <span class="keywordflow">return</span> 0; <span class="comment">// empty variable names are invalid </span>
<a name="l06125"></a>06125  
<a name="l06126"></a>06126                 <span class="comment">// $$ we can&#39;t use offsetof(T, Name) because T is non-POD, so we just allocate additional length characters </span>
<a name="l06127"></a>06127                 <span class="keywordtype">void</span>* memory = global_allocate(<span class="keyword">sizeof</span>(T) + length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l06128"></a>06128                 <span class="keywordflow">if</span> (!memory) <span class="keywordflow">return</span> 0; 
<a name="l06129"></a>06129  
<a name="l06130"></a>06130                 T* Result = <span class="keyword">new</span> (memory) T(); 
<a name="l06131"></a>06131  
<a name="l06132"></a>06132                 memcpy(Result-&gt;Name, Name, (length + 1) * <span class="keyword">sizeof</span>(char_t)); 
<a name="l06133"></a>06133  
<a name="l06134"></a>06134                 <span class="keywordflow">return</span> Result; 
<a name="l06135"></a>06135         } 
<a name="l06136"></a>06136  
<a name="l06137"></a>06137         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* new_XPathVariable(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> Type, <span class="keyword">const</span> char_t* Name) 
<a name="l06138"></a>06138         { 
<a name="l06139"></a>06139                 <span class="keywordflow">switch</span> (Type) 
<a name="l06140"></a>06140                 { 
<a name="l06141"></a>06141                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>: 
<a name="l06142"></a>06142                         <span class="keywordflow">return</span> new_XPathVariable&lt;XPathVariableNodeSet&gt;(Name); 
<a name="l06143"></a>06143  
<a name="l06144"></a>06144                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>: 
<a name="l06145"></a>06145                         <span class="keywordflow">return</span> new_XPathVariable&lt;XPathVariableNumber&gt;(Name); 
<a name="l06146"></a>06146  
<a name="l06147"></a>06147                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>: 
<a name="l06148"></a>06148                         <span class="keywordflow">return</span> new_XPathVariable&lt;XPathVariableString&gt;(Name); 
<a name="l06149"></a>06149  
<a name="l06150"></a>06150                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>: 
<a name="l06151"></a>06151                         <span class="keywordflow">return</span> new_XPathVariable&lt;XPathVariableBoolean&gt;(Name); 
<a name="l06152"></a>06152  
<a name="l06153"></a>06153                 <span class="keywordflow">default</span>: 
<a name="l06154"></a>06154                         <span class="keywordflow">return</span> 0; 
<a name="l06155"></a>06155                 } 
<a name="l06156"></a>06156         } 
<a name="l06157"></a>06157  
<a name="l06158"></a>06158         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> delete_XPathVariable(T* var) 
<a name="l06159"></a>06159         { 
<a name="l06160"></a>06160                 var-&gt;~T(); 
<a name="l06161"></a>06161                 global_deallocate(var); 
<a name="l06162"></a>06162         } 
<a name="l06163"></a>06163  
<a name="l06164"></a>06164         <span class="keywordtype">void</span> delete_XPathVariable(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> Type, <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var) 
<a name="l06165"></a>06165         { 
<a name="l06166"></a>06166                 <span class="keywordflow">switch</span> (Type) 
<a name="l06167"></a>06167                 { 
<a name="l06168"></a>06168                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>: 
<a name="l06169"></a>06169                         delete_XPathVariable(static_cast&lt;XPathVariableNodeSet*&gt;(var)); 
<a name="l06170"></a>06170                         <span class="keywordflow">break</span>; 
<a name="l06171"></a>06171  
<a name="l06172"></a>06172                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>: 
<a name="l06173"></a>06173                         delete_XPathVariable(static_cast&lt;XPathVariableNumber*&gt;(var)); 
<a name="l06174"></a>06174                         <span class="keywordflow">break</span>; 
<a name="l06175"></a>06175  
<a name="l06176"></a>06176                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>: 
<a name="l06177"></a>06177                         delete_XPathVariable(static_cast&lt;XPathVariableString*&gt;(var)); 
<a name="l06178"></a>06178                         <span class="keywordflow">break</span>; 
<a name="l06179"></a>06179  
<a name="l06180"></a>06180                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>: 
<a name="l06181"></a>06181                         delete_XPathVariable(static_cast&lt;XPathVariableBoolean*&gt;(var)); 
<a name="l06182"></a>06182                         <span class="keywordflow">break</span>; 
<a name="l06183"></a>06183  
<a name="l06184"></a>06184                 <span class="keywordflow">default</span>: 
<a name="l06185"></a>06185                         assert(!<span class="stringliteral">&quot;Invalid variable Type&quot;</span>); 
<a name="l06186"></a>06186                 } 
<a name="l06187"></a>06187         } 
<a name="l06188"></a>06188  
<a name="l06189"></a>06189         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* GetVariable(<a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html" title="A set of XPath variables.">XPathVariableSet</a>* <span class="keyword">set</span>, <span class="keyword">const</span> char_t* begin, <span class="keyword">const</span> char_t* end) 
<a name="l06190"></a>06190         { 
<a name="l06191"></a>06191                 char_t buffer[32]; 
<a name="l06192"></a>06192  
<a name="l06193"></a>06193                 <span class="keywordtype">size_t</span> length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - begin); 
<a name="l06194"></a>06194                 char_t* scratch = buffer; 
<a name="l06195"></a>06195  
<a name="l06196"></a>06196                 <span class="keywordflow">if</span> (length &gt;= <span class="keyword">sizeof</span>(buffer) / <span class="keyword">sizeof</span>(buffer[0])) 
<a name="l06197"></a>06197                 { 
<a name="l06198"></a>06198                         <span class="comment">// need to make dummy on-heap copy </span>
<a name="l06199"></a>06199                         scratch = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate((length + 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l06200"></a>06200                         <span class="keywordflow">if</span> (!scratch) <span class="keywordflow">return</span> 0; 
<a name="l06201"></a>06201                 } 
<a name="l06202"></a>06202  
<a name="l06203"></a>06203                 <span class="comment">// copy string to zero-terminated buffer and perform lookup </span>
<a name="l06204"></a>06204                 memcpy(scratch, begin, length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l06205"></a>06205                 scratch[length] = 0; 
<a name="l06206"></a>06206  
<a name="l06207"></a>06207                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* Result = <span class="keyword">set</span>-&gt;Get(scratch); 
<a name="l06208"></a>06208  
<a name="l06209"></a>06209                 <span class="comment">// free dummy buffer </span>
<a name="l06210"></a>06210                 <span class="keywordflow">if</span> (scratch != buffer) global_deallocate(scratch); 
<a name="l06211"></a>06211  
<a name="l06212"></a>06212                 <span class="keywordflow">return</span> Result; 
<a name="l06213"></a>06213         } 
<a name="l06214"></a>06214 } 
<a name="l06215"></a>06215  
<a name="l06216"></a>06216 <span class="comment">// Internal node set class </span>
<a name="l06217"></a>06217 <span class="keyword">namespace </span>
<a name="l06218"></a>06218 { 
<a name="l06219"></a>06219         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> XPathSort(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* begin, <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* end, <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> Type, <span class="keywordtype">bool</span> rev) 
<a name="l06220"></a>06220         { 
<a name="l06221"></a>06221                 <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> order = rev ? XPathNodeSet::TypeSortedReverse : XPathNodeSet::TypeSorted; 
<a name="l06222"></a>06222  
<a name="l06223"></a>06223                 <span class="keywordflow">if</span> (Type == XPathNodeSet::TypeUnsorted) 
<a name="l06224"></a>06224                 { 
<a name="l06225"></a>06225                         sort(begin, end, document_order_comparator()); 
<a name="l06226"></a>06226  
<a name="l06227"></a>06227                         Type = XPathNodeSet::TypeSorted; 
<a name="l06228"></a>06228                 } 
<a name="l06229"></a>06229                  
<a name="l06230"></a>06230                 <span class="keywordflow">if</span> (Type != order) reverse(begin, end); 
<a name="l06231"></a>06231                          
<a name="l06232"></a>06232                 <span class="keywordflow">return</span> order; 
<a name="l06233"></a>06233         } 
<a name="l06234"></a>06234  
<a name="l06235"></a>06235         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> XPathFirst(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* begin, <span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* end, <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> Type) 
<a name="l06236"></a>06236         { 
<a name="l06237"></a>06237                 <span class="keywordflow">if</span> (begin == end) <span class="keywordflow">return</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>(); 
<a name="l06238"></a>06238  
<a name="l06239"></a>06239                 <span class="keywordflow">switch</span> (Type) 
<a name="l06240"></a>06240                 { 
<a name="l06241"></a>06241                 <span class="keywordflow">case</span> XPathNodeSet::TypeSorted: 
<a name="l06242"></a>06242                         <span class="keywordflow">return</span> *begin; 
<a name="l06243"></a>06243  
<a name="l06244"></a>06244                 <span class="keywordflow">case</span> XPathNodeSet::TypeSortedReverse: 
<a name="l06245"></a>06245                         <span class="keywordflow">return</span> *(end - 1); 
<a name="l06246"></a>06246  
<a name="l06247"></a>06247                 <span class="keywordflow">case</span> XPathNodeSet::TypeUnsorted: 
<a name="l06248"></a>06248                         <span class="keywordflow">return</span> *min_element(begin, end, document_order_comparator()); 
<a name="l06249"></a>06249  
<a name="l06250"></a>06250                 <span class="keywordflow">default</span>: 
<a name="l06251"></a>06251                         assert(!<span class="stringliteral">&quot;Invalid node set Type&quot;</span>); 
<a name="l06252"></a>06252                         <span class="keywordflow">return</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>(); 
<a name="l06253"></a>06253                 } 
<a name="l06254"></a>06254         } 
<a name="l06255"></a>06255         <span class="keyword">class </span>XPathNodeSet_raw 
<a name="l06256"></a>06256         { 
<a name="l06257"></a>06257                 <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> _type; 
<a name="l06258"></a>06258  
<a name="l06259"></a>06259                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* _begin; 
<a name="l06260"></a>06260                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* _end; 
<a name="l06261"></a>06261                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* _eos; 
<a name="l06262"></a>06262  
<a name="l06263"></a>06263         <span class="keyword">public</span>: 
<a name="l06264"></a>06264                 XPathNodeSet_raw(): _type(<a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>::TypeUnsorted), _begin(0), _end(0), _eos(0) 
<a name="l06265"></a>06265                 { 
<a name="l06266"></a>06266                 } 
<a name="l06267"></a>06267  
<a name="l06268"></a>06268                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* begin()<span class="keyword"> const </span>
<a name="l06269"></a>06269 <span class="keyword">                </span>{ 
<a name="l06270"></a>06270                         <span class="keywordflow">return</span> _begin; 
<a name="l06271"></a>06271                 } 
<a name="l06272"></a>06272  
<a name="l06273"></a>06273                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* end()<span class="keyword"> const </span>
<a name="l06274"></a>06274 <span class="keyword">                </span>{ 
<a name="l06275"></a>06275                         <span class="keywordflow">return</span> _end; 
<a name="l06276"></a>06276                 } 
<a name="l06277"></a>06277  
<a name="l06278"></a>06278                 <span class="keywordtype">bool</span> Empty()<span class="keyword"> const </span>
<a name="l06279"></a>06279 <span class="keyword">                </span>{ 
<a name="l06280"></a>06280                         <span class="keywordflow">return</span> _begin == _end; 
<a name="l06281"></a>06281                 } 
<a name="l06282"></a>06282  
<a name="l06283"></a>06283                 <span class="keywordtype">size_t</span> size()<span class="keyword"> const </span>
<a name="l06284"></a>06284 <span class="keyword">                </span>{ 
<a name="l06285"></a>06285                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(_end - _begin); 
<a name="l06286"></a>06286                 } 
<a name="l06287"></a>06287  
<a name="l06288"></a>06288                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> first()<span class="keyword"> const </span>
<a name="l06289"></a>06289 <span class="keyword">                </span>{ 
<a name="l06290"></a>06290                         <span class="keywordflow">return</span> XPathFirst(_begin, _end, _type); 
<a name="l06291"></a>06291                 } 
<a name="l06292"></a>06292  
<a name="l06293"></a>06293                 <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; node, XPathAllocator* alloc) 
<a name="l06294"></a>06294                 { 
<a name="l06295"></a>06295                         <span class="keywordflow">if</span> (_end == _eos) 
<a name="l06296"></a>06296                         { 
<a name="l06297"></a>06297                                 <span class="keywordtype">size_t</span> capacity = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(_eos - _begin); 
<a name="l06298"></a>06298  
<a name="l06299"></a>06299                                 <span class="comment">// get new capacity (1.5x rule) </span>
<a name="l06300"></a>06300                                 <span class="keywordtype">size_t</span> new_capacity = capacity + capacity / 2 + 1; 
<a name="l06301"></a>06301  
<a name="l06302"></a>06302                                 <span class="comment">// reallocate the old array or allocate a new one </span>
<a name="l06303"></a>06303                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* data = <span class="keyword">static_cast&lt;</span><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>*<span class="keyword">&gt;</span>(alloc-&gt;reallocate(_begin, capacity * <span class="keyword">sizeof</span>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>), new_capacity * <span class="keyword">sizeof</span>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>))); 
<a name="l06304"></a>06304                                 assert(data); 
<a name="l06305"></a>06305  
<a name="l06306"></a>06306                                 <span class="comment">// finalize </span>
<a name="l06307"></a>06307                                 _begin = data; 
<a name="l06308"></a>06308                                 _end = data + capacity; 
<a name="l06309"></a>06309                                 _eos = data + new_capacity; 
<a name="l06310"></a>06310                         } 
<a name="l06311"></a>06311  
<a name="l06312"></a>06312                         *_end++ = node; 
<a name="l06313"></a>06313                 } 
<a name="l06314"></a>06314  
<a name="l06315"></a>06315                 <span class="keywordtype">void</span> append(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* begin, <span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* end, XPathAllocator* alloc) 
<a name="l06316"></a>06316                 { 
<a name="l06317"></a>06317                         <span class="keywordtype">size_t</span> size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(_end - _begin); 
<a name="l06318"></a>06318                         <span class="keywordtype">size_t</span> capacity = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(_eos - _begin); 
<a name="l06319"></a>06319                         <span class="keywordtype">size_t</span> count = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - begin); 
<a name="l06320"></a>06320  
<a name="l06321"></a>06321                         <span class="keywordflow">if</span> (size + count &gt; capacity) 
<a name="l06322"></a>06322                         { 
<a name="l06323"></a>06323                                 <span class="comment">// reallocate the old array or allocate a new one </span>
<a name="l06324"></a>06324                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* data = <span class="keyword">static_cast&lt;</span><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>*<span class="keyword">&gt;</span>(alloc-&gt;reallocate(_begin, capacity * <span class="keyword">sizeof</span>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>), (size + count) * <span class="keyword">sizeof</span>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>))); 
<a name="l06325"></a>06325                                 assert(data); 
<a name="l06326"></a>06326  
<a name="l06327"></a>06327                                 <span class="comment">// finalize </span>
<a name="l06328"></a>06328                                 _begin = data; 
<a name="l06329"></a>06329                                 _end = data + size; 
<a name="l06330"></a>06330                                 _eos = data + size + count; 
<a name="l06331"></a>06331                         } 
<a name="l06332"></a>06332  
<a name="l06333"></a>06333                         memcpy(_end, begin, count * <span class="keyword">sizeof</span>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>)); 
<a name="l06334"></a>06334                         _end += count; 
<a name="l06335"></a>06335                 } 
<a name="l06336"></a>06336  
<a name="l06337"></a>06337                 <span class="keywordtype">void</span> sort_do() 
<a name="l06338"></a>06338                 { 
<a name="l06339"></a>06339                         _type = XPathSort(_begin, _end, _type, <span class="keyword">false</span>); 
<a name="l06340"></a>06340                 } 
<a name="l06341"></a>06341  
<a name="l06342"></a>06342                 <span class="keywordtype">void</span> truncate(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* pos) 
<a name="l06343"></a>06343                 { 
<a name="l06344"></a>06344                         assert(_begin &lt;= pos &amp;&amp; pos &lt;= _end); 
<a name="l06345"></a>06345  
<a name="l06346"></a>06346                         _end = pos; 
<a name="l06347"></a>06347                 } 
<a name="l06348"></a>06348  
<a name="l06349"></a>06349                 <span class="keywordtype">void</span> RemoveDuplicates() 
<a name="l06350"></a>06350                 { 
<a name="l06351"></a>06351                         <span class="keywordflow">if</span> (_type == XPathNodeSet::TypeUnsorted) 
<a name="l06352"></a>06352                                 sort(_begin, _end, duplicate_comparator()); 
<a name="l06353"></a>06353                  
<a name="l06354"></a>06354                         _end = unique(_begin, _end); 
<a name="l06355"></a>06355                 } 
<a name="l06356"></a>06356  
<a name="l06357"></a>06357                 <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> Type()<span class="keyword"> const </span>
<a name="l06358"></a>06358 <span class="keyword">                </span>{ 
<a name="l06359"></a>06359                         <span class="keywordflow">return</span> _type; 
<a name="l06360"></a>06360                 } 
<a name="l06361"></a>06361  
<a name="l06362"></a>06362                 <span class="keywordtype">void</span> SetType(<a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> Type) 
<a name="l06363"></a>06363                 { 
<a name="l06364"></a>06364                         _type = Type; 
<a name="l06365"></a>06365                 } 
<a name="l06366"></a>06366         }; 
<a name="l06367"></a>06367 } 
<a name="l06368"></a>06368  
<a name="l06369"></a>06369 <span class="keyword">namespace </span>
<a name="l06370"></a>06370 { 
<a name="l06371"></a>06371         <span class="keyword">struct </span>XPathContext 
<a name="l06372"></a>06372         { 
<a name="l06373"></a>06373                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> n; 
<a name="l06374"></a>06374                 <span class="keywordtype">size_t</span> position, size; 
<a name="l06375"></a>06375  
<a name="l06376"></a>06376                 XPathContext(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n, <span class="keywordtype">size_t</span> position, <span class="keywordtype">size_t</span> size): n(n), position(position), size(size) 
<a name="l06377"></a>06377                 { 
<a name="l06378"></a>06378                 } 
<a name="l06379"></a>06379         }; 
<a name="l06380"></a>06380  
<a name="l06381"></a>06381         <span class="keyword">enum</span> lexeme_t 
<a name="l06382"></a>06382         { 
<a name="l06383"></a>06383                 lex_none = 0, 
<a name="l06384"></a>06384                 lex_equal, 
<a name="l06385"></a>06385                 lex_not_equal, 
<a name="l06386"></a>06386                 lex_less, 
<a name="l06387"></a>06387                 lex_greater, 
<a name="l06388"></a>06388                 lex_less_or_equal, 
<a name="l06389"></a>06389                 lex_greater_or_equal, 
<a name="l06390"></a>06390                 lex_plus, 
<a name="l06391"></a>06391                 lex_minus, 
<a name="l06392"></a>06392                 lex_multiply, 
<a name="l06393"></a>06393                 lex_union, 
<a name="l06394"></a>06394                 lex_var_ref, 
<a name="l06395"></a>06395                 lex_open_brace, 
<a name="l06396"></a>06396                 lex_close_brace, 
<a name="l06397"></a>06397                 lex_quoted_string, 
<a name="l06398"></a>06398                 lex_number, 
<a name="l06399"></a>06399                 lex_slash, 
<a name="l06400"></a>06400                 lex_double_slash, 
<a name="l06401"></a>06401                 lex_open_square_brace, 
<a name="l06402"></a>06402                 lex_close_square_brace, 
<a name="l06403"></a>06403                 lex_string, 
<a name="l06404"></a>06404                 lex_comma, 
<a name="l06405"></a>06405                 lex_axis_attribute, 
<a name="l06406"></a>06406                 lex_dot, 
<a name="l06407"></a>06407                 lex_double_dot, 
<a name="l06408"></a>06408                 lex_double_colon, 
<a name="l06409"></a>06409                 lex_eof 
<a name="l06410"></a>06410         }; 
<a name="l06411"></a>06411  
<a name="l06412"></a>06412         <span class="keyword">struct </span>XPathLexerString 
<a name="l06413"></a>06413         { 
<a name="l06414"></a>06414                 <span class="keyword">const</span> char_t* begin; 
<a name="l06415"></a>06415                 <span class="keyword">const</span> char_t* end; 
<a name="l06416"></a>06416  
<a name="l06417"></a>06417                 XPathLexerString(): begin(0), end(0) 
<a name="l06418"></a>06418                 { 
<a name="l06419"></a>06419                 } 
<a name="l06420"></a>06420  
<a name="l06421"></a>06421                 <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> char_t* other)<span class="keyword"> const </span>
<a name="l06422"></a>06422 <span class="keyword">                </span>{ 
<a name="l06423"></a>06423                         <span class="keywordtype">size_t</span> length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - begin); 
<a name="l06424"></a>06424  
<a name="l06425"></a>06425                         <span class="keywordflow">return</span> strequalrange(other, begin, length); 
<a name="l06426"></a>06426                 } 
<a name="l06427"></a>06427         }; 
<a name="l06428"></a>06428  
<a name="l06429"></a>06429         <span class="keyword">class </span>XPathLexer 
<a name="l06430"></a>06430         { 
<a name="l06431"></a>06431                 <span class="keyword">const</span> char_t* _cur; 
<a name="l06432"></a>06432                 <span class="keyword">const</span> char_t* _cur_lexeme_pos; 
<a name="l06433"></a>06433                 XPathLexerString _cur_lexeme_contents; 
<a name="l06434"></a>06434  
<a name="l06435"></a>06435                 lexeme_t _cur_lexeme; 
<a name="l06436"></a>06436  
<a name="l06437"></a>06437         <span class="keyword">public</span>: 
<a name="l06438"></a>06438                 <span class="keyword">explicit</span> XPathLexer(<span class="keyword">const</span> char_t* query): _cur(query) 
<a name="l06439"></a>06439                 { 
<a name="l06440"></a>06440                         next(); 
<a name="l06441"></a>06441                 } 
<a name="l06442"></a>06442                  
<a name="l06443"></a>06443                 <span class="keyword">const</span> char_t* state()<span class="keyword"> const </span>
<a name="l06444"></a>06444 <span class="keyword">                </span>{ 
<a name="l06445"></a>06445                         <span class="keywordflow">return</span> _cur; 
<a name="l06446"></a>06446                 } 
<a name="l06447"></a>06447                  
<a name="l06448"></a>06448                 <span class="keywordtype">void</span> next() 
<a name="l06449"></a>06449                 { 
<a name="l06450"></a>06450                         <span class="keyword">const</span> char_t* cur = _cur; 
<a name="l06451"></a>06451  
<a name="l06452"></a>06452                         <span class="keywordflow">while</span> (IS_CHARTYPE(*cur, ct_space)) ++cur; 
<a name="l06453"></a>06453  
<a name="l06454"></a>06454                         <span class="comment">// Save lexeme position for error reporting </span>
<a name="l06455"></a>06455                         _cur_lexeme_pos = cur; 
<a name="l06456"></a>06456  
<a name="l06457"></a>06457                         <span class="keywordflow">switch</span> (*cur) 
<a name="l06458"></a>06458                         { 
<a name="l06459"></a>06459                         <span class="keywordflow">case</span> 0: 
<a name="l06460"></a>06460                                 _cur_lexeme = lex_eof; 
<a name="l06461"></a>06461                                 <span class="keywordflow">break</span>; 
<a name="l06462"></a>06462                          
<a name="l06463"></a>06463                         <span class="keywordflow">case</span> <span class="charliteral">&#39;&gt;&#39;</span>: 
<a name="l06464"></a>06464                                 <span class="keywordflow">if</span> (*(cur+1) == <span class="charliteral">&#39;=&#39;</span>) 
<a name="l06465"></a>06465                                 { 
<a name="l06466"></a>06466                                         cur += 2; 
<a name="l06467"></a>06467                                         _cur_lexeme = lex_greater_or_equal; 
<a name="l06468"></a>06468                                 } 
<a name="l06469"></a>06469                                 <span class="keywordflow">else</span> 
<a name="l06470"></a>06470                                 { 
<a name="l06471"></a>06471                                         cur += 1; 
<a name="l06472"></a>06472                                         _cur_lexeme = lex_greater; 
<a name="l06473"></a>06473                                 } 
<a name="l06474"></a>06474                                 <span class="keywordflow">break</span>; 
<a name="l06475"></a>06475  
<a name="l06476"></a>06476                         <span class="keywordflow">case</span> <span class="charliteral">&#39;&lt;&#39;</span>: 
<a name="l06477"></a>06477                                 <span class="keywordflow">if</span> (*(cur+1) == <span class="charliteral">&#39;=&#39;</span>) 
<a name="l06478"></a>06478                                 { 
<a name="l06479"></a>06479                                         cur += 2; 
<a name="l06480"></a>06480                                         _cur_lexeme = lex_less_or_equal; 
<a name="l06481"></a>06481                                 } 
<a name="l06482"></a>06482                                 <span class="keywordflow">else</span> 
<a name="l06483"></a>06483                                 { 
<a name="l06484"></a>06484                                         cur += 1; 
<a name="l06485"></a>06485                                         _cur_lexeme = lex_less; 
<a name="l06486"></a>06486                                 } 
<a name="l06487"></a>06487                                 <span class="keywordflow">break</span>; 
<a name="l06488"></a>06488  
<a name="l06489"></a>06489                         <span class="keywordflow">case</span> <span class="charliteral">&#39;!&#39;</span>: 
<a name="l06490"></a>06490                                 <span class="keywordflow">if</span> (*(cur+1) == <span class="charliteral">&#39;=&#39;</span>) 
<a name="l06491"></a>06491                                 { 
<a name="l06492"></a>06492                                         cur += 2; 
<a name="l06493"></a>06493                                         _cur_lexeme = lex_not_equal; 
<a name="l06494"></a>06494                                 } 
<a name="l06495"></a>06495                                 <span class="keywordflow">else</span> 
<a name="l06496"></a>06496                                 { 
<a name="l06497"></a>06497                                         _cur_lexeme = lex_none; 
<a name="l06498"></a>06498                                 } 
<a name="l06499"></a>06499                                 <span class="keywordflow">break</span>; 
<a name="l06500"></a>06500  
<a name="l06501"></a>06501                         <span class="keywordflow">case</span> <span class="charliteral">&#39;=&#39;</span>: 
<a name="l06502"></a>06502                                 cur += 1; 
<a name="l06503"></a>06503                                 _cur_lexeme = lex_equal; 
<a name="l06504"></a>06504  
<a name="l06505"></a>06505                                 <span class="keywordflow">break</span>; 
<a name="l06506"></a>06506                          
<a name="l06507"></a>06507                         <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>: 
<a name="l06508"></a>06508                                 cur += 1; 
<a name="l06509"></a>06509                                 _cur_lexeme = lex_plus; 
<a name="l06510"></a>06510  
<a name="l06511"></a>06511                                 <span class="keywordflow">break</span>; 
<a name="l06512"></a>06512  
<a name="l06513"></a>06513                         <span class="keywordflow">case</span> <span class="charliteral">&#39;-&#39;</span>: 
<a name="l06514"></a>06514                                 cur += 1; 
<a name="l06515"></a>06515                                 _cur_lexeme = lex_minus; 
<a name="l06516"></a>06516  
<a name="l06517"></a>06517                                 <span class="keywordflow">break</span>; 
<a name="l06518"></a>06518  
<a name="l06519"></a>06519                         <span class="keywordflow">case</span> <span class="charliteral">&#39;*&#39;</span>: 
<a name="l06520"></a>06520                                 cur += 1; 
<a name="l06521"></a>06521                                 _cur_lexeme = lex_multiply; 
<a name="l06522"></a>06522  
<a name="l06523"></a>06523                                 <span class="keywordflow">break</span>; 
<a name="l06524"></a>06524  
<a name="l06525"></a>06525                         <span class="keywordflow">case</span> <span class="charliteral">&#39;|&#39;</span>: 
<a name="l06526"></a>06526                                 cur += 1; 
<a name="l06527"></a>06527                                 _cur_lexeme = lex_union; 
<a name="l06528"></a>06528  
<a name="l06529"></a>06529                                 <span class="keywordflow">break</span>; 
<a name="l06530"></a>06530                          
<a name="l06531"></a>06531                         <span class="keywordflow">case</span> <span class="charliteral">&#39;$&#39;</span>: 
<a name="l06532"></a>06532                                 cur += 1; 
<a name="l06533"></a>06533  
<a name="l06534"></a>06534                                 <span class="keywordflow">if</span> (IS_CHARTYPEX(*cur, ctx_start_symbol)) 
<a name="l06535"></a>06535                                 { 
<a name="l06536"></a>06536                                         _cur_lexeme_contents.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a39a71c0c078f648de0e716ed59a0446a" title="Get a Child node iterator that references the first child Node.">begin</a> = cur; 
<a name="l06537"></a>06537  
<a name="l06538"></a>06538                                         <span class="keywordflow">while</span> (IS_CHARTYPEX(*cur, ctx_symbol)) cur++; 
<a name="l06539"></a>06539  
<a name="l06540"></a>06540                                         <span class="keywordflow">if</span> (cur[0] == <span class="charliteral">&#39;:&#39;</span> &amp;&amp; IS_CHARTYPEX(cur[1], ctx_symbol)) <span class="comment">// qName </span>
<a name="l06541"></a>06541                                         { 
<a name="l06542"></a>06542                                                 cur++; <span class="comment">// : </span>
<a name="l06543"></a>06543  
<a name="l06544"></a>06544                                                 <span class="keywordflow">while</span> (IS_CHARTYPEX(*cur, ctx_symbol)) cur++; 
<a name="l06545"></a>06545                                         } 
<a name="l06546"></a>06546  
<a name="l06547"></a>06547                                         _cur_lexeme_contents.end = cur; 
<a name="l06548"></a>06548                                  
<a name="l06549"></a>06549                                         _cur_lexeme = lex_var_ref; 
<a name="l06550"></a>06550                                 } 
<a name="l06551"></a>06551                                 <span class="keywordflow">else</span> 
<a name="l06552"></a>06552                                 { 
<a name="l06553"></a>06553                                         _cur_lexeme = lex_none; 
<a name="l06554"></a>06554                                 } 
<a name="l06555"></a>06555  
<a name="l06556"></a>06556                                 <span class="keywordflow">break</span>; 
<a name="l06557"></a>06557  
<a name="l06558"></a>06558                         <span class="keywordflow">case</span> <span class="charliteral">&#39;(&#39;</span>: 
<a name="l06559"></a>06559                                 cur += 1; 
<a name="l06560"></a>06560                                 _cur_lexeme = lex_open_brace; 
<a name="l06561"></a>06561  
<a name="l06562"></a>06562                                 <span class="keywordflow">break</span>; 
<a name="l06563"></a>06563  
<a name="l06564"></a>06564                         <span class="keywordflow">case</span> <span class="charliteral">&#39;)&#39;</span>: 
<a name="l06565"></a>06565                                 cur += 1; 
<a name="l06566"></a>06566                                 _cur_lexeme = lex_close_brace; 
<a name="l06567"></a>06567  
<a name="l06568"></a>06568                                 <span class="keywordflow">break</span>; 
<a name="l06569"></a>06569                          
<a name="l06570"></a>06570                         <span class="keywordflow">case</span> <span class="charliteral">&#39;[&#39;</span>: 
<a name="l06571"></a>06571                                 cur += 1; 
<a name="l06572"></a>06572                                 _cur_lexeme = lex_open_square_brace; 
<a name="l06573"></a>06573  
<a name="l06574"></a>06574                                 <span class="keywordflow">break</span>; 
<a name="l06575"></a>06575  
<a name="l06576"></a>06576                         <span class="keywordflow">case</span> <span class="charliteral">&#39;]&#39;</span>: 
<a name="l06577"></a>06577                                 cur += 1; 
<a name="l06578"></a>06578                                 _cur_lexeme = lex_close_square_brace; 
<a name="l06579"></a>06579  
<a name="l06580"></a>06580                                 <span class="keywordflow">break</span>; 
<a name="l06581"></a>06581  
<a name="l06582"></a>06582                         <span class="keywordflow">case</span> <span class="charliteral">&#39;,&#39;</span>: 
<a name="l06583"></a>06583                                 cur += 1; 
<a name="l06584"></a>06584                                 _cur_lexeme = lex_comma; 
<a name="l06585"></a>06585  
<a name="l06586"></a>06586                                 <span class="keywordflow">break</span>; 
<a name="l06587"></a>06587  
<a name="l06588"></a>06588                         <span class="keywordflow">case</span> <span class="charliteral">&#39;/&#39;</span>: 
<a name="l06589"></a>06589                                 <span class="keywordflow">if</span> (*(cur+1) == <span class="charliteral">&#39;/&#39;</span>) 
<a name="l06590"></a>06590                                 { 
<a name="l06591"></a>06591                                         cur += 2; 
<a name="l06592"></a>06592                                         _cur_lexeme = lex_double_slash; 
<a name="l06593"></a>06593                                 } 
<a name="l06594"></a>06594                                 <span class="keywordflow">else</span> 
<a name="l06595"></a>06595                                 { 
<a name="l06596"></a>06596                                         cur += 1; 
<a name="l06597"></a>06597                                         _cur_lexeme = lex_slash; 
<a name="l06598"></a>06598                                 } 
<a name="l06599"></a>06599                                 <span class="keywordflow">break</span>; 
<a name="l06600"></a>06600                  
<a name="l06601"></a>06601                         <span class="keywordflow">case</span> <span class="charliteral">&#39;.&#39;</span>: 
<a name="l06602"></a>06602                                 <span class="keywordflow">if</span> (*(cur+1) == <span class="charliteral">&#39;.&#39;</span>) 
<a name="l06603"></a>06603                                 { 
<a name="l06604"></a>06604                                         cur += 2; 
<a name="l06605"></a>06605                                         _cur_lexeme = lex_double_dot; 
<a name="l06606"></a>06606                                 } 
<a name="l06607"></a>06607                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_CHARTYPEX(*(cur+1), ctx_digit)) 
<a name="l06608"></a>06608                                 { 
<a name="l06609"></a>06609                                         _cur_lexeme_contents.begin = cur; <span class="comment">// . </span>
<a name="l06610"></a>06610  
<a name="l06611"></a>06611                                         ++cur; 
<a name="l06612"></a>06612  
<a name="l06613"></a>06613                                         <span class="keywordflow">while</span> (IS_CHARTYPEX(*cur, ctx_digit)) cur++; 
<a name="l06614"></a>06614  
<a name="l06615"></a>06615                                         _cur_lexeme_contents.end = cur; 
<a name="l06616"></a>06616                                          
<a name="l06617"></a>06617                                         _cur_lexeme = lex_number; 
<a name="l06618"></a>06618                                 } 
<a name="l06619"></a>06619                                 <span class="keywordflow">else</span> 
<a name="l06620"></a>06620                                 { 
<a name="l06621"></a>06621                                         cur += 1; 
<a name="l06622"></a>06622                                         _cur_lexeme = lex_dot; 
<a name="l06623"></a>06623                                 } 
<a name="l06624"></a>06624                                 <span class="keywordflow">break</span>; 
<a name="l06625"></a>06625  
<a name="l06626"></a>06626                         <span class="keywordflow">case</span> <span class="charliteral">&#39;@&#39;</span>: 
<a name="l06627"></a>06627                                 cur += 1; 
<a name="l06628"></a>06628                                 _cur_lexeme = lex_axis_attribute; 
<a name="l06629"></a>06629  
<a name="l06630"></a>06630                                 <span class="keywordflow">break</span>; 
<a name="l06631"></a>06631  
<a name="l06632"></a>06632                         <span class="keywordflow">case</span> <span class="charliteral">&#39;&quot;&#39;</span>: 
<a name="l06633"></a>06633                         <span class="keywordflow">case</span> <span class="charliteral">&#39;\&#39;&#39;</span>: 
<a name="l06634"></a>06634                         { 
<a name="l06635"></a>06635                                 char_t terminator = *cur; 
<a name="l06636"></a>06636  
<a name="l06637"></a>06637                                 ++cur; 
<a name="l06638"></a>06638  
<a name="l06639"></a>06639                                 _cur_lexeme_contents.begin = cur; 
<a name="l06640"></a>06640                                 <span class="keywordflow">while</span> (*cur &amp;&amp; *cur != terminator) cur++; 
<a name="l06641"></a>06641                                 _cur_lexeme_contents.end = cur; 
<a name="l06642"></a>06642                                  
<a name="l06643"></a>06643                                 <span class="keywordflow">if</span> (!*cur) 
<a name="l06644"></a>06644                                         _cur_lexeme = lex_none; 
<a name="l06645"></a>06645                                 <span class="keywordflow">else</span> 
<a name="l06646"></a>06646                                 { 
<a name="l06647"></a>06647                                         cur += 1; 
<a name="l06648"></a>06648                                         _cur_lexeme = lex_quoted_string; 
<a name="l06649"></a>06649                                 } 
<a name="l06650"></a>06650  
<a name="l06651"></a>06651                                 <span class="keywordflow">break</span>; 
<a name="l06652"></a>06652                         } 
<a name="l06653"></a>06653  
<a name="l06654"></a>06654                         <span class="keywordflow">case</span> <span class="charliteral">&#39;:&#39;</span>: 
<a name="l06655"></a>06655                                 <span class="keywordflow">if</span> (*(cur+1) == <span class="charliteral">&#39;:&#39;</span>) 
<a name="l06656"></a>06656                                 { 
<a name="l06657"></a>06657                                         cur += 2; 
<a name="l06658"></a>06658                                         _cur_lexeme = lex_double_colon; 
<a name="l06659"></a>06659                                 } 
<a name="l06660"></a>06660                                 <span class="keywordflow">else</span> 
<a name="l06661"></a>06661                                 { 
<a name="l06662"></a>06662                                         _cur_lexeme = lex_none; 
<a name="l06663"></a>06663                                 } 
<a name="l06664"></a>06664                                 <span class="keywordflow">break</span>; 
<a name="l06665"></a>06665  
<a name="l06666"></a>06666                         <span class="keywordflow">default</span>: 
<a name="l06667"></a>06667                                 <span class="keywordflow">if</span> (IS_CHARTYPEX(*cur, ctx_digit)) 
<a name="l06668"></a>06668                                 { 
<a name="l06669"></a>06669                                         _cur_lexeme_contents.begin = cur; 
<a name="l06670"></a>06670  
<a name="l06671"></a>06671                                         <span class="keywordflow">while</span> (IS_CHARTYPEX(*cur, ctx_digit)) cur++; 
<a name="l06672"></a>06672                                  
<a name="l06673"></a>06673                                         <span class="keywordflow">if</span> (*cur == <span class="charliteral">&#39;.&#39;</span>) 
<a name="l06674"></a>06674                                         { 
<a name="l06675"></a>06675                                                 cur++; 
<a name="l06676"></a>06676  
<a name="l06677"></a>06677                                                 <span class="keywordflow">while</span> (IS_CHARTYPEX(*cur, ctx_digit)) cur++; 
<a name="l06678"></a>06678                                         } 
<a name="l06679"></a>06679  
<a name="l06680"></a>06680                                         _cur_lexeme_contents.end = cur; 
<a name="l06681"></a>06681  
<a name="l06682"></a>06682                                         _cur_lexeme = lex_number; 
<a name="l06683"></a>06683                                 } 
<a name="l06684"></a>06684                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_CHARTYPEX(*cur, ctx_start_symbol)) 
<a name="l06685"></a>06685                                 { 
<a name="l06686"></a>06686                                         _cur_lexeme_contents.begin = cur; 
<a name="l06687"></a>06687  
<a name="l06688"></a>06688                                         <span class="keywordflow">while</span> (IS_CHARTYPEX(*cur, ctx_symbol)) cur++; 
<a name="l06689"></a>06689  
<a name="l06690"></a>06690                                         <span class="keywordflow">if</span> (cur[0] == <span class="charliteral">&#39;:&#39;</span>) 
<a name="l06691"></a>06691                                         { 
<a name="l06692"></a>06692                                                 <span class="keywordflow">if</span> (cur[1] == <span class="charliteral">&#39;*&#39;</span>) <span class="comment">// namespace test ncName:* </span>
<a name="l06693"></a>06693                                                 { 
<a name="l06694"></a>06694                                                         cur += 2; <span class="comment">// :* </span>
<a name="l06695"></a>06695                                                 } 
<a name="l06696"></a>06696                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IS_CHARTYPEX(cur[1], ctx_symbol)) <span class="comment">// namespace test qName </span>
<a name="l06697"></a>06697                                                 { 
<a name="l06698"></a>06698                                                         cur++; <span class="comment">// : </span>
<a name="l06699"></a>06699  
<a name="l06700"></a>06700                                                         <span class="keywordflow">while</span> (IS_CHARTYPEX(*cur, ctx_symbol)) cur++; 
<a name="l06701"></a>06701                                                 } 
<a name="l06702"></a>06702                                         } 
<a name="l06703"></a>06703  
<a name="l06704"></a>06704                                         _cur_lexeme_contents.end = cur; 
<a name="l06705"></a>06705                                  
<a name="l06706"></a>06706                                         _cur_lexeme = lex_string; 
<a name="l06707"></a>06707                                 } 
<a name="l06708"></a>06708                                 <span class="keywordflow">else</span> 
<a name="l06709"></a>06709                                 { 
<a name="l06710"></a>06710                                         _cur_lexeme = lex_none; 
<a name="l06711"></a>06711                                 } 
<a name="l06712"></a>06712                         } 
<a name="l06713"></a>06713  
<a name="l06714"></a>06714                         _cur = cur; 
<a name="l06715"></a>06715                 } 
<a name="l06716"></a>06716  
<a name="l06717"></a>06717                 lexeme_t current()<span class="keyword"> const </span>
<a name="l06718"></a>06718 <span class="keyword">                </span>{ 
<a name="l06719"></a>06719                         <span class="keywordflow">return</span> _cur_lexeme; 
<a name="l06720"></a>06720                 } 
<a name="l06721"></a>06721  
<a name="l06722"></a>06722                 <span class="keyword">const</span> char_t* current_pos()<span class="keyword"> const </span>
<a name="l06723"></a>06723 <span class="keyword">                </span>{ 
<a name="l06724"></a>06724                         <span class="keywordflow">return</span> _cur_lexeme_pos; 
<a name="l06725"></a>06725                 } 
<a name="l06726"></a>06726  
<a name="l06727"></a>06727                 <span class="keyword">const</span> XPathLexerString&amp; contents()<span class="keyword"> const </span>
<a name="l06728"></a>06728 <span class="keyword">                </span>{ 
<a name="l06729"></a>06729                         assert(_cur_lexeme == lex_var_ref || _cur_lexeme == lex_number || _cur_lexeme == lex_string || _cur_lexeme == lex_quoted_string); 
<a name="l06730"></a>06730  
<a name="l06731"></a>06731                         <span class="keywordflow">return</span> _cur_lexeme_contents; 
<a name="l06732"></a>06732                 } 
<a name="l06733"></a>06733         }; 
<a name="l06734"></a>06734  
<a name="l06735"></a>06735         <span class="keyword">enum</span> ast_type_t 
<a name="l06736"></a>06736         { 
<a name="l06737"></a>06737                 ast_op_or,                                              <span class="comment">// left or right </span>
<a name="l06738"></a>06738                 ast_op_and,                                             <span class="comment">// left and right </span>
<a name="l06739"></a>06739                 ast_op_equal,                                   <span class="comment">// left = right </span>
<a name="l06740"></a>06740                 ast_op_not_equal,                               <span class="comment">// left != right </span>
<a name="l06741"></a>06741                 ast_op_less,                                    <span class="comment">// left &lt; right </span>
<a name="l06742"></a>06742                 ast_op_greater,                                 <span class="comment">// left &gt; right </span>
<a name="l06743"></a>06743                 ast_op_less_or_equal,                   <span class="comment">// left &lt;= right </span>
<a name="l06744"></a>06744                 ast_op_greater_or_equal,                <span class="comment">// left &gt;= right </span>
<a name="l06745"></a>06745                 ast_op_add,                                             <span class="comment">// left + right </span>
<a name="l06746"></a>06746                 ast_op_subtract,                                <span class="comment">// left - right </span>
<a name="l06747"></a>06747                 ast_op_multiply,                                <span class="comment">// left * right </span>
<a name="l06748"></a>06748                 ast_op_divide,                                  <span class="comment">// left / right </span>
<a name="l06749"></a>06749                 ast_op_mod,                                             <span class="comment">// left % right </span>
<a name="l06750"></a>06750                 ast_op_negate,                                  <span class="comment">// left - right </span>
<a name="l06751"></a>06751                 ast_op_union,                                   <span class="comment">// left | right </span>
<a name="l06752"></a>06752                 ast_predicate,                                  <span class="comment">// apply predicate to set; next points to next predicate </span>
<a name="l06753"></a>06753                 ast_filter,                                             <span class="comment">// select * from left where right </span>
<a name="l06754"></a>06754                 ast_filter_posinv,                              <span class="comment">// select * from left where right; proximity position invariant </span>
<a name="l06755"></a>06755                 ast_string_constant,                    <span class="comment">// string constant </span>
<a name="l06756"></a>06756                 ast_number_constant,                    <span class="comment">// number constant </span>
<a name="l06757"></a>06757                 ast_variable,                                   <span class="comment">// variable </span>
<a name="l06758"></a>06758                 ast_func_last,                                  <span class="comment">// last() </span>
<a name="l06759"></a>06759                 ast_func_position,                              <span class="comment">// position() </span>
<a name="l06760"></a>06760                 ast_func_count,                                 <span class="comment">// count(left) </span>
<a name="l06761"></a>06761                 ast_func_id,                                    <span class="comment">// id(left) </span>
<a name="l06762"></a>06762                 ast_func_local_Name_0,                  <span class="comment">// local-Name() </span>
<a name="l06763"></a>06763                 ast_func_local_Name_1,                  <span class="comment">// local-Name(left) </span>
<a name="l06764"></a>06764                 ast_func_namespace_uri_0,               <span class="comment">// namespace-uri() </span>
<a name="l06765"></a>06765                 ast_func_namespace_uri_1,               <span class="comment">// namespace-uri(left) </span>
<a name="l06766"></a>06766                 ast_func_Name_0,                                <span class="comment">// Name() </span>
<a name="l06767"></a>06767                 ast_func_Name_1,                                <span class="comment">// Name(left) </span>
<a name="l06768"></a>06768                 ast_func_string_0,                              <span class="comment">// string() </span>
<a name="l06769"></a>06769                 ast_func_string_1,                              <span class="comment">// string(left) </span>
<a name="l06770"></a>06770                 ast_func_concat,                                <span class="comment">// concat(left, right, siblings) </span>
<a name="l06771"></a>06771                 ast_func_starts_with,                   <span class="comment">// starts_with(left, right) </span>
<a name="l06772"></a>06772                 ast_func_contains,                              <span class="comment">// contains(left, right) </span>
<a name="l06773"></a>06773                 ast_func_substring_before,              <span class="comment">// substring-before(left, right) </span>
<a name="l06774"></a>06774                 ast_func_substring_after,               <span class="comment">// substring-after(left, right) </span>
<a name="l06775"></a>06775                 ast_func_substring_2,                   <span class="comment">// substring(left, right) </span>
<a name="l06776"></a>06776                 ast_func_substring_3,                   <span class="comment">// substring(left, right, third) </span>
<a name="l06777"></a>06777                 ast_func_string_length_0,               <span class="comment">// string-length() </span>
<a name="l06778"></a>06778                 ast_func_string_length_1,               <span class="comment">// string-length(left) </span>
<a name="l06779"></a>06779                 ast_func_normalize_space_0,             <span class="comment">// normalize-space() </span>
<a name="l06780"></a>06780                 ast_func_normalize_space_1,             <span class="comment">// normalize-space(left) </span>
<a name="l06781"></a>06781                 ast_func_translate,                             <span class="comment">// translate(left, right, third) </span>
<a name="l06782"></a>06782                 ast_func_boolean,                               <span class="comment">// boolean(left) </span>
<a name="l06783"></a>06783                 ast_func_not,                                   <span class="comment">// not(left) </span>
<a name="l06784"></a>06784                 ast_func_true,                                  <span class="comment">// true() </span>
<a name="l06785"></a>06785                 ast_func_false,                                 <span class="comment">// false() </span>
<a name="l06786"></a>06786                 ast_func_lang,                                  <span class="comment">// lang(left) </span>
<a name="l06787"></a>06787                 ast_func_number_0,                              <span class="comment">// number() </span>
<a name="l06788"></a>06788                 ast_func_number_1,                              <span class="comment">// number(left) </span>
<a name="l06789"></a>06789                 ast_func_sum,                                   <span class="comment">// sum(left) </span>
<a name="l06790"></a>06790                 ast_func_floor,                                 <span class="comment">// floor(left) </span>
<a name="l06791"></a>06791                 ast_func_ceiling,                               <span class="comment">// ceiling(left) </span>
<a name="l06792"></a>06792                 ast_func_round,                                 <span class="comment">// round(left) </span>
<a name="l06793"></a>06793                 ast_step,                                               <span class="comment">// process set left with step </span>
<a name="l06794"></a>06794                 ast_step_GetRoot                                        <span class="comment">// select GetRoot node </span>
<a name="l06795"></a>06795         }; 
<a name="l06796"></a>06796  
<a name="l06797"></a>06797         <span class="keyword">enum</span> axis_t 
<a name="l06798"></a>06798         { 
<a name="l06799"></a>06799                 axis_ancestor, 
<a name="l06800"></a>06800                 axis_ancestor_or_self, 
<a name="l06801"></a>06801                 axis_attribute, 
<a name="l06802"></a>06802                 axis_GetChild, 
<a name="l06803"></a>06803                 axis_descendant, 
<a name="l06804"></a>06804                 axis_descendant_or_self, 
<a name="l06805"></a>06805                 axis_following, 
<a name="l06806"></a>06806                 axis_following_sibling, 
<a name="l06807"></a>06807                 axis_namespace, 
<a name="l06808"></a>06808                 axis_GetParent, 
<a name="l06809"></a>06809                 axis_preceding, 
<a name="l06810"></a>06810                 axis_preceding_sibling, 
<a name="l06811"></a>06811                 axis_self 
<a name="l06812"></a>06812         }; 
<a name="l06813"></a>06813          
<a name="l06814"></a>06814         <span class="keyword">enum</span> nodetest_t 
<a name="l06815"></a>06815         { 
<a name="l06816"></a>06816                 nodetest_none, 
<a name="l06817"></a>06817                 nodetest_Name, 
<a name="l06818"></a>06818                 nodetest_type_node, 
<a name="l06819"></a>06819                 nodetest_type_comment, 
<a name="l06820"></a>06820                 nodetest_type_pi, 
<a name="l06821"></a>06821                 nodetest_type_text, 
<a name="l06822"></a>06822                 nodetest_pi, 
<a name="l06823"></a>06823                 nodetest_all, 
<a name="l06824"></a>06824                 nodetest_all_in_namespace 
<a name="l06825"></a>06825         }; 
<a name="l06826"></a>06826  
<a name="l06827"></a>06827         <span class="keyword">template</span> &lt;axis_t N&gt; <span class="keyword">struct </span>axis_to_type 
<a name="l06828"></a>06828         { 
<a name="l06829"></a>06829                 <span class="keyword">static</span> <span class="keyword">const</span> axis_t axis; 
<a name="l06830"></a>06830         }; 
<a name="l06831"></a>06831  
<a name="l06832"></a>06832         <span class="keyword">template</span> &lt;axis_t N&gt; <span class="keyword">const</span> axis_t axis_to_type&lt;N&gt;::axis = N; 
<a name="l06833"></a>06833                  
<a name="l06834"></a>06834         <span class="keyword">class </span>XPathAstNode 
<a name="l06835"></a>06835         { 
<a name="l06836"></a>06836         <span class="keyword">private</span>: 
<a name="l06837"></a>06837                 <span class="comment">// node Type </span>
<a name="l06838"></a>06838                 <span class="keywordtype">char</span> _type; 
<a name="l06839"></a>06839                 <span class="keywordtype">char</span> _retType; 
<a name="l06840"></a>06840  
<a name="l06841"></a>06841                 <span class="comment">// for ast_step / ast_predicate </span>
<a name="l06842"></a>06842                 <span class="keywordtype">char</span> _axis; 
<a name="l06843"></a>06843                 <span class="keywordtype">char</span> _test; 
<a name="l06844"></a>06844  
<a name="l06845"></a>06845                 <span class="comment">// tree node structure </span>
<a name="l06846"></a>06846                 XPathAstNode* _left; 
<a name="l06847"></a>06847                 XPathAstNode* _right; 
<a name="l06848"></a>06848                 XPathAstNode* _next; 
<a name="l06849"></a>06849  
<a name="l06850"></a>06850                 <span class="keyword">union </span>
<a name="l06851"></a>06851                 { 
<a name="l06852"></a>06852                         <span class="comment">// Value for ast_string_constant </span>
<a name="l06853"></a>06853                         <span class="keyword">const</span> char_t* string; 
<a name="l06854"></a>06854                         <span class="comment">// Value for ast_number_constant </span>
<a name="l06855"></a>06855                         <span class="keywordtype">double</span> number; 
<a name="l06856"></a>06856                         <span class="comment">// variable for ast_variable </span>
<a name="l06857"></a>06857                         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* variable; 
<a name="l06858"></a>06858                         <span class="comment">// node test for ast_step (node Name/namespace/node Type/pi target) </span>
<a name="l06859"></a>06859                         <span class="keyword">const</span> char_t* nodetest; 
<a name="l06860"></a>06860                 } _data; 
<a name="l06861"></a>06861  
<a name="l06862"></a>06862                 XPathAstNode(<span class="keyword">const</span> XPathAstNode&amp;); 
<a name="l06863"></a>06863                 XPathAstNode&amp; operator=(<span class="keyword">const</span> XPathAstNode&amp;); 
<a name="l06864"></a>06864  
<a name="l06865"></a>06865                 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Comp&gt; <span class="keyword">static</span> <span class="keywordtype">bool</span> compare_eq(XPathAstNode* lhs, XPathAstNode* rhs, <span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack, <span class="keyword">const</span> Comp&amp; comp) 
<a name="l06866"></a>06866                 { 
<a name="l06867"></a>06867                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> lt = lhs-&gt;retType(), rt = rhs-&gt;retType(); 
<a name="l06868"></a>06868  
<a name="l06869"></a>06869                         <span class="keywordflow">if</span> (lt != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a> &amp;&amp; rt != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l06870"></a>06870                         { 
<a name="l06871"></a>06871                                 <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a> || rt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>) 
<a name="l06872"></a>06872                                         <span class="keywordflow">return</span> comp(lhs-&gt;eval_boolean(c, stack), rhs-&gt;eval_boolean(c, stack)); 
<a name="l06873"></a>06873                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a> || rt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>) 
<a name="l06874"></a>06874                                         <span class="keywordflow">return</span> comp(lhs-&gt;eval_number(c, stack), rhs-&gt;eval_number(c, stack)); 
<a name="l06875"></a>06875                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a> || rt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>) 
<a name="l06876"></a>06876                                 { 
<a name="l06877"></a>06877                                         XPathAllocatorCapture cr(stack.Result); 
<a name="l06878"></a>06878  
<a name="l06879"></a>06879                                         XPathString ls = lhs-&gt;eval_string(c, stack); 
<a name="l06880"></a>06880                                         XPathString rs = rhs-&gt;eval_string(c, stack); 
<a name="l06881"></a>06881  
<a name="l06882"></a>06882                                         <span class="keywordflow">return</span> comp(ls, rs); 
<a name="l06883"></a>06883                                 } 
<a name="l06884"></a>06884                         } 
<a name="l06885"></a>06885                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a> &amp;&amp; rt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l06886"></a>06886                         { 
<a name="l06887"></a>06887                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l06888"></a>06888  
<a name="l06889"></a>06889                                 XPathNodeSet_raw ls = lhs-&gt;eval_NodeSet(c, stack); 
<a name="l06890"></a>06890                                 XPathNodeSet_raw rs = rhs-&gt;eval_NodeSet(c, stack); 
<a name="l06891"></a>06891  
<a name="l06892"></a>06892                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* li = ls.begin(); li != ls.end(); ++li) 
<a name="l06893"></a>06893                                         <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* ri = rs.begin(); ri != rs.end(); ++ri) 
<a name="l06894"></a>06894                                         { 
<a name="l06895"></a>06895                                                 XPathAllocatorCapture cri(stack.Result); 
<a name="l06896"></a>06896  
<a name="l06897"></a>06897                                                 <span class="keywordflow">if</span> (comp(string_Value(*li, stack.Result), string_Value(*ri, stack.Result))) 
<a name="l06898"></a>06898                                                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l06899"></a>06899                                         } 
<a name="l06900"></a>06900  
<a name="l06901"></a>06901                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l06902"></a>06902                         } 
<a name="l06903"></a>06903                         <span class="keywordflow">else</span> 
<a name="l06904"></a>06904                         { 
<a name="l06905"></a>06905                                 <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l06906"></a>06906                                 { 
<a name="l06907"></a>06907                                         swap(lhs, rhs); 
<a name="l06908"></a>06908                                         swap(lt, rt); 
<a name="l06909"></a>06909                                 } 
<a name="l06910"></a>06910  
<a name="l06911"></a>06911                                 <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>) 
<a name="l06912"></a>06912                                         <span class="keywordflow">return</span> comp(lhs-&gt;eval_boolean(c, stack), rhs-&gt;eval_boolean(c, stack)); 
<a name="l06913"></a>06913                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>) 
<a name="l06914"></a>06914                                 { 
<a name="l06915"></a>06915                                         XPathAllocatorCapture cr(stack.Result); 
<a name="l06916"></a>06916  
<a name="l06917"></a>06917                                         <span class="keywordtype">double</span> l = lhs-&gt;eval_number(c, stack); 
<a name="l06918"></a>06918                                         XPathNodeSet_raw rs = rhs-&gt;eval_NodeSet(c, stack); 
<a name="l06919"></a>06919  
<a name="l06920"></a>06920                                         <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* ri = rs.begin(); ri != rs.end(); ++ri) 
<a name="l06921"></a>06921                                         { 
<a name="l06922"></a>06922                                                 XPathAllocatorCapture cri(stack.Result); 
<a name="l06923"></a>06923  
<a name="l06924"></a>06924                                                 <span class="keywordflow">if</span> (comp(l, convert_Stringo_number(string_Value(*ri, stack.Result).c_str()))) 
<a name="l06925"></a>06925                                                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l06926"></a>06926                                         } 
<a name="l06927"></a>06927  
<a name="l06928"></a>06928                                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l06929"></a>06929                                 } 
<a name="l06930"></a>06930                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>) 
<a name="l06931"></a>06931                                 { 
<a name="l06932"></a>06932                                         XPathAllocatorCapture cr(stack.Result); 
<a name="l06933"></a>06933  
<a name="l06934"></a>06934                                         XPathString l = lhs-&gt;eval_string(c, stack); 
<a name="l06935"></a>06935                                         XPathNodeSet_raw rs = rhs-&gt;eval_NodeSet(c, stack); 
<a name="l06936"></a>06936  
<a name="l06937"></a>06937                                         <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* ri = rs.begin(); ri != rs.end(); ++ri) 
<a name="l06938"></a>06938                                         { 
<a name="l06939"></a>06939                                                 XPathAllocatorCapture cri(stack.Result); 
<a name="l06940"></a>06940  
<a name="l06941"></a>06941                                                 <span class="keywordflow">if</span> (comp(l, string_Value(*ri, stack.Result))) 
<a name="l06942"></a>06942                                                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l06943"></a>06943                                         } 
<a name="l06944"></a>06944  
<a name="l06945"></a>06945                                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l06946"></a>06946                                 } 
<a name="l06947"></a>06947                         } 
<a name="l06948"></a>06948  
<a name="l06949"></a>06949                         assert(!<span class="stringliteral">&quot;Wrong Types&quot;</span>); 
<a name="l06950"></a>06950                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l06951"></a>06951                 } 
<a name="l06952"></a>06952  
<a name="l06953"></a>06953                 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Comp&gt; <span class="keyword">static</span> <span class="keywordtype">bool</span> compare_rel(XPathAstNode* lhs, XPathAstNode* rhs, <span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack, <span class="keyword">const</span> Comp&amp; comp) 
<a name="l06954"></a>06954                 { 
<a name="l06955"></a>06955                         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> lt = lhs-&gt;retType(), rt = rhs-&gt;retType(); 
<a name="l06956"></a>06956  
<a name="l06957"></a>06957                         <span class="keywordflow">if</span> (lt != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a> &amp;&amp; rt != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l06958"></a>06958                                 <span class="keywordflow">return</span> comp(lhs-&gt;eval_number(c, stack), rhs-&gt;eval_number(c, stack)); 
<a name="l06959"></a>06959                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a> &amp;&amp; rt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l06960"></a>06960                         { 
<a name="l06961"></a>06961                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l06962"></a>06962  
<a name="l06963"></a>06963                                 XPathNodeSet_raw ls = lhs-&gt;eval_NodeSet(c, stack); 
<a name="l06964"></a>06964                                 XPathNodeSet_raw rs = rhs-&gt;eval_NodeSet(c, stack); 
<a name="l06965"></a>06965  
<a name="l06966"></a>06966                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* li = ls.begin(); li != ls.end(); ++li) 
<a name="l06967"></a>06967                                 { 
<a name="l06968"></a>06968                                         XPathAllocatorCapture cri(stack.Result); 
<a name="l06969"></a>06969  
<a name="l06970"></a>06970                                         <span class="keywordtype">double</span> l = convert_Stringo_number(string_Value(*li, stack.Result).c_str()); 
<a name="l06971"></a>06971  
<a name="l06972"></a>06972                                         <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* ri = rs.begin(); ri != rs.end(); ++ri) 
<a name="l06973"></a>06973                                         { 
<a name="l06974"></a>06974                                                 XPathAllocatorCapture crii(stack.Result); 
<a name="l06975"></a>06975  
<a name="l06976"></a>06976                                                 <span class="keywordflow">if</span> (comp(l, convert_Stringo_number(string_Value(*ri, stack.Result).c_str()))) 
<a name="l06977"></a>06977                                                         <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l06978"></a>06978                                         } 
<a name="l06979"></a>06979                                 } 
<a name="l06980"></a>06980  
<a name="l06981"></a>06981                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l06982"></a>06982                         } 
<a name="l06983"></a>06983                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a> &amp;&amp; rt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l06984"></a>06984                         { 
<a name="l06985"></a>06985                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l06986"></a>06986  
<a name="l06987"></a>06987                                 <span class="keywordtype">double</span> l = lhs-&gt;eval_number(c, stack); 
<a name="l06988"></a>06988                                 XPathNodeSet_raw rs = rhs-&gt;eval_NodeSet(c, stack); 
<a name="l06989"></a>06989  
<a name="l06990"></a>06990                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* ri = rs.begin(); ri != rs.end(); ++ri) 
<a name="l06991"></a>06991                                 { 
<a name="l06992"></a>06992                                         XPathAllocatorCapture cri(stack.Result); 
<a name="l06993"></a>06993  
<a name="l06994"></a>06994                                         <span class="keywordflow">if</span> (comp(l, convert_Stringo_number(string_Value(*ri, stack.Result).c_str()))) 
<a name="l06995"></a>06995                                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l06996"></a>06996                                 } 
<a name="l06997"></a>06997  
<a name="l06998"></a>06998                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l06999"></a>06999                         } 
<a name="l07000"></a>07000                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lt == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a> &amp;&amp; rt != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l07001"></a>07001                         { 
<a name="l07002"></a>07002                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07003"></a>07003  
<a name="l07004"></a>07004                                 XPathNodeSet_raw ls = lhs-&gt;eval_NodeSet(c, stack); 
<a name="l07005"></a>07005                                 <span class="keywordtype">double</span> r = rhs-&gt;eval_number(c, stack); 
<a name="l07006"></a>07006  
<a name="l07007"></a>07007                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* li = ls.begin(); li != ls.end(); ++li) 
<a name="l07008"></a>07008                                 { 
<a name="l07009"></a>07009                                         XPathAllocatorCapture cri(stack.Result); 
<a name="l07010"></a>07010  
<a name="l07011"></a>07011                                         <span class="keywordflow">if</span> (comp(convert_Stringo_number(string_Value(*li, stack.Result).c_str()), r)) 
<a name="l07012"></a>07012                                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l07013"></a>07013                                 } 
<a name="l07014"></a>07014  
<a name="l07015"></a>07015                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l07016"></a>07016                         } 
<a name="l07017"></a>07017                         <span class="keywordflow">else</span> 
<a name="l07018"></a>07018                         { 
<a name="l07019"></a>07019                                 assert(!<span class="stringliteral">&quot;Wrong Types&quot;</span>); 
<a name="l07020"></a>07020                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l07021"></a>07021                         } 
<a name="l07022"></a>07022                 } 
<a name="l07023"></a>07023  
<a name="l07024"></a>07024                 <span class="keywordtype">void</span> apply_predicate(XPathNodeSet_raw&amp; ns, <span class="keywordtype">size_t</span> first, XPathAstNode* expr, <span class="keyword">const</span> XPathStack&amp; stack) 
<a name="l07025"></a>07025                 { 
<a name="l07026"></a>07026                         assert(ns.size() &gt;= first); 
<a name="l07027"></a>07027  
<a name="l07028"></a>07028                         <span class="keywordtype">size_t</span> i = 1; 
<a name="l07029"></a>07029                         <span class="keywordtype">size_t</span> size = ns.size() - first; 
<a name="l07030"></a>07030                                  
<a name="l07031"></a>07031                         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* last = ns.begin() + first; 
<a name="l07032"></a>07032                                  
<a name="l07033"></a>07033                         <span class="comment">// RemoveIf... or well, sort of </span>
<a name="l07034"></a>07034                         <span class="keywordflow">for</span> (<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* it = last; it != ns.end(); ++it, ++i) 
<a name="l07035"></a>07035                         { 
<a name="l07036"></a>07036                                 XPathContext c(*it, i, size); 
<a name="l07037"></a>07037                          
<a name="l07038"></a>07038                                 <span class="keywordflow">if</span> (expr-&gt;retType() == XPathTypeNumber) 
<a name="l07039"></a>07039                                 { 
<a name="l07040"></a>07040                                         <span class="keywordflow">if</span> (expr-&gt;eval_number(c, stack) == i) 
<a name="l07041"></a>07041                                                 *last++ = *it; 
<a name="l07042"></a>07042                                 } 
<a name="l07043"></a>07043                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (expr-&gt;eval_boolean(c, stack)) 
<a name="l07044"></a>07044                                         *last++ = *it; 
<a name="l07045"></a>07045                         } 
<a name="l07046"></a>07046                          
<a name="l07047"></a>07047                         ns.truncate(last); 
<a name="l07048"></a>07048                 } 
<a name="l07049"></a>07049  
<a name="l07050"></a>07050                 <span class="keywordtype">void</span> apply_predicates(XPathNodeSet_raw&amp; ns, <span class="keywordtype">size_t</span> first, <span class="keyword">const</span> XPathStack&amp; stack) 
<a name="l07051"></a>07051                 { 
<a name="l07052"></a>07052                         <span class="keywordflow">if</span> (ns.size() == first) <span class="keywordflow">return</span>; 
<a name="l07053"></a>07053                          
<a name="l07054"></a>07054                         <span class="keywordflow">for</span> (XPathAstNode* pred = _right; pred; pred = pred-&gt;_next) 
<a name="l07055"></a>07055                         { 
<a name="l07056"></a>07056                                 apply_predicate(ns, first, pred-&gt;_left, stack); 
<a name="l07057"></a>07057                         } 
<a name="l07058"></a>07058                 } 
<a name="l07059"></a>07059  
<a name="l07060"></a>07060                 <span class="keywordtype">void</span> step_push(XPathNodeSet_raw&amp; ns, <span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; a, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; GetParent, XPathAllocator* alloc) 
<a name="l07061"></a>07061                 { 
<a name="l07062"></a>07062                         <span class="keywordflow">if</span> (!a) <span class="keywordflow">return</span>; 
<a name="l07063"></a>07063  
<a name="l07064"></a>07064                         <span class="keyword">const</span> char_t* Name = a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#ab4c1186366d975d2086bf81df2ce1135" title="Get the name of this Attribute.">Name</a>(); 
<a name="l07065"></a>07065  
<a name="l07066"></a>07066                         <span class="comment">// There are no GetAttribute nodes corresponding to attributes that declare namespaces </span>
<a name="l07067"></a>07067                         <span class="comment">// That is, &quot;xmlns:...&quot; or &quot;xmlns&quot; </span>
<a name="l07068"></a>07068                         <span class="keywordflow">if</span> (starts_with(Name, <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;xmlns&quot;</span>)) &amp;&amp; (Name[5] == 0 || Name[5] == <span class="charliteral">&#39;:&#39;</span>)) <span class="keywordflow">return</span>; 
<a name="l07069"></a>07069                          
<a name="l07070"></a>07070                         <span class="keywordflow">switch</span> (_test) 
<a name="l07071"></a>07071                         { 
<a name="l07072"></a>07072                         <span class="keywordflow">case</span> nodetest_Name: 
<a name="l07073"></a>07073                                 <span class="keywordflow">if</span> (strequal(Name, _data.nodetest)) ns.push_back(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>(a, GetParent), alloc); 
<a name="l07074"></a>07074                                 <span class="keywordflow">break</span>; 
<a name="l07075"></a>07075                                  
<a name="l07076"></a>07076                         <span class="keywordflow">case</span> nodetest_type_node: 
<a name="l07077"></a>07077                         <span class="keywordflow">case</span> nodetest_all: 
<a name="l07078"></a>07078                                 ns.push_back(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>(a, GetParent), alloc); 
<a name="l07079"></a>07079                                 <span class="keywordflow">break</span>; 
<a name="l07080"></a>07080                                  
<a name="l07081"></a>07081                         <span class="keywordflow">case</span> nodetest_all_in_namespace: 
<a name="l07082"></a>07082                                 <span class="keywordflow">if</span> (starts_with(Name, _data.nodetest)) 
<a name="l07083"></a>07083                                         ns.push_back(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>(a, GetParent), alloc); 
<a name="l07084"></a>07084                                 <span class="keywordflow">break</span>; 
<a name="l07085"></a>07085                          
<a name="l07086"></a>07086                         <span class="keywordflow">default</span>: 
<a name="l07087"></a>07087                                 ; 
<a name="l07088"></a>07088                         } 
<a name="l07089"></a>07089                 } 
<a name="l07090"></a>07090                  
<a name="l07091"></a>07091                 <span class="keywordtype">void</span> step_push(XPathNodeSet_raw&amp; ns, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; n, XPathAllocator* alloc) 
<a name="l07092"></a>07092                 { 
<a name="l07093"></a>07093                         <span class="keywordflow">if</span> (!n) <span class="keywordflow">return</span>; 
<a name="l07094"></a>07094  
<a name="l07095"></a>07095                         <span class="keywordflow">switch</span> (_test) 
<a name="l07096"></a>07096                         { 
<a name="l07097"></a>07097                         <span class="keywordflow">case</span> nodetest_Name: 
<a name="l07098"></a>07098                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a> &amp;&amp; strequal(n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>(), _data.nodetest)) ns.push_back(n, alloc); 
<a name="l07099"></a>07099                                 <span class="keywordflow">break</span>; 
<a name="l07100"></a>07100                                  
<a name="l07101"></a>07101                         <span class="keywordflow">case</span> nodetest_type_node: 
<a name="l07102"></a>07102                                 ns.push_back(n, alloc); 
<a name="l07103"></a>07103                                 <span class="keywordflow">break</span>; 
<a name="l07104"></a>07104                                  
<a name="l07105"></a>07105                         <span class="keywordflow">case</span> nodetest_type_comment: 
<a name="l07106"></a>07106                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == NodeComment) 
<a name="l07107"></a>07107                                         ns.push_back(n, alloc); 
<a name="l07108"></a>07108                                 <span class="keywordflow">break</span>; 
<a name="l07109"></a>07109                                  
<a name="l07110"></a>07110                         <span class="keywordflow">case</span> nodetest_type_text: 
<a name="l07111"></a>07111                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3ab48d4b88d7a7757e3e8505c90db3b2bf" title="Plain character data, i.e. &amp;#39;text&amp;#39;.">NodePcdata</a> || n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == NodeCdata) 
<a name="l07112"></a>07112                                         ns.push_back(n, alloc); 
<a name="l07113"></a>07113                                 <span class="keywordflow">break</span>; 
<a name="l07114"></a>07114                                  
<a name="l07115"></a>07115                         <span class="keywordflow">case</span> nodetest_type_pi: 
<a name="l07116"></a>07116                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == NodePi) 
<a name="l07117"></a>07117                                         ns.push_back(n, alloc); 
<a name="l07118"></a>07118                                 <span class="keywordflow">break</span>; 
<a name="l07119"></a>07119                                                                          
<a name="l07120"></a>07120                         <span class="keywordflow">case</span> nodetest_pi: 
<a name="l07121"></a>07121                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a3c09d11be0cea840f23f55e084cf72fa" title="Processing instructions to the XML parser, i.e. &amp;#39;&amp;lt;?name?&amp;gt;&amp;#39;.">NodePi</a> &amp;&amp; strequal(n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>(), _data.nodetest)) 
<a name="l07122"></a>07122                                         ns.push_back(n, alloc); 
<a name="l07123"></a>07123                                 <span class="keywordflow">break</span>; 
<a name="l07124"></a>07124                                  
<a name="l07125"></a>07125                         <span class="keywordflow">case</span> nodetest_all: 
<a name="l07126"></a>07126                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == NodeElement) 
<a name="l07127"></a>07127                                         ns.push_back(n, alloc); 
<a name="l07128"></a>07128                                 <span class="keywordflow">break</span>; 
<a name="l07129"></a>07129                                  
<a name="l07130"></a>07130                         <span class="keywordflow">case</span> nodetest_all_in_namespace: 
<a name="l07131"></a>07131                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">Type</a>() == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3a92facb9678134df6404ce63e7e48624c" title="Element tag, i.e. &amp;#39;&amp;lt;node&amp;gt;&amp;#39;.">NodeElement</a> &amp;&amp; starts_with(n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">Name</a>(), _data.nodetest)) 
<a name="l07132"></a>07132                                         ns.push_back(n, alloc); 
<a name="l07133"></a>07133                                 <span class="keywordflow">break</span>; 
<a name="l07134"></a>07134  
<a name="l07135"></a>07135                         <span class="keywordflow">default</span>: 
<a name="l07136"></a>07136                                 assert(!<span class="stringliteral">&quot;Unknown axis&quot;</span>); 
<a name="l07137"></a>07137                         }  
<a name="l07138"></a>07138                 } 
<a name="l07139"></a>07139  
<a name="l07140"></a>07140                 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> step_fill(XPathNodeSet_raw&amp; ns, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; n, XPathAllocator* alloc, T) 
<a name="l07141"></a>07141                 { 
<a name="l07142"></a>07142                         <span class="keyword">const</span> axis_t axis = T::axis; 
<a name="l07143"></a>07143  
<a name="l07144"></a>07144                         <span class="keywordflow">switch</span> (axis) 
<a name="l07145"></a>07145                         { 
<a name="l07146"></a>07146                         <span class="keywordflow">case</span> axis_attribute: 
<a name="l07147"></a>07147                         { 
<a name="l07148"></a>07148                                 <span class="keywordflow">for</span> (<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#ae484caac4f1fb2a4b7767ddfed28bf0c" title="Get the First Attribute in this Node.">GetFirstAttribute</a>(); a; a = a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a602c51cb79ed0cc33bd898aefe77da70" title="Get the next attribute.">GetNextAttribute</a>()) 
<a name="l07149"></a>07149                                         step_push(ns, a, n, alloc); 
<a name="l07150"></a>07150                                  
<a name="l07151"></a>07151                                 <span class="keywordflow">break</span>; 
<a name="l07152"></a>07152                         } 
<a name="l07153"></a>07153                          
<a name="l07154"></a>07154                         <span class="keywordflow">case</span> axis_GetChild: 
<a name="l07155"></a>07155                         { 
<a name="l07156"></a>07156                                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); c; c = c.GetNextSibling()) 
<a name="l07157"></a>07157                                         step_push(ns, c, alloc); 
<a name="l07158"></a>07158                                          
<a name="l07159"></a>07159                                 <span class="keywordflow">break</span>; 
<a name="l07160"></a>07160                         } 
<a name="l07161"></a>07161                          
<a name="l07162"></a>07162                         <span class="keywordflow">case</span> axis_descendant: 
<a name="l07163"></a>07163                         <span class="keywordflow">case</span> axis_descendant_or_self: 
<a name="l07164"></a>07164                         { 
<a name="l07165"></a>07165                                 <span class="keywordflow">if</span> (axis == axis_descendant_or_self) 
<a name="l07166"></a>07166                                         step_push(ns, n, alloc); 
<a name="l07167"></a>07167                                          
<a name="l07168"></a>07168                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l07169"></a>07169                                  
<a name="l07170"></a>07170                                 <span class="keywordflow">while</span> (cur &amp;&amp; cur != n) 
<a name="l07171"></a>07171                                 { 
<a name="l07172"></a>07172                                         step_push(ns, cur, alloc); 
<a name="l07173"></a>07173                                          
<a name="l07174"></a>07174                                         <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>()) 
<a name="l07175"></a>07175                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l07176"></a>07176                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) 
<a name="l07177"></a>07177                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l07178"></a>07178                                         <span class="keywordflow">else</span> 
<a name="l07179"></a>07179                                         { 
<a name="l07180"></a>07180                                                 <span class="keywordflow">while</span> (!cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>() &amp;&amp; cur != n) 
<a name="l07181"></a>07181                                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07182"></a>07182                                          
<a name="l07183"></a>07183                                                 <span class="keywordflow">if</span> (cur != n) cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l07184"></a>07184                                         } 
<a name="l07185"></a>07185                                 } 
<a name="l07186"></a>07186                                  
<a name="l07187"></a>07187                                 <span class="keywordflow">break</span>; 
<a name="l07188"></a>07188                         } 
<a name="l07189"></a>07189                          
<a name="l07190"></a>07190                         <span class="keywordflow">case</span> axis_following_sibling: 
<a name="l07191"></a>07191                         { 
<a name="l07192"></a>07192                                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); c; c = c.GetNextSibling()) 
<a name="l07193"></a>07193                                         step_push(ns, c, alloc); 
<a name="l07194"></a>07194                                  
<a name="l07195"></a>07195                                 <span class="keywordflow">break</span>; 
<a name="l07196"></a>07196                         } 
<a name="l07197"></a>07197                          
<a name="l07198"></a>07198                         <span class="keywordflow">case</span> axis_preceding_sibling: 
<a name="l07199"></a>07199                         { 
<a name="l07200"></a>07200                                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> c = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>(); c; c = c.GetPreviousSibling()) 
<a name="l07201"></a>07201                                         step_push(ns, c, alloc); 
<a name="l07202"></a>07202                                  
<a name="l07203"></a>07203                                 <span class="keywordflow">break</span>; 
<a name="l07204"></a>07204                         } 
<a name="l07205"></a>07205                          
<a name="l07206"></a>07206                         <span class="keywordflow">case</span> axis_following: 
<a name="l07207"></a>07207                         { 
<a name="l07208"></a>07208                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = n; 
<a name="l07209"></a>07209  
<a name="l07210"></a>07210                                 <span class="comment">// exit from this node so that we don&#39;t include descendants </span>
<a name="l07211"></a>07211                                 <span class="keywordflow">while</span> (cur &amp;&amp; !cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07212"></a>07212                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l07213"></a>07213  
<a name="l07214"></a>07214                                 <span class="keywordflow">for</span> (;;) 
<a name="l07215"></a>07215                                 { 
<a name="l07216"></a>07216                                         step_push(ns, cur, alloc); 
<a name="l07217"></a>07217  
<a name="l07218"></a>07218                                         <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>()) 
<a name="l07219"></a>07219                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l07220"></a>07220                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) 
<a name="l07221"></a>07221                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l07222"></a>07222                                         <span class="keywordflow">else</span> 
<a name="l07223"></a>07223                                         { 
<a name="l07224"></a>07224                                                 <span class="keywordflow">while</span> (cur &amp;&amp; !cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07225"></a>07225                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l07226"></a>07226  
<a name="l07227"></a>07227                                                 <span class="keywordflow">if</span> (!cur) <span class="keywordflow">break</span>; 
<a name="l07228"></a>07228                                         } 
<a name="l07229"></a>07229                                 } 
<a name="l07230"></a>07230  
<a name="l07231"></a>07231                                 <span class="keywordflow">break</span>; 
<a name="l07232"></a>07232                         } 
<a name="l07233"></a>07233  
<a name="l07234"></a>07234                         <span class="keywordflow">case</span> axis_preceding: 
<a name="l07235"></a>07235                         { 
<a name="l07236"></a>07236                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = n; 
<a name="l07237"></a>07237  
<a name="l07238"></a>07238                                 <span class="keywordflow">while</span> (cur &amp;&amp; !cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>()) cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07239"></a>07239                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>(); 
<a name="l07240"></a>07240  
<a name="l07241"></a>07241                                 <span class="keywordflow">for</span> (;;) 
<a name="l07242"></a>07242                                 { 
<a name="l07243"></a>07243                                         <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a10f1a568c8c2c691126f1a9ed2afb922" title="Get the last child Node of this Node.">GetLastChild</a>()) 
<a name="l07244"></a>07244                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a10f1a568c8c2c691126f1a9ed2afb922" title="Get the last child Node of this Node.">GetLastChild</a>(); 
<a name="l07245"></a>07245                                         <span class="keywordflow">else</span> 
<a name="l07246"></a>07246                                         { 
<a name="l07247"></a>07247                                                 <span class="comment">// leaf node, can&#39;t be ancestor </span>
<a name="l07248"></a>07248                                                 step_push(ns, cur, alloc); 
<a name="l07249"></a>07249  
<a name="l07250"></a>07250                                                 <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>()) 
<a name="l07251"></a>07251                                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>(); 
<a name="l07252"></a>07252                                                 <span class="keywordflow">else</span> 
<a name="l07253"></a>07253                                                 { 
<a name="l07254"></a>07254                                                         <span class="keywordflow">do</span>  
<a name="l07255"></a>07255                                                         { 
<a name="l07256"></a>07256                                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07257"></a>07257                                                                 <span class="keywordflow">if</span> (!cur) <span class="keywordflow">break</span>; 
<a name="l07258"></a>07258  
<a name="l07259"></a>07259                                                                 <span class="keywordflow">if</span> (!NodeIs_ancestor(cur, n)) step_push(ns, cur, alloc); 
<a name="l07260"></a>07260                                                         } 
<a name="l07261"></a>07261                                                         <span class="keywordflow">while</span> (!cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>()); 
<a name="l07262"></a>07262  
<a name="l07263"></a>07263                                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#aef027853db1468edcebb6dbdef6031a3" title="Attempt to retrieve the previous sibling of this Node.">GetPreviousSibling</a>(); 
<a name="l07264"></a>07264  
<a name="l07265"></a>07265                                                         <span class="keywordflow">if</span> (!cur) <span class="keywordflow">break</span>; 
<a name="l07266"></a>07266                                                 } 
<a name="l07267"></a>07267                                         } 
<a name="l07268"></a>07268                                 } 
<a name="l07269"></a>07269  
<a name="l07270"></a>07270                                 <span class="keywordflow">break</span>; 
<a name="l07271"></a>07271                         } 
<a name="l07272"></a>07272                          
<a name="l07273"></a>07273                         <span class="keywordflow">case</span> axis_ancestor: 
<a name="l07274"></a>07274                         <span class="keywordflow">case</span> axis_ancestor_or_self: 
<a name="l07275"></a>07275                         { 
<a name="l07276"></a>07276                                 <span class="keywordflow">if</span> (axis == axis_ancestor_or_self) 
<a name="l07277"></a>07277                                         step_push(ns, n, alloc); 
<a name="l07278"></a>07278  
<a name="l07279"></a>07279                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07280"></a>07280                                  
<a name="l07281"></a>07281                                 <span class="keywordflow">while</span> (cur) 
<a name="l07282"></a>07282                                 { 
<a name="l07283"></a>07283                                         step_push(ns, cur, alloc); 
<a name="l07284"></a>07284                                          
<a name="l07285"></a>07285                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07286"></a>07286                                 } 
<a name="l07287"></a>07287                                  
<a name="l07288"></a>07288                                 <span class="keywordflow">break</span>; 
<a name="l07289"></a>07289                         } 
<a name="l07290"></a>07290  
<a name="l07291"></a>07291                         <span class="keywordflow">case</span> axis_self: 
<a name="l07292"></a>07292                         { 
<a name="l07293"></a>07293                                 step_push(ns, n, alloc); 
<a name="l07294"></a>07294  
<a name="l07295"></a>07295                                 <span class="keywordflow">break</span>; 
<a name="l07296"></a>07296                         } 
<a name="l07297"></a>07297  
<a name="l07298"></a>07298                         <span class="keywordflow">case</span> axis_GetParent: 
<a name="l07299"></a>07299                         { 
<a name="l07300"></a>07300                                 <span class="keywordflow">if</span> (n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>()) step_push(ns, n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(), alloc); 
<a name="l07301"></a>07301  
<a name="l07302"></a>07302                                 <span class="keywordflow">break</span>; 
<a name="l07303"></a>07303                         } 
<a name="l07304"></a>07304                                  
<a name="l07305"></a>07305                         <span class="keywordflow">default</span>: 
<a name="l07306"></a>07306                                 assert(!<span class="stringliteral">&quot;Unimplemented axis&quot;</span>); 
<a name="l07307"></a>07307                         } 
<a name="l07308"></a>07308                 } 
<a name="l07309"></a>07309                  
<a name="l07310"></a>07310                 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> step_fill(XPathNodeSet_raw&amp; ns, <span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; a, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; p, XPathAllocator* alloc, T v) 
<a name="l07311"></a>07311                 { 
<a name="l07312"></a>07312                         <span class="keyword">const</span> axis_t axis = T::axis; 
<a name="l07313"></a>07313  
<a name="l07314"></a>07314                         <span class="keywordflow">switch</span> (axis) 
<a name="l07315"></a>07315                         { 
<a name="l07316"></a>07316                         <span class="keywordflow">case</span> axis_ancestor: 
<a name="l07317"></a>07317                         <span class="keywordflow">case</span> axis_ancestor_or_self: 
<a name="l07318"></a>07318                         { 
<a name="l07319"></a>07319                                 <span class="keywordflow">if</span> (axis == axis_ancestor_or_self &amp;&amp; _test == nodetest_type_node) <span class="comment">// reject attributes based on principal node Type test </span>
<a name="l07320"></a>07320                                         step_push(ns, a, p, alloc); 
<a name="l07321"></a>07321  
<a name="l07322"></a>07322                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = p; 
<a name="l07323"></a>07323                                  
<a name="l07324"></a>07324                                 <span class="keywordflow">while</span> (cur) 
<a name="l07325"></a>07325                                 { 
<a name="l07326"></a>07326                                         step_push(ns, cur, alloc); 
<a name="l07327"></a>07327                                          
<a name="l07328"></a>07328                                         cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07329"></a>07329                                 } 
<a name="l07330"></a>07330                                  
<a name="l07331"></a>07331                                 <span class="keywordflow">break</span>; 
<a name="l07332"></a>07332                         } 
<a name="l07333"></a>07333  
<a name="l07334"></a>07334                         <span class="keywordflow">case</span> axis_descendant_or_self: 
<a name="l07335"></a>07335                         <span class="keywordflow">case</span> axis_self: 
<a name="l07336"></a>07336                         { 
<a name="l07337"></a>07337                                 <span class="keywordflow">if</span> (_test == nodetest_type_node) <span class="comment">// reject attributes based on principal node Type test </span>
<a name="l07338"></a>07338                                         step_push(ns, a, p, alloc); 
<a name="l07339"></a>07339  
<a name="l07340"></a>07340                                 <span class="keywordflow">break</span>; 
<a name="l07341"></a>07341                         } 
<a name="l07342"></a>07342  
<a name="l07343"></a>07343                         <span class="keywordflow">case</span> axis_following: 
<a name="l07344"></a>07344                         { 
<a name="l07345"></a>07345                                 <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> cur = p; 
<a name="l07346"></a>07346                                  
<a name="l07347"></a>07347                                 <span class="keywordflow">for</span> (;;) 
<a name="l07348"></a>07348                                 { 
<a name="l07349"></a>07349                                         <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>()) 
<a name="l07350"></a>07350                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a70a568eff666114c28cba812ff202cb6" title="Get the first child Node of this Node.">GetFirstChild</a>(); 
<a name="l07351"></a>07351                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) 
<a name="l07352"></a>07352                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l07353"></a>07353                                         <span class="keywordflow">else</span> 
<a name="l07354"></a>07354                                         { 
<a name="l07355"></a>07355                                                 <span class="keywordflow">while</span> (cur &amp;&amp; !cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>()) cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l07356"></a>07356                                                 cur = cur.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a079c3f9835d5ee05b827ba540764e8bb" title="Attempt to retrieve the next sibling of this Node.">GetNextSibling</a>(); 
<a name="l07357"></a>07357                                                  
<a name="l07358"></a>07358                                                 <span class="keywordflow">if</span> (!cur) <span class="keywordflow">break</span>; 
<a name="l07359"></a>07359                                         } 
<a name="l07360"></a>07360  
<a name="l07361"></a>07361                                         step_push(ns, cur, alloc); 
<a name="l07362"></a>07362                                 } 
<a name="l07363"></a>07363  
<a name="l07364"></a>07364                                 <span class="keywordflow">break</span>; 
<a name="l07365"></a>07365                         } 
<a name="l07366"></a>07366  
<a name="l07367"></a>07367                         <span class="keywordflow">case</span> axis_GetParent: 
<a name="l07368"></a>07368                         { 
<a name="l07369"></a>07369                                 step_push(ns, p, alloc); 
<a name="l07370"></a>07370  
<a name="l07371"></a>07371                                 <span class="keywordflow">break</span>; 
<a name="l07372"></a>07372                         } 
<a name="l07373"></a>07373  
<a name="l07374"></a>07374                         <span class="keywordflow">case</span> axis_preceding: 
<a name="l07375"></a>07375                         { 
<a name="l07376"></a>07376                                 <span class="comment">// preceding:: axis does not include GetAttribute nodes and GetAttribute ancestors (they are the same as GetParent&#39;s ancestors), so we can reuse node preceding </span>
<a name="l07377"></a>07377                                 step_fill(ns, p, alloc, v); 
<a name="l07378"></a>07378                                 <span class="keywordflow">break</span>; 
<a name="l07379"></a>07379                         } 
<a name="l07380"></a>07380                          
<a name="l07381"></a>07381                         <span class="keywordflow">default</span>: 
<a name="l07382"></a>07382                                 assert(!<span class="stringliteral">&quot;Unimplemented axis&quot;</span>); 
<a name="l07383"></a>07383                         } 
<a name="l07384"></a>07384                 } 
<a name="l07385"></a>07385                  
<a name="l07386"></a>07386                 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; XPathNodeSet_raw step_do(<span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack, T v) 
<a name="l07387"></a>07387                 { 
<a name="l07388"></a>07388                         <span class="keyword">const</span> axis_t axis = T::axis; 
<a name="l07389"></a>07389                         <span class="keywordtype">bool</span> attributes = (axis == axis_ancestor || axis == axis_ancestor_or_self || axis == axis_descendant_or_self || axis == axis_following || axis == axis_GetParent || axis == axis_preceding || axis == axis_self); 
<a name="l07390"></a>07390  
<a name="l07391"></a>07391                         XPathNodeSet_raw ns; 
<a name="l07392"></a>07392                         ns.SetType((axis == axis_ancestor || axis == axis_ancestor_or_self || axis == axis_preceding || axis == axis_preceding_sibling) ? XPathNodeSet::TypeSortedReverse : XPathNodeSet::TypeSorted); 
<a name="l07393"></a>07393  
<a name="l07394"></a>07394                         <span class="keywordflow">if</span> (_left) 
<a name="l07395"></a>07395                         { 
<a name="l07396"></a>07396                                 XPathNodeSet_raw s = _left-&gt;eval_NodeSet(c, stack); 
<a name="l07397"></a>07397  
<a name="l07398"></a>07398                                 <span class="comment">// self axis preserves the original order </span>
<a name="l07399"></a>07399                                 <span class="keywordflow">if</span> (axis == axis_self) ns.SetType(s.Type()); 
<a name="l07400"></a>07400  
<a name="l07401"></a>07401                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* it = s.begin(); it != s.end(); ++it) 
<a name="l07402"></a>07402                                 { 
<a name="l07403"></a>07403                                         <span class="keywordtype">size_t</span> size = ns.size(); 
<a name="l07404"></a>07404  
<a name="l07405"></a>07405                                         <span class="comment">// in general, all axes generate elements in a particular order, but there is no order guarantee if axis is applied to two nodes </span>
<a name="l07406"></a>07406                                         <span class="keywordflow">if</span> (axis != axis_self &amp;&amp; size != 0) ns.SetType(XPathNodeSet::TypeUnsorted); 
<a name="l07407"></a>07407                                          
<a name="l07408"></a>07408                                         <span class="keywordflow">if</span> (it-&gt;GetNode()) 
<a name="l07409"></a>07409                                                 step_fill(ns, it-&gt;GetNode(), stack.Result, v); 
<a name="l07410"></a>07410                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attributes) 
<a name="l07411"></a>07411                                                 step_fill(ns, it-&gt;GetAttribute(), it-&gt;GetParent(), stack.Result, v); 
<a name="l07412"></a>07412                                                  
<a name="l07413"></a>07413                                         apply_predicates(ns, size, stack); 
<a name="l07414"></a>07414                                 } 
<a name="l07415"></a>07415                         } 
<a name="l07416"></a>07416                         <span class="keywordflow">else</span> 
<a name="l07417"></a>07417                         { 
<a name="l07418"></a>07418                                 <span class="keywordflow">if</span> (c.n.GetNode()) 
<a name="l07419"></a>07419                                         step_fill(ns, c.n.GetNode(), stack.Result, v); 
<a name="l07420"></a>07420                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attributes) 
<a name="l07421"></a>07421                                         step_fill(ns, c.n.GetAttribute(), c.n.GetParent(), stack.Result, v); 
<a name="l07422"></a>07422                                  
<a name="l07423"></a>07423                                 apply_predicates(ns, 0, stack); 
<a name="l07424"></a>07424                         } 
<a name="l07425"></a>07425  
<a name="l07426"></a>07426                         <span class="comment">// GetChild, GetAttribute and self axes always generate unique set of nodes </span>
<a name="l07427"></a>07427                         <span class="comment">// for other axis, if the set stayed sorted, it stayed unique because the traversal algorithms do not visit the same node twice </span>
<a name="l07428"></a>07428                         <span class="keywordflow">if</span> (axis != axis_GetChild &amp;&amp; axis != axis_attribute &amp;&amp; axis != axis_self &amp;&amp; ns.Type() == XPathNodeSet::TypeUnsorted) 
<a name="l07429"></a>07429                                 ns.RemoveDuplicates(); 
<a name="l07430"></a>07430  
<a name="l07431"></a>07431                         <span class="keywordflow">return</span> ns; 
<a name="l07432"></a>07432                 } 
<a name="l07433"></a>07433                  
<a name="l07434"></a>07434         <span class="keyword">public</span>: 
<a name="l07435"></a>07435                 XPathAstNode(ast_type_t Type, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> retType, <span class="keyword">const</span> char_t* Value): 
<a name="l07436"></a>07436                         _type((char)Type), _retType((char)retType), _axis(0), _test(0), _left(0), _right(0), _next(0) 
<a name="l07437"></a>07437                 { 
<a name="l07438"></a>07438                         assert(Type == ast_string_constant); 
<a name="l07439"></a>07439                         _data.string = Value; 
<a name="l07440"></a>07440                 } 
<a name="l07441"></a>07441  
<a name="l07442"></a>07442                 XPathAstNode(ast_type_t Type, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> retType, <span class="keywordtype">double</span> Value): 
<a name="l07443"></a>07443                         _type((char)Type), _retType((char)retType), _axis(0), _test(0), _left(0), _right(0), _next(0) 
<a name="l07444"></a>07444                 { 
<a name="l07445"></a>07445                         assert(Type == ast_number_constant); 
<a name="l07446"></a>07446                         _data.number = Value; 
<a name="l07447"></a>07447                 } 
<a name="l07448"></a>07448                  
<a name="l07449"></a>07449                 XPathAstNode(ast_type_t Type, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> retType, <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* Value): 
<a name="l07450"></a>07450                         _type((char)Type), _retType((char)retType), _axis(0), _test(0), _left(0), _right(0), _next(0) 
<a name="l07451"></a>07451                 { 
<a name="l07452"></a>07452                         assert(Type == ast_variable); 
<a name="l07453"></a>07453                         _data.variable = Value; 
<a name="l07454"></a>07454                 } 
<a name="l07455"></a>07455                  
<a name="l07456"></a>07456                 XPathAstNode(ast_type_t Type, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> retType, XPathAstNode* left = 0, XPathAstNode* right = 0): 
<a name="l07457"></a>07457                         _type((char)Type), _retType((char)retType), _axis(0), _test(0), _left(left), _right(right), _next(0) 
<a name="l07458"></a>07458                 { 
<a name="l07459"></a>07459                 } 
<a name="l07460"></a>07460  
<a name="l07461"></a>07461                 XPathAstNode(ast_type_t Type, XPathAstNode* left, axis_t axis, nodetest_t test, <span class="keyword">const</span> char_t* contents): 
<a name="l07462"></a>07462                         _type((char)Type), _retType(<a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>), _axis((char)axis), _test((char)test), _left(left), _right(0), _next(0) 
<a name="l07463"></a>07463                 { 
<a name="l07464"></a>07464                         _data.nodetest = contents; 
<a name="l07465"></a>07465                 } 
<a name="l07466"></a>07466  
<a name="l07467"></a>07467                 <span class="keywordtype">void</span> SetNext(XPathAstNode* Value) 
<a name="l07468"></a>07468                 { 
<a name="l07469"></a>07469                         _next = Value; 
<a name="l07470"></a>07470                 } 
<a name="l07471"></a>07471  
<a name="l07472"></a>07472                 <span class="keywordtype">void</span> SetRight(XPathAstNode* Value) 
<a name="l07473"></a>07473                 { 
<a name="l07474"></a>07474                         _right = Value; 
<a name="l07475"></a>07475                 } 
<a name="l07476"></a>07476  
<a name="l07477"></a>07477                 <span class="keywordtype">bool</span> eval_boolean(<span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack) 
<a name="l07478"></a>07478                 { 
<a name="l07479"></a>07479                         <span class="keywordflow">switch</span> (_type) 
<a name="l07480"></a>07480                         { 
<a name="l07481"></a>07481                         <span class="keywordflow">case</span> ast_op_or: 
<a name="l07482"></a>07482                                 <span class="keywordflow">return</span> _left-&gt;eval_boolean(c, stack) || _right-&gt;eval_boolean(c, stack); 
<a name="l07483"></a>07483                                  
<a name="l07484"></a>07484                         <span class="keywordflow">case</span> ast_op_and: 
<a name="l07485"></a>07485                                 <span class="keywordflow">return</span> _left-&gt;eval_boolean(c, stack) &amp;&amp; _right-&gt;eval_boolean(c, stack); 
<a name="l07486"></a>07486                                  
<a name="l07487"></a>07487                         <span class="keywordflow">case</span> ast_op_equal: 
<a name="l07488"></a>07488                                 <span class="keywordflow">return</span> compare_eq(_left, _right, c, stack, equal_to()); 
<a name="l07489"></a>07489  
<a name="l07490"></a>07490                         <span class="keywordflow">case</span> ast_op_not_equal: 
<a name="l07491"></a>07491                                 <span class="keywordflow">return</span> compare_eq(_left, _right, c, stack, not_equal_to()); 
<a name="l07492"></a>07492          
<a name="l07493"></a>07493                         <span class="keywordflow">case</span> ast_op_less: 
<a name="l07494"></a>07494                                 <span class="keywordflow">return</span> compare_rel(_left, _right, c, stack, less()); 
<a name="l07495"></a>07495                          
<a name="l07496"></a>07496                         <span class="keywordflow">case</span> ast_op_greater: 
<a name="l07497"></a>07497                                 <span class="keywordflow">return</span> compare_rel(_right, _left, c, stack, less()); 
<a name="l07498"></a>07498  
<a name="l07499"></a>07499                         <span class="keywordflow">case</span> ast_op_less_or_equal: 
<a name="l07500"></a>07500                                 <span class="keywordflow">return</span> compare_rel(_left, _right, c, stack, less_equal()); 
<a name="l07501"></a>07501                          
<a name="l07502"></a>07502                         <span class="keywordflow">case</span> ast_op_greater_or_equal: 
<a name="l07503"></a>07503                                 <span class="keywordflow">return</span> compare_rel(_right, _left, c, stack, less_equal()); 
<a name="l07504"></a>07504  
<a name="l07505"></a>07505                         <span class="keywordflow">case</span> ast_func_starts_with: 
<a name="l07506"></a>07506                         { 
<a name="l07507"></a>07507                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07508"></a>07508  
<a name="l07509"></a>07509                                 XPathString lr = _left-&gt;eval_string(c, stack); 
<a name="l07510"></a>07510                                 XPathString rr = _right-&gt;eval_string(c, stack); 
<a name="l07511"></a>07511  
<a name="l07512"></a>07512                                 <span class="keywordflow">return</span> starts_with(lr.c_str(), rr.c_str()); 
<a name="l07513"></a>07513                         } 
<a name="l07514"></a>07514  
<a name="l07515"></a>07515                         <span class="keywordflow">case</span> ast_func_contains: 
<a name="l07516"></a>07516                         { 
<a name="l07517"></a>07517                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07518"></a>07518  
<a name="l07519"></a>07519                                 XPathString lr = _left-&gt;eval_string(c, stack); 
<a name="l07520"></a>07520                                 XPathString rr = _right-&gt;eval_string(c, stack); 
<a name="l07521"></a>07521  
<a name="l07522"></a>07522                                 <span class="keywordflow">return</span> FindSubstring(lr.c_str(), rr.c_str()) != 0; 
<a name="l07523"></a>07523                         } 
<a name="l07524"></a>07524  
<a name="l07525"></a>07525                         <span class="keywordflow">case</span> ast_func_boolean: 
<a name="l07526"></a>07526                                 <span class="keywordflow">return</span> _left-&gt;eval_boolean(c, stack); 
<a name="l07527"></a>07527                                  
<a name="l07528"></a>07528                         <span class="keywordflow">case</span> ast_func_not: 
<a name="l07529"></a>07529                                 <span class="keywordflow">return</span> !_left-&gt;eval_boolean(c, stack); 
<a name="l07530"></a>07530                                  
<a name="l07531"></a>07531                         <span class="keywordflow">case</span> ast_func_true: 
<a name="l07532"></a>07532                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l07533"></a>07533                                  
<a name="l07534"></a>07534                         <span class="keywordflow">case</span> ast_func_false: 
<a name="l07535"></a>07535                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l07536"></a>07536  
<a name="l07537"></a>07537                         <span class="keywordflow">case</span> ast_func_lang: 
<a name="l07538"></a>07538                         { 
<a name="l07539"></a>07539                                 <span class="keywordflow">if</span> (c.n.GetAttribute()) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l07540"></a>07540                                  
<a name="l07541"></a>07541                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07542"></a>07542  
<a name="l07543"></a>07543                                 XPathString lang = _left-&gt;eval_string(c, stack); 
<a name="l07544"></a>07544                                  
<a name="l07545"></a>07545                                 <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> n = c.n.GetNode(); n; n = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>()) 
<a name="l07546"></a>07546                                 { 
<a name="l07547"></a>07547                                         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> a = n.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a338eeb27d2a0cf39823f228abb5d936c" title="Attempt to get an Attribute on this Node with a given name.">GetAttribute</a>(<a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;xml:lang&quot;</span>)); 
<a name="l07548"></a>07548                                          
<a name="l07549"></a>07549                                         <span class="keywordflow">if</span> (a) 
<a name="l07550"></a>07550                                         { 
<a name="l07551"></a>07551                                                 <span class="keyword">const</span> char_t* Value = a.<a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html#a8a8099b39bca8894a8226ce0e82d3451" title="Get the Value of this Attribute.">Value</a>(); 
<a name="l07552"></a>07552                                                  
<a name="l07553"></a>07553                                                 <span class="comment">// strnicmp / strncasecmp is not portable </span>
<a name="l07554"></a>07554                                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> char_t* lit = lang.c_str(); *lit; ++lit) 
<a name="l07555"></a>07555                                                 { 
<a name="l07556"></a>07556                                                         <span class="keywordflow">if</span> (tolower_ascii(*lit) != tolower_ascii(*Value)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l07557"></a>07557                                                         ++Value; 
<a name="l07558"></a>07558                                                 } 
<a name="l07559"></a>07559                                                  
<a name="l07560"></a>07560                                                 <span class="keywordflow">return</span> *Value == 0 || *Value == <span class="charliteral">&#39;-&#39;</span>; 
<a name="l07561"></a>07561                                         } 
<a name="l07562"></a>07562                                 } 
<a name="l07563"></a>07563                                  
<a name="l07564"></a>07564                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l07565"></a>07565                         } 
<a name="l07566"></a>07566  
<a name="l07567"></a>07567                         <span class="keywordflow">case</span> ast_variable: 
<a name="l07568"></a>07568                         { 
<a name="l07569"></a>07569                                 assert(_retType == _data.variable-&gt;Type()); 
<a name="l07570"></a>07570  
<a name="l07571"></a>07571                                 <span class="keywordflow">if</span> (_retType == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>) 
<a name="l07572"></a>07572                                         <span class="keywordflow">return</span> _data.variable-&gt;GetBoolean(); 
<a name="l07573"></a>07573  
<a name="l07574"></a>07574                                 <span class="comment">// fallthrough to Type conversion </span>
<a name="l07575"></a>07575                         } 
<a name="l07576"></a>07576  
<a name="l07577"></a>07577                         <span class="keywordflow">default</span>: 
<a name="l07578"></a>07578                         { 
<a name="l07579"></a>07579                                 <span class="keywordflow">switch</span> (_retType) 
<a name="l07580"></a>07580                                 { 
<a name="l07581"></a>07581                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>: 
<a name="l07582"></a>07582                                         <span class="keywordflow">return</span> convert_number_to_boolean(eval_number(c, stack)); 
<a name="l07583"></a>07583                                          
<a name="l07584"></a>07584                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>: 
<a name="l07585"></a>07585                                 { 
<a name="l07586"></a>07586                                         XPathAllocatorCapture cr(stack.Result); 
<a name="l07587"></a>07587  
<a name="l07588"></a>07588                                         <span class="keywordflow">return</span> !eval_string(c, stack).Empty(); 
<a name="l07589"></a>07589                                 } 
<a name="l07590"></a>07590                                          
<a name="l07591"></a>07591                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>:                           
<a name="l07592"></a>07592                                 { 
<a name="l07593"></a>07593                                         XPathAllocatorCapture cr(stack.Result); 
<a name="l07594"></a>07594  
<a name="l07595"></a>07595                                         <span class="keywordflow">return</span> !eval_NodeSet(c, stack).Empty(); 
<a name="l07596"></a>07596                                 } 
<a name="l07597"></a>07597  
<a name="l07598"></a>07598                                 <span class="keywordflow">default</span>: 
<a name="l07599"></a>07599                                         assert(!<span class="stringliteral">&quot;Wrong expression for return Type boolean&quot;</span>); 
<a name="l07600"></a>07600                                         <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l07601"></a>07601                                 } 
<a name="l07602"></a>07602                         } 
<a name="l07603"></a>07603                         } 
<a name="l07604"></a>07604                 } 
<a name="l07605"></a>07605  
<a name="l07606"></a>07606                 <span class="keywordtype">double</span> eval_number(<span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack) 
<a name="l07607"></a>07607                 { 
<a name="l07608"></a>07608                         <span class="keywordflow">switch</span> (_type) 
<a name="l07609"></a>07609                         { 
<a name="l07610"></a>07610                         <span class="keywordflow">case</span> ast_op_add: 
<a name="l07611"></a>07611                                 <span class="keywordflow">return</span> _left-&gt;eval_number(c, stack) + _right-&gt;eval_number(c, stack); 
<a name="l07612"></a>07612                                  
<a name="l07613"></a>07613                         <span class="keywordflow">case</span> ast_op_subtract: 
<a name="l07614"></a>07614                                 <span class="keywordflow">return</span> _left-&gt;eval_number(c, stack) - _right-&gt;eval_number(c, stack); 
<a name="l07615"></a>07615  
<a name="l07616"></a>07616                         <span class="keywordflow">case</span> ast_op_multiply: 
<a name="l07617"></a>07617                                 <span class="keywordflow">return</span> _left-&gt;eval_number(c, stack) * _right-&gt;eval_number(c, stack); 
<a name="l07618"></a>07618  
<a name="l07619"></a>07619                         <span class="keywordflow">case</span> ast_op_divide: 
<a name="l07620"></a>07620                                 <span class="keywordflow">return</span> _left-&gt;eval_number(c, stack) / _right-&gt;eval_number(c, stack); 
<a name="l07621"></a>07621  
<a name="l07622"></a>07622                         <span class="keywordflow">case</span> ast_op_mod: 
<a name="l07623"></a>07623                                 <span class="keywordflow">return</span> fmod(_left-&gt;eval_number(c, stack), _right-&gt;eval_number(c, stack)); 
<a name="l07624"></a>07624  
<a name="l07625"></a>07625                         <span class="keywordflow">case</span> ast_op_negate: 
<a name="l07626"></a>07626                                 <span class="keywordflow">return</span> -_left-&gt;eval_number(c, stack); 
<a name="l07627"></a>07627  
<a name="l07628"></a>07628                         <span class="keywordflow">case</span> ast_number_constant: 
<a name="l07629"></a>07629                                 <span class="keywordflow">return</span> _data.number; 
<a name="l07630"></a>07630  
<a name="l07631"></a>07631                         <span class="keywordflow">case</span> ast_func_last: 
<a name="l07632"></a>07632                                 <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)c.size; 
<a name="l07633"></a>07633                          
<a name="l07634"></a>07634                         <span class="keywordflow">case</span> ast_func_position: 
<a name="l07635"></a>07635                                 <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)c.position; 
<a name="l07636"></a>07636  
<a name="l07637"></a>07637                         <span class="keywordflow">case</span> ast_func_count: 
<a name="l07638"></a>07638                         { 
<a name="l07639"></a>07639                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07640"></a>07640  
<a name="l07641"></a>07641                                 <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)_left-&gt;eval_NodeSet(c, stack).size(); 
<a name="l07642"></a>07642                         } 
<a name="l07643"></a>07643                          
<a name="l07644"></a>07644                         <span class="keywordflow">case</span> ast_func_string_length_0: 
<a name="l07645"></a>07645                         { 
<a name="l07646"></a>07646                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07647"></a>07647  
<a name="l07648"></a>07648                                 <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)string_Value(c.n, stack.Result).length(); 
<a name="l07649"></a>07649                         } 
<a name="l07650"></a>07650                          
<a name="l07651"></a>07651                         <span class="keywordflow">case</span> ast_func_string_length_1: 
<a name="l07652"></a>07652                         { 
<a name="l07653"></a>07653                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07654"></a>07654  
<a name="l07655"></a>07655                                 <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)_left-&gt;eval_string(c, stack).length(); 
<a name="l07656"></a>07656                         } 
<a name="l07657"></a>07657                          
<a name="l07658"></a>07658                         <span class="keywordflow">case</span> ast_func_number_0: 
<a name="l07659"></a>07659                         { 
<a name="l07660"></a>07660                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07661"></a>07661  
<a name="l07662"></a>07662                                 <span class="keywordflow">return</span> convert_Stringo_number(string_Value(c.n, stack.Result).c_str()); 
<a name="l07663"></a>07663                         } 
<a name="l07664"></a>07664                          
<a name="l07665"></a>07665                         <span class="keywordflow">case</span> ast_func_number_1: 
<a name="l07666"></a>07666                                 <span class="keywordflow">return</span> _left-&gt;eval_number(c, stack); 
<a name="l07667"></a>07667  
<a name="l07668"></a>07668                         <span class="keywordflow">case</span> ast_func_sum: 
<a name="l07669"></a>07669                         { 
<a name="l07670"></a>07670                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07671"></a>07671  
<a name="l07672"></a>07672                                 <span class="keywordtype">double</span> r = 0; 
<a name="l07673"></a>07673                                  
<a name="l07674"></a>07674                                 XPathNodeSet_raw ns = _left-&gt;eval_NodeSet(c, stack); 
<a name="l07675"></a>07675                                  
<a name="l07676"></a>07676                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* it = ns.begin(); it != ns.end(); ++it) 
<a name="l07677"></a>07677                                 { 
<a name="l07678"></a>07678                                         XPathAllocatorCapture cri(stack.Result); 
<a name="l07679"></a>07679  
<a name="l07680"></a>07680                                         r += convert_Stringo_number(string_Value(*it, stack.Result).c_str()); 
<a name="l07681"></a>07681                                 } 
<a name="l07682"></a>07682                          
<a name="l07683"></a>07683                                 <span class="keywordflow">return</span> r; 
<a name="l07684"></a>07684                         } 
<a name="l07685"></a>07685  
<a name="l07686"></a>07686                         <span class="keywordflow">case</span> ast_func_floor: 
<a name="l07687"></a>07687                         { 
<a name="l07688"></a>07688                                 <span class="keywordtype">double</span> r = _left-&gt;eval_number(c, stack); 
<a name="l07689"></a>07689                                  
<a name="l07690"></a>07690                                 <span class="keywordflow">return</span> r == r ? floor(r) : r; 
<a name="l07691"></a>07691                         } 
<a name="l07692"></a>07692  
<a name="l07693"></a>07693                         <span class="keywordflow">case</span> ast_func_ceiling: 
<a name="l07694"></a>07694                         { 
<a name="l07695"></a>07695                                 <span class="keywordtype">double</span> r = _left-&gt;eval_number(c, stack); 
<a name="l07696"></a>07696                                  
<a name="l07697"></a>07697                                 <span class="keywordflow">return</span> r == r ? ceil(r) : r; 
<a name="l07698"></a>07698                         } 
<a name="l07699"></a>07699  
<a name="l07700"></a>07700                         <span class="keywordflow">case</span> ast_func_round: 
<a name="l07701"></a>07701                                 <span class="keywordflow">return</span> round_nearest_nzero(_left-&gt;eval_number(c, stack)); 
<a name="l07702"></a>07702                          
<a name="l07703"></a>07703                         <span class="keywordflow">case</span> ast_variable: 
<a name="l07704"></a>07704                         { 
<a name="l07705"></a>07705                                 assert(_retType == _data.variable-&gt;Type()); 
<a name="l07706"></a>07706  
<a name="l07707"></a>07707                                 <span class="keywordflow">if</span> (_retType == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>) 
<a name="l07708"></a>07708                                         <span class="keywordflow">return</span> _data.variable-&gt;GetNumber(); 
<a name="l07709"></a>07709  
<a name="l07710"></a>07710                                 <span class="comment">// fallthrough to Type conversion </span>
<a name="l07711"></a>07711                         } 
<a name="l07712"></a>07712  
<a name="l07713"></a>07713                         <span class="keywordflow">default</span>: 
<a name="l07714"></a>07714                         { 
<a name="l07715"></a>07715                                 <span class="keywordflow">switch</span> (_retType) 
<a name="l07716"></a>07716                                 { 
<a name="l07717"></a>07717                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>: 
<a name="l07718"></a>07718                                         <span class="keywordflow">return</span> eval_boolean(c, stack) ? 1 : 0; 
<a name="l07719"></a>07719                                          
<a name="l07720"></a>07720                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>: 
<a name="l07721"></a>07721                                 { 
<a name="l07722"></a>07722                                         XPathAllocatorCapture cr(stack.Result); 
<a name="l07723"></a>07723  
<a name="l07724"></a>07724                                         <span class="keywordflow">return</span> convert_Stringo_number(eval_string(c, stack).c_str()); 
<a name="l07725"></a>07725                                 } 
<a name="l07726"></a>07726                                          
<a name="l07727"></a>07727                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>: 
<a name="l07728"></a>07728                                 { 
<a name="l07729"></a>07729                                         XPathAllocatorCapture cr(stack.Result); 
<a name="l07730"></a>07730  
<a name="l07731"></a>07731                                         <span class="keywordflow">return</span> convert_Stringo_number(eval_string(c, stack).c_str()); 
<a name="l07732"></a>07732                                 } 
<a name="l07733"></a>07733                                          
<a name="l07734"></a>07734                                 <span class="keywordflow">default</span>: 
<a name="l07735"></a>07735                                         assert(!<span class="stringliteral">&quot;Wrong expression for return Type number&quot;</span>); 
<a name="l07736"></a>07736                                         <span class="keywordflow">return</span> 0; 
<a name="l07737"></a>07737                                 } 
<a name="l07738"></a>07738                                  
<a name="l07739"></a>07739                         } 
<a name="l07740"></a>07740                         } 
<a name="l07741"></a>07741                 } 
<a name="l07742"></a>07742                  
<a name="l07743"></a>07743                 XPathString eval_string_concat(<span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack) 
<a name="l07744"></a>07744                 { 
<a name="l07745"></a>07745                         assert(_type == ast_func_concat); 
<a name="l07746"></a>07746  
<a name="l07747"></a>07747                         XPathAllocatorCapture ct(stack.temp); 
<a name="l07748"></a>07748  
<a name="l07749"></a>07749                         <span class="comment">// count the string number </span>
<a name="l07750"></a>07750                         <span class="keywordtype">size_t</span> count = 1; 
<a name="l07751"></a>07751                         <span class="keywordflow">for</span> (XPathAstNode* nc = _right; nc; nc = nc-&gt;_next) count++; 
<a name="l07752"></a>07752  
<a name="l07753"></a>07753                         <span class="comment">// gather all strings </span>
<a name="l07754"></a>07754                         XPathString static_buffer[4]; 
<a name="l07755"></a>07755                         XPathString* buffer = static_buffer; 
<a name="l07756"></a>07756  
<a name="l07757"></a>07757                         <span class="comment">// allocate on-heap for large concats </span>
<a name="l07758"></a>07758                         <span class="keywordflow">if</span> (count &gt; <span class="keyword">sizeof</span>(static_buffer) / <span class="keyword">sizeof</span>(static_buffer[0])) 
<a name="l07759"></a>07759                         { 
<a name="l07760"></a>07760                                 buffer = <span class="keyword">static_cast&lt;</span>XPathString*<span class="keyword">&gt;</span>(stack.temp-&gt;allocate(count * <span class="keyword">sizeof</span>(XPathString))); 
<a name="l07761"></a>07761                                 assert(buffer); 
<a name="l07762"></a>07762                         } 
<a name="l07763"></a>07763  
<a name="l07764"></a>07764                         <span class="comment">// evaluate all strings to temporary stack </span>
<a name="l07765"></a>07765                         XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l07766"></a>07766  
<a name="l07767"></a>07767                         buffer[0] = _left-&gt;eval_string(c, swapped_stack); 
<a name="l07768"></a>07768  
<a name="l07769"></a>07769                         <span class="keywordtype">size_t</span> pos = 1; 
<a name="l07770"></a>07770                         <span class="keywordflow">for</span> (XPathAstNode* n = _right; n; n = n-&gt;_next, ++pos) buffer[pos] = n-&gt;eval_string(c, swapped_stack); 
<a name="l07771"></a>07771                         assert(pos == count); 
<a name="l07772"></a>07772  
<a name="l07773"></a>07773                         <span class="comment">// get total length </span>
<a name="l07774"></a>07774                         <span class="keywordtype">size_t</span> length = 0; 
<a name="l07775"></a>07775                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i) length += buffer[i].length(); 
<a name="l07776"></a>07776  
<a name="l07777"></a>07777                         <span class="comment">// create final string </span>
<a name="l07778"></a>07778                         char_t* Result = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(stack.Result-&gt;allocate((length + 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l07779"></a>07779                         assert(Result); 
<a name="l07780"></a>07780  
<a name="l07781"></a>07781                         char_t* ri = Result; 
<a name="l07782"></a>07782  
<a name="l07783"></a>07783                         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; count; ++j) 
<a name="l07784"></a>07784                                 <span class="keywordflow">for</span> (<span class="keyword">const</span> char_t* bi = buffer[j].c_str(); *bi; ++bi) 
<a name="l07785"></a>07785                                         *ri++ = *bi; 
<a name="l07786"></a>07786  
<a name="l07787"></a>07787                         *ri = 0; 
<a name="l07788"></a>07788  
<a name="l07789"></a>07789                         <span class="keywordflow">return</span> XPathString(Result, <span class="keyword">true</span>); 
<a name="l07790"></a>07790                 } 
<a name="l07791"></a>07791  
<a name="l07792"></a>07792                 XPathString eval_string(<span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack) 
<a name="l07793"></a>07793                 { 
<a name="l07794"></a>07794                         <span class="keywordflow">switch</span> (_type) 
<a name="l07795"></a>07795                         { 
<a name="l07796"></a>07796                         <span class="keywordflow">case</span> ast_string_constant: 
<a name="l07797"></a>07797                                 <span class="keywordflow">return</span> XPathStringConst(_data.string); 
<a name="l07798"></a>07798                          
<a name="l07799"></a>07799                         <span class="keywordflow">case</span> ast_func_local_Name_0: 
<a name="l07800"></a>07800                         { 
<a name="l07801"></a>07801                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> na = c.n; 
<a name="l07802"></a>07802                                  
<a name="l07803"></a>07803                                 <span class="keywordflow">return</span> XPathStringConst(local_Name(na)); 
<a name="l07804"></a>07804                         } 
<a name="l07805"></a>07805  
<a name="l07806"></a>07806                         <span class="keywordflow">case</span> ast_func_local_Name_1: 
<a name="l07807"></a>07807                         { 
<a name="l07808"></a>07808                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07809"></a>07809  
<a name="l07810"></a>07810                                 XPathNodeSet_raw ns = _left-&gt;eval_NodeSet(c, stack); 
<a name="l07811"></a>07811                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> na = ns.first(); 
<a name="l07812"></a>07812                                  
<a name="l07813"></a>07813                                 <span class="keywordflow">return</span> XPathStringConst(local_Name(na)); 
<a name="l07814"></a>07814                         } 
<a name="l07815"></a>07815  
<a name="l07816"></a>07816                         <span class="keywordflow">case</span> ast_func_Name_0: 
<a name="l07817"></a>07817                         { 
<a name="l07818"></a>07818                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> na = c.n; 
<a name="l07819"></a>07819                                  
<a name="l07820"></a>07820                                 <span class="keywordflow">return</span> XPathStringConst(qualified_Name(na)); 
<a name="l07821"></a>07821                         } 
<a name="l07822"></a>07822  
<a name="l07823"></a>07823                         <span class="keywordflow">case</span> ast_func_Name_1: 
<a name="l07824"></a>07824                         { 
<a name="l07825"></a>07825                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07826"></a>07826  
<a name="l07827"></a>07827                                 XPathNodeSet_raw ns = _left-&gt;eval_NodeSet(c, stack); 
<a name="l07828"></a>07828                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> na = ns.first(); 
<a name="l07829"></a>07829                                  
<a name="l07830"></a>07830                                 <span class="keywordflow">return</span> XPathStringConst(qualified_Name(na)); 
<a name="l07831"></a>07831                         } 
<a name="l07832"></a>07832  
<a name="l07833"></a>07833                         <span class="keywordflow">case</span> ast_func_namespace_uri_0: 
<a name="l07834"></a>07834                         { 
<a name="l07835"></a>07835                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> na = c.n; 
<a name="l07836"></a>07836                                  
<a name="l07837"></a>07837                                 <span class="keywordflow">return</span> XPathStringConst(namespace_uri(na)); 
<a name="l07838"></a>07838                         } 
<a name="l07839"></a>07839  
<a name="l07840"></a>07840                         <span class="keywordflow">case</span> ast_func_namespace_uri_1: 
<a name="l07841"></a>07841                         { 
<a name="l07842"></a>07842                                 XPathAllocatorCapture cr(stack.Result); 
<a name="l07843"></a>07843  
<a name="l07844"></a>07844                                 XPathNodeSet_raw ns = _left-&gt;eval_NodeSet(c, stack); 
<a name="l07845"></a>07845                                 <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> na = ns.first(); 
<a name="l07846"></a>07846                                  
<a name="l07847"></a>07847                                 <span class="keywordflow">return</span> XPathStringConst(namespace_uri(na)); 
<a name="l07848"></a>07848                         } 
<a name="l07849"></a>07849  
<a name="l07850"></a>07850                         <span class="keywordflow">case</span> ast_func_string_0: 
<a name="l07851"></a>07851                                 <span class="keywordflow">return</span> string_Value(c.n, stack.Result); 
<a name="l07852"></a>07852  
<a name="l07853"></a>07853                         <span class="keywordflow">case</span> ast_func_string_1: 
<a name="l07854"></a>07854                                 <span class="keywordflow">return</span> _left-&gt;eval_string(c, stack); 
<a name="l07855"></a>07855  
<a name="l07856"></a>07856                         <span class="keywordflow">case</span> ast_func_concat: 
<a name="l07857"></a>07857                                 <span class="keywordflow">return</span> eval_string_concat(c, stack); 
<a name="l07858"></a>07858  
<a name="l07859"></a>07859                         <span class="keywordflow">case</span> ast_func_substring_before: 
<a name="l07860"></a>07860                         { 
<a name="l07861"></a>07861                                 XPathAllocatorCapture cr(stack.temp); 
<a name="l07862"></a>07862  
<a name="l07863"></a>07863                                 XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l07864"></a>07864  
<a name="l07865"></a>07865                                 XPathString s = _left-&gt;eval_string(c, swapped_stack); 
<a name="l07866"></a>07866                                 XPathString p = _right-&gt;eval_string(c, swapped_stack); 
<a name="l07867"></a>07867  
<a name="l07868"></a>07868                                 <span class="keyword">const</span> char_t* pos = FindSubstring(s.c_str(), p.c_str()); 
<a name="l07869"></a>07869                                  
<a name="l07870"></a>07870                                 <span class="keywordflow">return</span> pos ? XPathString(s.c_str(), pos, stack.Result) : XPathString(); 
<a name="l07871"></a>07871                         } 
<a name="l07872"></a>07872                          
<a name="l07873"></a>07873                         <span class="keywordflow">case</span> ast_func_substring_after: 
<a name="l07874"></a>07874                         { 
<a name="l07875"></a>07875                                 XPathAllocatorCapture cr(stack.temp); 
<a name="l07876"></a>07876  
<a name="l07877"></a>07877                                 XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l07878"></a>07878  
<a name="l07879"></a>07879                                 XPathString s = _left-&gt;eval_string(c, swapped_stack); 
<a name="l07880"></a>07880                                 XPathString p = _right-&gt;eval_string(c, swapped_stack); 
<a name="l07881"></a>07881                                  
<a name="l07882"></a>07882                                 <span class="keyword">const</span> char_t* pos = FindSubstring(s.c_str(), p.c_str()); 
<a name="l07883"></a>07883                                 <span class="keywordflow">if</span> (!pos) <span class="keywordflow">return</span> XPathString(); 
<a name="l07884"></a>07884  
<a name="l07885"></a>07885                                 <span class="keyword">const</span> char_t* Result = pos + p.length(); 
<a name="l07886"></a>07886  
<a name="l07887"></a>07887                                 <span class="keywordflow">return</span> s.uses_heap() ? XPathString(Result, stack.Result) : XPathStringConst(Result); 
<a name="l07888"></a>07888                         } 
<a name="l07889"></a>07889  
<a name="l07890"></a>07890                         <span class="keywordflow">case</span> ast_func_substring_2: 
<a name="l07891"></a>07891                         { 
<a name="l07892"></a>07892                                 XPathAllocatorCapture cr(stack.temp); 
<a name="l07893"></a>07893  
<a name="l07894"></a>07894                                 XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l07895"></a>07895  
<a name="l07896"></a>07896                                 XPathString s = _left-&gt;eval_string(c, swapped_stack); 
<a name="l07897"></a>07897                                 <span class="keywordtype">size_t</span> s_length = s.length(); 
<a name="l07898"></a>07898  
<a name="l07899"></a>07899                                 <span class="keywordtype">double</span> first = round_nearest(_right-&gt;eval_number(c, stack)); 
<a name="l07900"></a>07900                                  
<a name="l07901"></a>07901                                 <span class="keywordflow">if</span> (is_nan(first)) <span class="keywordflow">return</span> XPathString(); <span class="comment">// NaN </span>
<a name="l07902"></a>07902                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (first &gt;= s_length + 1) <span class="keywordflow">return</span> XPathString(); 
<a name="l07903"></a>07903                                  
<a name="l07904"></a>07904                                 <span class="keywordtype">size_t</span> pos = first &lt; 1 ? 1 : (size_t)first; 
<a name="l07905"></a>07905                                 assert(1 &lt;= pos &amp;&amp; pos &lt;= s_length + 1); 
<a name="l07906"></a>07906  
<a name="l07907"></a>07907                                 <span class="keyword">const</span> char_t* rbegin = s.c_str() + (pos - 1); 
<a name="l07908"></a>07908                                  
<a name="l07909"></a>07909                                 <span class="keywordflow">return</span> s.uses_heap() ? XPathString(rbegin, stack.Result) : XPathStringConst(rbegin); 
<a name="l07910"></a>07910                         } 
<a name="l07911"></a>07911                          
<a name="l07912"></a>07912                         <span class="keywordflow">case</span> ast_func_substring_3: 
<a name="l07913"></a>07913                         { 
<a name="l07914"></a>07914                                 XPathAllocatorCapture cr(stack.temp); 
<a name="l07915"></a>07915  
<a name="l07916"></a>07916                                 XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l07917"></a>07917  
<a name="l07918"></a>07918                                 XPathString s = _left-&gt;eval_string(c, swapped_stack); 
<a name="l07919"></a>07919                                 <span class="keywordtype">size_t</span> s_length = s.length(); 
<a name="l07920"></a>07920  
<a name="l07921"></a>07921                                 <span class="keywordtype">double</span> first = round_nearest(_right-&gt;eval_number(c, stack)); 
<a name="l07922"></a>07922                                 <span class="keywordtype">double</span> last = first + round_nearest(_right-&gt;_next-&gt;eval_number(c, stack)); 
<a name="l07923"></a>07923                                  
<a name="l07924"></a>07924                                 <span class="keywordflow">if</span> (is_nan(first) || is_nan(last)) <span class="keywordflow">return</span> XPathString(); 
<a name="l07925"></a>07925                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (first &gt;= s_length + 1) <span class="keywordflow">return</span> XPathString(); 
<a name="l07926"></a>07926                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (first &gt;= last) <span class="keywordflow">return</span> XPathString(); 
<a name="l07927"></a>07927                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (last &lt; 1) <span class="keywordflow">return</span> XPathString(); 
<a name="l07928"></a>07928                                  
<a name="l07929"></a>07929                                 <span class="keywordtype">size_t</span> pos = first &lt; 1 ? 1 : (size_t)first; 
<a name="l07930"></a>07930                                 <span class="keywordtype">size_t</span> end = last &gt;= s_length + 1 ? s_length + 1 : (size_t)last; 
<a name="l07931"></a>07931  
<a name="l07932"></a>07932                                 assert(1 &lt;= pos &amp;&amp; pos &lt;= end &amp;&amp; end &lt;= s_length + 1); 
<a name="l07933"></a>07933                                 <span class="keyword">const</span> char_t* rbegin = s.c_str() + (pos - 1); 
<a name="l07934"></a>07934                                 <span class="keyword">const</span> char_t* rend = s.c_str() + (end - 1); 
<a name="l07935"></a>07935  
<a name="l07936"></a>07936                                 <span class="keywordflow">return</span> (end == s_length + 1 &amp;&amp; !s.uses_heap()) ? XPathStringConst(rbegin) : XPathString(rbegin, rend, stack.Result); 
<a name="l07937"></a>07937                         } 
<a name="l07938"></a>07938  
<a name="l07939"></a>07939                         <span class="keywordflow">case</span> ast_func_normalize_space_0: 
<a name="l07940"></a>07940                         { 
<a name="l07941"></a>07941                                 XPathString s = string_Value(c.n, stack.Result); 
<a name="l07942"></a>07942  
<a name="l07943"></a>07943                                 normalize_space(s.data(stack.Result)); 
<a name="l07944"></a>07944  
<a name="l07945"></a>07945                                 <span class="keywordflow">return</span> s; 
<a name="l07946"></a>07946                         } 
<a name="l07947"></a>07947  
<a name="l07948"></a>07948                         <span class="keywordflow">case</span> ast_func_normalize_space_1: 
<a name="l07949"></a>07949                         { 
<a name="l07950"></a>07950                                 XPathString s = _left-&gt;eval_string(c, stack); 
<a name="l07951"></a>07951  
<a name="l07952"></a>07952                                 normalize_space(s.data(stack.Result)); 
<a name="l07953"></a>07953                          
<a name="l07954"></a>07954                                 <span class="keywordflow">return</span> s; 
<a name="l07955"></a>07955                         } 
<a name="l07956"></a>07956  
<a name="l07957"></a>07957                         <span class="keywordflow">case</span> ast_func_translate: 
<a name="l07958"></a>07958                         { 
<a name="l07959"></a>07959                                 XPathAllocatorCapture cr(stack.temp); 
<a name="l07960"></a>07960  
<a name="l07961"></a>07961                                 XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l07962"></a>07962  
<a name="l07963"></a>07963                                 XPathString s = _left-&gt;eval_string(c, stack); 
<a name="l07964"></a>07964                                 XPathString from = _right-&gt;eval_string(c, swapped_stack); 
<a name="l07965"></a>07965                                 XPathString to = _right-&gt;_next-&gt;eval_string(c, swapped_stack); 
<a name="l07966"></a>07966  
<a name="l07967"></a>07967                                 translate(s.data(stack.Result), from.c_str(), to.c_str()); 
<a name="l07968"></a>07968  
<a name="l07969"></a>07969                                 <span class="keywordflow">return</span> s; 
<a name="l07970"></a>07970                         } 
<a name="l07971"></a>07971  
<a name="l07972"></a>07972                         <span class="keywordflow">case</span> ast_variable: 
<a name="l07973"></a>07973                         { 
<a name="l07974"></a>07974                                 assert(_retType == _data.variable-&gt;Type()); 
<a name="l07975"></a>07975  
<a name="l07976"></a>07976                                 <span class="keywordflow">if</span> (_retType == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>) 
<a name="l07977"></a>07977                                         <span class="keywordflow">return</span> XPathStringConst(_data.variable-&gt;GetString()); 
<a name="l07978"></a>07978  
<a name="l07979"></a>07979                                 <span class="comment">// fallthrough to Type conversion </span>
<a name="l07980"></a>07980                         } 
<a name="l07981"></a>07981  
<a name="l07982"></a>07982                         <span class="keywordflow">default</span>: 
<a name="l07983"></a>07983                         { 
<a name="l07984"></a>07984                                 <span class="keywordflow">switch</span> (_retType) 
<a name="l07985"></a>07985                                 { 
<a name="l07986"></a>07986                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>: 
<a name="l07987"></a>07987                                         <span class="keywordflow">return</span> XPathStringConst(eval_boolean(c, stack) ? <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;true&quot;</span>) : <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;false&quot;</span>)); 
<a name="l07988"></a>07988                                          
<a name="l07989"></a>07989                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>: 
<a name="l07990"></a>07990                                         <span class="keywordflow">return</span> convert_number_to_string(eval_number(c, stack), stack.Result); 
<a name="l07991"></a>07991                                          
<a name="l07992"></a>07992                                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>: 
<a name="l07993"></a>07993                                 { 
<a name="l07994"></a>07994                                         XPathAllocatorCapture cr(stack.temp); 
<a name="l07995"></a>07995  
<a name="l07996"></a>07996                                         XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l07997"></a>07997  
<a name="l07998"></a>07998                                         XPathNodeSet_raw ns = eval_NodeSet(c, swapped_stack); 
<a name="l07999"></a>07999                                         <span class="keywordflow">return</span> ns.Empty() ? XPathString() : string_Value(ns.first(), stack.Result); 
<a name="l08000"></a>08000                                 } 
<a name="l08001"></a>08001                                  
<a name="l08002"></a>08002                                 <span class="keywordflow">default</span>: 
<a name="l08003"></a>08003                                         assert(!<span class="stringliteral">&quot;Wrong expression for return Type string&quot;</span>); 
<a name="l08004"></a>08004                                         <span class="keywordflow">return</span> XPathString(); 
<a name="l08005"></a>08005                                 } 
<a name="l08006"></a>08006                         } 
<a name="l08007"></a>08007                         } 
<a name="l08008"></a>08008                 } 
<a name="l08009"></a>08009  
<a name="l08010"></a>08010                 XPathNodeSet_raw eval_NodeSet(<span class="keyword">const</span> XPathContext&amp; c, <span class="keyword">const</span> XPathStack&amp; stack) 
<a name="l08011"></a>08011                 { 
<a name="l08012"></a>08012                         <span class="keywordflow">switch</span> (_type) 
<a name="l08013"></a>08013                         { 
<a name="l08014"></a>08014                         <span class="keywordflow">case</span> ast_op_union: 
<a name="l08015"></a>08015                         { 
<a name="l08016"></a>08016                                 XPathAllocatorCapture cr(stack.temp); 
<a name="l08017"></a>08017  
<a name="l08018"></a>08018                                 XPathStack swapped_stack = {stack.temp, stack.Result}; 
<a name="l08019"></a>08019  
<a name="l08020"></a>08020                                 XPathNodeSet_raw ls = _left-&gt;eval_NodeSet(c, swapped_stack); 
<a name="l08021"></a>08021                                 XPathNodeSet_raw rs = _right-&gt;eval_NodeSet(c, stack); 
<a name="l08022"></a>08022                                  
<a name="l08023"></a>08023                                 <span class="comment">// we can optimize merging two sorted sets, but this is a very rare operation, so don&#39;t bother </span>
<a name="l08024"></a>08024                                 rs.SetType(XPathNodeSet::TypeUnsorted); 
<a name="l08025"></a>08025  
<a name="l08026"></a>08026                                 rs.append(ls.begin(), ls.end(), stack.Result); 
<a name="l08027"></a>08027                                 rs.RemoveDuplicates(); 
<a name="l08028"></a>08028                                  
<a name="l08029"></a>08029                                 <span class="keywordflow">return</span> rs; 
<a name="l08030"></a>08030                         } 
<a name="l08031"></a>08031  
<a name="l08032"></a>08032                         <span class="keywordflow">case</span> ast_filter: 
<a name="l08033"></a>08033                         <span class="keywordflow">case</span> ast_filter_posinv: 
<a name="l08034"></a>08034                         { 
<a name="l08035"></a>08035                                 XPathNodeSet_raw <span class="keyword">set</span> = _left-&gt;eval_NodeSet(c, stack); 
<a name="l08036"></a>08036  
<a name="l08037"></a>08037                                 <span class="comment">// either expression is a number or it contains position() call; sort by document order </span>
<a name="l08038"></a>08038                                 <span class="keywordflow">if</span> (_type == ast_filter) <span class="keyword">set</span>.sort_do(); 
<a name="l08039"></a>08039  
<a name="l08040"></a>08040                                 apply_predicate(<span class="keyword">set</span>, 0, _right, stack); 
<a name="l08041"></a>08041                          
<a name="l08042"></a>08042                                 <span class="keywordflow">return</span> <span class="keyword">set</span>; 
<a name="l08043"></a>08043                         } 
<a name="l08044"></a>08044                          
<a name="l08045"></a>08045                         <span class="keywordflow">case</span> ast_func_id: 
<a name="l08046"></a>08046                                 <span class="keywordflow">return</span> XPathNodeSet_raw(); 
<a name="l08047"></a>08047                          
<a name="l08048"></a>08048                         <span class="keywordflow">case</span> ast_step: 
<a name="l08049"></a>08049                         { 
<a name="l08050"></a>08050                                 <span class="keywordflow">switch</span> (_axis) 
<a name="l08051"></a>08051                                 { 
<a name="l08052"></a>08052                                 <span class="keywordflow">case</span> axis_ancestor: 
<a name="l08053"></a>08053                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_ancestor&gt;()); 
<a name="l08054"></a>08054                                          
<a name="l08055"></a>08055                                 <span class="keywordflow">case</span> axis_ancestor_or_self: 
<a name="l08056"></a>08056                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_ancestor_or_self&gt;()); 
<a name="l08057"></a>08057  
<a name="l08058"></a>08058                                 <span class="keywordflow">case</span> axis_attribute: 
<a name="l08059"></a>08059                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_attribute&gt;()); 
<a name="l08060"></a>08060  
<a name="l08061"></a>08061                                 <span class="keywordflow">case</span> axis_GetChild: 
<a name="l08062"></a>08062                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_GetChild&gt;()); 
<a name="l08063"></a>08063                                  
<a name="l08064"></a>08064                                 <span class="keywordflow">case</span> axis_descendant: 
<a name="l08065"></a>08065                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_descendant&gt;()); 
<a name="l08066"></a>08066  
<a name="l08067"></a>08067                                 <span class="keywordflow">case</span> axis_descendant_or_self: 
<a name="l08068"></a>08068                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_descendant_or_self&gt;()); 
<a name="l08069"></a>08069  
<a name="l08070"></a>08070                                 <span class="keywordflow">case</span> axis_following: 
<a name="l08071"></a>08071                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_following&gt;()); 
<a name="l08072"></a>08072                                  
<a name="l08073"></a>08073                                 <span class="keywordflow">case</span> axis_following_sibling: 
<a name="l08074"></a>08074                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_following_sibling&gt;()); 
<a name="l08075"></a>08075                                  
<a name="l08076"></a>08076                                 <span class="keywordflow">case</span> axis_namespace: 
<a name="l08077"></a>08077                                         <span class="comment">// namespaced axis is not supported </span>
<a name="l08078"></a>08078                                         <span class="keywordflow">return</span> XPathNodeSet_raw(); 
<a name="l08079"></a>08079                                  
<a name="l08080"></a>08080                                 <span class="keywordflow">case</span> axis_GetParent: 
<a name="l08081"></a>08081                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_GetParent&gt;()); 
<a name="l08082"></a>08082                                  
<a name="l08083"></a>08083                                 <span class="keywordflow">case</span> axis_preceding: 
<a name="l08084"></a>08084                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_preceding&gt;()); 
<a name="l08085"></a>08085  
<a name="l08086"></a>08086                                 <span class="keywordflow">case</span> axis_preceding_sibling: 
<a name="l08087"></a>08087                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_preceding_sibling&gt;()); 
<a name="l08088"></a>08088                                  
<a name="l08089"></a>08089                                 <span class="keywordflow">case</span> axis_self: 
<a name="l08090"></a>08090                                         <span class="keywordflow">return</span> step_do(c, stack, axis_to_type&lt;axis_self&gt;()); 
<a name="l08091"></a>08091                                 } 
<a name="l08092"></a>08092                         } 
<a name="l08093"></a>08093  
<a name="l08094"></a>08094                         <span class="keywordflow">case</span> ast_step_GetRoot: 
<a name="l08095"></a>08095                         { 
<a name="l08096"></a>08096                                 assert(!_right); <span class="comment">// GetRoot step can&#39;t have any predicates </span>
<a name="l08097"></a>08097  
<a name="l08098"></a>08098                                 XPathNodeSet_raw ns; 
<a name="l08099"></a>08099  
<a name="l08100"></a>08100                                 ns.SetType(XPathNodeSet::TypeSorted); 
<a name="l08101"></a>08101  
<a name="l08102"></a>08102                                 <span class="keywordflow">if</span> (c.n.GetNode()) ns.push_back(c.n.GetNode().GetRoot(), stack.Result); 
<a name="l08103"></a>08103                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c.n.GetAttribute()) ns.push_back(c.n.GetParent().GetRoot(), stack.Result); 
<a name="l08104"></a>08104  
<a name="l08105"></a>08105                                 <span class="keywordflow">return</span> ns; 
<a name="l08106"></a>08106                         } 
<a name="l08107"></a>08107  
<a name="l08108"></a>08108                         <span class="keywordflow">case</span> ast_variable: 
<a name="l08109"></a>08109                         { 
<a name="l08110"></a>08110                                 assert(_retType == _data.variable-&gt;Type()); 
<a name="l08111"></a>08111  
<a name="l08112"></a>08112                                 <span class="keywordflow">if</span> (_retType == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) 
<a name="l08113"></a>08113                                 { 
<a name="l08114"></a>08114                                         <span class="keyword">const</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>&amp; s = _data.variable-&gt;GetNodeSet(); 
<a name="l08115"></a>08115  
<a name="l08116"></a>08116                                         XPathNodeSet_raw ns; 
<a name="l08117"></a>08117  
<a name="l08118"></a>08118                                         ns.SetType(s.<a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a95c90708290e045ef04425a71b2ddf25" title="Get collection Type.">Type</a>()); 
<a name="l08119"></a>08119                                         ns.append(s.<a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a887d84cf19f5d2155ab9153bc02e8d1e" title="Get Beginning iterator.">begin</a>(), s.<a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a1b5507aca9b87bbaa0c698f293ae8fd4" title="Get Ending iterator.">end</a>(), stack.Result); 
<a name="l08120"></a>08120  
<a name="l08121"></a>08121                                         <span class="keywordflow">return</span> ns; 
<a name="l08122"></a>08122                                 } 
<a name="l08123"></a>08123  
<a name="l08124"></a>08124                                 <span class="comment">// fallthrough to Type conversion </span>
<a name="l08125"></a>08125                         } 
<a name="l08126"></a>08126  
<a name="l08127"></a>08127                         <span class="keywordflow">default</span>: 
<a name="l08128"></a>08128                                 assert(!<span class="stringliteral">&quot;Wrong expression for return Type node set&quot;</span>); 
<a name="l08129"></a>08129                                 <span class="keywordflow">return</span> XPathNodeSet_raw(); 
<a name="l08130"></a>08130                         } 
<a name="l08131"></a>08131                 } 
<a name="l08132"></a>08132                  
<a name="l08133"></a>08133                 <span class="keywordtype">bool</span> is_posinv() 
<a name="l08134"></a>08134                 { 
<a name="l08135"></a>08135                         <span class="keywordflow">switch</span> (_type) 
<a name="l08136"></a>08136                         { 
<a name="l08137"></a>08137                         <span class="keywordflow">case</span> ast_func_position: 
<a name="l08138"></a>08138                                 <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l08139"></a>08139  
<a name="l08140"></a>08140                         <span class="keywordflow">case</span> ast_string_constant: 
<a name="l08141"></a>08141                         <span class="keywordflow">case</span> ast_number_constant: 
<a name="l08142"></a>08142                         <span class="keywordflow">case</span> ast_variable: 
<a name="l08143"></a>08143                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l08144"></a>08144  
<a name="l08145"></a>08145                         <span class="keywordflow">case</span> ast_step: 
<a name="l08146"></a>08146                         <span class="keywordflow">case</span> ast_step_GetRoot: 
<a name="l08147"></a>08147                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l08148"></a>08148  
<a name="l08149"></a>08149                         <span class="keywordflow">case</span> ast_predicate: 
<a name="l08150"></a>08150                         <span class="keywordflow">case</span> ast_filter: 
<a name="l08151"></a>08151                         <span class="keywordflow">case</span> ast_filter_posinv: 
<a name="l08152"></a>08152                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l08153"></a>08153  
<a name="l08154"></a>08154                         <span class="keywordflow">default</span>: 
<a name="l08155"></a>08155                                 <span class="keywordflow">if</span> (_left &amp;&amp; !_left-&gt;is_posinv()) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l08156"></a>08156                                  
<a name="l08157"></a>08157                                 <span class="keywordflow">for</span> (XPathAstNode* n = _right; n; n = n-&gt;_next) 
<a name="l08158"></a>08158                                         <span class="keywordflow">if</span> (!n-&gt;is_posinv()) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l08159"></a>08159                                          
<a name="l08160"></a>08160                                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l08161"></a>08161                         } 
<a name="l08162"></a>08162                 } 
<a name="l08163"></a>08163  
<a name="l08164"></a>08164                 <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> retType()<span class="keyword"> const </span>
<a name="l08165"></a>08165 <span class="keyword">                </span>{ 
<a name="l08166"></a>08166                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a><span class="keyword">&gt;</span>(_retType); 
<a name="l08167"></a>08167                 } 
<a name="l08168"></a>08168         }; 
<a name="l08169"></a>08169  
<a name="l08170"></a>08170         <span class="keyword">struct </span>XPathParser 
<a name="l08171"></a>08171         { 
<a name="l08172"></a>08172                 XPathAllocator* _alloc; 
<a name="l08173"></a>08173                 XPathLexer _lexer; 
<a name="l08174"></a>08174  
<a name="l08175"></a>08175                 <span class="keyword">const</span> char_t* _query; 
<a name="l08176"></a>08176                 <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html" title="A set of XPath variables.">XPathVariableSet</a>* _variables; 
<a name="l08177"></a>08177  
<a name="l08178"></a>08178                 <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html" title="XPath parsing result.">XPathParseResult</a>* _Result; 
<a name="l08179"></a>08179  
<a name="l08180"></a>08180 <span class="preprocessor">        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l08181"></a>08181 <span class="preprocessor"></span>                jmp_buf _error_handler; 
<a name="l08182"></a>08182 <span class="preprocessor">        #endif </span>
<a name="l08183"></a>08183 <span class="preprocessor"></span> 
<a name="l08184"></a>08184                 <span class="keywordtype">void</span> throw_error(<span class="keyword">const</span> <span class="keywordtype">char</span>* message) 
<a name="l08185"></a>08185                 { 
<a name="l08186"></a>08186                         _Result-&gt;error = message; 
<a name="l08187"></a>08187                         _Result-&gt;Offset = _lexer.current_pos() - _query; 
<a name="l08188"></a>08188  
<a name="l08189"></a>08189 <span class="preprocessor">                #ifdef XML_NO_EXCEPTIONS </span>
<a name="l08190"></a>08190 <span class="preprocessor"></span>                        longjmp(_error_handler, 1); 
<a name="l08191"></a>08191 <span class="preprocessor">                #else </span>
<a name="l08192"></a>08192 <span class="preprocessor"></span>                        <span class="keywordflow">throw</span> <a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html" title="Thrown in a variety of XPath only situations, to indicate type mismatch or other issues.">XPathException</a>(*_Result); 
<a name="l08193"></a>08193 <span class="preprocessor">                #endif </span>
<a name="l08194"></a>08194 <span class="preprocessor"></span>                } 
<a name="l08195"></a>08195  
<a name="l08196"></a>08196                 <span class="keywordtype">void</span> throw_error_oom() 
<a name="l08197"></a>08197                 { 
<a name="l08198"></a>08198 <span class="preprocessor">                #ifdef XML_NO_EXCEPTIONS </span>
<a name="l08199"></a>08199 <span class="preprocessor"></span>                        throw_error(<span class="stringliteral">&quot;Out of memory&quot;</span>); 
<a name="l08200"></a>08200 <span class="preprocessor">                #else </span>
<a name="l08201"></a>08201 <span class="preprocessor"></span>                        <span class="keywordflow">throw</span> std::bad_alloc(); 
<a name="l08202"></a>08202 <span class="preprocessor">                #endif </span>
<a name="l08203"></a>08203 <span class="preprocessor"></span>                } 
<a name="l08204"></a>08204  
<a name="l08205"></a>08205                 <span class="keywordtype">void</span>* alloc_node() 
<a name="l08206"></a>08206                 { 
<a name="l08207"></a>08207                         <span class="keywordtype">void</span>* Result = _alloc-&gt;allocate_nothrow(<span class="keyword">sizeof</span>(XPathAstNode)); 
<a name="l08208"></a>08208  
<a name="l08209"></a>08209                         <span class="keywordflow">if</span> (!Result) throw_error_oom(); 
<a name="l08210"></a>08210  
<a name="l08211"></a>08211                         <span class="keywordflow">return</span> Result; 
<a name="l08212"></a>08212                 } 
<a name="l08213"></a>08213  
<a name="l08214"></a>08214                 <span class="keyword">const</span> char_t* alloc_string(<span class="keyword">const</span> XPathLexerString&amp; Value) 
<a name="l08215"></a>08215                 { 
<a name="l08216"></a>08216                         <span class="keywordflow">if</span> (Value.begin) 
<a name="l08217"></a>08217                         { 
<a name="l08218"></a>08218                                 <span class="keywordtype">size_t</span> length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(Value.end - Value.begin); 
<a name="l08219"></a>08219  
<a name="l08220"></a>08220                                 char_t* c = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(_alloc-&gt;allocate_nothrow((length + 1) * <span class="keyword">sizeof</span>(char_t))); 
<a name="l08221"></a>08221                                 <span class="keywordflow">if</span> (!c) throw_error_oom(); 
<a name="l08222"></a>08222  
<a name="l08223"></a>08223                                 memcpy(c, Value.begin, length * <span class="keyword">sizeof</span>(char_t)); 
<a name="l08224"></a>08224                                 c[length] = 0; 
<a name="l08225"></a>08225  
<a name="l08226"></a>08226                                 <span class="keywordflow">return</span> c; 
<a name="l08227"></a>08227                         } 
<a name="l08228"></a>08228                         <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0; 
<a name="l08229"></a>08229                 } 
<a name="l08230"></a>08230  
<a name="l08231"></a>08231                 XPathAstNode* ParseFunctionHelper(ast_type_t Type0, ast_type_t Type1, <span class="keywordtype">size_t</span> argc, XPathAstNode* args[2]) 
<a name="l08232"></a>08232                 { 
<a name="l08233"></a>08233                         assert(argc &lt;= 1); 
<a name="l08234"></a>08234  
<a name="l08235"></a>08235                         <span class="keywordflow">if</span> (argc == 1 &amp;&amp; args[0]-&gt;retType() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) throw_error(<span class="stringliteral">&quot;Function has to be applied to node set&quot;</span>); 
<a name="l08236"></a>08236  
<a name="l08237"></a>08237                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(argc == 0 ? Type0 : Type1, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0]); 
<a name="l08238"></a>08238                 } 
<a name="l08239"></a>08239  
<a name="l08240"></a>08240                 XPathAstNode* ParseFunction(<span class="keyword">const</span> XPathLexerString&amp; Name, <span class="keywordtype">size_t</span> argc, XPathAstNode* args[2]) 
<a name="l08241"></a>08241                 { 
<a name="l08242"></a>08242                         <span class="keywordflow">switch</span> (Name.begin[0]) 
<a name="l08243"></a>08243                         { 
<a name="l08244"></a>08244                         <span class="keywordflow">case</span> <span class="charliteral">&#39;b&#39;</span>: 
<a name="l08245"></a>08245                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;boolean&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08246"></a>08246                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_boolean, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, args[0]); 
<a name="l08247"></a>08247                                          
<a name="l08248"></a>08248                                 <span class="keywordflow">break</span>; 
<a name="l08249"></a>08249                          
<a name="l08250"></a>08250                         <span class="keywordflow">case</span> <span class="charliteral">&#39;c&#39;</span>: 
<a name="l08251"></a>08251                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;count&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08252"></a>08252                                 { 
<a name="l08253"></a>08253                                         <span class="keywordflow">if</span> (args[0]-&gt;retType() != XPathTypeNodeSet) throw_error(<span class="stringliteral">&quot;Function has to be applied to node set&quot;</span>); 
<a name="l08254"></a>08254                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_count, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, args[0]); 
<a name="l08255"></a>08255                                 } 
<a name="l08256"></a>08256                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;contains&quot;</span>) &amp;&amp; argc == 2) 
<a name="l08257"></a>08257                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_contains, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0], args[1]); 
<a name="l08258"></a>08258                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;concat&quot;</span>) &amp;&amp; argc &gt;= 2) 
<a name="l08259"></a>08259                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_concat, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0], args[1]); 
<a name="l08260"></a>08260                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;ceiling&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08261"></a>08261                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_ceiling, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, args[0]); 
<a name="l08262"></a>08262                                          
<a name="l08263"></a>08263                                 <span class="keywordflow">break</span>; 
<a name="l08264"></a>08264                          
<a name="l08265"></a>08265                         <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>: 
<a name="l08266"></a>08266                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;false&quot;</span>) &amp;&amp; argc == 0) 
<a name="l08267"></a>08267                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_false, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>); 
<a name="l08268"></a>08268                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;floor&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08269"></a>08269                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_floor, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, args[0]); 
<a name="l08270"></a>08270                                          
<a name="l08271"></a>08271                                 <span class="keywordflow">break</span>; 
<a name="l08272"></a>08272                          
<a name="l08273"></a>08273                         <span class="keywordflow">case</span> <span class="charliteral">&#39;i&#39;</span>: 
<a name="l08274"></a>08274                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;id&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08275"></a>08275                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_id, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>, args[0]); 
<a name="l08276"></a>08276                                          
<a name="l08277"></a>08277                                 <span class="keywordflow">break</span>; 
<a name="l08278"></a>08278                          
<a name="l08279"></a>08279                         <span class="keywordflow">case</span> <span class="charliteral">&#39;l&#39;</span>: 
<a name="l08280"></a>08280                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;last&quot;</span>) &amp;&amp; argc == 0) 
<a name="l08281"></a>08281                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_last, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>); 
<a name="l08282"></a>08282                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;lang&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08283"></a>08283                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_lang, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, args[0]); 
<a name="l08284"></a>08284                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;local-Name&quot;</span>) &amp;&amp; argc &lt;= 1) 
<a name="l08285"></a>08285                                         <span class="keywordflow">return</span> ParseFunctionHelper(ast_func_local_Name_0, ast_func_local_Name_1, argc, args); 
<a name="l08286"></a>08286                          
<a name="l08287"></a>08287                                 <span class="keywordflow">break</span>; 
<a name="l08288"></a>08288                          
<a name="l08289"></a>08289                         <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>: 
<a name="l08290"></a>08290                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;Name&quot;</span>) &amp;&amp; argc &lt;= 1) 
<a name="l08291"></a>08291                                         <span class="keywordflow">return</span> ParseFunctionHelper(ast_func_Name_0, ast_func_Name_1, argc, args); 
<a name="l08292"></a>08292                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;namespace-uri&quot;</span>) &amp;&amp; argc &lt;= 1) 
<a name="l08293"></a>08293                                         <span class="keywordflow">return</span> ParseFunctionHelper(ast_func_namespace_uri_0, ast_func_namespace_uri_1, argc, args); 
<a name="l08294"></a>08294                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;normalize-space&quot;</span>) &amp;&amp; argc &lt;= 1) 
<a name="l08295"></a>08295                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(argc == 0 ? ast_func_normalize_space_0 : ast_func_normalize_space_1, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0], args[1]); 
<a name="l08296"></a>08296                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;not&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08297"></a>08297                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_not, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, args[0]); 
<a name="l08298"></a>08298                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;number&quot;</span>) &amp;&amp; argc &lt;= 1) 
<a name="l08299"></a>08299                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(argc == 0 ? ast_func_number_0 : ast_func_number_1, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, args[0]); 
<a name="l08300"></a>08300                          
<a name="l08301"></a>08301                                 <span class="keywordflow">break</span>; 
<a name="l08302"></a>08302                          
<a name="l08303"></a>08303                         <span class="keywordflow">case</span> <span class="charliteral">&#39;p&#39;</span>: 
<a name="l08304"></a>08304                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;position&quot;</span>) &amp;&amp; argc == 0) 
<a name="l08305"></a>08305                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_position, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>); 
<a name="l08306"></a>08306                                  
<a name="l08307"></a>08307                                 <span class="keywordflow">break</span>; 
<a name="l08308"></a>08308                          
<a name="l08309"></a>08309                         <span class="keywordflow">case</span> <span class="charliteral">&#39;r&#39;</span>: 
<a name="l08310"></a>08310                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;round&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08311"></a>08311                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_round, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, args[0]); 
<a name="l08312"></a>08312  
<a name="l08313"></a>08313                                 <span class="keywordflow">break</span>; 
<a name="l08314"></a>08314                          
<a name="l08315"></a>08315                         <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>: 
<a name="l08316"></a>08316                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;string&quot;</span>) &amp;&amp; argc &lt;= 1) 
<a name="l08317"></a>08317                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(argc == 0 ? ast_func_string_0 : ast_func_string_1, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0]); 
<a name="l08318"></a>08318                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;string-length&quot;</span>) &amp;&amp; argc &lt;= 1) 
<a name="l08319"></a>08319                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(argc == 0 ? ast_func_string_length_0 : ast_func_string_length_1, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0]); 
<a name="l08320"></a>08320                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;starts-with&quot;</span>) &amp;&amp; argc == 2) 
<a name="l08321"></a>08321                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_starts_with, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, args[0], args[1]); 
<a name="l08322"></a>08322                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;substring-before&quot;</span>) &amp;&amp; argc == 2) 
<a name="l08323"></a>08323                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_substring_before, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0], args[1]); 
<a name="l08324"></a>08324                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;substring-after&quot;</span>) &amp;&amp; argc == 2) 
<a name="l08325"></a>08325                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_substring_after, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0], args[1]); 
<a name="l08326"></a>08326                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;substring&quot;</span>) &amp;&amp; (argc == 2 || argc == 3)) 
<a name="l08327"></a>08327                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(argc == 2 ? ast_func_substring_2 : ast_func_substring_3, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0], args[1]); 
<a name="l08328"></a>08328                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;sum&quot;</span>) &amp;&amp; argc == 1) 
<a name="l08329"></a>08329                                 { 
<a name="l08330"></a>08330                                         <span class="keywordflow">if</span> (args[0]-&gt;retType() != XPathTypeNodeSet) throw_error(<span class="stringliteral">&quot;Function has to be applied to node set&quot;</span>); 
<a name="l08331"></a>08331                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_sum, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, args[0]); 
<a name="l08332"></a>08332                                 } 
<a name="l08333"></a>08333  
<a name="l08334"></a>08334                                 <span class="keywordflow">break</span>; 
<a name="l08335"></a>08335                          
<a name="l08336"></a>08336                         <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>: 
<a name="l08337"></a>08337                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;translate&quot;</span>) &amp;&amp; argc == 3) 
<a name="l08338"></a>08338                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_translate, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, args[0], args[1]); 
<a name="l08339"></a>08339                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;true&quot;</span>) &amp;&amp; argc == 0) 
<a name="l08340"></a>08340                                         <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_func_true, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>); 
<a name="l08341"></a>08341                                          
<a name="l08342"></a>08342                                 <span class="keywordflow">break</span>; 
<a name="l08343"></a>08343                         } 
<a name="l08344"></a>08344  
<a name="l08345"></a>08345                         throw_error(<span class="stringliteral">&quot;Unrecognized function or wrong parameter count&quot;</span>); 
<a name="l08346"></a>08346  
<a name="l08347"></a>08347                         <span class="keywordflow">return</span> 0; 
<a name="l08348"></a>08348                 } 
<a name="l08349"></a>08349  
<a name="l08350"></a>08350                 axis_t ParseAxisName(<span class="keyword">const</span> XPathLexerString&amp; Name, <span class="keywordtype">bool</span>&amp; specified) 
<a name="l08351"></a>08351                 { 
<a name="l08352"></a>08352                         specified = <span class="keyword">true</span>; 
<a name="l08353"></a>08353  
<a name="l08354"></a>08354                         <span class="keywordflow">switch</span> (Name.begin[0]) 
<a name="l08355"></a>08355                         { 
<a name="l08356"></a>08356                         <span class="keywordflow">case</span> <span class="charliteral">&#39;a&#39;</span>: 
<a name="l08357"></a>08357                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;ancestor&quot;</span>)) 
<a name="l08358"></a>08358                                         <span class="keywordflow">return</span> axis_ancestor; 
<a name="l08359"></a>08359                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;ancestor-or-self&quot;</span>)) 
<a name="l08360"></a>08360                                         <span class="keywordflow">return</span> axis_ancestor_or_self; 
<a name="l08361"></a>08361                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;GetAttribute&quot;</span>)) 
<a name="l08362"></a>08362                                         <span class="keywordflow">return</span> axis_attribute; 
<a name="l08363"></a>08363                                  
<a name="l08364"></a>08364                                 <span class="keywordflow">break</span>; 
<a name="l08365"></a>08365                          
<a name="l08366"></a>08366                         <span class="keywordflow">case</span> <span class="charliteral">&#39;c&#39;</span>: 
<a name="l08367"></a>08367                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;GetChild&quot;</span>)) 
<a name="l08368"></a>08368                                         <span class="keywordflow">return</span> axis_GetChild; 
<a name="l08369"></a>08369                                  
<a name="l08370"></a>08370                                 <span class="keywordflow">break</span>; 
<a name="l08371"></a>08371                          
<a name="l08372"></a>08372                         <span class="keywordflow">case</span> <span class="charliteral">&#39;d&#39;</span>: 
<a name="l08373"></a>08373                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;descendant&quot;</span>)) 
<a name="l08374"></a>08374                                         <span class="keywordflow">return</span> axis_descendant; 
<a name="l08375"></a>08375                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;descendant-or-self&quot;</span>)) 
<a name="l08376"></a>08376                                         <span class="keywordflow">return</span> axis_descendant_or_self; 
<a name="l08377"></a>08377                                  
<a name="l08378"></a>08378                                 <span class="keywordflow">break</span>; 
<a name="l08379"></a>08379                          
<a name="l08380"></a>08380                         <span class="keywordflow">case</span> <span class="charliteral">&#39;f&#39;</span>: 
<a name="l08381"></a>08381                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;following&quot;</span>)) 
<a name="l08382"></a>08382                                         <span class="keywordflow">return</span> axis_following; 
<a name="l08383"></a>08383                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;following-sibling&quot;</span>)) 
<a name="l08384"></a>08384                                         <span class="keywordflow">return</span> axis_following_sibling; 
<a name="l08385"></a>08385                                  
<a name="l08386"></a>08386                                 <span class="keywordflow">break</span>; 
<a name="l08387"></a>08387                          
<a name="l08388"></a>08388                         <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>: 
<a name="l08389"></a>08389                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;namespace&quot;</span>)) 
<a name="l08390"></a>08390                                         <span class="keywordflow">return</span> axis_namespace; 
<a name="l08391"></a>08391                                  
<a name="l08392"></a>08392                                 <span class="keywordflow">break</span>; 
<a name="l08393"></a>08393                          
<a name="l08394"></a>08394                         <span class="keywordflow">case</span> <span class="charliteral">&#39;p&#39;</span>: 
<a name="l08395"></a>08395                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;GetParent&quot;</span>)) 
<a name="l08396"></a>08396                                         <span class="keywordflow">return</span> axis_GetParent; 
<a name="l08397"></a>08397                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;preceding&quot;</span>)) 
<a name="l08398"></a>08398                                         <span class="keywordflow">return</span> axis_preceding; 
<a name="l08399"></a>08399                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;preceding-sibling&quot;</span>)) 
<a name="l08400"></a>08400                                         <span class="keywordflow">return</span> axis_preceding_sibling; 
<a name="l08401"></a>08401                                  
<a name="l08402"></a>08402                                 <span class="keywordflow">break</span>; 
<a name="l08403"></a>08403                          
<a name="l08404"></a>08404                         <span class="keywordflow">case</span> <span class="charliteral">&#39;s&#39;</span>: 
<a name="l08405"></a>08405                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;self&quot;</span>)) 
<a name="l08406"></a>08406                                         <span class="keywordflow">return</span> axis_self; 
<a name="l08407"></a>08407                                  
<a name="l08408"></a>08408                                 <span class="keywordflow">break</span>; 
<a name="l08409"></a>08409                         } 
<a name="l08410"></a>08410  
<a name="l08411"></a>08411                         specified = <span class="keyword">false</span>; 
<a name="l08412"></a>08412                         <span class="keywordflow">return</span> axis_GetChild; 
<a name="l08413"></a>08413                 } 
<a name="l08414"></a>08414  
<a name="l08415"></a>08415                 nodetest_t ParseNodeTest_type(<span class="keyword">const</span> XPathLexerString&amp; Name) 
<a name="l08416"></a>08416                 { 
<a name="l08417"></a>08417                         <span class="keywordflow">switch</span> (Name.begin[0]) 
<a name="l08418"></a>08418                         { 
<a name="l08419"></a>08419                         <span class="keywordflow">case</span> <span class="charliteral">&#39;c&#39;</span>: 
<a name="l08420"></a>08420                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;comment&quot;</span>)) 
<a name="l08421"></a>08421                                         <span class="keywordflow">return</span> nodetest_type_comment; 
<a name="l08422"></a>08422  
<a name="l08423"></a>08423                                 <span class="keywordflow">break</span>; 
<a name="l08424"></a>08424  
<a name="l08425"></a>08425                         <span class="keywordflow">case</span> <span class="charliteral">&#39;n&#39;</span>: 
<a name="l08426"></a>08426                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;node&quot;</span>)) 
<a name="l08427"></a>08427                                         <span class="keywordflow">return</span> nodetest_type_node; 
<a name="l08428"></a>08428  
<a name="l08429"></a>08429                                 <span class="keywordflow">break</span>; 
<a name="l08430"></a>08430  
<a name="l08431"></a>08431                         <span class="keywordflow">case</span> <span class="charliteral">&#39;p&#39;</span>: 
<a name="l08432"></a>08432                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;processing-instruction&quot;</span>)) 
<a name="l08433"></a>08433                                         <span class="keywordflow">return</span> nodetest_type_pi; 
<a name="l08434"></a>08434  
<a name="l08435"></a>08435                                 <span class="keywordflow">break</span>; 
<a name="l08436"></a>08436  
<a name="l08437"></a>08437                         <span class="keywordflow">case</span> <span class="charliteral">&#39;t&#39;</span>: 
<a name="l08438"></a>08438                                 <span class="keywordflow">if</span> (Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;text&quot;</span>)) 
<a name="l08439"></a>08439                                         <span class="keywordflow">return</span> nodetest_type_text; 
<a name="l08440"></a>08440  
<a name="l08441"></a>08441                                 <span class="keywordflow">break</span>; 
<a name="l08442"></a>08442                         } 
<a name="l08443"></a>08443  
<a name="l08444"></a>08444                         <span class="keywordflow">return</span> nodetest_none; 
<a name="l08445"></a>08445                 } 
<a name="l08446"></a>08446  
<a name="l08447"></a>08447                 <span class="comment">// PrimaryExpr ::= VariableReference | &#39;(&#39; Expr &#39;)&#39; | Literal | Number | FunctionCall </span>
<a name="l08448"></a>08448                 XPathAstNode* ParsePrimaryExpression() 
<a name="l08449"></a>08449                 { 
<a name="l08450"></a>08450                         <span class="keywordflow">switch</span> (_lexer.current()) 
<a name="l08451"></a>08451                         { 
<a name="l08452"></a>08452                         <span class="keywordflow">case</span> lex_var_ref: 
<a name="l08453"></a>08453                         { 
<a name="l08454"></a>08454                                 XPathLexerString Name = _lexer.contents(); 
<a name="l08455"></a>08455  
<a name="l08456"></a>08456                                 <span class="keywordflow">if</span> (!_variables) 
<a name="l08457"></a>08457                                         throw_error(<span class="stringliteral">&quot;Unknown variable: variable set is not provided&quot;</span>); 
<a name="l08458"></a>08458  
<a name="l08459"></a>08459                                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = GetVariable(_variables, Name.begin, Name.end); 
<a name="l08460"></a>08460  
<a name="l08461"></a>08461                                 <span class="keywordflow">if</span> (!var) 
<a name="l08462"></a>08462                                         throw_error(<span class="stringliteral">&quot;Unknown variable: variable set does not contain the given Name&quot;</span>); 
<a name="l08463"></a>08463  
<a name="l08464"></a>08464                                 _lexer.next(); 
<a name="l08465"></a>08465  
<a name="l08466"></a>08466                                 <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_variable, var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a6c2986292fe674b79ea9dbf261c4a96f" title="Get the variable type.">Type</a>(), var); 
<a name="l08467"></a>08467                         } 
<a name="l08468"></a>08468  
<a name="l08469"></a>08469                         <span class="keywordflow">case</span> lex_open_brace: 
<a name="l08470"></a>08470                         { 
<a name="l08471"></a>08471                                 _lexer.next(); 
<a name="l08472"></a>08472  
<a name="l08473"></a>08473                                 XPathAstNode* n = ParseExpression(); 
<a name="l08474"></a>08474  
<a name="l08475"></a>08475                                 <span class="keywordflow">if</span> (_lexer.current() != lex_close_brace) 
<a name="l08476"></a>08476                                         throw_error(<span class="stringliteral">&quot;Unmatched braces&quot;</span>); 
<a name="l08477"></a>08477  
<a name="l08478"></a>08478                                 _lexer.next(); 
<a name="l08479"></a>08479  
<a name="l08480"></a>08480                                 <span class="keywordflow">return</span> n; 
<a name="l08481"></a>08481                         } 
<a name="l08482"></a>08482  
<a name="l08483"></a>08483                         <span class="keywordflow">case</span> lex_quoted_string: 
<a name="l08484"></a>08484                         { 
<a name="l08485"></a>08485                                 <span class="keyword">const</span> char_t* Value = alloc_string(_lexer.contents()); 
<a name="l08486"></a>08486  
<a name="l08487"></a>08487                                 XPathAstNode* n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_string_constant, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>, Value); 
<a name="l08488"></a>08488                                 _lexer.next(); 
<a name="l08489"></a>08489  
<a name="l08490"></a>08490                                 <span class="keywordflow">return</span> n; 
<a name="l08491"></a>08491                         } 
<a name="l08492"></a>08492  
<a name="l08493"></a>08493                         <span class="keywordflow">case</span> lex_number: 
<a name="l08494"></a>08494                         { 
<a name="l08495"></a>08495                                 <span class="keywordtype">double</span> Value = 0; 
<a name="l08496"></a>08496  
<a name="l08497"></a>08497                                 <span class="keywordflow">if</span> (!convert_Stringo_number(_lexer.contents().begin, _lexer.contents().end, &amp;Value)) 
<a name="l08498"></a>08498                                         throw_error_oom(); 
<a name="l08499"></a>08499  
<a name="l08500"></a>08500                                 XPathAstNode* n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_number_constant, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, Value); 
<a name="l08501"></a>08501                                 _lexer.next(); 
<a name="l08502"></a>08502  
<a name="l08503"></a>08503                                 <span class="keywordflow">return</span> n; 
<a name="l08504"></a>08504                         } 
<a name="l08505"></a>08505  
<a name="l08506"></a>08506                         <span class="keywordflow">case</span> lex_string: 
<a name="l08507"></a>08507                         { 
<a name="l08508"></a>08508                                 XPathAstNode* args[2] = {0}; 
<a name="l08509"></a>08509                                 <span class="keywordtype">size_t</span> argc = 0; 
<a name="l08510"></a>08510                                  
<a name="l08511"></a>08511                                 XPathLexerString function = _lexer.contents(); 
<a name="l08512"></a>08512                                 _lexer.next(); 
<a name="l08513"></a>08513                                  
<a name="l08514"></a>08514                                 XPathAstNode* LastArg = 0; 
<a name="l08515"></a>08515                                  
<a name="l08516"></a>08516                                 <span class="keywordflow">if</span> (_lexer.current() != lex_open_brace) 
<a name="l08517"></a>08517                                         throw_error(<span class="stringliteral">&quot;Unrecognized function call&quot;</span>); 
<a name="l08518"></a>08518                                 _lexer.next(); 
<a name="l08519"></a>08519  
<a name="l08520"></a>08520                                 <span class="keywordflow">if</span> (_lexer.current() != lex_close_brace) 
<a name="l08521"></a>08521                                         args[argc++] = ParseExpression(); 
<a name="l08522"></a>08522  
<a name="l08523"></a>08523                                 <span class="keywordflow">while</span> (_lexer.current() != lex_close_brace) 
<a name="l08524"></a>08524                                 { 
<a name="l08525"></a>08525                                         <span class="keywordflow">if</span> (_lexer.current() != lex_comma) 
<a name="l08526"></a>08526                                                 throw_error(<span class="stringliteral">&quot;No comma between function arguments&quot;</span>); 
<a name="l08527"></a>08527                                         _lexer.next(); 
<a name="l08528"></a>08528                                          
<a name="l08529"></a>08529                                         XPathAstNode* n = ParseExpression(); 
<a name="l08530"></a>08530                                          
<a name="l08531"></a>08531                                         <span class="keywordflow">if</span> (argc &lt; 2) args[argc] = n; 
<a name="l08532"></a>08532                                         <span class="keywordflow">else</span> LastArg-&gt;SetNext(n); 
<a name="l08533"></a>08533  
<a name="l08534"></a>08534                                         argc++; 
<a name="l08535"></a>08535                                         LastArg = n; 
<a name="l08536"></a>08536                                 } 
<a name="l08537"></a>08537                                  
<a name="l08538"></a>08538                                 _lexer.next(); 
<a name="l08539"></a>08539  
<a name="l08540"></a>08540                                 <span class="keywordflow">return</span> ParseFunction(function, argc, args); 
<a name="l08541"></a>08541                         } 
<a name="l08542"></a>08542  
<a name="l08543"></a>08543                         <span class="keywordflow">default</span>: 
<a name="l08544"></a>08544                                 throw_error(<span class="stringliteral">&quot;Unrecognizable primary expression&quot;</span>); 
<a name="l08545"></a>08545  
<a name="l08546"></a>08546                                 <span class="keywordflow">return</span> 0; 
<a name="l08547"></a>08547                         } 
<a name="l08548"></a>08548                 } 
<a name="l08549"></a>08549                  
<a name="l08550"></a>08550                 <span class="comment">// FilterExpr ::= PrimaryExpr | FilterExpr Predicate </span>
<a name="l08551"></a>08551                 <span class="comment">// Predicate ::= &#39;[&#39; PredicateExpr &#39;]&#39; </span>
<a name="l08552"></a>08552                 <span class="comment">// PredicateExpr ::= Expr </span>
<a name="l08553"></a>08553                 XPathAstNode* ParseFilterExpression() 
<a name="l08554"></a>08554                 { 
<a name="l08555"></a>08555                         XPathAstNode* n = ParsePrimaryExpression(); 
<a name="l08556"></a>08556  
<a name="l08557"></a>08557                         <span class="keywordflow">while</span> (_lexer.current() == lex_open_square_brace) 
<a name="l08558"></a>08558                         { 
<a name="l08559"></a>08559                                 _lexer.next(); 
<a name="l08560"></a>08560  
<a name="l08561"></a>08561                                 XPathAstNode* expr = ParseExpression(); 
<a name="l08562"></a>08562  
<a name="l08563"></a>08563                                 <span class="keywordflow">if</span> (n-&gt;retType() != XPathTypeNodeSet) throw_error(<span class="stringliteral">&quot;Predicate has to be applied to node set&quot;</span>); 
<a name="l08564"></a>08564  
<a name="l08565"></a>08565                                 <span class="keywordtype">bool</span> posinv = expr-&gt;retType() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a> &amp;&amp; expr-&gt;is_posinv(); 
<a name="l08566"></a>08566  
<a name="l08567"></a>08567                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(posinv ? ast_filter_posinv : ast_filter, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>, n, expr); 
<a name="l08568"></a>08568  
<a name="l08569"></a>08569                                 <span class="keywordflow">if</span> (_lexer.current() != lex_close_square_brace) 
<a name="l08570"></a>08570                                         throw_error(<span class="stringliteral">&quot;Unmatched square brace&quot;</span>); 
<a name="l08571"></a>08571                          
<a name="l08572"></a>08572                                 _lexer.next(); 
<a name="l08573"></a>08573                         } 
<a name="l08574"></a>08574                          
<a name="l08575"></a>08575                         <span class="keywordflow">return</span> n; 
<a name="l08576"></a>08576                 } 
<a name="l08577"></a>08577                  
<a name="l08578"></a>08578                 <span class="comment">// Step ::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep </span>
<a name="l08579"></a>08579                 <span class="comment">// AxisSpecifier ::= AxisName &#39;::&#39; | &#39;@&#39;? </span>
<a name="l08580"></a>08580                 <span class="comment">// NodeTest ::= NameTest | NodeType &#39;(&#39; &#39;)&#39; | &#39;processing-instruction&#39; &#39;(&#39; Literal &#39;)&#39; </span>
<a name="l08581"></a>08581                 <span class="comment">// NameTest ::= &#39;*&#39; | NCName &#39;:&#39; &#39;*&#39; | QName </span>
<a name="l08582"></a>08582                 <span class="comment">// AbbreviatedStep ::= &#39;.&#39; | &#39;..&#39; </span>
<a name="l08583"></a>08583                 XPathAstNode* ParseStep(XPathAstNode* <span class="keyword">set</span>) 
<a name="l08584"></a>08584                 { 
<a name="l08585"></a>08585                         <span class="keywordflow">if</span> (<span class="keyword">set</span> &amp;&amp; set-&gt;retType() != XPathTypeNodeSet) 
<a name="l08586"></a>08586                                 throw_error(<span class="stringliteral">&quot;Step has to be applied to node set&quot;</span>); 
<a name="l08587"></a>08587  
<a name="l08588"></a>08588                         <span class="keywordtype">bool</span> axis_specified = <span class="keyword">false</span>; 
<a name="l08589"></a>08589                         axis_t axis = axis_GetChild; <span class="comment">// implied GetChild axis </span>
<a name="l08590"></a>08590  
<a name="l08591"></a>08591                         <span class="keywordflow">if</span> (_lexer.current() == lex_axis_attribute) 
<a name="l08592"></a>08592                         { 
<a name="l08593"></a>08593                                 axis = axis_attribute; 
<a name="l08594"></a>08594                                 axis_specified = <span class="keyword">true</span>; 
<a name="l08595"></a>08595                                  
<a name="l08596"></a>08596                                 _lexer.next(); 
<a name="l08597"></a>08597                         } 
<a name="l08598"></a>08598                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_lexer.current() == lex_dot) 
<a name="l08599"></a>08599                         { 
<a name="l08600"></a>08600                                 _lexer.next(); 
<a name="l08601"></a>08601                                  
<a name="l08602"></a>08602                                 <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step, <span class="keyword">set</span>, axis_self, nodetest_type_node, 0); 
<a name="l08603"></a>08603                         } 
<a name="l08604"></a>08604                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_lexer.current() == lex_double_dot) 
<a name="l08605"></a>08605                         { 
<a name="l08606"></a>08606                                 _lexer.next(); 
<a name="l08607"></a>08607                                  
<a name="l08608"></a>08608                                 <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step, <span class="keyword">set</span>, axis_GetParent, nodetest_type_node, 0); 
<a name="l08609"></a>08609                         } 
<a name="l08610"></a>08610                  
<a name="l08611"></a>08611                         nodetest_t nt_type = nodetest_none; 
<a name="l08612"></a>08612                         XPathLexerString nt_Name; 
<a name="l08613"></a>08613                          
<a name="l08614"></a>08614                         <span class="keywordflow">if</span> (_lexer.current() == lex_string) 
<a name="l08615"></a>08615                         { 
<a name="l08616"></a>08616                                 <span class="comment">// node Name test </span>
<a name="l08617"></a>08617                                 nt_Name = _lexer.contents(); 
<a name="l08618"></a>08618                                 _lexer.next(); 
<a name="l08619"></a>08619  
<a name="l08620"></a>08620                                 <span class="comment">// was it an axis Name? </span>
<a name="l08621"></a>08621                                 <span class="keywordflow">if</span> (_lexer.current() == lex_double_colon) 
<a name="l08622"></a>08622                                 { 
<a name="l08623"></a>08623                                         <span class="comment">// parse axis Name </span>
<a name="l08624"></a>08624                                         <span class="keywordflow">if</span> (axis_specified) throw_error(<span class="stringliteral">&quot;Two axis specifiers in one step&quot;</span>); 
<a name="l08625"></a>08625  
<a name="l08626"></a>08626                                         axis = ParseAxisName(nt_Name, axis_specified); 
<a name="l08627"></a>08627  
<a name="l08628"></a>08628                                         <span class="keywordflow">if</span> (!axis_specified) throw_error(<span class="stringliteral">&quot;Unknown axis&quot;</span>); 
<a name="l08629"></a>08629  
<a name="l08630"></a>08630                                         <span class="comment">// read actual node test </span>
<a name="l08631"></a>08631                                         _lexer.next(); 
<a name="l08632"></a>08632  
<a name="l08633"></a>08633                                         <span class="keywordflow">if</span> (_lexer.current() == lex_multiply) 
<a name="l08634"></a>08634                                         { 
<a name="l08635"></a>08635                                                 nt_type = nodetest_all; 
<a name="l08636"></a>08636                                                 nt_Name = XPathLexerString(); 
<a name="l08637"></a>08637                                                 _lexer.next(); 
<a name="l08638"></a>08638                                         } 
<a name="l08639"></a>08639                                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_lexer.current() == lex_string) 
<a name="l08640"></a>08640                                         { 
<a name="l08641"></a>08641                                                 nt_Name = _lexer.contents(); 
<a name="l08642"></a>08642                                                 _lexer.next(); 
<a name="l08643"></a>08643                                         } 
<a name="l08644"></a>08644                                         <span class="keywordflow">else</span> throw_error(<span class="stringliteral">&quot;Unrecognized node test&quot;</span>); 
<a name="l08645"></a>08645                                 } 
<a name="l08646"></a>08646                                  
<a name="l08647"></a>08647                                 <span class="keywordflow">if</span> (nt_type == nodetest_none) 
<a name="l08648"></a>08648                                 { 
<a name="l08649"></a>08649                                         <span class="comment">// node Type test or processing-instruction </span>
<a name="l08650"></a>08650                                         <span class="keywordflow">if</span> (_lexer.current() == lex_open_brace) 
<a name="l08651"></a>08651                                         { 
<a name="l08652"></a>08652                                                 _lexer.next(); 
<a name="l08653"></a>08653                                                  
<a name="l08654"></a>08654                                                 <span class="keywordflow">if</span> (_lexer.current() == lex_close_brace) 
<a name="l08655"></a>08655                                                 { 
<a name="l08656"></a>08656                                                         _lexer.next(); 
<a name="l08657"></a>08657  
<a name="l08658"></a>08658                                                         nt_type = ParseNodeTest_type(nt_Name); 
<a name="l08659"></a>08659  
<a name="l08660"></a>08660                                                         <span class="keywordflow">if</span> (nt_type == nodetest_none) throw_error(<span class="stringliteral">&quot;Unrecognized node Type&quot;</span>); 
<a name="l08661"></a>08661                                                          
<a name="l08662"></a>08662                                                         nt_Name = XPathLexerString(); 
<a name="l08663"></a>08663                                                 } 
<a name="l08664"></a>08664                                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nt_Name == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;processing-instruction&quot;</span>)) 
<a name="l08665"></a>08665                                                 { 
<a name="l08666"></a>08666                                                         <span class="keywordflow">if</span> (_lexer.current() != lex_quoted_string) 
<a name="l08667"></a>08667                                                                 throw_error(<span class="stringliteral">&quot;Only literals are allowed as arguments to processing-instruction()&quot;</span>); 
<a name="l08668"></a>08668                                                  
<a name="l08669"></a>08669                                                         nt_type = nodetest_pi; 
<a name="l08670"></a>08670                                                         nt_Name = _lexer.contents(); 
<a name="l08671"></a>08671                                                         _lexer.next(); 
<a name="l08672"></a>08672                                                          
<a name="l08673"></a>08673                                                         <span class="keywordflow">if</span> (_lexer.current() != lex_close_brace) 
<a name="l08674"></a>08674                                                                 throw_error(<span class="stringliteral">&quot;Unmatched brace near processing-instruction()&quot;</span>); 
<a name="l08675"></a>08675                                                         _lexer.next(); 
<a name="l08676"></a>08676                                                 } 
<a name="l08677"></a>08677                                                 <span class="keywordflow">else</span> 
<a name="l08678"></a>08678                                                         throw_error(<span class="stringliteral">&quot;Unmatched brace near node Type test&quot;</span>); 
<a name="l08679"></a>08679  
<a name="l08680"></a>08680                                         } 
<a name="l08681"></a>08681                                         <span class="comment">// QName or NCName:* </span>
<a name="l08682"></a>08682                                         <span class="keywordflow">else</span> 
<a name="l08683"></a>08683                                         { 
<a name="l08684"></a>08684                                                 <span class="keywordflow">if</span> (nt_Name.end - nt_Name.begin &gt; 2 &amp;&amp; nt_Name.end[-2] == <span class="charliteral">&#39;:&#39;</span> &amp;&amp; nt_Name.end[-1] == <span class="charliteral">&#39;*&#39;</span>) <span class="comment">// NCName:* </span>
<a name="l08685"></a>08685                                                 { 
<a name="l08686"></a>08686                                                         nt_Name.end--; <span class="comment">// erase * </span>
<a name="l08687"></a>08687                                                          
<a name="l08688"></a>08688                                                         nt_type = nodetest_all_in_namespace; 
<a name="l08689"></a>08689                                                 } 
<a name="l08690"></a>08690                                                 <span class="keywordflow">else</span> nt_type = nodetest_Name; 
<a name="l08691"></a>08691                                         } 
<a name="l08692"></a>08692                                 } 
<a name="l08693"></a>08693                         } 
<a name="l08694"></a>08694                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_lexer.current() == lex_multiply) 
<a name="l08695"></a>08695                         { 
<a name="l08696"></a>08696                                 nt_type = nodetest_all; 
<a name="l08697"></a>08697                                 _lexer.next(); 
<a name="l08698"></a>08698                         } 
<a name="l08699"></a>08699                         <span class="keywordflow">else</span> throw_error(<span class="stringliteral">&quot;Unrecognized node test&quot;</span>); 
<a name="l08700"></a>08700                          
<a name="l08701"></a>08701                         XPathAstNode* n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step, <span class="keyword">set</span>, axis, nt_type, alloc_string(nt_Name)); 
<a name="l08702"></a>08702                          
<a name="l08703"></a>08703                         XPathAstNode* last = 0; 
<a name="l08704"></a>08704                          
<a name="l08705"></a>08705                         <span class="keywordflow">while</span> (_lexer.current() == lex_open_square_brace) 
<a name="l08706"></a>08706                         { 
<a name="l08707"></a>08707                                 _lexer.next(); 
<a name="l08708"></a>08708                                  
<a name="l08709"></a>08709                                 XPathAstNode* expr = ParseExpression(); 
<a name="l08710"></a>08710  
<a name="l08711"></a>08711                                 XPathAstNode* pred = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_predicate, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>, expr); 
<a name="l08712"></a>08712                                  
<a name="l08713"></a>08713                                 <span class="keywordflow">if</span> (_lexer.current() != lex_close_square_brace) 
<a name="l08714"></a>08714                                         throw_error(<span class="stringliteral">&quot;Unmatched square brace&quot;</span>); 
<a name="l08715"></a>08715                                 _lexer.next(); 
<a name="l08716"></a>08716                                  
<a name="l08717"></a>08717                                 <span class="keywordflow">if</span> (last) last-&gt;SetNext(pred); 
<a name="l08718"></a>08718                                 <span class="keywordflow">else</span> n-&gt;SetRight(pred); 
<a name="l08719"></a>08719                                  
<a name="l08720"></a>08720                                 last = pred; 
<a name="l08721"></a>08721                         } 
<a name="l08722"></a>08722                          
<a name="l08723"></a>08723                         <span class="keywordflow">return</span> n; 
<a name="l08724"></a>08724                 } 
<a name="l08725"></a>08725                  
<a name="l08726"></a>08726                 <span class="comment">// RelativeLocationPath ::= Step | RelativeLocationPath &#39;/&#39; Step | RelativeLocationPath &#39;//&#39; Step </span>
<a name="l08727"></a>08727                 XPathAstNode* ParseRelativeLocation_Path(XPathAstNode* <span class="keyword">set</span>) 
<a name="l08728"></a>08728                 { 
<a name="l08729"></a>08729                         XPathAstNode* n = ParseStep(<span class="keyword">set</span>); 
<a name="l08730"></a>08730                          
<a name="l08731"></a>08731                         <span class="keywordflow">while</span> (_lexer.current() == lex_slash || _lexer.current() == lex_double_slash) 
<a name="l08732"></a>08732                         { 
<a name="l08733"></a>08733                                 lexeme_t l = _lexer.current(); 
<a name="l08734"></a>08734                                 _lexer.next(); 
<a name="l08735"></a>08735  
<a name="l08736"></a>08736                                 <span class="keywordflow">if</span> (l == lex_double_slash) 
<a name="l08737"></a>08737                                         n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0); 
<a name="l08738"></a>08738                                  
<a name="l08739"></a>08739                                 n = ParseStep(n); 
<a name="l08740"></a>08740                         } 
<a name="l08741"></a>08741                          
<a name="l08742"></a>08742                         <span class="keywordflow">return</span> n; 
<a name="l08743"></a>08743                 } 
<a name="l08744"></a>08744                  
<a name="l08745"></a>08745                 <span class="comment">// LocationPath ::= RelativeLocationPath | AbsoluteLocationPath </span>
<a name="l08746"></a>08746                 <span class="comment">// AbsoluteLocationPath ::= &#39;/&#39; RelativeLocationPath? | &#39;//&#39; RelativeLocationPath </span>
<a name="l08747"></a>08747                 XPathAstNode* ParseLocationPath() 
<a name="l08748"></a>08748                 { 
<a name="l08749"></a>08749                         <span class="keywordflow">if</span> (_lexer.current() == lex_slash) 
<a name="l08750"></a>08750                         { 
<a name="l08751"></a>08751                                 _lexer.next(); 
<a name="l08752"></a>08752                                  
<a name="l08753"></a>08753                                 XPathAstNode* n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step_GetRoot, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>); 
<a name="l08754"></a>08754  
<a name="l08755"></a>08755                                 <span class="comment">// relative location Path can start from axis_attribute, dot, double_dot, multiply and string lexemes; any other lexeme means standalone GetRoot Path </span>
<a name="l08756"></a>08756                                 lexeme_t l = _lexer.current(); 
<a name="l08757"></a>08757  
<a name="l08758"></a>08758                                 <span class="keywordflow">if</span> (l == lex_string || l == lex_axis_attribute || l == lex_dot || l == lex_double_dot || l == lex_multiply) 
<a name="l08759"></a>08759                                         <span class="keywordflow">return</span> ParseRelativeLocation_Path(n); 
<a name="l08760"></a>08760                                 <span class="keywordflow">else</span> 
<a name="l08761"></a>08761                                         <span class="keywordflow">return</span> n; 
<a name="l08762"></a>08762                         } 
<a name="l08763"></a>08763                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_lexer.current() == lex_double_slash) 
<a name="l08764"></a>08764                         { 
<a name="l08765"></a>08765                                 _lexer.next(); 
<a name="l08766"></a>08766                                  
<a name="l08767"></a>08767                                 XPathAstNode* n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step_GetRoot, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>); 
<a name="l08768"></a>08768                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0); 
<a name="l08769"></a>08769                                  
<a name="l08770"></a>08770                                 <span class="keywordflow">return</span> ParseRelativeLocation_Path(n); 
<a name="l08771"></a>08771                         } 
<a name="l08772"></a>08772  
<a name="l08773"></a>08773                         <span class="comment">// else clause moved outside of if because of bogus warning &#39;control may reach end of non-void function being inlined&#39; in gcc 4.0.1 </span>
<a name="l08774"></a>08774                         <span class="keywordflow">return</span> ParseRelativeLocation_Path(0); 
<a name="l08775"></a>08775                 } 
<a name="l08776"></a>08776                  
<a name="l08777"></a>08777                 <span class="comment">// PathExpr ::= LocationPath </span>
<a name="l08778"></a>08778                 <span class="comment">//                              | FilterExpr </span>
<a name="l08779"></a>08779                 <span class="comment">//                              | FilterExpr &#39;/&#39; RelativeLocationPath </span>
<a name="l08780"></a>08780                 <span class="comment">//                              | FilterExpr &#39;//&#39; RelativeLocationPath </span>
<a name="l08781"></a>08781                 XPathAstNode* ParsePathExpression() 
<a name="l08782"></a>08782                 { 
<a name="l08783"></a>08783                         <span class="comment">// Clarification. </span>
<a name="l08784"></a>08784                         <span class="comment">// PathExpr begins with either LocationPath or FilterExpr. </span>
<a name="l08785"></a>08785                         <span class="comment">// FilterExpr begins with PrimaryExpr </span>
<a name="l08786"></a>08786                         <span class="comment">// PrimaryExpr begins with &#39;$&#39; in case of it being a variable reference, </span>
<a name="l08787"></a>08787                         <span class="comment">// &#39;(&#39; in case of it being an expression, string literal, number constant or </span>
<a name="l08788"></a>08788                         <span class="comment">// function call. </span>
<a name="l08789"></a>08789  
<a name="l08790"></a>08790                         <span class="keywordflow">if</span> (_lexer.current() == lex_var_ref || _lexer.current() == lex_open_brace ||  
<a name="l08791"></a>08791                                 _lexer.current() == lex_quoted_string || _lexer.current() == lex_number || 
<a name="l08792"></a>08792                                 _lexer.current() == lex_string) 
<a name="l08793"></a>08793                         { 
<a name="l08794"></a>08794                                 <span class="keywordflow">if</span> (_lexer.current() == lex_string) 
<a name="l08795"></a>08795                                 { 
<a name="l08796"></a>08796                                         <span class="comment">// This is either a function call, or not - if not, we shall proceed with location Path </span>
<a name="l08797"></a>08797                                         <span class="keyword">const</span> char_t* state = _lexer.state(); 
<a name="l08798"></a>08798                                          
<a name="l08799"></a>08799                                         <span class="keywordflow">while</span> (IS_CHARTYPE(*state, ct_space)) ++state; 
<a name="l08800"></a>08800                                          
<a name="l08801"></a>08801                                         <span class="keywordflow">if</span> (*state != <span class="charliteral">&#39;(&#39;</span>) <span class="keywordflow">return</span> ParseLocationPath(); 
<a name="l08802"></a>08802  
<a name="l08803"></a>08803                                         <span class="comment">// This looks like a function call; however this still can be a node-test. Check it. </span>
<a name="l08804"></a>08804                                         <span class="keywordflow">if</span> (ParseNodeTest_type(_lexer.contents()) != nodetest_none) <span class="keywordflow">return</span> ParseLocationPath(); 
<a name="l08805"></a>08805                                 } 
<a name="l08806"></a>08806                                  
<a name="l08807"></a>08807                                 XPathAstNode* n = ParseFilterExpression(); 
<a name="l08808"></a>08808  
<a name="l08809"></a>08809                                 <span class="keywordflow">if</span> (_lexer.current() == lex_slash || _lexer.current() == lex_double_slash) 
<a name="l08810"></a>08810                                 { 
<a name="l08811"></a>08811                                         lexeme_t l = _lexer.current(); 
<a name="l08812"></a>08812                                         _lexer.next(); 
<a name="l08813"></a>08813                                          
<a name="l08814"></a>08814                                         <span class="keywordflow">if</span> (l == lex_double_slash) 
<a name="l08815"></a>08815                                         { 
<a name="l08816"></a>08816                                                 <span class="keywordflow">if</span> (n-&gt;retType() != XPathTypeNodeSet) throw_error(<span class="stringliteral">&quot;Step has to be applied to node set&quot;</span>); 
<a name="l08817"></a>08817  
<a name="l08818"></a>08818                                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_step, n, axis_descendant_or_self, nodetest_type_node, 0); 
<a name="l08819"></a>08819                                         } 
<a name="l08820"></a>08820          
<a name="l08821"></a>08821                                         <span class="comment">// select from location Path </span>
<a name="l08822"></a>08822                                         <span class="keywordflow">return</span> ParseRelativeLocation_Path(n); 
<a name="l08823"></a>08823                                 } 
<a name="l08824"></a>08824  
<a name="l08825"></a>08825                                 <span class="keywordflow">return</span> n; 
<a name="l08826"></a>08826                         } 
<a name="l08827"></a>08827                         <span class="keywordflow">else</span> <span class="keywordflow">return</span> ParseLocationPath(); 
<a name="l08828"></a>08828                 } 
<a name="l08829"></a>08829  
<a name="l08830"></a>08830                 <span class="comment">// UnionExpr ::= PathExpr | UnionExpr &#39;|&#39; PathExpr </span>
<a name="l08831"></a>08831                 XPathAstNode* ParseUnionExpression() 
<a name="l08832"></a>08832                 { 
<a name="l08833"></a>08833                         XPathAstNode* n = ParsePathExpression(); 
<a name="l08834"></a>08834  
<a name="l08835"></a>08835                         <span class="keywordflow">while</span> (_lexer.current() == lex_union) 
<a name="l08836"></a>08836                         { 
<a name="l08837"></a>08837                                 _lexer.next(); 
<a name="l08838"></a>08838  
<a name="l08839"></a>08839                                 XPathAstNode* expr = ParseUnionExpression(); 
<a name="l08840"></a>08840  
<a name="l08841"></a>08841                                 <span class="keywordflow">if</span> (n-&gt;retType() != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a> || expr-&gt;retType() != XPathTypeNodeSet) 
<a name="l08842"></a>08842                                         throw_error(<span class="stringliteral">&quot;Union operator has to be applied to node sets&quot;</span>); 
<a name="l08843"></a>08843  
<a name="l08844"></a>08844                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_op_union, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>, n, expr); 
<a name="l08845"></a>08845                         } 
<a name="l08846"></a>08846  
<a name="l08847"></a>08847                         <span class="keywordflow">return</span> n; 
<a name="l08848"></a>08848                 } 
<a name="l08849"></a>08849  
<a name="l08850"></a>08850                 <span class="comment">// UnaryExpr ::= UnionExpr | &#39;-&#39; UnaryExpr </span>
<a name="l08851"></a>08851                 XPathAstNode* ParseUnaryExpression() 
<a name="l08852"></a>08852                 { 
<a name="l08853"></a>08853                         <span class="keywordflow">if</span> (_lexer.current() == lex_minus) 
<a name="l08854"></a>08854                         { 
<a name="l08855"></a>08855                                 _lexer.next(); 
<a name="l08856"></a>08856  
<a name="l08857"></a>08857                                 XPathAstNode* expr = ParseUnaryExpression(); 
<a name="l08858"></a>08858  
<a name="l08859"></a>08859                                 <span class="keywordflow">return</span> <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_op_negate, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, expr); 
<a name="l08860"></a>08860                         } 
<a name="l08861"></a>08861                         <span class="keywordflow">else</span> <span class="keywordflow">return</span> ParseUnionExpression(); 
<a name="l08862"></a>08862                 } 
<a name="l08863"></a>08863                  
<a name="l08864"></a>08864                 <span class="comment">// MultiplicativeExpr ::= UnaryExpr </span>
<a name="l08865"></a>08865                 <span class="comment">//                                                | MultiplicativeExpr &#39;*&#39; UnaryExpr </span>
<a name="l08866"></a>08866                 <span class="comment">//                                                | MultiplicativeExpr &#39;div&#39; UnaryExpr </span>
<a name="l08867"></a>08867                 <span class="comment">//                                                | MultiplicativeExpr &#39;mod&#39; UnaryExpr </span>
<a name="l08868"></a>08868                 XPathAstNode* ParseMultiplicativeExpression() 
<a name="l08869"></a>08869                 { 
<a name="l08870"></a>08870                         XPathAstNode* n = ParseUnaryExpression(); 
<a name="l08871"></a>08871  
<a name="l08872"></a>08872                         <span class="keywordflow">while</span> (_lexer.current() == lex_multiply || (_lexer.current() == lex_string &amp;&amp; 
<a name="l08873"></a>08873                                    (_lexer.contents() == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;mod&quot;</span>) || _lexer.contents() == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;div&quot;</span>)))) 
<a name="l08874"></a>08874                         { 
<a name="l08875"></a>08875                                 ast_type_t op = _lexer.current() == lex_multiply ? ast_op_multiply : 
<a name="l08876"></a>08876                                         _lexer.contents().begin[0] == <span class="charliteral">&#39;d&#39;</span> ? ast_op_divide : ast_op_mod; 
<a name="l08877"></a>08877                                 _lexer.next(); 
<a name="l08878"></a>08878  
<a name="l08879"></a>08879                                 XPathAstNode* expr = ParseUnaryExpression(); 
<a name="l08880"></a>08880  
<a name="l08881"></a>08881                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(op, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, n, expr); 
<a name="l08882"></a>08882                         } 
<a name="l08883"></a>08883  
<a name="l08884"></a>08884                         <span class="keywordflow">return</span> n; 
<a name="l08885"></a>08885                 } 
<a name="l08886"></a>08886  
<a name="l08887"></a>08887                 <span class="comment">// AdditiveExpr ::= MultiplicativeExpr </span>
<a name="l08888"></a>08888                 <span class="comment">//                                      | AdditiveExpr &#39;+&#39; MultiplicativeExpr </span>
<a name="l08889"></a>08889                 <span class="comment">//                                      | AdditiveExpr &#39;-&#39; MultiplicativeExpr </span>
<a name="l08890"></a>08890                 XPathAstNode* ParseAdditiveExpression() 
<a name="l08891"></a>08891                 { 
<a name="l08892"></a>08892                         XPathAstNode* n = ParseMultiplicativeExpression(); 
<a name="l08893"></a>08893  
<a name="l08894"></a>08894                         <span class="keywordflow">while</span> (_lexer.current() == lex_plus || _lexer.current() == lex_minus) 
<a name="l08895"></a>08895                         { 
<a name="l08896"></a>08896                                 lexeme_t l = _lexer.current(); 
<a name="l08897"></a>08897  
<a name="l08898"></a>08898                                 _lexer.next(); 
<a name="l08899"></a>08899  
<a name="l08900"></a>08900                                 XPathAstNode* expr = ParseMultiplicativeExpression(); 
<a name="l08901"></a>08901  
<a name="l08902"></a>08902                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(l == lex_plus ? ast_op_add : ast_op_subtract, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>, n, expr); 
<a name="l08903"></a>08903                         } 
<a name="l08904"></a>08904  
<a name="l08905"></a>08905                         <span class="keywordflow">return</span> n; 
<a name="l08906"></a>08906                 } 
<a name="l08907"></a>08907  
<a name="l08908"></a>08908                 <span class="comment">// RelationalExpr ::= AdditiveExpr </span>
<a name="l08909"></a>08909                 <span class="comment">//                                        | RelationalExpr &#39;&lt;&#39; AdditiveExpr </span>
<a name="l08910"></a>08910                 <span class="comment">//                                        | RelationalExpr &#39;&gt;&#39; AdditiveExpr </span>
<a name="l08911"></a>08911                 <span class="comment">//                                        | RelationalExpr &#39;&lt;=&#39; AdditiveExpr </span>
<a name="l08912"></a>08912                 <span class="comment">//                                        | RelationalExpr &#39;&gt;=&#39; AdditiveExpr </span>
<a name="l08913"></a>08913                 XPathAstNode* ParseRelationalExpression() 
<a name="l08914"></a>08914                 { 
<a name="l08915"></a>08915                         XPathAstNode* n = ParseAdditiveExpression(); 
<a name="l08916"></a>08916  
<a name="l08917"></a>08917                         <span class="keywordflow">while</span> (_lexer.current() == lex_less || _lexer.current() == lex_less_or_equal ||  
<a name="l08918"></a>08918                                    _lexer.current() == lex_greater || _lexer.current() == lex_greater_or_equal) 
<a name="l08919"></a>08919                         { 
<a name="l08920"></a>08920                                 lexeme_t l = _lexer.current(); 
<a name="l08921"></a>08921                                 _lexer.next(); 
<a name="l08922"></a>08922  
<a name="l08923"></a>08923                                 XPathAstNode* expr = ParseAdditiveExpression(); 
<a name="l08924"></a>08924  
<a name="l08925"></a>08925                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(l == lex_less ? ast_op_less : l == lex_greater ? ast_op_greater : 
<a name="l08926"></a>08926                                                                 l == lex_less_or_equal ? ast_op_less_or_equal : ast_op_greater_or_equal, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, n, expr); 
<a name="l08927"></a>08927                         } 
<a name="l08928"></a>08928  
<a name="l08929"></a>08929                         <span class="keywordflow">return</span> n; 
<a name="l08930"></a>08930                 } 
<a name="l08931"></a>08931                  
<a name="l08932"></a>08932                 <span class="comment">// EqualityExpr ::= RelationalExpr </span>
<a name="l08933"></a>08933                 <span class="comment">//                                      | EqualityExpr &#39;=&#39; RelationalExpr </span>
<a name="l08934"></a>08934                 <span class="comment">//                                      | EqualityExpr &#39;!=&#39; RelationalExpr </span>
<a name="l08935"></a>08935                 XPathAstNode* ParseEqualityExpression() 
<a name="l08936"></a>08936                 { 
<a name="l08937"></a>08937                         XPathAstNode* n = ParseRelationalExpression(); 
<a name="l08938"></a>08938  
<a name="l08939"></a>08939                         <span class="keywordflow">while</span> (_lexer.current() == lex_equal || _lexer.current() == lex_not_equal) 
<a name="l08940"></a>08940                         { 
<a name="l08941"></a>08941                                 lexeme_t l = _lexer.current(); 
<a name="l08942"></a>08942  
<a name="l08943"></a>08943                                 _lexer.next(); 
<a name="l08944"></a>08944  
<a name="l08945"></a>08945                                 XPathAstNode* expr = ParseRelationalExpression(); 
<a name="l08946"></a>08946  
<a name="l08947"></a>08947                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(l == lex_equal ? ast_op_equal : ast_op_not_equal, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, n, expr); 
<a name="l08948"></a>08948                         } 
<a name="l08949"></a>08949  
<a name="l08950"></a>08950                         <span class="keywordflow">return</span> n; 
<a name="l08951"></a>08951                 } 
<a name="l08952"></a>08952                  
<a name="l08953"></a>08953                 <span class="comment">// AndExpr ::= EqualityExpr | AndExpr &#39;and&#39; EqualityExpr </span>
<a name="l08954"></a>08954                 XPathAstNode* ParseAndExpression() 
<a name="l08955"></a>08955                 { 
<a name="l08956"></a>08956                         XPathAstNode* n = ParseEqualityExpression(); 
<a name="l08957"></a>08957  
<a name="l08958"></a>08958                         <span class="keywordflow">while</span> (_lexer.current() == lex_string &amp;&amp; _lexer.contents() == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;and&quot;</span>)) 
<a name="l08959"></a>08959                         { 
<a name="l08960"></a>08960                                 _lexer.next(); 
<a name="l08961"></a>08961  
<a name="l08962"></a>08962                                 XPathAstNode* expr = ParseEqualityExpression(); 
<a name="l08963"></a>08963  
<a name="l08964"></a>08964                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_op_and, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, n, expr); 
<a name="l08965"></a>08965                         } 
<a name="l08966"></a>08966  
<a name="l08967"></a>08967                         <span class="keywordflow">return</span> n; 
<a name="l08968"></a>08968                 } 
<a name="l08969"></a>08969  
<a name="l08970"></a>08970                 <span class="comment">// OrExpr ::= AndExpr | OrExpr &#39;or&#39; AndExpr </span>
<a name="l08971"></a>08971                 XPathAstNode* ParseOrExpression() 
<a name="l08972"></a>08972                 { 
<a name="l08973"></a>08973                         XPathAstNode* n = ParseAndExpression(); 
<a name="l08974"></a>08974  
<a name="l08975"></a>08975                         <span class="keywordflow">while</span> (_lexer.current() == lex_string &amp;&amp; _lexer.contents() == <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;or&quot;</span>)) 
<a name="l08976"></a>08976                         { 
<a name="l08977"></a>08977                                 _lexer.next(); 
<a name="l08978"></a>08978  
<a name="l08979"></a>08979                                 XPathAstNode* expr = ParseAndExpression(); 
<a name="l08980"></a>08980  
<a name="l08981"></a>08981                                 n = <span class="keyword">new</span> (alloc_node()) XPathAstNode(ast_op_or, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>, n, expr); 
<a name="l08982"></a>08982                         } 
<a name="l08983"></a>08983  
<a name="l08984"></a>08984                         <span class="keywordflow">return</span> n; 
<a name="l08985"></a>08985                 } 
<a name="l08986"></a>08986                  
<a name="l08987"></a>08987                 <span class="comment">// Expr ::= OrExpr </span>
<a name="l08988"></a>08988                 XPathAstNode* ParseExpression() 
<a name="l08989"></a>08989                 { 
<a name="l08990"></a>08990                         <span class="keywordflow">return</span> ParseOrExpression(); 
<a name="l08991"></a>08991                 } 
<a name="l08992"></a>08992  
<a name="l08993"></a>08993                 XPathParser(<span class="keyword">const</span> char_t* query, <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html" title="A set of XPath variables.">XPathVariableSet</a>* variables, XPathAllocator* alloc, <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html" title="XPath parsing result.">XPathParseResult</a>* Result): _alloc(alloc), _lexer(query), _query(query), _variables(variables), _Result(Result) 
<a name="l08994"></a>08994                 { 
<a name="l08995"></a>08995                 } 
<a name="l08996"></a>08996  
<a name="l08997"></a>08997                 XPathAstNode* parse() 
<a name="l08998"></a>08998                 { 
<a name="l08999"></a>08999                         XPathAstNode* Result = ParseExpression(); 
<a name="l09000"></a>09000                          
<a name="l09001"></a>09001                         <span class="keywordflow">if</span> (_lexer.current() != lex_eof) 
<a name="l09002"></a>09002                         { 
<a name="l09003"></a>09003                                 <span class="comment">// there are still unparsed tokens left, error </span>
<a name="l09004"></a>09004                                 throw_error(<span class="stringliteral">&quot;Incorrect query&quot;</span>); 
<a name="l09005"></a>09005                         } 
<a name="l09006"></a>09006                          
<a name="l09007"></a>09007                         <span class="keywordflow">return</span> Result; 
<a name="l09008"></a>09008                 } 
<a name="l09009"></a>09009  
<a name="l09010"></a>09010                 <span class="keyword">static</span> XPathAstNode* parse(<span class="keyword">const</span> char_t* query, <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html" title="A set of XPath variables.">XPathVariableSet</a>* variables, XPathAllocator* alloc, <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html" title="XPath parsing result.">XPathParseResult</a>* Result) 
<a name="l09011"></a>09011                 { 
<a name="l09012"></a>09012                         XPathParser parser(query, variables, alloc, Result); 
<a name="l09013"></a>09013  
<a name="l09014"></a>09014 <span class="preprocessor">                #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09015"></a>09015 <span class="preprocessor"></span>                        <span class="keywordtype">int</span> error = setjmp(parser._error_handler); 
<a name="l09016"></a>09016  
<a name="l09017"></a>09017                         <span class="keywordflow">return</span> (error == 0) ? parser.parse() : 0; 
<a name="l09018"></a>09018 <span class="preprocessor">                #else </span>
<a name="l09019"></a>09019 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> parser.parse(); 
<a name="l09020"></a>09020 <span class="preprocessor">                #endif </span>
<a name="l09021"></a>09021 <span class="preprocessor"></span>                } 
<a name="l09022"></a>09022         }; 
<a name="l09023"></a>09023  
<a name="l09024"></a>09024         <span class="keyword">struct </span>XPathQueryImpl 
<a name="l09025"></a>09025         { 
<a name="l09026"></a>09026                 <span class="keyword">static</span> XPathQueryImpl* create() 
<a name="l09027"></a>09027                 { 
<a name="l09028"></a>09028                         <span class="keywordtype">void</span>* memory = global_allocate(<span class="keyword">sizeof</span>(XPathQueryImpl)); 
<a name="l09029"></a>09029  
<a name="l09030"></a>09030                         <span class="keywordflow">return</span> <span class="keyword">new</span> (memory) XPathQueryImpl(); 
<a name="l09031"></a>09031                 } 
<a name="l09032"></a>09032  
<a name="l09033"></a>09033                 <span class="keyword">static</span> <span class="keywordtype">void</span> destroy(<span class="keywordtype">void</span>* ptr) 
<a name="l09034"></a>09034                 { 
<a name="l09035"></a>09035                         <span class="keywordflow">if</span> (!ptr) <span class="keywordflow">return</span>; 
<a name="l09036"></a>09036                          
<a name="l09037"></a>09037                         <span class="comment">// free all allocated pages </span>
<a name="l09038"></a>09038                         <span class="keyword">static_cast&lt;</span>XPathQueryImpl*<span class="keyword">&gt;</span>(ptr)-&gt;alloc.release(); 
<a name="l09039"></a>09039  
<a name="l09040"></a>09040                         <span class="comment">// free allocator memory (with the first page) </span>
<a name="l09041"></a>09041                         global_deallocate(ptr); 
<a name="l09042"></a>09042                 } 
<a name="l09043"></a>09043  
<a name="l09044"></a>09044                 XPathQueryImpl(): GetRoot(0), alloc(&amp;block) 
<a name="l09045"></a>09045                 { 
<a name="l09046"></a>09046                         block.next = 0; 
<a name="l09047"></a>09047                 } 
<a name="l09048"></a>09048  
<a name="l09049"></a>09049                 XPathAstNode* GetRoot; 
<a name="l09050"></a>09050                 XPathAllocator alloc; 
<a name="l09051"></a>09051                 XPathMemoryBlock block; 
<a name="l09052"></a>09052         }; 
<a name="l09053"></a>09053  
<a name="l09054"></a>09054         XPathString EvaluateString_impl(XPathQueryImpl* impl, <span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n, XPathStackData&amp; sd) 
<a name="l09055"></a>09055         { 
<a name="l09056"></a>09056                 <span class="keywordflow">if</span> (!impl) <span class="keywordflow">return</span> XPathString(); 
<a name="l09057"></a>09057  
<a name="l09058"></a>09058 <span class="preprocessor">        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09059"></a>09059 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (setjmp(sd.error_handler)) <span class="keywordflow">return</span> XPathString(); 
<a name="l09060"></a>09060 <span class="preprocessor">        #endif </span>
<a name="l09061"></a>09061 <span class="preprocessor"></span> 
<a name="l09062"></a>09062                 XPathContext c(n, 1, 1); 
<a name="l09063"></a>09063  
<a name="l09064"></a>09064                 <span class="keywordflow">return</span> impl-&gt;GetRoot-&gt;eval_string(c, sd.stack); 
<a name="l09065"></a>09065         } 
<a name="l09066"></a>09066 } 
<a name="l09067"></a>09067  
<a name="l09068"></a>09068 
<a name="l09069"></a>09069 <span class="keyword">namespace </span>phys
<a name="l09070"></a>09070 { <span class="keyword">namespace </span>xml
<a name="l09071"></a>09071 { 
<a name="l09072"></a>09072 <span class="preprocessor">#ifndef XML_NO_EXCEPTIONS </span>
<a name="l09073"></a><a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html#a39d6511632945aa46b63e80f5364e959">09073</a> <span class="preprocessor"></span>        <a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html#a39d6511632945aa46b63e80f5364e959" title="Construct exception from parse Result.">XPathException::XPathException</a>(<span class="keyword">const</span> <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html" title="XPath parsing result.">XPathParseResult</a>&amp; Result): _Result(Result) 
<a name="l09074"></a>09074         { 
<a name="l09075"></a>09075                 assert(Result.<a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a5e601cfd490fd3d1ed4bcdfb36d9d920" title="Error message (0 if no error).">error</a>); 
<a name="l09076"></a>09076         } 
<a name="l09077"></a>09077          
<a name="l09078"></a><a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html#ab16319369cd5f40990300b1b22b8f6cb">09078</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html#ab16319369cd5f40990300b1b22b8f6cb" title="Get error message.">XPathException::what</a>() <span class="keyword">const</span> throw() 
<a name="l09079"></a>09079         { 
<a name="l09080"></a>09080                 <span class="keywordflow">return</span> _Result.<a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a5e601cfd490fd3d1ed4bcdfb36d9d920" title="Error message (0 if no error).">error</a>; 
<a name="l09081"></a>09081         } 
<a name="l09082"></a>09082  
<a name="l09083"></a><a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html#a5410a12f705cbbc006175c08872b5749">09083</a>         <span class="keyword">const</span> <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html" title="XPath parsing result.">XPathParseResult</a>&amp; <a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html#a5410a12f705cbbc006175c08872b5749" title="Get parse Result.">XPathException::Result</a>()<span class="keyword"> const </span>
<a name="l09084"></a>09084 <span class="keyword">        </span>{ 
<a name="l09085"></a>09085                 <span class="keywordflow">return</span> _Result; 
<a name="l09086"></a>09086         } 
<a name="l09087"></a>09087 <span class="preprocessor">#endif </span>
<a name="l09088"></a>09088 <span class="preprocessor"></span>         
<a name="l09089"></a>09089         XPathNode::XPathNode() 
<a name="l09090"></a>09090         { 
<a name="l09091"></a>09091         } 
<a name="l09092"></a>09092                  
<a name="l09093"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ab70dcfefef2107eca2d1932faada475e">09093</a>         XPathNode::XPathNode(<span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; node): _node(node) 
<a name="l09094"></a>09094         { 
<a name="l09095"></a>09095         } 
<a name="l09096"></a>09096                  
<a name="l09097"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a3f9446596022b6e0ab77afc2748c98e0">09097</a>         XPathNode::XPathNode(<span class="keyword">const</span> <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a>&amp; GetAttribute, <span class="keyword">const</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>&amp; GetParent): _node(GetAttribute ? GetParent : <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>()), _attribute(GetAttribute) 
<a name="l09098"></a>09098         { 
<a name="l09099"></a>09099         } 
<a name="l09100"></a>09100  
<a name="l09101"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35">09101</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ad34ea7db6cabdfe92656b7d033dbbf35" title="Get the xml::Node this is referencing.">XPathNode::GetNode</a>()<span class="keyword"> const </span>
<a name="l09102"></a>09102 <span class="keyword">        </span>{ 
<a name="l09103"></a>09103                 <span class="keywordflow">return</span> _attribute ? <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a>() : _node; 
<a name="l09104"></a>09104         } 
<a name="l09105"></a>09105                  
<a name="l09106"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c">09106</a>         <a class="code" href="../../da/ddf/classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">Attribute</a> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a258785388868adf9fa53437cac7cd41c" title="Get the xml::Attribute this is referencing.">XPathNode::GetAttribute</a>()<span class="keyword"> const </span>
<a name="l09107"></a>09107 <span class="keyword">        </span>{ 
<a name="l09108"></a>09108                 <span class="keywordflow">return</span> _attribute; 
<a name="l09109"></a>09109         } 
<a name="l09110"></a>09110          
<a name="l09111"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa">09111</a>         <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">Node</a> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a10d6dce64d14cf3d39bb952efd4ca8aa" title="Get the parent of the xml::Node or xml::Attribute this refers to.">XPathNode::GetParent</a>()<span class="keyword"> const </span>
<a name="l09112"></a>09112 <span class="keyword">        </span>{ 
<a name="l09113"></a>09113                 <span class="keywordflow">return</span> _attribute ? _node : _node.<a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a80f32b90ed88ef442f99dc7a5f29ca0d" title="Attempt to retrieve the parent of this Node.">GetParent</a>(); 
<a name="l09114"></a>09114         } 
<a name="l09115"></a>09115  
<a name="l09116"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a0d11818941c2e31671c5d0cd8f1ce9f9">09116</a>         XPathNode::operator XPathNode::unspecified_bool_type()<span class="keyword"> const </span>
<a name="l09117"></a>09117 <span class="keyword">        </span>{ 
<a name="l09118"></a>09118                 <span class="keywordflow">return</span> (_node || _attribute) ? &amp;XPathNode::_node : 0; 
<a name="l09119"></a>09119         } 
<a name="l09120"></a>09120          
<a name="l09121"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a3c596b9cacb6265df6acffb91b9a7484">09121</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a3c596b9cacb6265df6acffb91b9a7484" title="Logical not operator, used a workaround for borland compiler.">XPathNode::operator!</a>()<span class="keyword"> const </span>
<a name="l09122"></a>09122 <span class="keyword">        </span>{ 
<a name="l09123"></a>09123                 <span class="keywordflow">return</span> !(_node || _attribute); 
<a name="l09124"></a>09124         } 
<a name="l09125"></a>09125  
<a name="l09126"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ab13702ded8707602871596e4f34e8302">09126</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#ab13702ded8707602871596e4f34e8302" title="Called when comparing two XPathNode instances for equality.">XPathNode::operator==</a>(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n)<span class="keyword"> const </span>
<a name="l09127"></a>09127 <span class="keyword">        </span>{ 
<a name="l09128"></a>09128                 <span class="keywordflow">return</span> _node == n._node &amp;&amp; _attribute == n._attribute; 
<a name="l09129"></a>09129         } 
<a name="l09130"></a>09130          
<a name="l09131"></a><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a121ba0e04b6619f45c5392374f2dc98d">09131</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html#a121ba0e04b6619f45c5392374f2dc98d" title="Called when comparing two XPathNode instances for inequality.">XPathNode::operator!=</a>(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n)<span class="keyword"> const </span>
<a name="l09132"></a>09132 <span class="keyword">        </span>{ 
<a name="l09133"></a>09133                 <span class="keywordflow">return</span> _node != n._node || _attribute != n._attribute; 
<a name="l09134"></a>09134         } 
<a name="l09135"></a>09135  
<a name="l09136"></a>09136 <span class="preprocessor">#ifdef __BORLANDC__ </span>
<a name="l09137"></a>09137 <span class="preprocessor"></span>        <span class="keywordtype">bool</span> operator&amp;&amp;(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; lhs, <span class="keywordtype">bool</span> rhs) 
<a name="l09138"></a>09138         { 
<a name="l09139"></a>09139                 <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)lhs &amp;&amp; rhs; 
<a name="l09140"></a>09140         } 
<a name="l09141"></a>09141  
<a name="l09142"></a>09142         <span class="keywordtype">bool</span> operator||(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; lhs, <span class="keywordtype">bool</span> rhs) 
<a name="l09143"></a>09143         { 
<a name="l09144"></a>09144                 <span class="keywordflow">return</span> (<span class="keywordtype">bool</span>)lhs || rhs; 
<a name="l09145"></a>09145         } 
<a name="l09146"></a>09146 <span class="preprocessor">#endif </span>
<a name="l09147"></a>09147 <span class="preprocessor"></span> 
<a name="l09148"></a>09148         <span class="keywordtype">void</span> XPathNodeSet::_assign(const_iterator begin, const_iterator end) 
<a name="l09149"></a>09149         { 
<a name="l09150"></a>09150                 assert(begin &lt;= end); 
<a name="l09151"></a>09151  
<a name="l09152"></a>09152                 <span class="keywordtype">size_t</span> size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(end - begin); 
<a name="l09153"></a>09153  
<a name="l09154"></a>09154                 <span class="keywordflow">if</span> (size &lt;= 1) 
<a name="l09155"></a>09155                 { 
<a name="l09156"></a>09156                         <span class="comment">// deallocate old buffer </span>
<a name="l09157"></a>09157                         <span class="keywordflow">if</span> (_begin != &amp;_storage) global_deallocate(_begin); 
<a name="l09158"></a>09158  
<a name="l09159"></a>09159                         <span class="comment">// use internal buffer </span>
<a name="l09160"></a>09160                         <span class="keywordflow">if</span> (begin != end) _storage = *begin; 
<a name="l09161"></a>09161  
<a name="l09162"></a>09162                         _begin = &amp;_storage; 
<a name="l09163"></a>09163                         _end = &amp;_storage + size; 
<a name="l09164"></a>09164                 } 
<a name="l09165"></a>09165                 <span class="keywordflow">else</span> 
<a name="l09166"></a>09166                 { 
<a name="l09167"></a>09167                         <span class="comment">// make heap copy </span>
<a name="l09168"></a>09168                         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>* storage = <span class="keyword">static_cast&lt;</span><a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>*<span class="keyword">&gt;</span>(global_allocate(size * <span class="keyword">sizeof</span>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>))); 
<a name="l09169"></a>09169  
<a name="l09170"></a>09170                         <span class="keywordflow">if</span> (!storage) 
<a name="l09171"></a>09171                         { 
<a name="l09172"></a>09172 <span class="preprocessor">                        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09173"></a>09173 <span class="preprocessor"></span>                                <span class="keywordflow">return</span>; 
<a name="l09174"></a>09174 <span class="preprocessor">                        #else </span>
<a name="l09175"></a>09175 <span class="preprocessor"></span>                                <span class="keywordflow">throw</span> std::bad_alloc(); 
<a name="l09176"></a>09176 <span class="preprocessor">                        #endif </span>
<a name="l09177"></a>09177 <span class="preprocessor"></span>                        } 
<a name="l09178"></a>09178  
<a name="l09179"></a>09179                         memcpy(storage, begin, size * <span class="keyword">sizeof</span>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>)); 
<a name="l09180"></a>09180                          
<a name="l09181"></a>09181                         <span class="comment">// deallocate old buffer </span>
<a name="l09182"></a>09182                         <span class="keywordflow">if</span> (_begin != &amp;_storage) global_deallocate(_begin); 
<a name="l09183"></a>09183  
<a name="l09184"></a>09184                         <span class="comment">// finalize </span>
<a name="l09185"></a>09185                         _begin = storage; 
<a name="l09186"></a>09186                         _end = storage + size; 
<a name="l09187"></a>09187                 } 
<a name="l09188"></a>09188         } 
<a name="l09189"></a>09189  
<a name="l09190"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a24b0e325cd45548e3f63bd37557eab93">09190</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a24b0e325cd45548e3f63bd37557eab93" title="Default constructor. Constructs empty set.">XPathNodeSet::XPathNodeSet</a>(): _type(TypeUnsorted), _begin(&amp;_storage), _end(&amp;_storage) 
<a name="l09191"></a>09191         { 
<a name="l09192"></a>09192         } 
<a name="l09193"></a>09193  
<a name="l09194"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a4184ec067744749dd044f7740d2dc6e3">09194</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a24b0e325cd45548e3f63bd37557eab93" title="Default constructor. Constructs empty set.">XPathNodeSet::XPathNodeSet</a>(<a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">const_iterator</a> begin, <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">const_iterator</a> end, <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">CollectionType</a> Type): _type(Type), _begin(&amp;_storage), _end(&amp;_storage) 
<a name="l09195"></a>09195         { 
<a name="l09196"></a>09196                 _assign(begin, end); 
<a name="l09197"></a>09197         } 
<a name="l09198"></a>09198  
<a name="l09199"></a>09199         XPathNodeSet::~XPathNodeSet() 
<a name="l09200"></a>09200         { 
<a name="l09201"></a>09201                 <span class="keywordflow">if</span> (_begin != &amp;_storage) global_deallocate(_begin); 
<a name="l09202"></a>09202         } 
<a name="l09203"></a>09203                  
<a name="l09204"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#af4ac7af973425828bd66dc278887695c">09204</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a24b0e325cd45548e3f63bd37557eab93" title="Default constructor. Constructs empty set.">XPathNodeSet::XPathNodeSet</a>(<span class="keyword">const</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>&amp; ns): _type(ns._type), _begin(&amp;_storage), _end(&amp;_storage) 
<a name="l09205"></a>09205         { 
<a name="l09206"></a>09206                 _assign(ns._begin, ns._end); 
<a name="l09207"></a>09207         } 
<a name="l09208"></a>09208          
<a name="l09209"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a10ab6b5b2188af5d7db6930473fa0190">09209</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>&amp; <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a10ab6b5b2188af5d7db6930473fa0190" title="Assignment Operator.">XPathNodeSet::operator=</a>(<span class="keyword">const</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>&amp; ns) 
<a name="l09210"></a>09210         { 
<a name="l09211"></a>09211                 <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;ns) <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l09212"></a>09212                  
<a name="l09213"></a>09213                 _type = ns._type; 
<a name="l09214"></a>09214                 _assign(ns._begin, ns._end); 
<a name="l09215"></a>09215  
<a name="l09216"></a>09216                 <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l09217"></a>09217         } 
<a name="l09218"></a>09218  
<a name="l09219"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a95c90708290e045ef04425a71b2ddf25">09219</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ab178d39e119369702541033c067a995c" title="The different ways a collection may or may not be ordered.">XPathNodeSet::CollectionType</a> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a95c90708290e045ef04425a71b2ddf25" title="Get collection Type.">XPathNodeSet::Type</a>()<span class="keyword"> const </span>
<a name="l09220"></a>09220 <span class="keyword">        </span>{ 
<a name="l09221"></a>09221                 <span class="keywordflow">return</span> _type; 
<a name="l09222"></a>09222         } 
<a name="l09223"></a>09223                  
<a name="l09224"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a306178fdaf66f2d0ccefd617f7afc7f3">09224</a>         <span class="keywordtype">size_t</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a306178fdaf66f2d0ccefd617f7afc7f3" title="Get collection size.">XPathNodeSet::size</a>()<span class="keyword"> const </span>
<a name="l09225"></a>09225 <span class="keyword">        </span>{ 
<a name="l09226"></a>09226                 <span class="keywordflow">return</span> _end - _begin; 
<a name="l09227"></a>09227         } 
<a name="l09228"></a>09228                  
<a name="l09229"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a91fa85dbf474c51bc7a9df1baf38d43a">09229</a>         <span class="keywordtype">bool</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a91fa85dbf474c51bc7a9df1baf38d43a" title="Check if collection is empty.">XPathNodeSet::Empty</a>()<span class="keyword"> const </span>
<a name="l09230"></a>09230 <span class="keyword">        </span>{ 
<a name="l09231"></a>09231                 <span class="keywordflow">return</span> _begin == _end; 
<a name="l09232"></a>09232         } 
<a name="l09233"></a>09233                  
<a name="l09234"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ad620a6cd79b94ae644d10a10d0519029">09234</a>         <span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ad620a6cd79b94ae644d10a10d0519029" title="Indexing operator.">XPathNodeSet::operator[]</a>(<span class="keywordtype">size_t</span> index)<span class="keyword"> const </span>
<a name="l09235"></a>09235 <span class="keyword">        </span>{ 
<a name="l09236"></a>09236                 assert(index &lt; <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a306178fdaf66f2d0ccefd617f7afc7f3" title="Get collection size.">size</a>()); 
<a name="l09237"></a>09237                 <span class="keywordflow">return</span> _begin[index]; 
<a name="l09238"></a>09238         } 
<a name="l09239"></a>09239  
<a name="l09240"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a887d84cf19f5d2155ab9153bc02e8d1e">09240</a>         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNodeSet::const_iterator</a> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a887d84cf19f5d2155ab9153bc02e8d1e" title="Get Beginning iterator.">XPathNodeSet::begin</a>()<span class="keyword"> const </span>
<a name="l09241"></a>09241 <span class="keyword">        </span>{ 
<a name="l09242"></a>09242                 <span class="keywordflow">return</span> _begin; 
<a name="l09243"></a>09243         } 
<a name="l09244"></a>09244                  
<a name="l09245"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a1b5507aca9b87bbaa0c698f293ae8fd4">09245</a>         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNodeSet::const_iterator</a> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a1b5507aca9b87bbaa0c698f293ae8fd4" title="Get Ending iterator.">XPathNodeSet::end</a>()<span class="keyword"> const </span>
<a name="l09246"></a>09246 <span class="keyword">        </span>{ 
<a name="l09247"></a>09247                 <span class="keywordflow">return</span> _end; 
<a name="l09248"></a>09248         } 
<a name="l09249"></a>09249          
<a name="l09250"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a509bb7206dfc0fa79887c7ab7c5999db">09250</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a509bb7206dfc0fa79887c7ab7c5999db" title="Sort the collection in ascending/descending order by document order.">XPathNodeSet::sort</a>(<span class="keywordtype">bool</span> reverse) 
<a name="l09251"></a>09251         { 
<a name="l09252"></a>09252                 _type = XPathSort(_begin, _end, _type, reverse); 
<a name="l09253"></a>09253         } 
<a name="l09254"></a>09254  
<a name="l09255"></a><a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ae38baf21701ebbe42af3abfb6976d100">09255</a>         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ae38baf21701ebbe42af3abfb6976d100" title="Get first node in the collection by document order.">XPathNodeSet::first</a>()<span class="keyword"> const </span>
<a name="l09256"></a>09256 <span class="keyword">        </span>{ 
<a name="l09257"></a>09257                 <span class="keywordflow">return</span> XPathFirst(_begin, _end, _type); 
<a name="l09258"></a>09258         } 
<a name="l09259"></a>09259  
<a name="l09260"></a><a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#ac41f4db5604d32679933be58bc74aa23">09260</a>         <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#ac41f4db5604d32679933be58bc74aa23" title="Default constructor, initializes object to failed state.">XPathParseResult::XPathParseResult</a>(): error(<span class="stringliteral">&quot;Internal error&quot;</span>), Offset(0) 
<a name="l09261"></a>09261         { 
<a name="l09262"></a>09262         } 
<a name="l09263"></a>09263  
<a name="l09264"></a><a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a8dddf12100a6c40f9abcd8c0b7b37816">09264</a>         <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a8dddf12100a6c40f9abcd8c0b7b37816" title="Cast to bool operator.">XPathParseResult::operator bool</a>()<span class="keyword"> const </span>
<a name="l09265"></a>09265 <span class="keyword">        </span>{ 
<a name="l09266"></a>09266                 <span class="keywordflow">return</span> error == 0; 
<a name="l09267"></a>09267         } 
<a name="l09268"></a><a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a722e220fa91f9bc48357ade351b8b038">09268</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a722e220fa91f9bc48357ade351b8b038" title="Creates a text description of the error situation, if any exists.">XPathParseResult::Description</a>()<span class="keyword"> const </span>
<a name="l09269"></a>09269 <span class="keyword">        </span>{ 
<a name="l09270"></a>09270                 <span class="keywordflow">return</span> error ? error : <span class="stringliteral">&quot;No error&quot;</span>; 
<a name="l09271"></a>09271         } 
<a name="l09272"></a>09272  
<a name="l09273"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8dd3bc4deb8cebad6796ffa10bbbcb21">09273</a>         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8dd3bc4deb8cebad6796ffa10bbbcb21" title="Protected Default constructor.">XPathVariable::XPathVariable</a>() 
<a name="l09274"></a>09274         { 
<a name="l09275"></a>09275         } 
<a name="l09276"></a>09276  
<a name="l09277"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#af51c0a3362e130e30df85068ab95de63">09277</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#af51c0a3362e130e30df85068ab95de63" title="Retrieve the name of this variable.">XPathVariable::Name</a>()<span class="keyword"> const </span>
<a name="l09278"></a>09278 <span class="keyword">        </span>{ 
<a name="l09279"></a>09279                 <span class="keywordflow">switch</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a>) 
<a name="l09280"></a>09280                 { 
<a name="l09281"></a>09281                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>: 
<a name="l09282"></a>09282                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>XPathVariableNodeSet*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Name; 
<a name="l09283"></a>09283  
<a name="l09284"></a>09284                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>: 
<a name="l09285"></a>09285                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>XPathVariableNumber*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Name; 
<a name="l09286"></a>09286  
<a name="l09287"></a>09287                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>: 
<a name="l09288"></a>09288                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>XPathVariableString*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Name; 
<a name="l09289"></a>09289  
<a name="l09290"></a>09290                 <span class="keywordflow">case</span> <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>: 
<a name="l09291"></a>09291                         <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>XPathVariableBoolean*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Name; 
<a name="l09292"></a>09292  
<a name="l09293"></a>09293                 <span class="keywordflow">default</span>: 
<a name="l09294"></a>09294                         assert(!<span class="stringliteral">&quot;Invalid variable Type&quot;</span>); 
<a name="l09295"></a>09295                         <span class="keywordflow">return</span> 0; 
<a name="l09296"></a>09296                 } 
<a name="l09297"></a>09297         } 
<a name="l09298"></a>09298  
<a name="l09299"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a6c2986292fe674b79ea9dbf261c4a96f">09299</a>         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a6c2986292fe674b79ea9dbf261c4a96f" title="Get the variable type.">XPathVariable::Type</a>()<span class="keyword"> const </span>
<a name="l09300"></a>09300 <span class="keyword">        </span>{ 
<a name="l09301"></a>09301                 <span class="keywordflow">return</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a>; 
<a name="l09302"></a>09302         } 
<a name="l09303"></a>09303  
<a name="l09304"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#ade5e5da86817afc6fafd64d4f9b21e9c">09304</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#ade5e5da86817afc6fafd64d4f9b21e9c" title="Get this as a bool.">XPathVariable::GetBoolean</a>()<span class="keyword"> const </span>
<a name="l09305"></a>09305 <span class="keyword">        </span>{ 
<a name="l09306"></a>09306                 <span class="keywordflow">return</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>) ? <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>XPathVariableBoolean*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Value : <span class="keyword">false</span>; 
<a name="l09307"></a>09307         } 
<a name="l09308"></a>09308  
<a name="l09309"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#ac3798fc142b781c48bd694f1cdd386c4">09309</a>         <span class="keywordtype">double</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#ac3798fc142b781c48bd694f1cdd386c4" title="Get this as a double.">XPathVariable::GetNumber</a>()<span class="keyword"> const </span>
<a name="l09310"></a>09310 <span class="keyword">        </span>{ 
<a name="l09311"></a>09311                 <span class="keywordflow">return</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>) ? <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>XPathVariableNumber*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Value : gen_nan(); 
<a name="l09312"></a>09312         } 
<a name="l09313"></a>09313  
<a name="l09314"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a5354bcb8e5c2ffa6ececcf259049338b">09314</a>         <span class="keyword">const</span> char_t* <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a5354bcb8e5c2ffa6ececcf259049338b" title="Get this as a c-string.">XPathVariable::GetString</a>()<span class="keyword"> const </span>
<a name="l09315"></a>09315 <span class="keyword">        </span>{ 
<a name="l09316"></a>09316                 <span class="keyword">const</span> char_t* Value = (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> == XPathTypeString) ? static_cast&lt;const XPathVariableString*&gt;(<span class="keyword">this</span>)-&gt;Value : 0; 
<a name="l09317"></a>09317                 <span class="keywordflow">return</span> Value ? Value : <a class="code" href="../../d0/d62/xml_8h.html#a98c5d1b3853d93a60bcc08bd92b1a71b" title="Used before the inclusion of string literal in the Pugi XML code, to allow the determination of the c...">XML_TEXT</a>(<span class="stringliteral">&quot;&quot;</span>); 
<a name="l09318"></a>09318         } 
<a name="l09319"></a>09319  
<a name="l09320"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a773036e3c3c3db0af26fa662782f7e56">09320</a>         <span class="keyword">const</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>&amp; <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a773036e3c3c3db0af26fa662782f7e56" title="Get this as a XPathNodeSet.">XPathVariable::GetNodeSet</a>()<span class="keyword"> const </span>
<a name="l09321"></a>09321 <span class="keyword">        </span>{ 
<a name="l09322"></a>09322                 <span class="keywordflow">return</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> == <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) ? <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>XPathVariableNodeSet*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Value : dummy_NodeSet; 
<a name="l09323"></a>09323         } 
<a name="l09324"></a>09324  
<a name="l09325"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3">09325</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">XPathVariable::Set</a>(<span class="keywordtype">bool</span> Value) 
<a name="l09326"></a>09326         { 
<a name="l09327"></a>09327                 <span class="keywordflow">if</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l09328"></a>09328  
<a name="l09329"></a>09329                 <span class="keyword">static_cast&lt;</span>XPathVariableBoolean*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Value = Value; 
<a name="l09330"></a>09330                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l09331"></a>09331         } 
<a name="l09332"></a>09332  
<a name="l09333"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#abb5f6da9b731d770e1a34ee9981b22be">09333</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">XPathVariable::Set</a>(<span class="keywordtype">double</span> Value) 
<a name="l09334"></a>09334         { 
<a name="l09335"></a>09335                 <span class="keywordflow">if</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l09336"></a>09336  
<a name="l09337"></a>09337                 <span class="keyword">static_cast&lt;</span>XPathVariableNumber*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Value = Value; 
<a name="l09338"></a>09338                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l09339"></a>09339         } 
<a name="l09340"></a>09340  
<a name="l09341"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#acf825ac8cd7dd20fc6f1c9fd7bb997fe">09341</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">XPathVariable::Set</a>(<span class="keyword">const</span> char_t* Value) 
<a name="l09342"></a>09342         { 
<a name="l09343"></a>09343                 <span class="keywordflow">if</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l09344"></a>09344  
<a name="l09345"></a>09345                 XPathVariableString* var = <span class="keyword">static_cast&lt;</span>XPathVariableString*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); 
<a name="l09346"></a>09346  
<a name="l09347"></a>09347                 <span class="comment">// duplicate string </span>
<a name="l09348"></a>09348                 <span class="keywordtype">size_t</span> size = (strlength(Value) + 1) * <span class="keyword">sizeof</span>(char_t); 
<a name="l09349"></a>09349  
<a name="l09350"></a>09350                 char_t* copy = <span class="keyword">static_cast&lt;</span>char_t*<span class="keyword">&gt;</span>(global_allocate(size)); 
<a name="l09351"></a>09351                 <span class="keywordflow">if</span> (!copy) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l09352"></a>09352  
<a name="l09353"></a>09353                 memcpy(copy, Value, size); 
<a name="l09354"></a>09354  
<a name="l09355"></a>09355                 <span class="comment">// replace old string </span>
<a name="l09356"></a>09356                 <span class="keywordflow">if</span> (var-&gt;Value) global_deallocate(var-&gt;Value); 
<a name="l09357"></a>09357                 var-&gt;Value = copy; 
<a name="l09358"></a>09358  
<a name="l09359"></a>09359                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l09360"></a>09360         } 
<a name="l09361"></a>09361  
<a name="l09362"></a><a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a121079abb73e70ade34f4e69181e5694">09362</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">XPathVariable::Set</a>(<span class="keyword">const</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>&amp; Value) 
<a name="l09363"></a>09363         { 
<a name="l09364"></a>09364                 <span class="keywordflow">if</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> != <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l09365"></a>09365  
<a name="l09366"></a>09366                 <span class="keyword">static_cast&lt;</span>XPathVariableNodeSet*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;Value = Value; 
<a name="l09367"></a>09367                 <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l09368"></a>09368         } 
<a name="l09369"></a>09369  
<a name="l09370"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a34733feeb7720d30c2a752f6f9cd6858">09370</a>         <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a34733feeb7720d30c2a752f6f9cd6858" title="Default Constructor, Blanks any XPathVariable it contains.">XPathVariableSet::XPathVariableSet</a>() 
<a name="l09371"></a>09371         { 
<a name="l09372"></a>09372                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <span class="keyword">sizeof</span>(_data) / <span class="keyword">sizeof</span>(_data[0]); ++i) _data[i] = 0; 
<a name="l09373"></a>09373         } 
<a name="l09374"></a>09374  
<a name="l09375"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#af9ac0b922e9399a30ee81a59eb44e464">09375</a>         <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#af9ac0b922e9399a30ee81a59eb44e464" title="Default Deconstructor, Deletes any XPathVariable it contains.">XPathVariableSet::~XPathVariableSet</a>() 
<a name="l09376"></a>09376         { 
<a name="l09377"></a>09377                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <span class="keyword">sizeof</span>(_data) / <span class="keyword">sizeof</span>(_data[0]); ++i) 
<a name="l09378"></a>09378                 { 
<a name="l09379"></a>09379                         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = _data[i]; 
<a name="l09380"></a>09380  
<a name="l09381"></a>09381                         <span class="keywordflow">while</span> (var) 
<a name="l09382"></a>09382                         { 
<a name="l09383"></a>09383                                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* next = var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#abe57b58f8b6d2622d5e1ae93bc5361a3" title="The next variable in the variable set. I think, and I am not certain, that this is a circularly linke...">_next</a>; 
<a name="l09384"></a>09384  
<a name="l09385"></a>09385                                 delete_XPathVariable(var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a>, var); 
<a name="l09386"></a>09386  
<a name="l09387"></a>09387                                 var = next; 
<a name="l09388"></a>09388                         } 
<a name="l09389"></a>09389                 } 
<a name="l09390"></a>09390         } 
<a name="l09391"></a>09391  
<a name="l09392"></a>09392         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* XPathVariableSet::find(<span class="keyword">const</span> char_t* Name)<span class="keyword"> const </span>
<a name="l09393"></a>09393 <span class="keyword">        </span>{ 
<a name="l09394"></a>09394                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> hash_size = <span class="keyword">sizeof</span>(_data) / <span class="keyword">sizeof</span>(_data[0]); 
<a name="l09395"></a>09395                 <span class="keywordtype">size_t</span> hash = hash_string(Name) % hash_size; 
<a name="l09396"></a>09396  
<a name="l09397"></a>09397                 <span class="comment">// look for existing variable </span>
<a name="l09398"></a>09398                 <span class="keywordflow">for</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = _data[hash]; var; var = var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#abe57b58f8b6d2622d5e1ae93bc5361a3" title="The next variable in the variable set. I think, and I am not certain, that this is a circularly linke...">_next</a>) 
<a name="l09399"></a>09399                         <span class="keywordflow">if</span> (strequal(var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#af51c0a3362e130e30df85068ab95de63" title="Retrieve the name of this variable.">Name</a>(), Name)) 
<a name="l09400"></a>09400                                 <span class="keywordflow">return</span> var; 
<a name="l09401"></a>09401  
<a name="l09402"></a>09402                 <span class="keywordflow">return</span> 0; 
<a name="l09403"></a>09403         } 
<a name="l09404"></a>09404  
<a name="l09405"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a26c9bb8f7aa3aaedfcdcdca2e1822deb">09405</a>         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a26c9bb8f7aa3aaedfcdcdca2e1822deb" title="Add a new variable or get the existing one, if the Types match.">XPathVariableSet::Add</a>(<span class="keyword">const</span> char_t* Name, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> Type) 
<a name="l09406"></a>09406         { 
<a name="l09407"></a>09407                 <span class="keyword">const</span> <span class="keywordtype">size_t</span> hash_size = <span class="keyword">sizeof</span>(_data) / <span class="keyword">sizeof</span>(_data[0]); 
<a name="l09408"></a>09408                 <span class="keywordtype">size_t</span> hash = hash_string(Name) % hash_size; 
<a name="l09409"></a>09409  
<a name="l09410"></a>09410                 <span class="comment">// look for existing variable </span>
<a name="l09411"></a>09411                 <span class="keywordflow">for</span> (<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = _data[hash]; var; var = var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#abe57b58f8b6d2622d5e1ae93bc5361a3" title="The next variable in the variable set. I think, and I am not certain, that this is a circularly linke...">_next</a>) 
<a name="l09412"></a>09412                         <span class="keywordflow">if</span> (strequal(var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#af51c0a3362e130e30df85068ab95de63" title="Retrieve the name of this variable.">Name</a>(), Name)) 
<a name="l09413"></a>09413                                 <span class="keywordflow">return</span> var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a6c2986292fe674b79ea9dbf261c4a96f" title="Get the variable type.">Type</a>() == Type ? var : 0; 
<a name="l09414"></a>09414  
<a name="l09415"></a>09415                 <span class="comment">// add new variable </span>
<a name="l09416"></a>09416                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* Result = new_XPathVariable(Type, Name); 
<a name="l09417"></a>09417  
<a name="l09418"></a>09418                 <span class="keywordflow">if</span> (Result) 
<a name="l09419"></a>09419                 { 
<a name="l09420"></a>09420                         Result-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#a8841d47677912f4b88743928cf931eac" title="What kind of data does this variable store.">_type</a> = Type; 
<a name="l09421"></a>09421                         Result-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#abe57b58f8b6d2622d5e1ae93bc5361a3" title="The next variable in the variable set. I think, and I am not certain, that this is a circularly linke...">_next</a> = _data[hash]; 
<a name="l09422"></a>09422  
<a name="l09423"></a>09423                         _data[hash] = Result; 
<a name="l09424"></a>09424                 } 
<a name="l09425"></a>09425  
<a name="l09426"></a>09426                 <span class="keywordflow">return</span> Result; 
<a name="l09427"></a>09427         } 
<a name="l09428"></a>09428  
<a name="l09429"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a7095efef6fc3978479fb8b6f203c6f4c">09429</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a7095efef6fc3978479fb8b6f203c6f4c" title="Set contained variable Value; no Type conversion is performed.">XPathVariableSet::Set</a>(<span class="keyword">const</span> char_t* Name, <span class="keywordtype">bool</span> Value) 
<a name="l09430"></a>09430         { 
<a name="l09431"></a>09431                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a26c9bb8f7aa3aaedfcdcdca2e1822deb" title="Add a new variable or get the existing one, if the Types match.">Add</a>(Name, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da7d21654ec17f33027de173dd47aa9092" title="A Boolean value.">XPathTypeBoolean</a>); 
<a name="l09432"></a>09432                 <span class="keywordflow">return</span> var ? var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">Set</a>(Value) : <span class="keyword">false</span>; 
<a name="l09433"></a>09433         } 
<a name="l09434"></a>09434  
<a name="l09435"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#aa713e33048ee463a58b9e6988daab214">09435</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a7095efef6fc3978479fb8b6f203c6f4c" title="Set contained variable Value; no Type conversion is performed.">XPathVariableSet::Set</a>(<span class="keyword">const</span> char_t* Name, <span class="keywordtype">double</span> Value) 
<a name="l09436"></a>09436         { 
<a name="l09437"></a>09437                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a26c9bb8f7aa3aaedfcdcdca2e1822deb" title="Add a new variable or get the existing one, if the Types match.">Add</a>(Name, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da5503130cd89cdb7f6c9f0cc72091a06c" title="Number This corresponds to a double or Real.">XPathTypeNumber</a>); 
<a name="l09438"></a>09438                 <span class="keywordflow">return</span> var ? var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">Set</a>(Value) : <span class="keyword">false</span>; 
<a name="l09439"></a>09439         } 
<a name="l09440"></a>09440  
<a name="l09441"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#afa99a98b5c4e4790a921f67a153a9ff4">09441</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a7095efef6fc3978479fb8b6f203c6f4c" title="Set contained variable Value; no Type conversion is performed.">XPathVariableSet::Set</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> char_t* Value) 
<a name="l09442"></a>09442         { 
<a name="l09443"></a>09443                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a26c9bb8f7aa3aaedfcdcdca2e1822deb" title="Add a new variable or get the existing one, if the Types match.">Add</a>(Name, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575da1201c2db15249e26d46d828213e1e88b" title="Corresponds to the String type.">XPathTypeString</a>); 
<a name="l09444"></a>09444                 <span class="keywordflow">return</span> var ? var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">Set</a>(Value) : <span class="keyword">false</span>; 
<a name="l09445"></a>09445         } 
<a name="l09446"></a>09446  
<a name="l09447"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a61fe3aa60d13a4a224d301456a230a7c">09447</a>         <span class="keywordtype">bool</span> <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a7095efef6fc3978479fb8b6f203c6f4c" title="Set contained variable Value; no Type conversion is performed.">XPathVariableSet::Set</a>(<span class="keyword">const</span> char_t* Name, <span class="keyword">const</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>&amp; Value) 
<a name="l09448"></a>09448         { 
<a name="l09449"></a>09449                 <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* var = <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a26c9bb8f7aa3aaedfcdcdca2e1822deb" title="Add a new variable or get the existing one, if the Types match.">Add</a>(Name, <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575dacb1f770045b8cfe7634feb3c2745b0ba" title="Node set (XPathNodeSet).">XPathTypeNodeSet</a>); 
<a name="l09450"></a>09450                 <span class="keywordflow">return</span> var ? var-&gt;<a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html#aea78a6ac9a12a1be68db8a56fbffebc3" title="Set variable Value; no Type conversion is performed.">Set</a>(Value) : <span class="keyword">false</span>; 
<a name="l09451"></a>09451         } 
<a name="l09452"></a>09452  
<a name="l09453"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#aaf4a46b271298bbb86a6379567e590ee">09453</a>         <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#aaf4a46b271298bbb86a6379567e590ee" title="Get the named XPathVariable.">XPathVariableSet::Get</a>(<span class="keyword">const</span> char_t* Name) 
<a name="l09454"></a>09454         { 
<a name="l09455"></a>09455                 <span class="keywordflow">return</span> find(Name); 
<a name="l09456"></a>09456         } 
<a name="l09457"></a>09457  
<a name="l09458"></a><a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#a64274e4889036c318c701614d2cfa5ab">09458</a>         <span class="keyword">const</span> <a class="code" href="../../df/dee/classphys_1_1xml_1_1XPathVariable.html" title="A single XPath variable.">XPathVariable</a>* <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html#aaf4a46b271298bbb86a6379567e590ee" title="Get the named XPathVariable.">XPathVariableSet::Get</a>(<span class="keyword">const</span> char_t* Name)<span class="keyword"> const </span>
<a name="l09459"></a>09459 <span class="keyword">        </span>{ 
<a name="l09460"></a>09460                 <span class="keywordflow">return</span> find(Name); 
<a name="l09461"></a>09461         } 
<a name="l09462"></a>09462  
<a name="l09463"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a1a63135370ef4999f3dd27540c9009a2">09463</a>         XPathQuery::XPathQuery(<span class="keyword">const</span> char_t* query, <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html" title="A set of XPath variables.">XPathVariableSet</a>* variables): _impl(0) 
<a name="l09464"></a>09464         { 
<a name="l09465"></a>09465                 XPathQueryImpl* impl = XPathQueryImpl::create(); 
<a name="l09466"></a>09466  
<a name="l09467"></a>09467                 <span class="keywordflow">if</span> (!impl) 
<a name="l09468"></a>09468                 { 
<a name="l09469"></a>09469 <span class="preprocessor">                #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09470"></a>09470 <span class="preprocessor"></span>                        _Result.<a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a5e601cfd490fd3d1ed4bcdfb36d9d920" title="Error message (0 if no error).">error</a> = <span class="stringliteral">&quot;Out of memory&quot;</span>; 
<a name="l09471"></a>09471 <span class="preprocessor">                #else </span>
<a name="l09472"></a>09472 <span class="preprocessor"></span>                        <span class="keywordflow">throw</span> std::bad_alloc(); 
<a name="l09473"></a>09473 <span class="preprocessor">                #endif </span>
<a name="l09474"></a>09474 <span class="preprocessor"></span>                } 
<a name="l09475"></a>09475                 <span class="keywordflow">else</span> 
<a name="l09476"></a>09476                 { 
<a name="l09477"></a>09477                         buffer_holder impl_holder(impl, XPathQueryImpl::destroy); 
<a name="l09478"></a>09478  
<a name="l09479"></a>09479                         impl-&gt;GetRoot = XPathParser::parse(query, variables, &amp;impl-&gt;alloc, &amp;_Result); 
<a name="l09480"></a>09480  
<a name="l09481"></a>09481                         <span class="keywordflow">if</span> (impl-&gt;GetRoot) 
<a name="l09482"></a>09482                         { 
<a name="l09483"></a>09483                                 _impl = <span class="keyword">static_cast&lt;</span>XPathQueryImpl*<span class="keyword">&gt;</span>(impl_holder.release()); 
<a name="l09484"></a>09484                                 _Result.<a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a5e601cfd490fd3d1ed4bcdfb36d9d920" title="Error message (0 if no error).">error</a> = 0; 
<a name="l09485"></a>09485                         } 
<a name="l09486"></a>09486                 } 
<a name="l09487"></a>09487         } 
<a name="l09488"></a>09488  
<a name="l09489"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a063a1c4513d62695ae73c981f2050dc4">09489</a>         <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a063a1c4513d62695ae73c981f2050dc4" title="Destructor.">XPathQuery::~XPathQuery</a>() 
<a name="l09490"></a>09490         { 
<a name="l09491"></a>09491                 XPathQueryImpl::destroy(_impl); 
<a name="l09492"></a>09492         } 
<a name="l09493"></a>09493  
<a name="l09494"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#af4c6025009b1e09cdf56124a047ca4f0">09494</a>         <a class="code" href="../../d9/d27/namespacephys_1_1xml.html#a339b9eef674ba44100110e5524bc575d" title="XPathQuery return type.">XPathValueType</a> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#af4c6025009b1e09cdf56124a047ca4f0" title="Get query expression return Type.">XPathQuery::ReturnType</a>()<span class="keyword"> const </span>
<a name="l09495"></a>09495 <span class="keyword">        </span>{ 
<a name="l09496"></a>09496                 <span class="keywordflow">if</span> (!_impl) <span class="keywordflow">return</span> XPathTypeNone; 
<a name="l09497"></a>09497  
<a name="l09498"></a>09498                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>XPathQueryImpl*<span class="keyword">&gt;</span>(_impl)-&gt;GetRoot-&gt;retType(); 
<a name="l09499"></a>09499         } 
<a name="l09500"></a>09500  
<a name="l09501"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a44fed594a458aa4b6cf4f3d12d5089a8">09501</a>         <span class="keywordtype">bool</span> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a44fed594a458aa4b6cf4f3d12d5089a8" title="Evaluate expression as boolean value in the specified context; performs Type conversion if necessary...">XPathQuery::EvaluateBoolean</a>(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n)<span class="keyword"> const </span>
<a name="l09502"></a>09502 <span class="keyword">        </span>{ 
<a name="l09503"></a>09503                 <span class="keywordflow">if</span> (!_impl) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l09504"></a>09504                  
<a name="l09505"></a>09505                 XPathContext c(n, 1, 1); 
<a name="l09506"></a>09506                 XPathStackData sd; 
<a name="l09507"></a>09507  
<a name="l09508"></a>09508 <span class="preprocessor">        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09509"></a>09509 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (setjmp(sd.error_handler)) <span class="keywordflow">return</span> <span class="keyword">false</span>; 
<a name="l09510"></a>09510 <span class="preprocessor">        #endif </span>
<a name="l09511"></a>09511 <span class="preprocessor"></span>                 
<a name="l09512"></a>09512                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>XPathQueryImpl*<span class="keyword">&gt;</span>(_impl)-&gt;GetRoot-&gt;eval_boolean(c, sd.stack); 
<a name="l09513"></a>09513         } 
<a name="l09514"></a>09514          
<a name="l09515"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#aacfcff30901ce20b92de56ec0e2d70e5">09515</a>         <span class="keywordtype">double</span> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#aacfcff30901ce20b92de56ec0e2d70e5" title="Evaluate expression as double value in the specified context; performs Type conversion if necessary...">XPathQuery::EvaluateNumber</a>(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n)<span class="keyword"> const </span>
<a name="l09516"></a>09516 <span class="keyword">        </span>{ 
<a name="l09517"></a>09517                 <span class="keywordflow">if</span> (!_impl) <span class="keywordflow">return</span> gen_nan(); 
<a name="l09518"></a>09518                  
<a name="l09519"></a>09519                 XPathContext c(n, 1, 1); 
<a name="l09520"></a>09520                 XPathStackData sd; 
<a name="l09521"></a>09521  
<a name="l09522"></a>09522 <span class="preprocessor">        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09523"></a>09523 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (setjmp(sd.error_handler)) <span class="keywordflow">return</span> gen_nan(); 
<a name="l09524"></a>09524 <span class="preprocessor">        #endif </span>
<a name="l09525"></a>09525 <span class="preprocessor"></span> 
<a name="l09526"></a>09526                 <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>XPathQueryImpl*<span class="keyword">&gt;</span>(_impl)-&gt;GetRoot-&gt;eval_number(c, sd.stack); 
<a name="l09527"></a>09527         } 
<a name="l09528"></a>09528  
<a name="l09529"></a>09529 <span class="preprocessor">#ifndef XML_NO_STL </span>
<a name="l09530"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#ab7084be2e608b38872167fe3321554b9">09530</a> <span class="preprocessor"></span>        String <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#ab7084be2e608b38872167fe3321554b9" title="Evaluate expression as string value in the specified context; performs Type conversion if necessary...">XPathQuery::EvaluateString</a>(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n)<span class="keyword"> const </span>
<a name="l09531"></a>09531 <span class="keyword">        </span>{ 
<a name="l09532"></a>09532                 XPathStackData sd; 
<a name="l09533"></a>09533  
<a name="l09534"></a>09534                 <span class="keywordflow">return</span> EvaluateString_impl(static_cast&lt;XPathQueryImpl*&gt;(_impl), n, sd).c_str(); 
<a name="l09535"></a>09535         } 
<a name="l09536"></a>09536 <span class="preprocessor">#endif </span>
<a name="l09537"></a>09537 <span class="preprocessor"></span> 
<a name="l09538"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#ac9f4705c639cbd7f3aef8266fa683cc2">09538</a>         <span class="keywordtype">size_t</span> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#ab7084be2e608b38872167fe3321554b9" title="Evaluate expression as string value in the specified context; performs Type conversion if necessary...">XPathQuery::EvaluateString</a>(char_t* buffer, <span class="keywordtype">size_t</span> capacity, <span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n)<span class="keyword"> const </span>
<a name="l09539"></a>09539 <span class="keyword">        </span>{ 
<a name="l09540"></a>09540                 XPathStackData sd; 
<a name="l09541"></a>09541  
<a name="l09542"></a>09542                 XPathString r = EvaluateString_impl(static_cast&lt;XPathQueryImpl*&gt;(_impl), n, sd); 
<a name="l09543"></a>09543  
<a name="l09544"></a>09544                 <span class="keywordtype">size_t</span> full_size = r.length() + 1; 
<a name="l09545"></a>09545                  
<a name="l09546"></a>09546                 <span class="keywordflow">if</span> (capacity &gt; 0) 
<a name="l09547"></a>09547                 { 
<a name="l09548"></a>09548                         <span class="keywordtype">size_t</span> size = (full_size &lt; capacity) ? full_size : capacity; 
<a name="l09549"></a>09549                         assert(size &gt; 0); 
<a name="l09550"></a>09550  
<a name="l09551"></a>09551                         memcpy(buffer, r.c_str(), (size - 1) * <span class="keyword">sizeof</span>(char_t)); 
<a name="l09552"></a>09552                         buffer[size - 1] = 0; 
<a name="l09553"></a>09553                 } 
<a name="l09554"></a>09554                  
<a name="l09555"></a>09555                 <span class="keywordflow">return</span> full_size; 
<a name="l09556"></a>09556         } 
<a name="l09557"></a>09557  
<a name="l09558"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#af00ba3d0346ccc01f249274947191333">09558</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#af00ba3d0346ccc01f249274947191333" title="Evaluate expression as node set in the specified context.">XPathQuery::EvaluateNodeSet</a>(<span class="keyword">const</span> <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>&amp; n)<span class="keyword"> const </span>
<a name="l09559"></a>09559 <span class="keyword">        </span>{ 
<a name="l09560"></a>09560                 <span class="keywordflow">if</span> (!_impl) <span class="keywordflow">return</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>(); 
<a name="l09561"></a>09561  
<a name="l09562"></a>09562                 XPathAstNode* GetRoot = <span class="keyword">static_cast&lt;</span>XPathQueryImpl*<span class="keyword">&gt;</span>(_impl)-&gt;GetRoot; 
<a name="l09563"></a>09563  
<a name="l09564"></a>09564                 <span class="keywordflow">if</span> (GetRoot-&gt;retType() != XPathTypeNodeSet) 
<a name="l09565"></a>09565                 { 
<a name="l09566"></a>09566 <span class="preprocessor">                #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09567"></a>09567 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>(); 
<a name="l09568"></a>09568 <span class="preprocessor">                #else </span>
<a name="l09569"></a>09569 <span class="preprocessor"></span>                        <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html" title="XPath parsing result.">XPathParseResult</a> Result; 
<a name="l09570"></a>09570                         Result.<a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html#a5e601cfd490fd3d1ed4bcdfb36d9d920" title="Error message (0 if no error).">error</a> = <span class="stringliteral">&quot;Expression does not evaluate to node set&quot;</span>; 
<a name="l09571"></a>09571  
<a name="l09572"></a>09572                         <span class="keywordflow">throw</span> <a class="code" href="../../d4/d30/classphys_1_1xml_1_1XPathException.html" title="Thrown in a variety of XPath only situations, to indicate type mismatch or other issues.">XPathException</a>(Result); 
<a name="l09573"></a>09573 <span class="preprocessor">                #endif </span>
<a name="l09574"></a>09574 <span class="preprocessor"></span>                } 
<a name="l09575"></a>09575                  
<a name="l09576"></a>09576                 XPathContext c(n, 1, 1); 
<a name="l09577"></a>09577                 XPathStackData sd; 
<a name="l09578"></a>09578  
<a name="l09579"></a>09579 <span class="preprocessor">        #ifdef XML_NO_EXCEPTIONS </span>
<a name="l09580"></a>09580 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (setjmp(sd.error_handler)) <span class="keywordflow">return</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>(); 
<a name="l09581"></a>09581 <span class="preprocessor">        #endif </span>
<a name="l09582"></a>09582 <span class="preprocessor"></span> 
<a name="l09583"></a>09583                 XPathNodeSet_raw r = GetRoot-&gt;eval_NodeSet(c, sd.stack); 
<a name="l09584"></a>09584  
<a name="l09585"></a>09585                 <span class="keywordflow">return</span> <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a>(r.begin(), r.end(), r.Type()); 
<a name="l09586"></a>09586         } 
<a name="l09587"></a>09587  
<a name="l09588"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a83f2039e91105c9cd0dcc7d524359198">09588</a>         <span class="keyword">const</span> <a class="code" href="../../d8/d54/structphys_1_1xml_1_1XPathParseResult.html" title="XPath parsing result.">XPathParseResult</a>&amp; <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a83f2039e91105c9cd0dcc7d524359198" title="Get parsing Result (used to get compilation errors when XML_NO_EXCEPTIONS is enabled).">XPathQuery::Result</a>()<span class="keyword"> const </span>
<a name="l09589"></a>09589 <span class="keyword">        </span>{ 
<a name="l09590"></a>09590                 <span class="keywordflow">return</span> _Result; 
<a name="l09591"></a>09591         } 
<a name="l09592"></a>09592  
<a name="l09593"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#a783704bb9a83379b6c8dadbfb5a835ce">09593</a>         XPathQuery::operator XPathQuery::unspecified_bool_type()<span class="keyword"> const </span>
<a name="l09594"></a>09594 <span class="keyword">        </span>{ 
<a name="l09595"></a>09595                 <span class="keywordflow">return</span> _impl ? &amp;XPathQuery::_impl : 0; 
<a name="l09596"></a>09596         } 
<a name="l09597"></a>09597  
<a name="l09598"></a><a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#afe0b62e0ab607855f5267b0690bda33b">09598</a>         <span class="keywordtype">bool</span> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#afe0b62e0ab607855f5267b0690bda33b" title="Logical not operator, used a workaround for borland compiler.">XPathQuery::operator!</a>()<span class="keyword"> const </span>
<a name="l09599"></a>09599 <span class="keyword">        </span>{ 
<a name="l09600"></a>09600                 <span class="keywordflow">return</span> !_impl; 
<a name="l09601"></a>09601         } 
<a name="l09602"></a>09602  
<a name="l09603"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11966aa8afdfa586404393ebae9b07f5">09603</a>         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11966aa8afdfa586404393ebae9b07f5" title="Select single node by evaluating an XPath query. Returns first node from the resulting node set...">Node::FindSingleNode</a>(<span class="keyword">const</span> char_t* query, <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html" title="A set of XPath variables.">XPathVariableSet</a>* variables)<span class="keyword"> const </span>
<a name="l09604"></a>09604 <span class="keyword">        </span>{ 
<a name="l09605"></a>09605                 <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html" title="A compiled XPath query object.">XPathQuery</a> q(query, variables); 
<a name="l09606"></a>09606                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11966aa8afdfa586404393ebae9b07f5" title="Select single node by evaluating an XPath query. Returns first node from the resulting node set...">FindSingleNode</a>(q); 
<a name="l09607"></a>09607         } 
<a name="l09608"></a>09608  
<a name="l09609"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a13b958f663f9605061e5e47dfd8e1966">09609</a>         <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a11966aa8afdfa586404393ebae9b07f5" title="Select single node by evaluating an XPath query. Returns first node from the resulting node set...">Node::FindSingleNode</a>(<span class="keyword">const</span> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html" title="A compiled XPath query object.">XPathQuery</a>&amp; query)<span class="keyword"> const </span>
<a name="l09610"></a>09610 <span class="keyword">        </span>{ 
<a name="l09611"></a>09611                 <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a> s = query.<a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#af00ba3d0346ccc01f249274947191333" title="Evaluate expression as node set in the specified context.">EvaluateNodeSet</a>(*<span class="keyword">this</span>); 
<a name="l09612"></a>09612                 <span class="keywordflow">return</span> s.<a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#a91fa85dbf474c51bc7a9df1baf38d43a" title="Check if collection is empty.">Empty</a>() ? <a class="code" href="../../df/dd4/classphys_1_1xml_1_1XPathNode.html" title="An XPath node which can store handles to a xml::Node or an xml::Attribute.">XPathNode</a>() : s.<a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html#ae38baf21701ebbe42af3abfb6976d100" title="Get first node in the collection by document order.">first</a>(); 
<a name="l09613"></a>09613         } 
<a name="l09614"></a>09614  
<a name="l09615"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a7390ba1c09b83544365abc7bf8ec5b8f">09615</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a7390ba1c09b83544365abc7bf8ec5b8f" title="Select a group of nodes by evaluating an XPath query.">Node::FindNodes</a>(<span class="keyword">const</span> char_t* query, <a class="code" href="../../df/dd1/classphys_1_1xml_1_1XPathVariableSet.html" title="A set of XPath variables.">XPathVariableSet</a>* variables)<span class="keyword"> const </span>
<a name="l09616"></a>09616 <span class="keyword">        </span>{ 
<a name="l09617"></a>09617                 <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html" title="A compiled XPath query object.">XPathQuery</a> q(query, variables); 
<a name="l09618"></a>09618                 <span class="keywordflow">return</span> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a7390ba1c09b83544365abc7bf8ec5b8f" title="Select a group of nodes by evaluating an XPath query.">FindNodes</a>(q); 
<a name="l09619"></a>09619         } 
<a name="l09620"></a>09620  
<a name="l09621"></a><a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a466766bf750da2a04acd8a32d2b8a458">09621</a>         <a class="code" href="../../de/dc2/classphys_1_1xml_1_1XPathNodeSet.html" title="A collection of nodes that an XPathQuery can work on.">XPathNodeSet</a> <a class="code" href="../../d7/d0a/classphys_1_1xml_1_1Node.html#a7390ba1c09b83544365abc7bf8ec5b8f" title="Select a group of nodes by evaluating an XPath query.">Node::FindNodes</a>(<span class="keyword">const</span> <a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html" title="A compiled XPath query object.">XPathQuery</a>&amp; query)<span class="keyword"> const </span>
<a name="l09622"></a>09622 <span class="keyword">        </span>{ 
<a name="l09623"></a>09623                 <span class="keywordflow">return</span> query.<a class="code" href="../../de/d52/classphys_1_1xml_1_1XPathQuery.html#af00ba3d0346ccc01f249274947191333" title="Evaluate expression as node set in the specified context.">EvaluateNodeSet</a>(*<span class="keyword">this</span>); 
<a name="l09624"></a>09624         } 
<a name="l09625"></a>09625 } 
<a name="l09626"></a>09626 } <span class="comment">// \phys</span>
<a name="l09627"></a>09627  
<a name="l09628"></a>09628 <span class="preprocessor">#endif </span>
<a name="l09629"></a>09629 <span class="preprocessor"></span> 
<a name="l09630"></a>09630 <span class="comment">/* </span>
<a name="l09631"></a>09631 <span class="comment"> * </span>
<a name="l09632"></a>09632 <span class="comment"> * Software, Files, Libraries and all other items referenced in this clause refers only </span>
<a name="l09633"></a>09633 <span class="comment"> * to the contents of this file and associated documentation. </span>
<a name="l09634"></a>09634 <span class="comment"> * </span>
<a name="l09635"></a>09635 <span class="comment"> * Copyright © 2006-2010 Arseny Kapoulkine </span>
<a name="l09636"></a>09636 <span class="comment"> * </span>
<a name="l09637"></a>09637 <span class="comment"> * Permission is hereby granted, free of charge, to any person </span>
<a name="l09638"></a>09638 <span class="comment"> * obtaining a copy of this software and associated documentation </span>
<a name="l09639"></a>09639 <span class="comment"> * files (the &quot;Software&quot;), to deal in the Software without </span>
<a name="l09640"></a>09640 <span class="comment"> * restriction, including without limitation the rights to use, </span>
<a name="l09641"></a>09641 <span class="comment"> * copy, modify, merge, publish, distribute, sublicense, and/or sell </span>
<a name="l09642"></a>09642 <span class="comment"> * copies of the Software, and to permit persons to whom the </span>
<a name="l09643"></a>09643 <span class="comment"> * Software is furnished to do so, subject to the following </span>
<a name="l09644"></a>09644 <span class="comment"> * conditions: </span>
<a name="l09645"></a>09645 <span class="comment"> * </span>
<a name="l09646"></a>09646 <span class="comment"> * The above copyright notice and this permission notice shall be </span>
<a name="l09647"></a>09647 <span class="comment"> * included in all copies or substantial portions of the Software. </span>
<a name="l09648"></a>09648 <span class="comment"> *  </span>
<a name="l09649"></a>09649 <span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, </span>
<a name="l09650"></a>09650 <span class="comment"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES </span>
<a name="l09651"></a>09651 <span class="comment"> * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND </span>
<a name="l09652"></a>09652 <span class="comment"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT </span>
<a name="l09653"></a>09653 <span class="comment"> * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, </span>
<a name="l09654"></a>09654 <span class="comment"> * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING </span>
<a name="l09655"></a>09655 <span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR </span>
<a name="l09656"></a>09656 <span class="comment"> * OTHER DEALINGS IN THE SOFTWARE. </span>
<a name="l09657"></a>09657 <span class="comment"> */</span> 
<a name="l09658"></a>09658 <span class="preprocessor">#endif // \PHYSXML </span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Feb 14 2011 04:15:43 for PhysGameEngine by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
