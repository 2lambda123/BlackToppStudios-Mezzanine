<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mezzanine::EventManager Class Reference</title>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="DoxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;" nowrap="nowrap">
   <div id="projectname"><a href="http://blacktoppstudios.com"><img src="logogreen100pxtall.png"/></a>MezzanineEngine&#160;<span id="projectnumber">March 7, 2013</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.xhtml"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.xhtml"><span>Classes</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.xhtml"><span>Class&#160;List</span></a></li>
      <li><a href="classes.xhtml"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.xhtml"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.xhtml"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMezzanine.xhtml">Mezzanine</a></li><li class="navelem"><a class="el" href="classMezzanine_1_1EventManager.xhtml">EventManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMezzanine_1_1EventManager-members.xhtml">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mezzanine::EventManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a container for Events and facilitates the transfer of data.  
 <a href="classMezzanine_1_1EventManager.xhtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="eventmanager_8h_source.xhtml">eventmanager.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Mezzanine::EventManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMezzanine_1_1EventManager__inherit__graph.svg" width="344" height="134"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.xhtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Mezzanine::EventManager:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classMezzanine_1_1EventManager__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a href="graph_legend.xhtml">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95ce9d2d865b0d8d9468448969b0ade2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a95ce9d2d865b0d8d9468448969b0ade2">EventManager</a> ()</td></tr>
<tr class="memdesc:a95ce9d2d865b0d8d9468448969b0ade2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a95ce9d2d865b0d8d9468448969b0ade2"></a><br/></td></tr>
<tr class="memitem:abf3650bfe862473ed2418dddbd83eec3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#abf3650bfe862473ed2418dddbd83eec3">EventManager</a> (<a class="el" href="classMezzanine_1_1XML_1_1Node.xhtml">XML::Node</a> &amp;XMLNode)</td></tr>
<tr class="memdesc:abf3650bfe862473ed2418dddbd83eec3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceMezzanine_1_1XML.xhtml" title="All tools for working with XML are located in this namespace.">XML</a> constructor.  <a href="#abf3650bfe862473ed2418dddbd83eec3"></a><br/></td></tr>
<tr class="memitem:a39b9e0f783c2ab0d39f5574a7a106141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a39b9e0f783c2ab0d39f5574a7a106141">~EventManager</a> ()</td></tr>
<tr class="memdesc:a39b9e0f783c2ab0d39f5574a7a106141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Deconstructor.  <a href="#a39b9e0f783c2ab0d39f5574a7a106141"></a><br/></td></tr>
<tr class="memitem:aa791c61d2665422614d54c7653e87e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#aa791c61d2665422614d54c7653e87e88">AddEvent</a> (<a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *EventToAdd)</td></tr>
<tr class="memdesc:aa791c61d2665422614d54c7653e87e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an event of any kind to the end of the Event Queue.  <a href="#aa791c61d2665422614d54c7653e87e88"></a><br/></td></tr>
<tr class="memitem:a2da4ef46b2ce56206412782eec43d93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a2da4ef46b2ce56206412782eec43d93e">AddPollingCheck</a> (const <a class="el" href="classMezzanine_1_1MetaCode.xhtml">MetaCode</a> &amp;InputToTryPolling)</td></tr>
<tr class="memdesc:a2da4ef46b2ce56206412782eec43d93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates extra events each iteration of the main loop, based on user input polling.  <a href="#a2da4ef46b2ce56206412782eec43d93e"></a><br/></td></tr>
<tr class="memitem:a3cf0fd9e33392aa24e9a735363212185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a3cf0fd9e33392aa24e9a735363212185">DetectJoysticks</a> ()</td></tr>
<tr class="memdesc:a3cf0fd9e33392aa24e9a735363212185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for Joysticks that are hooked up to the system.  <a href="#a3cf0fd9e33392aa24e9a735363212185"></a><br/></td></tr>
<tr class="memitem:a0a3d6cc2efbb528f35694c0157976c7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a0a3d6cc2efbb528f35694c0157976c7e">DoMainLoopItems</a> ()</td></tr>
<tr class="memdesc:a0a3d6cc2efbb528f35694c0157976c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main loop calls this once per frame.   <a href="#a0a3d6cc2efbb528f35694c0157976c7e"></a><br/></td></tr>
<tr class="memitem:aecbaa2cfdffc3dc10db2f4b0146bbe27"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classMezzanine_1_1EventCollision.xhtml">EventCollision</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#aecbaa2cfdffc3dc10db2f4b0146bbe27">GetAllCollisionEvents</a> ()</td></tr>
<tr class="memdesc:aecbaa2cfdffc3dc10db2f4b0146bbe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a complete list of all the Collision Events.  <a href="#aecbaa2cfdffc3dc10db2f4b0146bbe27"></a><br/></td></tr>
<tr class="memitem:a30d4178ebdcc6f145ffdeb5e656e02ed"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classMezzanine_1_1EventGameWindow.xhtml">EventGameWindow</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a30d4178ebdcc6f145ffdeb5e656e02ed">GetAllGameWindowEvents</a> ()</td></tr>
<tr class="memdesc:a30d4178ebdcc6f145ffdeb5e656e02ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a complete list of all the Render <a class="el" href="structMezzanine_1_1Time.xhtml" title="A container for the metrics of time relevant for the timer class.">Time</a> events.  <a href="#a30d4178ebdcc6f145ffdeb5e656e02ed"></a><br/></td></tr>
<tr class="memitem:a6f374c33be1d1f0a0c5315d299ed7f06"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classMezzanine_1_1EventQuit.xhtml">EventQuit</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a6f374c33be1d1f0a0c5315d299ed7f06">GetAllQuitEvents</a> ()</td></tr>
<tr class="memdesc:a6f374c33be1d1f0a0c5315d299ed7f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a complete list of all the quit events.  <a href="#a6f374c33be1d1f0a0c5315d299ed7f06"></a><br/></td></tr>
<tr class="memitem:a045496478f798eb263477bf1b6ae2930"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classMezzanine_1_1EventRenderTime.xhtml">EventRenderTime</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a045496478f798eb263477bf1b6ae2930">GetAllRenderTimeEvents</a> ()</td></tr>
<tr class="memdesc:a045496478f798eb263477bf1b6ae2930"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a complete list of all the Render <a class="el" href="structMezzanine_1_1Time.xhtml" title="A container for the metrics of time relevant for the timer class.">Time</a> events.  <a href="#a045496478f798eb263477bf1b6ae2930"></a><br/></td></tr>
<tr class="memitem:a1728f075217522f266186a1e9c01426f"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a1728f075217522f266186a1e9c01426f">GetAllSpecificEvents</a> (<a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a> SpecificType)</td></tr>
<tr class="memdesc:a1728f075217522f266186a1e9c01426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a complete list of all the specified events.  <a href="#a1728f075217522f266186a1e9c01426f"></a><br/></td></tr>
<tr class="memitem:ab9ca42a030761beb40e0ac808443c334"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classMezzanine_1_1EventUserInput.xhtml">EventUserInput</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#ab9ca42a030761beb40e0ac808443c334">GetAllUserInputEvents</a> ()</td></tr>
<tr class="memdesc:ab9ca42a030761beb40e0ac808443c334"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns a complete list of all the User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> events.  <a href="#ab9ca42a030761beb40e0ac808443c334"></a><br/></td></tr>
<tr class="memitem:ab77895920f1fca668d8dee6dbf7c2e07"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceMezzanine.xhtml#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#ab77895920f1fca668d8dee6dbf7c2e07">GetImplementationTypeName</a> () const </td></tr>
<tr class="memdesc:ab77895920f1fca668d8dee6dbf7c2e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Allows any manager name to be sent to a stream. Primarily used for logging.   <a href="#ab77895920f1fca668d8dee6dbf7c2e07"></a><br/></td></tr>
<tr class="memitem:aa99549992a346234799b4043baa01de3"><td class="memItemLeft" align="right" valign="top">virtual ManagerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#aa99549992a346234799b4043baa01de3">GetInterfaceType</a> () const </td></tr>
<tr class="memdesc:aa99549992a346234799b4043baa01de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the type of this manager.   <a href="#aa99549992a346234799b4043baa01de3"></a><br/></td></tr>
<tr class="memitem:accd05e5d1ab12e96febd9513d9a7c7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventCollision.xhtml">EventCollision</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#accd05e5d1ab12e96febd9513d9a7c7d9">GetNextCollisionEvent</a> ()</td></tr>
<tr class="memdesc:accd05e5d1ab12e96febd9513d9a7c7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next Collision event.  <a href="#accd05e5d1ab12e96febd9513d9a7c7d9"></a><br/></td></tr>
<tr class="memitem:acc384c86846251daeb046c350331325e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#acc384c86846251daeb046c350331325e">GetNextEvent</a> ()</td></tr>
<tr class="memdesc:acc384c86846251daeb046c350331325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the Next event.  <a href="#acc384c86846251daeb046c350331325e"></a><br/></td></tr>
<tr class="memitem:ac5cfb6cd66c2da5957004a24c63db430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventGameWindow.xhtml">EventGameWindow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#ac5cfb6cd66c2da5957004a24c63db430">GetNextGameWindowEvent</a> ()</td></tr>
<tr class="memdesc:ac5cfb6cd66c2da5957004a24c63db430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next GameWindow event.  <a href="#ac5cfb6cd66c2da5957004a24c63db430"></a><br/></td></tr>
<tr class="memitem:a47a088031994a3637bf82d474f92edab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventQuit.xhtml">EventQuit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a47a088031994a3637bf82d474f92edab">GetNextQuitEvent</a> ()</td></tr>
<tr class="memdesc:a47a088031994a3637bf82d474f92edab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a>.  <a href="#a47a088031994a3637bf82d474f92edab"></a><br/></td></tr>
<tr class="memitem:a30ffa2db08501d04a5b6f7b42dbb5d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventRenderTime.xhtml">EventRenderTime</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a30ffa2db08501d04a5b6f7b42dbb5d7e">GetNextRenderTimeEvent</a> ()</td></tr>
<tr class="memdesc:a30ffa2db08501d04a5b6f7b42dbb5d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next Rendertime event.  <a href="#a30ffa2db08501d04a5b6f7b42dbb5d7e"></a><br/></td></tr>
<tr class="memitem:a4be1f66f9f731ea390a7d4d6494dcdbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a4be1f66f9f731ea390a7d4d6494dcdbd">GetNextSpecificEvent</a> (<a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a> SpecificType)</td></tr>
<tr class="memdesc:a4be1f66f9f731ea390a7d4d6494dcdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next kind event of the Specified type.  <a href="#a4be1f66f9f731ea390a7d4d6494dcdbd"></a><br/></td></tr>
<tr class="memitem:a1049a36dc6c981a8c7d816a180bb7f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventUserInput.xhtml">EventUserInput</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a1049a36dc6c981a8c7d816a180bb7f09">GetNextUserInputEvent</a> ()</td></tr>
<tr class="memdesc:a1049a36dc6c981a8c7d816a180bb7f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> event.  <a href="#a1049a36dc6c981a8c7d816a180bb7f09"></a><br/></td></tr>
<tr class="memitem:aa3f1b41578307c7ac801340b275af027"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#aa3f1b41578307c7ac801340b275af027">GetRemainingEventCount</a> ()</td></tr>
<tr class="memdesc:aa3f1b41578307c7ac801340b275af027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a count of events.  <a href="#aa3f1b41578307c7ac801340b275af027"></a><br/></td></tr>
<tr class="memitem:a48c9a0c34b666736f5d1cc6d4a9a983f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a48c9a0c34b666736f5d1cc6d4a9a983f">Initialize</a> ()</td></tr>
<tr class="memdesc:a48c9a0c34b666736f5d1cc6d4a9a983f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Items requiring other Managers.   <a href="#a48c9a0c34b666736f5d1cc6d4a9a983f"></a><br/></td></tr>
<tr class="memitem:ab5ddd669f45aaf0210777807a9f0a7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventCollision.xhtml">EventCollision</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#ab5ddd669f45aaf0210777807a9f0a7c0">PopNextCollisionEvent</a> ()</td></tr>
<tr class="memdesc:ab5ddd669f45aaf0210777807a9f0a7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next Collision event and removes it from the Que.  <a href="#ab5ddd669f45aaf0210777807a9f0a7c0"></a><br/></td></tr>
<tr class="memitem:a3edb93529db1ded51ddeccf10ea6e17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a3edb93529db1ded51ddeccf10ea6e17e">PopNextEvent</a> ()</td></tr>
<tr class="memdesc:a3edb93529db1ded51ddeccf10ea6e17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the Next event, and removes the Event from storage.  <a href="#a3edb93529db1ded51ddeccf10ea6e17e"></a><br/></td></tr>
<tr class="memitem:a3ec49cc795bfbe0270f8ab09d02639d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventGameWindow.xhtml">EventGameWindow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a3ec49cc795bfbe0270f8ab09d02639d0">PopNextGameWindowEvent</a> ()</td></tr>
<tr class="memdesc:a3ec49cc795bfbe0270f8ab09d02639d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next GameWindow event and removes it from the Que.  <a href="#a3ec49cc795bfbe0270f8ab09d02639d0"></a><br/></td></tr>
<tr class="memitem:ade1d2d4f31cb0d89ec038fc6ec498181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventQuit.xhtml">EventQuit</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#ade1d2d4f31cb0d89ec038fc6ec498181">PopNextQuitEvent</a> ()</td></tr>
<tr class="memdesc:ade1d2d4f31cb0d89ec038fc6ec498181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> and removes it from the Que.  <a href="#ade1d2d4f31cb0d89ec038fc6ec498181"></a><br/></td></tr>
<tr class="memitem:af5feae2419180bb856d19dfdfff1ffb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventRenderTime.xhtml">EventRenderTime</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#af5feae2419180bb856d19dfdfff1ffb7">PopNextRenderTimeEvent</a> ()</td></tr>
<tr class="memdesc:af5feae2419180bb856d19dfdfff1ffb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next Rendertime event and removes it from the Que.  <a href="#af5feae2419180bb856d19dfdfff1ffb7"></a><br/></td></tr>
<tr class="memitem:adffc75d1a715167011b005df3f76e4df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#adffc75d1a715167011b005df3f76e4df">PopNextSpecificEvent</a> (<a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a> SpecificType)</td></tr>
<tr class="memdesc:adffc75d1a715167011b005df3f76e4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next kind event of the Specified type, and removes it from the Que.  <a href="#adffc75d1a715167011b005df3f76e4df"></a><br/></td></tr>
<tr class="memitem:a54f836733044afe17bf3ce9aa6a5f8ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1EventUserInput.xhtml">EventUserInput</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a54f836733044afe17bf3ce9aa6a5f8ae">PopNextUserInputEvent</a> ()</td></tr>
<tr class="memdesc:a54f836733044afe17bf3ce9aa6a5f8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> event and removes it from the Que.  <a href="#a54f836733044afe17bf3ce9aa6a5f8ae"></a><br/></td></tr>
<tr class="memitem:a209b69a260ea1a2351e005802d13803b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a209b69a260ea1a2351e005802d13803b">RemoveAllSpecificEvents</a> (<a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a> SpecificType)</td></tr>
<tr class="memdesc:a209b69a260ea1a2351e005802d13803b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This removes all the events of the specified type.  <a href="#a209b69a260ea1a2351e005802d13803b"></a><br/></td></tr>
<tr class="memitem:ae3a90f7fdd0b75b4e4ff5e5d3ad3e332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#ae3a90f7fdd0b75b4e4ff5e5d3ad3e332">RemoveEvent</a> (<a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *EventToRemove)</td></tr>
<tr class="memdesc:ae3a90f7fdd0b75b4e4ff5e5d3ad3e332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an event of any kind from the Event Queue.  <a href="#ae3a90f7fdd0b75b4e4ff5e5d3ad3e332"></a><br/></td></tr>
<tr class="memitem:ac35a0aa7e6e98a8024025f3babd40749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#ac35a0aa7e6e98a8024025f3babd40749">RemoveNextCollisionEvent</a> ()</td></tr>
<tr class="memdesc:ac35a0aa7e6e98a8024025f3babd40749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the First Collision Event From the que without looking at it.  <a href="#ac35a0aa7e6e98a8024025f3babd40749"></a><br/></td></tr>
<tr class="memitem:a0694b97c1b9696f5b28d0baf7a2f7c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a0694b97c1b9696f5b28d0baf7a2f7c40">RemoveNextEvent</a> ()</td></tr>
<tr class="memdesc:a0694b97c1b9696f5b28d0baf7a2f7c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an Event From the que without looking at it.  <a href="#a0694b97c1b9696f5b28d0baf7a2f7c40"></a><br/></td></tr>
<tr class="memitem:a6108fd63aed85b5a3f38987f75603c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a6108fd63aed85b5a3f38987f75603c53">RemoveNextGameWindowEvent</a> ()</td></tr>
<tr class="memdesc:a6108fd63aed85b5a3f38987f75603c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the First GameWindow Event From the que without looking at it.  <a href="#a6108fd63aed85b5a3f38987f75603c53"></a><br/></td></tr>
<tr class="memitem:a10735469d564d6731c3741acf265879c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a10735469d564d6731c3741acf265879c">RemoveNextQuitEvent</a> ()</td></tr>
<tr class="memdesc:a10735469d564d6731c3741acf265879c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the First <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> From the que without looking at it.  <a href="#a10735469d564d6731c3741acf265879c"></a><br/></td></tr>
<tr class="memitem:a9a0b6340a0b0a6a96b7918f758f44c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a9a0b6340a0b0a6a96b7918f758f44c31">RemoveNextRenderTimeEvent</a> ()</td></tr>
<tr class="memdesc:a9a0b6340a0b0a6a96b7918f758f44c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the First Rendertime Event From the que without looking at it.  <a href="#a9a0b6340a0b0a6a96b7918f758f44c31"></a><br/></td></tr>
<tr class="memitem:a8fe12f47a64f3af8dcb30f13ee60e303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a8fe12f47a64f3af8dcb30f13ee60e303">RemoveNextSpecificEvent</a> (<a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a> SpecificType)</td></tr>
<tr class="memdesc:a8fe12f47a64f3af8dcb30f13ee60e303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the Next kind event of the Specified type, and removes it from the Que.  <a href="#a8fe12f47a64f3af8dcb30f13ee60e303"></a><br/></td></tr>
<tr class="memitem:a1d2681b16ec802f8271f2651ff40c083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a1d2681b16ec802f8271f2651ff40c083">RemoveNextUserInputEvent</a> ()</td></tr>
<tr class="memdesc:a1d2681b16ec802f8271f2651ff40c083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the First User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> Event From the que without looking at it.  <a href="#a1d2681b16ec802f8271f2651ff40c083"></a><br/></td></tr>
<tr class="memitem:a446cab99c7c67b42e28753cda14d79a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a446cab99c7c67b42e28753cda14d79a4">RemovePollingCheck</a> (const <a class="el" href="classMezzanine_1_1MetaCode.xhtml">MetaCode</a> &amp;InputToStopPolling)</td></tr>
<tr class="memdesc:a446cab99c7c67b42e28753cda14d79a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes Events from the list(s) of what needs to be polled.  <a href="#a446cab99c7c67b42e28753cda14d79a4"></a><br/></td></tr>
<tr class="memitem:a07119a541a60a515e2108c79cf6e3aac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a07119a541a60a515e2108c79cf6e3aac">UpdateEvents</a> ()</td></tr>
<tr class="memdesc:a07119a541a60a515e2108c79cf6e3aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulls Events from the all the subsystems for use in the <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">EventManager</a>.  <a href="#a07119a541a60a515e2108c79cf6e3aac"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classMezzanine_1_1ManagerBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classMezzanine_1_1ManagerBase')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classMezzanine_1_1ManagerBase.xhtml">Mezzanine::ManagerBase</a></td></tr>
<tr class="memitem:a6ee3249f71f330394e81e349370d57a8 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ee3249f71f330394e81e349370d57a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a6ee3249f71f330394e81e349370d57a8">ManagerBase</a> ()</td></tr>
<tr class="memdesc:a6ee3249f71f330394e81e349370d57a8 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr class="memitem:ad98752e65db50b66fbb000dedbc07786 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ad98752e65db50b66fbb000dedbc07786">~ManagerBase</a> ()</td></tr>
<tr class="memdesc:ad98752e65db50b66fbb000dedbc07786 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructor.  <a href="#ad98752e65db50b66fbb000dedbc07786"></a><br/></td></tr>
<tr class="memitem:aec6f56b909c0453370771f921d29e7d7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec6f56b909c0453370771f921d29e7d7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#aec6f56b909c0453370771f921d29e7d7">ErasePostMainLoopItems</a> ()</td></tr>
<tr class="memdesc:aec6f56b909c0453370771f921d29e7d7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This simply calls <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#af33945c6196024c530990780b2a44cfc" title="This assigns a function to be the callback function to run prior to the main loop.">SetPostMainLoopItems()</a> passing it 0. <br/></td></tr>
<tr class="memitem:a173afcb032bfe374c220d17e24a2ef2c inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173afcb032bfe374c220d17e24a2ef2c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a173afcb032bfe374c220d17e24a2ef2c">ErasePreMainLoopItems</a> ()</td></tr>
<tr class="memdesc:a173afcb032bfe374c220d17e24a2ef2c inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This simply calls <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a2837c3c4ec588e4a3cbed39fa8287ef0" title="This assigns a function to be the callback function to run prior to the main loop.">SetPreMainLoopItems()</a> passing it 0. <br/></td></tr>
<tr class="memitem:a70b61244d5182ad40dd056b2664a6aa7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMezzanine.xhtml#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a70b61244d5182ad40dd056b2664a6aa7">GetInterfaceTypeAsString</a> () const </td></tr>
<tr class="memdesc:a70b61244d5182ad40dd056b2664a6aa7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string of the interface type of this manager.  <a href="#a70b61244d5182ad40dd056b2664a6aa7"></a><br/></td></tr>
<tr class="memitem:a661b5cafe1a0f77c9fbd17c7444d1fea inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab23a9aa27c4e3cb58d902a149d3c6de2">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a661b5cafe1a0f77c9fbd17c7444d1fea">GetPostMainLoopItems</a> () const </td></tr>
<tr class="memdesc:a661b5cafe1a0f77c9fbd17c7444d1fea inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the Callback that would be called before the main loop items.  <a href="#a661b5cafe1a0f77c9fbd17c7444d1fea"></a><br/></td></tr>
<tr class="memitem:a45c0e893c832e257475321fb1e826f20 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab23a9aa27c4e3cb58d902a149d3c6de2">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a45c0e893c832e257475321fb1e826f20">GetPreMainLoopItems</a> () const </td></tr>
<tr class="memdesc:a45c0e893c832e257475321fb1e826f20 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns the Callback that would be called before the main loop items.  <a href="#a45c0e893c832e257475321fb1e826f20"></a><br/></td></tr>
<tr class="memitem:a2d0d7e80c5a151c9f0d91a0366605cca inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a2d0d7e80c5a151c9f0d91a0366605cca">GetPriority</a> ()</td></tr>
<tr class="memdesc:a2d0d7e80c5a151c9f0d91a0366605cca inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the Priority of this manager.  <a href="#a2d0d7e80c5a151c9f0d91a0366605cca"></a><br/></td></tr>
<tr class="memitem:ade516a30e6d24b4ffd1accf1b1efd948 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ade516a30e6d24b4ffd1accf1b1efd948">IsInitialized</a> ()</td></tr>
<tr class="memdesc:ade516a30e6d24b4ffd1accf1b1efd948 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not this manager has been initialized.  <a href="#ade516a30e6d24b4ffd1accf1b1efd948"></a><br/></td></tr>
<tr class="memitem:aec26bca08780fd29f49370973f39cbf7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#aec26bca08780fd29f49370973f39cbf7">PostMainLoopItems</a> ()</td></tr>
<tr class="memdesc:aec26bca08780fd29f49370973f39cbf7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This runs any callback that is required after the mainloop items are run.  <a href="#aec26bca08780fd29f49370973f39cbf7"></a><br/></td></tr>
<tr class="memitem:a786e385f50879d6643962ea17b9e13e7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a786e385f50879d6643962ea17b9e13e7">PreMainLoopItems</a> ()</td></tr>
<tr class="memdesc:a786e385f50879d6643962ea17b9e13e7 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This runs any callback that is required before the mainloop items are run.  <a href="#a786e385f50879d6643962ea17b9e13e7"></a><br/></td></tr>
<tr class="memitem:af33945c6196024c530990780b2a44cfc inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#af33945c6196024c530990780b2a44cfc">SetPostMainLoopItems</a> (<a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab23a9aa27c4e3cb58d902a149d3c6de2">Callback</a> PostMainCallback)</td></tr>
<tr class="memdesc:af33945c6196024c530990780b2a44cfc inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This assigns a function to be the callback function to run prior to the main loop.  <a href="#af33945c6196024c530990780b2a44cfc"></a><br/></td></tr>
<tr class="memitem:a2837c3c4ec588e4a3cbed39fa8287ef0 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a2837c3c4ec588e4a3cbed39fa8287ef0">SetPreMainLoopItems</a> (<a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab23a9aa27c4e3cb58d902a149d3c6de2">Callback</a> PreMainCallback)</td></tr>
<tr class="memdesc:a2837c3c4ec588e4a3cbed39fa8287ef0 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This assigns a function to be the callback function to run prior to the main loop.  <a href="#a2837c3c4ec588e4a3cbed39fa8287ef0"></a><br/></td></tr>
<tr class="memitem:a226c8f18a44d8ef6e261a9ae202ff044 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a226c8f18a44d8ef6e261a9ae202ff044">SetPriority</a> (short int Priority_)</td></tr>
<tr class="memdesc:a226c8f18a44d8ef6e261a9ae202ff044 inherit pub_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the Priority of this manager.  <a href="#a226c8f18a44d8ef6e261a9ae202ff044"></a><br/></td></tr>
<tr class="inherit_header pub_methods_classMezzanine_1_1Singleton"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classMezzanine_1_1Singleton')"><img src="closed.png" alt="-"/>&nbsp;Public Member Functions inherited from <a class="el" href="classMezzanine_1_1Singleton.xhtml">Mezzanine::Singleton< EventManager ></a></td></tr>
<tr class="memitem:a7174af94e201bdaeab717cdbcbb2e565 inherit pub_methods_classMezzanine_1_1Singleton"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7174af94e201bdaeab717cdbcbb2e565"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Singleton.xhtml#a7174af94e201bdaeab717cdbcbb2e565">Singleton</a> ()</td></tr>
<tr class="memdesc:a7174af94e201bdaeab717cdbcbb2e565 inherit pub_methods_classMezzanine_1_1Singleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor. <br/></td></tr>
<tr class="memitem:a5e45fc3969b0fae3d095676cc515da1d inherit pub_methods_classMezzanine_1_1Singleton"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e45fc3969b0fae3d095676cc515da1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Singleton.xhtml#a5e45fc3969b0fae3d095676cc515da1d">~Singleton</a> ()</td></tr>
<tr class="memdesc:a5e45fc3969b0fae3d095676cc515da1d inherit pub_methods_classMezzanine_1_1Singleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a241e80fc1115c080af059dc4396f11bb"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a241e80fc1115c080af059dc4396f11bb">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classMezzanine_1_1EventManager.xhtml">Mezzanine::EventManager</a> &amp;Mgr)</td></tr>
<tr class="memdesc:a241e80fc1115c080af059dc4396f11bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the passed <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a> to <a class="el" href="namespaceMezzanine_1_1XML.xhtml" title="All tools for working with XML are located in this namespace.">XML</a>.  <a href="#a241e80fc1115c080af059dc4396f11bb"></a><br/></td></tr>
<tr class="memitem:a063bbbf2108e405b70c707090ba7eab0"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1EventManager.xhtml#a063bbbf2108e405b70c707090ba7eab0">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="classMezzanine_1_1EventManager.xhtml">Mezzanine::EventManager</a> &amp;Mgr)</td></tr>
<tr class="memdesc:a063bbbf2108e405b70c707090ba7eab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a>.  <a href="#a063bbbf2108e405b70c707090ba7eab0"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classMezzanine_1_1ManagerBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classMezzanine_1_1ManagerBase')"><img src="closed.png" alt="-"/>&nbsp;Public Types inherited from <a class="el" href="classMezzanine_1_1ManagerBase.xhtml">Mezzanine::ManagerBase</a></td></tr>
<tr class="memitem:ab23a9aa27c4e3cb58d902a149d3c6de2 inherit pub_types_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23a9aa27c4e3cb58d902a149d3c6de2"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab23a9aa27c4e3cb58d902a149d3c6de2">Callback</a> )()</td></tr>
<tr class="memdesc:ab23a9aa27c4e3cb58d902a149d3c6de2 inherit pub_types_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This makes working with Callback function pointer a bit easier. <br/></td></tr>
<tr class="memitem:a9a6f3e238f66cbc68dfec11e4160aa6c inherit pub_types_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>ManagerType</b> { <br/>
&#160;&#160;<b>ActorManager</b> =  1, 
<b>AudioManager</b>, 
<b>CameraManager</b>, 
<b>CollisionShapeManager</b>, 
<br/>
&#160;&#160;<b>EventManager</b>, 
<b>GraphicsManager</b>, 
<b>InputManager</b>, 
<b>LogManager</b>, 
<br/>
&#160;&#160;<b>MeshManager</b>, 
<b>NetworkManager</b>, 
<b>PagingManager</b>, 
<b>PhysicsManager</b>, 
<br/>
&#160;&#160;<b>ResourceManager</b>, 
<b>SceneManager</b>, 
<b>ScriptingManager</b>, 
<b>TerrainManager</b>, 
<br/>
&#160;&#160;<b>TimerManager</b>, 
<b>UIManager</b>, 
<b>UserCreated</b> =  512
<br/>
 }</td></tr>
<tr class="inherit_header pub_static_methods_classMezzanine_1_1ManagerBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classMezzanine_1_1ManagerBase')"><img src="closed.png" alt="-"/>&nbsp;Static Public Member Functions inherited from <a class="el" href="classMezzanine_1_1ManagerBase.xhtml">Mezzanine::ManagerBase</a></td></tr>
<tr class="memitem:a446009f2bdf870d4a135d65e941bc066 inherit pub_static_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceMezzanine.xhtml#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a446009f2bdf870d4a135d65e941bc066">GetTypeNameAsString</a> (const ManagerType &amp;ManagerType)</td></tr>
<tr class="memdesc:a446009f2bdf870d4a135d65e941bc066 inherit pub_static_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the string form of the type of manager.  <a href="#a446009f2bdf870d4a135d65e941bc066"></a><br/></td></tr>
<tr class="memitem:ae76f56a9d8585b96c3cda9f51368b60a inherit pub_static_methods_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">static ManagerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ae76f56a9d8585b96c3cda9f51368b60a">GetTypeNameFromString</a> (const <a class="el" href="namespaceMezzanine.xhtml#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a> &amp;ManagerName)</td></tr>
<tr class="memdesc:ae76f56a9d8585b96c3cda9f51368b60a inherit pub_static_methods_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of manager requested from a string.  <a href="#ae76f56a9d8585b96c3cda9f51368b60a"></a><br/></td></tr>
<tr class="inherit_header pub_static_methods_classMezzanine_1_1Singleton"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classMezzanine_1_1Singleton')"><img src="closed.png" alt="-"/>&nbsp;Static Public Member Functions inherited from <a class="el" href="classMezzanine_1_1Singleton.xhtml">Mezzanine::Singleton< EventManager ></a></td></tr>
<tr class="memitem:a78fc425584913f0b2c615ec440871a67 inherit pub_static_methods_classMezzanine_1_1Singleton"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMezzanine_1_1EventManager.xhtml">EventManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Singleton.xhtml#a78fc425584913f0b2c615ec440871a67">GetSingletonPtr</a> ()</td></tr>
<tr class="memdesc:a78fc425584913f0b2c615ec440871a67 inherit pub_static_methods_classMezzanine_1_1Singleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches a pointer to the singleton.  <a href="#a78fc425584913f0b2c615ec440871a67"></a><br/></td></tr>
<tr class="memitem:a554165fe3e4b594b678d64215fd7a6f9 inherit pub_static_methods_classMezzanine_1_1Singleton"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1Singleton.xhtml#a554165fe3e4b594b678d64215fd7a6f9">SingletonValid</a> ()</td></tr>
<tr class="memdesc:a554165fe3e4b594b678d64215fd7a6f9 inherit pub_static_methods_classMezzanine_1_1Singleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the singleton pointer is valid.  <a href="#a554165fe3e4b594b678d64215fd7a6f9"></a><br/></td></tr>
<tr class="inherit_header pro_attribs_classMezzanine_1_1ManagerBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classMezzanine_1_1ManagerBase')"><img src="closed.png" alt="-"/>&nbsp;Protected Attributes inherited from <a class="el" href="classMezzanine_1_1ManagerBase.xhtml">Mezzanine::ManagerBase</a></td></tr>
<tr class="memitem:ada3bad0fe77ff2fa7404eea7a5c16264 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ada3bad0fe77ff2fa7404eea7a5c16264">Initialized</a></td></tr>
<tr class="memdesc:ada3bad0fe77ff2fa7404eea7a5c16264 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple bool indicating whether or not this manager has been initialized.  <a href="#ada3bad0fe77ff2fa7404eea7a5c16264"></a><br/></td></tr>
<tr class="memitem:ab27f3f7458b9a6f2a08974d096125ed5 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab23a9aa27c4e3cb58d902a149d3c6de2">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab27f3f7458b9a6f2a08974d096125ed5">PostMainLoop</a></td></tr>
<tr class="memdesc:ab27f3f7458b9a6f2a08974d096125ed5 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a function pointer to the function that should be called after running Main Loop Items.  <a href="#ab27f3f7458b9a6f2a08974d096125ed5"></a><br/></td></tr>
<tr class="memitem:a1652110258237bc313a02757229d0f47 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ab23a9aa27c4e3cb58d902a149d3c6de2">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a1652110258237bc313a02757229d0f47">PreMainLoop</a></td></tr>
<tr class="memdesc:a1652110258237bc313a02757229d0f47 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a function pointer to the function that should be called before running Main Loop Items.  <a href="#a1652110258237bc313a02757229d0f47"></a><br/></td></tr>
<tr class="memitem:a96fb02bf2f4e8b4afe70dedd0d8c6ac9 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top">short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a96fb02bf2f4e8b4afe70dedd0d8c6ac9">Priority</a></td></tr>
<tr class="memdesc:a96fb02bf2f4e8b4afe70dedd0d8c6ac9 inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a weighting used by the main loop to decide what order the managers should be called in.  <a href="#a96fb02bf2f4e8b4afe70dedd0d8c6ac9"></a><br/></td></tr>
<tr class="memitem:ae619b4bd732d7345e0ef59ecde6d03cc inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMezzanine_1_1Entresol.xhtml">Entresol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ae619b4bd732d7345e0ef59ecde6d03cc">TheEntresol</a></td></tr>
<tr class="memdesc:ae619b4bd732d7345e0ef59ecde6d03cc inherit pro_attribs_classMezzanine_1_1ManagerBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual pointer to the world.  <a href="#ae619b4bd732d7345e0ef59ecde6d03cc"></a><br/></td></tr>
<tr class="inherit_header pro_static_attribs_classMezzanine_1_1Singleton"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classMezzanine_1_1Singleton')"><img src="closed.png" alt="-"/>&nbsp;Static Protected Attributes inherited from <a class="el" href="classMezzanine_1_1Singleton.xhtml">Mezzanine::Singleton< EventManager ></a></td></tr>
<tr class="memitem:a0db9959ccd7daa1345f4567aa0b0655d inherit pro_static_attribs_classMezzanine_1_1Singleton"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0db9959ccd7daa1345f4567aa0b0655d"></a>
static <a class="el" href="classMezzanine_1_1EventManager.xhtml">EventManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>SingletonPtr</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is a container for Events and facilitates the transfer of data. </p>
<p>The Event Manager Exists to passed important information about Gamestate from where it is generated to where it is needed. It is the Game Developers option whether they want to grab events directly using the get functions that have filters, or if they want to get all the events at once from a central location and dispatch form there. <br/>
 Since all User input comes in the form of events, this is also where user input Polling and optional input sources like Joysticks are controlled from. <br/>
 All of these event are stored in an internal Queue and order is preserved. So the First item In will be the First Out (FIFO). This is not strictly a FIFO buffer, there are a number of functions for getting of managing specific kinds of events. Generally these 'Filtered' management functions Still return the first of those kinds of event. </p>
<dl class="section warning"><dt>Warning</dt><dd>Delete pointers you get from this. Anything can create events and Put them here, and anything can get them out, This means the simple way to not cause memory leaks is to have the routines extracting the events delete the events. </dd>
<dd>
Currently this is not thread safe, even though it should be. </dd></dl>

<p>Definition at line <a class="el" href="eventmanager_8h_source.xhtml#l00121">121</a> of file <a class="el" href="eventmanager_8h_source.xhtml">eventmanager.h</a>.</p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a95ce9d2d865b0d8d9468448969b0ade2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mezzanine::EventManager::EventManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This creates an empty EventManger </p>

</div>
</div>
<a class="anchor" id="abf3650bfe862473ed2418dddbd83eec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mezzanine::EventManager::EventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1XML_1_1Node.xhtml">XML::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>XMLNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceMezzanine_1_1XML.xhtml" title="All tools for working with XML are located in this namespace.">XML</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">XMLNode</td><td>The node of the xml document to construct from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39b9e0f783c2ab0d39f5574a7a106141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mezzanine::EventManager::~EventManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Deconstructor. </p>
<p>This deletes everything still in the event manager and tears it down. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="aa791c61d2665422614d54c7653e87e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::AddEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *&#160;</td>
          <td class="paramname"><em>EventToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an event of any kind to the end of the Event Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EventToAdd</td><td>This is a pointer to an Event.</td></tr>
  </table>
  </dd>
</dl>
<p>This adds the existing event to the Queue. Be careful this is not delete, and does not go out of scope. Deleting the Event is now the responsibilty of the code that pulls it out of Event Manager. </p>

</div>
</div>
<a class="anchor" id="a2da4ef46b2ce56206412782eec43d93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::AddPollingCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1MetaCode.xhtml">MetaCode</a> &amp;&#160;</td>
          <td class="paramname"><em>InputToTryPolling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates extra events each iteration of the main loop, based on user input polling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputToTryPolling</td><td>This accepts a <a class="el" href="classMezzanine_1_1MetaCode.xhtml" title="This Determines the kind of user input.">MetaCode</a> and will try to watch for occurences like this one</td></tr>
  </table>
  </dd>
</dl>
<p>This will trigger the input system to generate an event (or add to an exiting event) when polling for the given kind of event. Each Iteration of the main loop there will be a <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a> that created. That Event will Include all the normal metacodes for user input that happened, and it will also have a meta code for each time this function was called. The added metacode may be partialky ignored, the Metavalue is almost always ignored, and in a situation where the can only be one of a given input on a system, the ID is ignore and 0 is assumed. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Unsupported Polling Check on this Platform</td><td>When the metacode passed cannot be polled on this platform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cf0fd9e33392aa24e9a735363212185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::DetectJoysticks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look for Joysticks that are hooked up to the system. </p>
<p>Currently this will only find the first joystick. This only needs to be done once after the joystick has been connected and detected/configured by the operating system. Joystick events may not be added if this has not been called. The is called once at when the Event manager is contructed, but if the joystick was not connected yet then it might not be found. </p>

</div>
</div>
<a class="anchor" id="a0a3d6cc2efbb528f35694c0157976c7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Mezzanine::EventManager::DoMainLoopItems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main loop calls this once per frame.  </p>
<p>This is where each manager is expected to put anything that needs to be run each iteration of the main loop  </p>

<p>Implements <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a4ee29e4baf6c4b9a3bfec1b2258d5cd2">Mezzanine::ManagerBase</a>.</p>

</div>
</div>
<a class="anchor" id="aecbaa2cfdffc3dc10db2f4b0146bbe27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classMezzanine_1_1EventCollision.xhtml">EventCollision</a>*&gt;* Mezzanine::EventManager::GetAllCollisionEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a complete list of all the Collision Events. </p>
<p>This finds all the Collision Events then creates a new list and returns that. This runs in linear time relative to the amounts of events. </p>
<dl class="section return"><dt>Returns</dt><dd>This returns a list&lt;EventCollision*&gt; pointer which is this a subset of this classes event pointer list. Use this carefully, it can cause errors if used improperly. This list pointer must be deleted, but not the events in it. </dd></dl>

</div>
</div>
<a class="anchor" id="a30d4178ebdcc6f145ffdeb5e656e02ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classMezzanine_1_1EventGameWindow.xhtml">EventGameWindow</a>*&gt;* Mezzanine::EventManager::GetAllGameWindowEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a complete list of all the Render <a class="el" href="structMezzanine_1_1Time.xhtml" title="A container for the metrics of time relevant for the timer class.">Time</a> events. </p>
<p>This finds all the <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a> Events then creates a new list and returns that. This runs in linear time relative to the amounts of events. </p>
<dl class="section return"><dt>Returns</dt><dd>This returns a list&lt;EventGameWindow*&gt; pointer which is this a subset of this classes event pointer list. Use this carefully, it can cause errors if used improperly. This list pointer must be deleted, but not the events in it. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f374c33be1d1f0a0c5315d299ed7f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classMezzanine_1_1EventQuit.xhtml">EventQuit</a>*&gt;* Mezzanine::EventManager::GetAllQuitEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a complete list of all the quit events. </p>
<p>This finds all the <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> Events then creates a new list and returns that. This runs in linear time relative to the amounts of events. </p>
<dl class="section warning"><dt>Warning</dt><dd>Something is wrong if you have more than a few quit events. These should be checked for in each iteration of the main loop. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This returns a std::list&lt;EventQuit*&gt; pointer which is this a subset of this classes event pointer list. Use this carefully, it can cause errors if used improperly. Additionally this list pointer must be deleted, but not the events in it. </dd></dl>

</div>
</div>
<a class="anchor" id="a045496478f798eb263477bf1b6ae2930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classMezzanine_1_1EventRenderTime.xhtml">EventRenderTime</a>*&gt;* Mezzanine::EventManager::GetAllRenderTimeEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a complete list of all the Render <a class="el" href="structMezzanine_1_1Time.xhtml" title="A container for the metrics of time relevant for the timer class.">Time</a> events. </p>
<p>This finds all the <a class="el" href="classMezzanine_1_1EventRenderTime.xhtml" title="This communicates the amount of time since the world was rendered.">EventRenderTime</a> Events then creates a new list and returns that. This runs in linear time relative to the amounts of events. </p>
<dl class="section return"><dt>Returns</dt><dd>This returns a list&lt;EventRenderTime*&gt; pointer which is this a subset of this classes event pointer list. Use this carefully, it can cause errors if used improperly. Additionally this list pointer must be deleted, but not the events in it. </dd></dl>

</div>
</div>
<a class="anchor" id="a1728f075217522f266186a1e9c01426f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a>*&gt;* Mezzanine::EventManager::GetAllSpecificEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a>&#160;</td>
          <td class="paramname"><em>SpecificType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a complete list of all the specified events. </p>
<p>This finds all the events that are of the specified type in the event manager, then creates a new list and return that. This runs in linear time relative to the amounts of events. </p>
<dl class="section warning"><dt>Warning</dt><dd>The pointers contained in this list must be used carefully. Do not delete them, this will cause errors. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This returns a std::list&lt;EventBase*&gt; pointer which is this a subset of this classes event pointer list. Use this carefully, it can cause errors if used improperly. Additionally this list pointer must be deleted, but not the events in it. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9ca42a030761beb40e0ac808443c334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classMezzanine_1_1EventUserInput.xhtml">EventUserInput</a>*&gt;* Mezzanine::EventManager::GetAllUserInputEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This returns a complete list of all the User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> events. </p>
<p>This finds all the <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a> Events then creates a new list and returns that. This runs in linear time relative to the amounts of events. </p>
<dl class="section return"><dt>Returns</dt><dd>This returns a std::list&lt;EventUserInput*&gt; pointer which is this a subset of this classes event pointer list. Use this carefully, it can cause errors if used improperly. Additionally this list pointer must be deleted, but not the events in it. </dd></dl>

</div>
</div>
<a class="anchor" id="ab77895920f1fca668d8dee6dbf7c2e07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceMezzanine.xhtml#acf9fcc130e6ebf08e3d8491aebcf1c86">String</a> Mezzanine::EventManager::GetImplementationTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This Allows any manager name to be sent to a stream. Primarily used for logging.  </p>
<p><dl class="section return"><dt>Returns</dt><dd>This returns a String that contains the name. </dd></dl>
 </p>

<p>Implements <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#ac41d60f674e75d3d16b5544f4feb199c">Mezzanine::ManagerBase</a>.</p>

</div>
</div>
<a class="anchor" id="aa99549992a346234799b4043baa01de3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ManagerType Mezzanine::EventManager::GetInterfaceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns the type of this manager.  </p>
<p>This is intended to make using and casting from Manager base easier. With this is is possible to cast from <a class="el" href="classMezzanine_1_1ManagerBase.xhtml" title="This is the base class from which all the World Managers inherit.">ManagerBase</a> to the correct Manager Type. </p>
<dl class="section return"><dt>Returns</dt><dd>This returns a ManagerTypeName to identify what this can be safely cast to. </dd></dl>
 </p>

<p>Implements <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a388aa37ed71b8667785b789c137aa8c6">Mezzanine::ManagerBase</a>.</p>

</div>
</div>
<a class="anchor" id="accd05e5d1ab12e96febd9513d9a7c7d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventCollision.xhtml">EventCollision</a>* Mezzanine::EventManager::GetNextCollisionEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next Collision event. </p>
<p>This Filtered event management function returns a pointer to the next Collision event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no Collision events in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventCollision.xhtml" title="This is an event class used to track collsions in the physics world.">EventCollision</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="acc384c86846251daeb046c350331325e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a>* Mezzanine::EventManager::GetNextEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the Next event. </p>
<p>This returns a pointer to the next Event. It is advisable to use this for performance reasons because it runs in constant time. However it does not return a specific kind of event, and must be cast in order to use the true content. This returns a pointer to 0 if there are no events in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a Event, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5cfb6cd66c2da5957004a24c63db430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventGameWindow.xhtml">EventGameWindow</a>* Mezzanine::EventManager::GetNextGameWindowEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next GameWindow event. </p>
<p>This Filtered event management function returns a pointer to the next GameWindow event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no GameWindow events in the que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventGameWindow.xhtml" title="Convey the message that Something happened to a game window.">EventGameWindow</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a47a088031994a3637bf82d474f92edab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventQuit.xhtml">EventQuit</a>* Mezzanine::EventManager::GetNextQuitEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a>. </p>
<p>This Filtered event management function returns a pointer to the next <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a>. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> events in the que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a30ffa2db08501d04a5b6f7b42dbb5d7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventRenderTime.xhtml">EventRenderTime</a>* Mezzanine::EventManager::GetNextRenderTimeEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next Rendertime event. </p>
<p>This Filtered event management function returns a pointer to the next Rendertime event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no <a class="el" href="classMezzanine_1_1EventRenderTime.xhtml" title="This communicates the amount of time since the world was rendered.">EventRenderTime</a> events in the que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventRenderTime.xhtml" title="This communicates the amount of time since the world was rendered.">EventRenderTime</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a4be1f66f9f731ea390a7d4d6494dcdbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a>* Mezzanine::EventManager::GetNextSpecificEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a>&#160;</td>
          <td class="paramname"><em>SpecificType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next kind event of the Specified type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpecificType</td><td>This is a Event::EventType that defines the type you want this to work with</td></tr>
  </table>
  </dd>
</dl>
<p>This and the other NextSpecificEvent functions are the core of the Event Filtering System. In general the other filtering functions call one of these and does very little work on their own. <br/>
 This performs a linear search starting with the oldest (first entered Events) and simply checks if it the of the correct type. Then this returns a pointer to the next event of the specified type, or returns a pointer to 0 if there are none of the correct pointers in the Que. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a1049a36dc6c981a8c7d816a180bb7f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventUserInput.xhtml">EventUserInput</a>* Mezzanine::EventManager::GetNextUserInputEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> event. </p>
<p>This Filtered event management function returns a pointer to the next User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> events in the que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3f1b41578307c7ac801340b275af027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Mezzanine::EventManager::GetRemainingEventCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a count of events. </p>
<p>This returns a total count of all events stored in this <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">EventManager</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>This returns an unsigned integer with the amount of of total events </dd></dl>

</div>
</div>
<a class="anchor" id="a48c9a0c34b666736f5d1cc6d4a9a983f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Mezzanine::EventManager::Initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure Items requiring other Managers.  </p>
<p>If you are using the <a class="el" href="classMezzanine_1_1World.xhtml">Mezzanine::World</a> this is called when Mezzanine::World::GameInit() is called. It is expected that by the time this is called either ManagerBase::ManagerBase(World*) or ManagerBase::SetGameWorld(World*) will have been called. This is where all configuration that requires atleast one other manager on the <a class="el" href="classMezzanine_1_1World.xhtml">Mezzanine::World</a> to exist.<br/>
<br/>
 Yes we know it is spelled wrong, but are Zs cooler anyway.  </p>

<p>Implements <a class="el" href="classMezzanine_1_1ManagerBase.xhtml#a864e3cac11928a602c1db28fa2d52ee2">Mezzanine::ManagerBase</a>.</p>

</div>
</div>
<a class="anchor" id="ab5ddd669f45aaf0210777807a9f0a7c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventCollision.xhtml">EventCollision</a>* Mezzanine::EventManager::PopNextCollisionEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next Collision event and removes it from the Que. </p>
<p>This Filtered event management function returns a pointer to the next Collision event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no Collision events in the que. This also removes the returned pointer form the Queue. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventRenderTime.xhtml" title="This communicates the amount of time since the world was rendered.">EventRenderTime</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a3edb93529db1ded51ddeccf10ea6e17e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a>* Mezzanine::EventManager::PopNextEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the Next event, and removes the Event from storage. </p>
<p>This functions just like GetNextEvent , except that it also removes the item from the internal storage of the <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">EventManager</a>. This returns a pointer to 0 if there are no events in the que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a Event, that will need to be deleted once it has been used. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ec49cc795bfbe0270f8ab09d02639d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventGameWindow.xhtml">EventGameWindow</a>* Mezzanine::EventManager::PopNextGameWindowEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next GameWindow event and removes it from the Que. </p>
<p>This Filtered event management function returns a pointer to the next GameWindow event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no GameWindow events in the que. This also removes the returned pointer form the Que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventRenderTime.xhtml" title="This communicates the amount of time since the world was rendered.">EventRenderTime</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="ade1d2d4f31cb0d89ec038fc6ec498181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventQuit.xhtml">EventQuit</a>* Mezzanine::EventManager::PopNextQuitEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> and removes it from the Que. </p>
<p>This Filtered event management function returns a pointer to the next <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a>. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> events in the que. This also removes the returned pointer form the Que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="af5feae2419180bb856d19dfdfff1ffb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventRenderTime.xhtml">EventRenderTime</a>* Mezzanine::EventManager::PopNextRenderTimeEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next Rendertime event and removes it from the Que. </p>
<p>This Filtered event management function returns a pointer to the next Rendertime event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no rendertime events in the que. This also removes the returned pointer form the Que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventRenderTime.xhtml" title="This communicates the amount of time since the world was rendered.">EventRenderTime</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="adffc75d1a715167011b005df3f76e4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a>* Mezzanine::EventManager::PopNextSpecificEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a>&#160;</td>
          <td class="paramname"><em>SpecificType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next kind event of the Specified type, and removes it from the Que. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpecificType</td><td>This is a Event::EventType that defines the type you want this to work with</td></tr>
  </table>
  </dd>
</dl>
<p>This is just like GetNextSpecificEvent(Event::EventType SpecificType) but it also removes the item from the Que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a54f836733044afe17bf3ce9aa6a5f8ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMezzanine_1_1EventUserInput.xhtml">EventUserInput</a>* Mezzanine::EventManager::PopNextUserInputEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> event and removes it from the Que. </p>
<p>This Filtered event management function returns a pointer to the next User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> event. It is inadvisable to use this for performance reasons because it runs in linear time relative to the amount of events. However, it will return an immediately usable pointer for case where an extreme level of performance is not required. This returns a pointer to 0 if there are no User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> events in the que. This also removes the returned pointer form the Que. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a>, that still needs to be removed from the event manager and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="a209b69a260ea1a2351e005802d13803b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveAllSpecificEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a>&#160;</td>
          <td class="paramname"><em>SpecificType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This removes all the events of the specified type. </p>
<p>This finds all the events that are of the specified type in the event manager, then removes them. </p>
<dl class="section warning"><dt>Warning</dt><dd>This does not delete the events. This is a memory leak unless used with GetAllSpecificEvents so that the events can be tracked indeendantly, and deleted. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3a90f7fdd0b75b4e4ff5e5d3ad3e332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventBase.xhtml">EventBase</a> *&#160;</td>
          <td class="paramname"><em>EventToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an event of any kind from the Event Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">EventToRemove</td><td>Pointer to the event that will be removed.</td></tr>
  </table>
  </dd>
</dl>
<p>In most cases you will want to use the <a class="el" href="classMezzanine_1_1EventManager.xhtml#a3edb93529db1ded51ddeccf10ea6e17e" title="Return a pointer to the Next event, and removes the Event from storage.">PopNextEvent()</a> methods when going through events. In some expert use cases however you may want to remove a specific event at an arbitrary place in the Queue. This is the method for doing so. </p>

</div>
</div>
<a class="anchor" id="ac35a0aa7e6e98a8024025f3babd40749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveNextCollisionEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the First Collision Event From the que without looking at it. </p>
<p>This together with <a class="el" href="classMezzanine_1_1EventManager.xhtml#accd05e5d1ab12e96febd9513d9a7c7d9" title="Returns a pointer to the Next Collision event.">GetNextCollisionEvent()</a> are the pretty much same as call <a class="el" href="classMezzanine_1_1EventManager.xhtml#ab5ddd669f45aaf0210777807a9f0a7c0" title="Returns a pointer to the Next Collision event and removes it from the Que.">PopNextCollisionEvent()</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not call <a class="el" href="classMezzanine_1_1EventManager.xhtml#accd05e5d1ab12e96febd9513d9a7c7d9" title="Returns a pointer to the Next Collision event.">GetNextCollisionEvent()</a> and haven't deleted or stored, or somehow dealt with this pointer, then this is a memory leak. Don't use this unless you are certain you have taken care of the pointer appropriately. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>can throw any STL exception a queue could. And with likely throw some kind of except if called when there are no Events in the Que. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0694b97c1b9696f5b28d0baf7a2f7c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveNextEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an Event From the que without looking at it. </p>
<p>This together with <a class="el" href="classMezzanine_1_1EventManager.xhtml#acc384c86846251daeb046c350331325e" title="Return a pointer to the Next event.">GetNextEvent()</a> are the same as call <a class="el" href="classMezzanine_1_1EventManager.xhtml#a3edb93529db1ded51ddeccf10ea6e17e" title="Return a pointer to the Next event, and removes the Event from storage.">PopNextEvent()</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not call <a class="el" href="classMezzanine_1_1EventManager.xhtml#acc384c86846251daeb046c350331325e" title="Return a pointer to the Next event.">GetNextEvent()</a> and haven't deleted or stored, or somehow dealt with this pointer, then this is a memory leak. Don't use this unless you are certain you have taken care of the pointer appropriately </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>can throw any STL exception a que could. <a class="el" href="classMezzanine_1_1Any.xhtml" title="This is a simple class used for type-safe casting of any type of data.">Any</a> with likely throw some kind of except if called when there are no Events in the Que. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6108fd63aed85b5a3f38987f75603c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveNextGameWindowEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the First GameWindow Event From the que without looking at it. </p>
<p>This together with <a class="el" href="classMezzanine_1_1EventManager.xhtml#ac5cfb6cd66c2da5957004a24c63db430" title="Returns a pointer to the Next GameWindow event.">GetNextGameWindowEvent()</a> are the pretty much same as call <a class="el" href="classMezzanine_1_1EventManager.xhtml#a3ec49cc795bfbe0270f8ab09d02639d0" title="Returns a pointer to the Next GameWindow event and removes it from the Que.">PopNextGameWindowEvent()</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not call <a class="el" href="classMezzanine_1_1EventManager.xhtml#ac5cfb6cd66c2da5957004a24c63db430" title="Returns a pointer to the Next GameWindow event.">GetNextGameWindowEvent()</a> and haven't deleted or stored, or somehow dealt with this pointer, then this is a memory leak. Don't use this unless you are certain you have taken care of the pointer appropriately </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>can throw any STL exception a queue could. And with likely throw some kind of except if called when there are no Events in the Que. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10735469d564d6731c3741acf265879c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveNextQuitEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the First <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> From the que without looking at it. </p>
<p>This together with <a class="el" href="classMezzanine_1_1EventManager.xhtml#a47a088031994a3637bf82d474f92edab" title="Returns a pointer to the Next EventQuit.">GetNextQuitEvent()</a> are the pretty much same as call <a class="el" href="classMezzanine_1_1EventManager.xhtml#ade1d2d4f31cb0d89ec038fc6ec498181" title="Returns a pointer to the Next EventQuit and removes it from the Que.">PopNextQuitEvent()</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not call <a class="el" href="classMezzanine_1_1EventManager.xhtml#a47a088031994a3637bf82d474f92edab" title="Returns a pointer to the Next EventQuit.">GetNextQuitEvent()</a> and haven't deleted or stored, or somehow dealt with this pointer, then this is a memory leak. Don't use this unless you are certain you have taken care of the pointer appropriately </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>can throw any STL exception a queue could. And with likely throw some kind of except if called when there are no Events in the Que. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a0b6340a0b0a6a96b7918f758f44c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveNextRenderTimeEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the First Rendertime Event From the que without looking at it. </p>
<p>This together with <a class="el" href="classMezzanine_1_1EventManager.xhtml#a30ffa2db08501d04a5b6f7b42dbb5d7e" title="Returns a pointer to the Next Rendertime event.">GetNextRenderTimeEvent()</a> are the pretty much same as call <a class="el" href="classMezzanine_1_1EventManager.xhtml#af5feae2419180bb856d19dfdfff1ffb7" title="Returns a pointer to the Next Rendertime event and removes it from the Que.">PopNextRenderTimeEvent()</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not call <a class="el" href="classMezzanine_1_1EventManager.xhtml#a30ffa2db08501d04a5b6f7b42dbb5d7e" title="Returns a pointer to the Next Rendertime event.">GetNextRenderTimeEvent()</a> and haven't deleted or stored, or somehow dealt with this pointer, then this is a memory leak. Don't use this unless you are certain you have taken care of the pointer appropriately </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>can throw any STL exception a queue could. And with likely throw some kind of except if called when there are no Events in the Que. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fe12f47a64f3af8dcb30f13ee60e303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveNextSpecificEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventBase.xhtml#ab85e31e97753b7e7ecb098f82526baef">EventBase::EventType</a>&#160;</td>
          <td class="paramname"><em>SpecificType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the Next kind event of the Specified type, and removes it from the Que. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SpecificType</td><td>This is a Event::EventType that defines the type you want this to work with</td></tr>
  </table>
  </dd>
</dl>
<p>This is just like PopNextSpecificEvent(Event::EventType SpecificType) but exept it doesn't bother with any of the needed structure involved with returning data, and just removes the specific event from the Queue. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not call GetNextSpecificEvent(Event::EventType SpecificType) and haven't deleted or stored, or somehow dealt with this pointer, then this is a memory leak. Don't use this unless you are certain you have taken care of the pointer appropriately. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>can throw any STL exception a queue could. And with likely throw some kind of except if called when there are no Events in the Que. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d2681b16ec802f8271f2651ff40c083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemoveNextUserInputEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the First User <a class="el" href="namespaceMezzanine_1_1Input.xhtml" title="This namespace is for all the classes belonging to the Input Subsystem.">Input</a> Event From the que without looking at it. </p>
<p>This together with <a class="el" href="classMezzanine_1_1EventManager.xhtml#a1049a36dc6c981a8c7d816a180bb7f09" title="Returns a pointer to the Next User Input event.">GetNextUserInputEvent()</a> are the pretty much same as call <a class="el" href="classMezzanine_1_1EventManager.xhtml#a54f836733044afe17bf3ce9aa6a5f8ae" title="Returns a pointer to the Next User Input event and removes it from the Que.">PopNextUserInputEvent()</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>If you did not call <a class="el" href="classMezzanine_1_1EventManager.xhtml#a1049a36dc6c981a8c7d816a180bb7f09" title="Returns a pointer to the Next User Input event.">GetNextUserInputEvent()</a> and haven't deleted or stored, or somehow dealt with this pointer, then this is a memory leak. Don't use this unless you are certain you have taken care of the pointer appropriately </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">This</td><td>can throw any STL exception a queue could. And with likely throw some kind of except if called when there are no Events in the Que. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a446cab99c7c67b42e28753cda14d79a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::RemovePollingCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1MetaCode.xhtml">MetaCode</a> &amp;&#160;</td>
          <td class="paramname"><em>InputToStopPolling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes Events from the list(s) of what needs to be polled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InputToStopPolling</td><td>This accepts a <a class="el" href="classMezzanine_1_1MetaCode.xhtml" title="This Determines the kind of user input.">MetaCode</a> and will try to Remove Watches like this one</td></tr>
  </table>
  </dd>
</dl>
<p>This will remove any check for polling that share the same inputcode and ID. This </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Polling check not present</td><td>Is thrown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07119a541a60a515e2108c79cf6e3aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Mezzanine::EventManager::UpdateEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pulls Events from the all the subsystems for use in the <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">EventManager</a>. </p>
<p>The work this function does is already performed in the main loop. This only really needs to be used If a game developer chooses to use his own main loop. This adds system events, like <a class="el" href="classMezzanine_1_1EventQuit.xhtml" title="This is intended to convey the message that quitting needs to happen.">EventQuit</a> and Other Windows manager events, and if any user input event actions, this generates one <a class="el" href="classMezzanine_1_1EventUserInput.xhtml" title="This is a container for MetaCodes that is used in the EventManager.">EventUserInput</a> that stores everythin that happened. </p>

</div>
</div>
<h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a241e80fc1115c080af059dc4396f11bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMezzanine_1_1EventManager.xhtml">Mezzanine::EventManager</a> &amp;&#160;</td>
          <td class="paramname"><em>Mgr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes the passed <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a> to <a class="el" href="namespaceMezzanine_1_1XML.xhtml" title="All tools for working with XML are located in this namespace.">XML</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The ostream to send the xml to. </td></tr>
    <tr><td class="paramname">Mgr</td><td>the <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a> to be serialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this returns the ostream, now with the serialized data </dd></dl>

</div>
</div>
<a class="anchor" id="a063bbbf2108e405b70c707090ba7eab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMezzanine_1_1EventManager.xhtml">Mezzanine::EventManager</a> &amp;&#160;</td>
          <td class="paramname"><em>Mgr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize a <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The istream to get the xml from to (re)make the <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a>. </td></tr>
    <tr><td class="paramname">Mgr</td><td>the <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a> to be deserialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this returns the ostream, advanced past the <a class="el" href="classMezzanine_1_1EventManager.xhtml" title="This is a container for Events and facilitates the transfer of data.">Mezzanine::EventManager</a> that was recreated onto Ev. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/sqeaky/Code/Mezzanine/Mezzanine/src/<a class="el" href="eventmanager_8h_source.xhtml">eventmanager.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 9 2013 23:03:26 for MezzanineEngine by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2</small></address>
</body>
</html>
