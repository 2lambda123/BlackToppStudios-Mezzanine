<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PhysGameEngine: phys::xml Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PhysGameEngine&#160;<span id="projectnumber">August 3, 2011</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1><a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> Manual </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="XMLTOC"></a>
Table Of Contents</h2>
<ul>
<li><a class="el" href="XMLManual.html#XMLOverview">Overview</a><ul>
<li><a class="el" href="XMLManual.html#XMLIntroduction">Introduction</a></li>
<li><a class="el" href="XMLManual.html#XMLFeedBack">FeedBack</a></li>
<li><a class="el" href="XMLManual.html#XMLAcknowledgments">Acknowledgments</a></li>
<li><a class="el" href="XMLManual.html#XMLLicense">License</a></li>
</ul>
</li>
<li><a class="el" href="XMLManual.html#XMLDOM">Document Object Model</a></li>
<li><a class="el" href="XMLManual.html#XMLLoading">Loading Documents</a></li>
<li><a class="el" href="XMLManual.html#XMLAccessing">Accessing Document Data</a></li>
<li><a class="el" href="XMLManual.html#XMLModifying">Modifiying Document</a></li>
<li><a class="el" href="XMLManual.html#XMLSaving">Saving Documents</a></li>
<li><a class="el" href="XMLManual.html#XMLXPath">XMLXPath</a> <br/>
 <br/>
 </li>
</ul>
<h2><a class="anchor" id="XMLOverview"></a>
Overview</h2>
<ul>
<li><a class="el" href="XMLManual.html#XMLIntroduction">Introduction</a></li>
<li><a class="el" href="XMLManual.html#XMLFeedBack">FeedBack</a></li>
<li><a class="el" href="XMLManual.html#XMLAcknowledgments">Acknowledgments</a></li>
<li><a class="el" href="XMLManual.html#XMLLicense">License</a></li>
</ul>
<h3><a class="anchor" id="XMLIntroduction"></a>
Introduction</h3>
<p><a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> is a light-weight C++ XML processing library. It consists of a DOM-like interface with rich traversal/modification capabilities, an extremely fast XML parser which constructs the DOM tree from an XML file/buffer, and an <a class="el" href="classphys_1_1xml_1_1XPathQuery.html">XPath 1.0 implementation</a> for complex data-driven tree queries. Full Unicode support is also available, with <a class="el" href="XMLManual.html#XMLUnicode">two Unicode interface variants</a> and conversions between different Unicode encodings (which happen automatically during parsing/saving). <br/>
 <br/>
 <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> enables very fast, convenient and memory-efficient XML document processing. However, since <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> has a DOM parser, it can't process XML documents that do not fit in memory; also the parser is a non-validating one, so if you need DTD or XML Schema validation, the XML parser is not for you. <br/>
 <br/>
 This is the complete manual for <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a>, which describes all features of the library in detail. If you want to start writing code as quickly as possible, you are advised to <a class="el" href="XMLQuickStart.html">read the quick start guide first</a>. </p>
<h3><a class="anchor" id="XMLFeedBack"></a>
FeedBack</h3>
<p>If you believe you've found a bug in <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> (bugs include compilation problems (errors/warnings), crashes, performance degradation and incorrect behavior), please contact Blacktopp Studios Inc ( <a href="http://www.blacktoppstudios.com/">http://www.blacktoppstudios.com/</a> ) . We check the the Forums ( <a href="http://www.blacktoppstudios.com/?page_id=753">http://www.blacktoppstudios.com/?page_id=753</a> ) and items sent by our contact form ( <a href="http://www.blacktoppstudios.com/?page_id=33">http://www.blacktoppstudios.com/?page_id=33</a> ) regularly. Be sure to include the relevant information so that the bug can be reproduced: the version of <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a>, compiler version and target architecture, the code that uses <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> and exhibits the bug, etc. <br/>
 <br/>
 Feature requests can be reported the same way as bugs, so if you're missing some functionality in <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> or if the API is rough in some places and you can suggest an improvement, please let us know. However, please note that there are many factors when considering API changes (compatibility with previous versions, API redundancy, etc.). <br/>
 <br/>
 If you have a contribution to <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a>, such as build script for some build system/IDE, or a well-designed set of helper functions, or a binding to some language other than C++, please let us know. You can include the relevant patches as issue attachments. We will have to communicate on the Licensing terms of your contribution though. <br/>
 <br/>
 If the provided methods of contact have an issue or not possible due to privacy or other concerns, you can contact the <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> author ( <a href="mailto:toppij@blacktoppstudios.com">toppij@blacktoppstudios.com</a> ) or pugixml author ( <a href="mailto:arseny.kapoulkine@gmail.com">arseny.kapoulkine@gmail.com</a> ) by e-mail directly. If you have an issue that pertains to pugixml and not <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> you can visit the pugixml issue submission form ( <a href="http://code.google.com/p/pugixml/issues/entry">http://code.google.com/p/pugixml/issues/entry</a> ) of the pugixml feature request form ( <a href="http://code.google.com/p/pugixml/issues/entry?template=Feature%20request">http://code.google.com/p/pugixml/issues/entry?template=Feature%20request</a> ). </p>
<h3><a class="anchor" id="XMLAcknowledgments"></a>
Acknowledgments</h3>
<p><a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> and pugixml could not be developed without the help from many people; some of them are listed in this section. If you've played a part in <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> or pugixml development and you can not find yourself on this list, I'm truly sorry; please send me an e-mail ( <a href="mailto:toppij@blacktoppstudios.com">toppij@blacktoppstudios.com</a> ) so I can fix this. <br/>
 <br/>
 Thanks to <b>Arseny</b> <b>Kapoulkine</b> for pugixml parser, which was used as a basis for <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a>. <br/>
 <br/>
 Thanks to <b>Kristen</b> <b>Wegner</b> for pugxml parser, which was used as a basis for pugixml. <br/>
 <br/>
 Thanks to <b>Neville</b> <b>Franks</b> for contributions to pugxml parser. <br/>
 <br/>
 Thanks to <b>Artyom</b> <b>Palvelev</b> for suggesting a lazy gap contraction approach. <br/>
 <br/>
 Thanks to <b>Vyacheslav</b> <b>Egorov</b> for documentation proofreading. </p>
<h3><a class="anchor" id="XMLLicense"></a>
License</h3>
<p>With written permission as per <a class="el" href="OriginalpugixmlLicense.html">The original pugixml license</a> we he sublicensed <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> under the <a class="el" href="GPLLicense.html">GPL Version 3</a>. In short This allows you to use <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> however you like with a few restrictions. If you change <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> you need to make the changes publically available. If you make software using <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> you need to make the source code publicly available. You may not use and Digital Rights Management (DRM) software to limit how others use the combined work you make. You can sell resulting works, but not through a digital distribution store that uses DRM.</p>
<h2><a class="anchor" id="XMLDOM"></a>
Document Object Model</h2>
<p><a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> stores XML data in DOM-like way: the entire XML document (both document structure and element data) is stored in memory as a tree. The tree can be loaded from a character stream (file, string, C++ I/O stream), then traversed with the special API or XPath expressions. The whole tree is mutable: both node structure and node/attribute data can be changed at any time. Finally, the result of document transformations can be saved to a character stream (file, C++ I/O stream or custom transport).</p>
<ul>
<li><a class="el" href="XMLManual.html#XMLTreeStructure">Tree structure</a></li>
<li><a class="el" href="XMLManual.html#XMLInterface">C++ interface</a></li>
<li><a class="el" href="XMLManual.html#XMLUnicode">Unicode Interface</a></li>
<li><a class="el" href="XMLManual.html#XMLThreadSafety">Thread-safety guarantees</a></li>
<li><a class="el" href="XMLManual.html#XMLExceptionSafety">Exception guarantees</a></li>
<li><a class="el" href="XMLManual.html#XMLMemory">Memory management</a><ul>
<li><a class="el" href="XMLManual.html#XMLCustomAlloc">Custom memory allocation/deallocation functions</a></li>
<li><a class="el" href="XMLManual.html#XMLMemoryInternals">Document memory management internals</a> </li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="XMLTreeStructure"></a>
Tree structure</h3>
<p>The XML document is represented with a tree data structure. The root of the tree is the document itself, which corresponds to C++ type <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a>. A Document has one or more child nodes, which correspond to C++ type <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a>. Nodes have different types; depending on a type, a node can have a collection of child nodes, a collection of attributes, which correspond to C++ type <a class="el" href="classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">phys::xml::Attribute</a>, and some additional data (i.e. Name). <br/>
 <br/>
 The tree nodes can be of one of the following types (which together form the enumeration <a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3" title="The types of nodes.">phys::xml::NodeType</a>):</p>
<ul>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodeDocument Document node</a> - This is the root of the tree, which consists of several child nodes. This node corresponds to <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> class; note that <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> is a sub-class of <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a>, so the entire node interface is also available. However, document nodes are special in several ways, which are covered below. There can be only one document node in the tree; document node does not have any XML representation. <br/>
</li>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodeElement Element/tag node</a> - This is the most common type of node, which represents XML elements. Element nodes have a name, a collection of attributes and a collection of child nodes (both of which may be empty). The attribute is a simple name/value pair. The example XML representation of element nodes is as follows: <div class="fragment"><pre class="fragment"> &lt;node attr=<span class="stringliteral">&quot;value&quot;</span>&gt;&lt;child/&gt;&lt;/node&gt; 
</pre></div> There are two element nodes here: one has name "node", single attribute "attr" and the single child "child" which has the name "child" and does not have any attributes or child nodes. <br/>
</li>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodePcdata Plain character data node</a> - Represent plain text in XML. PCDATA nodes have a value, but do not have a name or children/attributes. Note that plain character data is not a part of the element node but instead has its own node; for example, an element node can have several child PCDATA nodes. The example XML representation of text nodes is as follows: <div class="fragment"><pre class="fragment"> &lt;node&gt; text1 &lt;child/&gt; text2 &lt;/node&gt; 
</pre></div> Here "node" element has three children, two of which are PCDATA nodes with values "text1" and "text2". <br/>
</li>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodeCdata Character data nodes</a> - These represent text in XML that is quoted in a special way. CDATA nodes do not differ from PCDATA nodes except in XML representation - the above text example looks like this with CDATA: <div class="fragment"><pre class="fragment"> &lt;node&gt; &lt;![CDATA[[text1]]&gt; &lt;child/&gt; &lt;![CDATA[[text2]]&gt; &lt;/node&gt; 
</pre></div> CDATA nodes make it easy to include non-escaped &lt;, &amp; and &gt; characters in plain text. CDATA value can not contain the character sequence ]]&gt;, since it is used to determine the end of node contents. <br/>
</li>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodeComment Comment nodes</a> - represent comments in XML. Comment nodes have a value, but do not have a name or children/attributes. The example XML representation of a comment node is as follows: <div class="fragment"><pre class="fragment"> &lt;!-- comment text --&gt; 
</pre></div> Here the comment node has value "comment text". By default comment nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespacephys_1_1xml.html#a83ba30a7bee5a0fd4aa2f6136c8793fc" title="This flag determines if comments (NodeComment) are added to the DOM tree. This flag is off by default...">phys::xml::ParseComments</a> flag. <br/>
</li>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodePi Processing instruction node</a> - Represent Processing Instructions (PI) in XML. PI nodes have a name and an optional value, but do not have children/attributes. The example XML representation of a PI node is as follows: <div class="fragment"><pre class="fragment"> &lt;?name value?&gt; 
</pre></div> Here the name (also called PI target) is "name", and the value is "value". By default PI nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespacephys_1_1xml.html#a4d324954fc33d50155bae04587da13e2" title="This flag determines if processing instructions (NodePi) are added to the DOM tree. This flag is off by default.">phys::xml::ParsePi</a> flag. <br/>
</li>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodeDeclaration Declaration node</a> - Represents document declarations in XML. Declaration nodes have a name ("xml") and an optional collection of attributes, but do not have value or children. There can be only one declaration node in a document; moreover, it should be the topmost node (its parent should be the document). The example XML representation of a declaration node is as follows: <div class="fragment"><pre class="fragment"> &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt; 
</pre></div> Here the node has name "xml" and a single attribute with name "version" and value "1.0". By default declaration nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespacephys_1_1xml.html#a463f15fc43d69ab835c8598826f65646" title="This flag determines if document declaration (NodeDeclaration) is added to the DOM tree...">phys::xml::ParseDeclaration</a> flag. Also, by default a dummy declaration is output when XML document is saved unless there is already a declaration in the document; you can disable this with <a class="el" href="namespacephys_1_1xml.html#aee4ccb3535945d4808a0cf6abe4cb050" title="Omit default XML declaration even if there is no declaration in the document. This flag is off by def...">phys::xml::FormatNoDeclaration</a> flag. <br/>
</li>
<li><a class="el" href="namespacephys_1_1xml.html#a668b0cc666a9d49f7c7222a7552115d3">NodeType::NodeDocType Document type declaration node</a> - Represents document type declarations in XML. Document type declaration nodes have a value, which corresponds to the entire document type contents; no additional nodes are created for inner elements like &lt;!ENTITY&gt;. There can be only one document type declaration node in a document; moreover, it should be the topmost node (its parent should be the document). The example XML representation of a document type declaration node is as follows: <div class="fragment"><pre class="fragment"> &lt;!DOCTYPE greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]&gt; 
</pre></div> Here the node has value "greeting [ &lt;!ELEMENT greeting (#PCDATA)&gt; ]". By default document type declaration nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior with <a class="el" href="namespacephys_1_1xml.html#adf5ee79dc4c200ad85b64a8308b0c805" title="This flag determines if document type declaration (NodeDoctype) is added to the DOM tree...">phys::xml::ParseDocType</a> flag. <br/>
 <br/>
 Finally, here is a complete example of XML document and the corresponding tree representation: <div class="fragment"><pre class="fragment"> &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt;
 &lt;mesh name=<span class="stringliteral">&quot;mesh_root&quot;</span>&gt;
     &lt;!-- here is a mesh node --&gt;
     some text
     &lt;![CDATA[someothertext]]&gt;
     some more text
     &lt;node attr1=<span class="stringliteral">&quot;value1&quot;</span> attr2=<span class="stringliteral">&quot;value2&quot;</span> /&gt;
     &lt;node attr1=<span class="stringliteral">&quot;value2&quot;</span>&gt;
         &lt;innernode/&gt;
     &lt;/node&gt;
 &lt;/mesh&gt;
 &lt;?include somedata?&gt;
</pre></div> <div align="center">
<img src="SampleTree.jpg" alt="SampleTree.jpg"/>
<p><strong>Complete Tree Representation of the Sample</strong></p></div>
   </li>
</ul>
<h3><a class="anchor" id="XMLInterface"></a>
C++ interface</h3>
<p>Despite the fact that there are several node types, there are only three C++ classes representing the tree (<a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a>, <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a>, <a class="el" href="classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">phys::xml::Attribute</a>); some operations on <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> are only valid for certain node types. The classes are described below. <br/>
 <br/>
 <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> is the owner of the entire document structure; it is a non-copyable class. The interface of <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> consists of loading functions ( see <a class="el" href="XMLManual.html#XMLLoading">Loading Documents</a> ), saving functions ( see <a class="el" href="XMLManual.html#XMLSaving">Saving Documents</a> ) and the entire interface of <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a>, which allows for document inspection and/or modification. Note that while <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> is a sub-class of <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a>, <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> is not a polymorphic type; the inheritance is present only to simplify usage. Alternatively you can use the <a class="el" href="classphys_1_1xml_1_1Document.html#a93d8521e3241281e15f77cf7568d5754" title="Get document element.">phys::xml::Document::DocumentElement</a> function to get the element node that's the immediate child of the document. <br/>
 <br/>
 Default constructor of <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> initializes the document to the tree with only a root node ( <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> node). You can then populate it with data using either tree modification functions or loading functions; all loading functions destroy the previous tree with all occupied memory, which puts existing node/attribute handles for this document to invalid state. If you want to destroy the previous tree, you can use the <a class="el" href="classphys_1_1xml_1_1Document.html#a9ab556271e4a1214ecb35ba6aef9e8e4" title="Removes all nodes, leaving the empty document.">phys::xml::Document::Reset</a> function; it destroys the tree and replaces it with either an empty one or a copy of the specified document. Destructor of <a class="el" href="classphys_1_1xml_1_1Document.html" title="The root node of any xml hierarchy is a Document Node.">phys::xml::Document</a> also destroys the tree, thus the lifetime of the document object should exceed the lifetimes of any node/attribute handles that point to the tree. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>While technically node/attribute handles can be alive when the tree they're referring to is destroyed, calling any member function for these handles results in undefined behavior. Thus it is recommended to make sure that the document is destroyed only after all references to its nodes/attributes are destroyed.</dd></dl>
<p><a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> is the handle to a document node; it can point to any node in the document, including the document node itself. There is a common interface for nodes of all types; the actual node type can be queried via the <a class="el" href="classphys_1_1xml_1_1Node.html#a33288f89218baf24d1061c6eeb08687f" title="Identify what kind of Node this is.">phys::xml::Node::Type()</a> method. Note that <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> is only a handle to the actual node, not the node itself - you can have several phys::xml::node handles pointing to the same underlying object. Destroying <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> handle does not destroy the node and does not remove it from the tree. The size of <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> is equal to that of a pointer, so it is nothing more than a lightweight wrapper around a pointer; you can safely pass or return <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a>:Node objects by value without additional overhead. <br/>
 <br/>
 There is a special value of <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> type, known as null node or empty node (such nodes have type NodeNull). It does not correspond to any node in any document, and thus resembles null pointer. However, all operations are defined on empty nodes; generally the operations don't do anything and return empty nodes/attributes or empty strings as their result (see documentation for specific functions for more detailed information). This is useful for chaining calls; i.e. you can get the grandparent of a node like so: node.GetParent().GetParent(); if a node is a null node or it does not have a parent, the first Node::GetParent() call returns null node; the second GetParent() call then also returns null node, which can make error handling easier. <br/>
 <br/>
 <a class="el" href="classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">phys::xml::Attribute</a> is a handle to an XML attribute; it has the same semantics as <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a>, i.e. there can be several <a class="el" href="classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">phys::xml::Attribute</a> handles pointing to the same underlying object and there is a special null attribute value, which propagates to function results. <br/>
 <br/>
 Both <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> and <a class="el" href="classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">phys::xml::Attribute</a> have the default constructor which initializes them to null objects. <br/>
 <br/>
 <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> and <a class="el" href="classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">phys::xml::Attribute</a> try to behave like pointers, that is, they can be compared with other objects of the same type, making it possible to use them as keys in associative containers. All handles to the same underlying object are equal, and any two handles to different underlying objects are not equal. Null handles only compare as equal to themselves. The result of relational comparison can not be reliably determined from the order of nodes in file or in any other way. Do not use relational comparison operators except for search optimization (i.e. associative container keys). <br/>
 <br/>
 If you want to use <a class="el" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> or <a class="el" href="classphys_1_1xml_1_1Attribute.html" title="A light-weight handle for manipulating attributes in DOM tree.">phys::xml::Attribute</a> objects as keys in hash-based associative containers, you can use the <a class="el" href="classphys_1_1xml_1_1Node.html#a830a1833c4b4b012f1b4481e91ccb1ca" title="Get hash Value (unique for handles to the same object)">phys::xml::Node::HashValue</a> or <a class="el" href="classphys_1_1xml_1_1Attribute.html#ac0c27e07b705c41670a0903f4fe18378" title="Get a unique identifying value for the Attribute this represents.">phys::xml::Attribute::HashValue</a> member functions. They return the hash values that are guaranteed to be the same for all handles to the same underlying object. The hash value for null handles is 0. <br/>
 <br/>
 Finally handles can be implicitly cast to boolean-like objects, so that you can test if the node/attribute is empty with the following code: if (node) { ... } or if (!node) { ... } else { ... }. Alternatively you can check if a given Node/Attribute handle is null by calling the <a class="el" href="classphys_1_1xml_1_1Attribute.html#a6d0157a562f283e9c87d1cc46b3405cc" title="Is this storing anything at all?">phys::xml::Attribute::Empty</a> or the <a class="el" href="classphys_1_1xml_1_1Node.html#a22c00132e42702d16468489ff0bd01d8" title="Is this storing anything at all?">phys::xml::Node::Empty</a> Methods. <br/>
 <br/>
 Nodes and attributes do not exist without a document tree, so you can't create them without adding them to some document. Once underlying node/attribute objects are destroyed, the handles to those objects become invalid. While this means that destruction of the entire tree invalidates all node/attribute handles, it also means that destroying a subtree ( by calling <a class="el" href="classphys_1_1xml_1_1Node.html#a946bb656b94c9d3a561200cd2cd3ee11" title="Remove specified child element.">phys::xml::Node::RemoveChild</a> ) or removing an attribute invalidates the corresponding handles. There is no way to check handle validity; you have to ensure correctness through external mechanisms. <br/>
 <br/>
 </p>
<h3><a class="anchor" id="XMLUnicode"></a>
Unicode Interface</h3>
<p>There are two choices of interface and internal representation when working with <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> : you can either choose the UTF-8 (also called char) interface or UTF-16/32 (also called wchar_t) one. The choice is controlled via XML_WCHAR_MODE define; you can set it via <a class="el" href="xml_8h.html" title="This is where bulk of the XML subsystem is declare, there are numerous class that are all tighlty int...">xml.h</a> or via preprocessor options beore engine compilation. If this define is set, the wchar_t interface is used; otherwise (by default) the char interface is used. The exact wide character encoding is assumed to be either UTF-16 or UTF-32 and is determined based on the size of wchar_t type. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>There are a few places that the reset of the engine assumes the use of the UTF-8/char interface. The task of integrating this cleanly is currently considered a low priority. If you use XML_WCHAR_MODE you will encounter bugs, they could be tiny or huge. Since we didn't test it, we assumed it doesn't work.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the size of wchar_t is 2, <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> assumes UTF-16 encoding instead of UCS-2, which means that some characters are represented as two code points.</dd></dl>
<p>All tree functions that work with strings work with either C-style null terminated strings or STL strings of the selected character type. For example, node name accessors look like this in char mode: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">phys::xml::Node::Name</a>() <span class="keyword">const</span>;
 <span class="keywordtype">bool</span> <a class="code" href="classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">phys::xml::Node::SetName</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* value);
</pre></div><p> and like this in wchar_t mode: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* <a class="code" href="classphys_1_1xml_1_1Node.html#a53facd97d76240a3f3fffc86caacdc24" title="Get the name of this Node.">phys::xml::Node::Name</a>() <span class="keyword">const</span>;
 <span class="keywordtype">bool</span> <a class="code" href="classphys_1_1xml_1_1Node.html#a81ae067921c4a37fae118c76c2af375f" title="Set the name of this Node.">phys::xml::Node::SetName</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* value);
</pre></div><p> There is a special type, <a class="el" href="namespacephys_1_1xml.html#afc87705cd1c2917d87b879715a2d8f6e" title="Used to represent a UTF8 code point, char, or wchar_t depending on how compiled.">phys::xml::char_t</a>, that is defined as the character type and depends on the engine configuration; it will be also used in the documentation hereafter. There is also a type phys::xml::string_t, which is defined as the STL string of the character type; it corresponds to std::string in char mode and to std::wstring in wchar_t mode. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is one our list of items to integrate more tighlty. At some point <a class="el" href="namespacephys_1_1xml.html#afc87705cd1c2917d87b879715a2d8f6e" title="Used to represent a UTF8 code point, char, or wchar_t depending on how compiled.">phys::xml::char_t</a> will be replace by <a class="el" href="namespacephys.html#a3098bae5b0a3cd16eec331f766cc562b" title="A datatype to represent one character.">phys::Character</a>, and phys::xml::string_t will be replaced by <a class="el" href="namespacephys.html#aa03900411993de7fbfec4789bc1d392e" title="A Datatype used to a series of characters.">phys::String</a>. For now they remain Interoperable.</dd></dl>
<p>In addition to the interface, the internal implementation changes to store XML data as <a class="el" href="namespacephys_1_1xml.html#afc87705cd1c2917d87b879715a2d8f6e" title="Used to represent a UTF8 code point, char, or wchar_t depending on how compiled.">phys::xml::char_t</a>; this means that these two modes have different memory usage characteristics. The conversion to <a class="el" href="namespacephys_1_1xml.html#afc87705cd1c2917d87b879715a2d8f6e" title="Used to represent a UTF8 code point, char, or wchar_t depending on how compiled.">phys::xml::char_t</a> upon document loading and from <a class="el" href="namespacephys_1_1xml.html#afc87705cd1c2917d87b879715a2d8f6e" title="Used to represent a UTF8 code point, char, or wchar_t depending on how compiled.">phys::xml::char_t</a> upon document saving happen automatically, which also carries minor performance penalty. The general advice however is to select the character mode based on usage scenario, i.e. if UTF-8 is inconvenient to process and most of your XML data is non-ASCII, wchar_t mode is probably a better choice (if this is the case any patches, notifications or bugfixes that could be sent our way would help.) <br/>
 <br/>
 There are cases when you'll have to convert string data between UTF-8 and wchar_t encodings; the following helper functions are provided for such purposes: </p>
<div class="fragment"><pre class="fragment"> std::string <a class="code" href="namespacephys_1_1xml.html#a2d4bf28045544dc7350827f568cad46f" title="Convert a c-style string of wchar_t to std::string containing UTF8.">AsUtf8</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* str);
 std::wstring <a class="code" href="namespacephys_1_1xml.html#a2d4bf28045544dc7350827f568cad46f" title="Convert a c-style string of wchar_t to std::string containing UTF8.">AsUtf8</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str);
</pre></div><p> Both functions accept a null-terminated string as an argument str, and return the converted string. AsUtf8 performs conversion from UTF-16/32 to UTF-8; AsWide performs conversion from UTF-8 to UTF-16/32. Invalid UTF sequences are silently discarded upon conversion. str has to be a valid string; passing null pointer results in undefined behavior. There are also two overloads with the same semantics which accept a string as an argument: </p>
<div class="fragment"><pre class="fragment"> std::string <a class="code" href="namespacephys_1_1xml.html#a2d4bf28045544dc7350827f568cad46f" title="Convert a c-style string of wchar_t to std::string containing UTF8.">AsUtf8</a>(<span class="keyword">const</span> std::wstring&amp; str);
 std::wstring <a class="code" href="namespacephys_1_1xml.html#a0a57ef612f499a03733ca18d0e4f0c4f" title="Convert a Convert a c-style string to std::wstring containing native encoding (Usually UCS2 on window...">AsWide</a>(<span class="keyword">const</span> std::string&amp; str);
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>Most examples in this documentation assume char interface and therefore will not compile with XML_WCHAR_MODE. This is done to simplify the documentation; usually the only changes you'll have to make is to pass wchar_t string literals, i.e. instead of <br/>
 <br/>
 <div class="fragment"><pre class="fragment"> <a class="code" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> node = doc.<a class="code" href="classphys_1_1xml_1_1Node.html#a4d3f74c2c2613c84376b1ab6f3ed19c9" title="Attempt to get a child Node with a given name.">GetChild</a>(<span class="stringliteral">&quot;bookstore&quot;</span>).FindChildbyAttribute(<span class="stringliteral">&quot;book&quot;</span>, <span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;12345&quot;</span>); 
</pre></div> <br/>
 <br/>
 you'll have to do <br/>
 <br/>
 <div class="fragment"><pre class="fragment"> <a class="code" href="classphys_1_1xml_1_1Node.html" title="A light-weight handle for manipulating nodes in DOM tree.">phys::xml::Node</a> node = doc.<a class="code" href="classphys_1_1xml_1_1Node.html#a4d3f74c2c2613c84376b1ab6f3ed19c9" title="Attempt to get a child Node with a given name.">GetChild</a>(L<span class="stringliteral">&quot;bookstore&quot;</span>).FindChildbyAttribute(L<span class="stringliteral">&quot;book&quot;</span>, L<span class="stringliteral">&quot;id&quot;</span>, L<span class="stringliteral">&quot;12345&quot;</span>); 
</pre></div></dd></dl>
<h3><a class="anchor" id="XMLThreadSafety"></a>
Thread-safety guarantees</h3>
<p>Almost all functions in <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> have the following thread-safety guarantees:</p>
<ul>
<li>It is safe to call free (non-member) functions from multiple threads</li>
<li>It is safe to perform concurrent read-only accesses to the same tree (all constant member functions do not modify the tree)</li>
<li>It is safe to perform concurrent read/write accesses, if there is only one read or write access to the single tree at a time</li>
</ul>
<p>Concurrent modification and traversing of a single tree requires synchronization, for example via reader-writer lock. Modification includes altering document structure and altering individual node/attribute data, i.e. changing names/values. <br/>
 <br/>
 The only exception is phys::SetMemory_management_functions; it modifies global variables and as such is not thread-safe. Its usage policy has more restrictions, see <a class="el" href="XMLManual.html#XMLCustomAlloc">Custom memory allocation/deallocation functions</a> . </p>
<h3><a class="anchor" id="XMLExceptionSafety"></a>
Exception guarantees</h3>
<p>With the exception of XPath, <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> itself does not throw any exceptions. Additionally, most <a class="el" href="namespacephys_1_1xml.html" title="This is where bulk of the XML subsystem resides, (See phys::xml Manual for details) there are numerou...">phys::xml</a> functions have a no-throw exception guarantee. <br/>
 <br/>
 This is not applicable to functions that operate on STL strings or IOstreams; such functions have either strong guarantee (functions that operate on strings) or basic guarantee (functions that operate on streams). Also functions that call user-defined callbacks (i.e. <a class="el" href="classphys_1_1xml_1_1Node.html#a0029d08d3689c36d882ada0c0c9cf6e9" title="Perform sophisticated (or whatever) algorithms on this and all descendant Nodes in the XML tree...">phys::xml::Node::Traverse</a> or <a class="el" href="classphys_1_1xml_1_1Node.html#ab2311cefdf1d7f4886cbebd7350d7731" title="Search for any Node descended from this Node using a function to check each Node individually.">phys::xml::Node::FindNode</a>) do not provide any exception guarantees beyond the ones provided by the callback. <br/>
 <br/>
 If exception handling is not disabled with XML_NO_EXCEPTIONS define, XPath functions may throw <a class="el" href="classphys_1_1xml_1_1XPathException.html" title="Thrown in a variety of XPath only situations, to indicate type mismatch or other issues.">phys::xml::XPathException</a> on parsing errors; also, XPath functions may throw std::bad_alloc in low memory conditions. Still, XPath functions provide strong exception guarantee. </p>
<h3><a class="anchor" id="XMLMemory"></a>
Memory management</h3>
<p>Still in progress </p>
<h4><a class="anchor" id="XMLCustomAlloc"></a>
Custom memory allocation/deallocation functions</h4>
<p>Still in progress </p>
<h4><a class="anchor" id="XMLMemoryInternals"></a>
Document memory management internals</h4>
<p>Still in progress </p>
<h3><a class="anchor" id="XMLUnicode"></a>
Unicode Interface</h3>
<p>Still in progress </p>
<h2><a class="anchor" id="XMLLoading"></a>
Loading Documents</h2>
<p>Still in progress </p>
<h2><a class="anchor" id="XMLAccessing"></a>
Accessing Document Data</h2>
<p>Still in progress </p>
<h2><a class="anchor" id="XMLModifying"></a>
Modifiying Document</h2>
<p>Still in progress </p>
<h2><a class="anchor" id="XMLSaving"></a>
Saving Documents</h2>
<p>Still in progress </p>
<h2><a class="anchor" id="XMLXPath"></a>
XMLXPath</h2>
<p>Still in progress </p>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Aug 3 2011 02:56:40 for PhysGameEngine by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
