#!/bin/bash
# Takes in PugiXML and emits XML files appropriate for direct inclusion in the Physgame library
# This expects the PugiXML source files to be in the subdirectory call PugiSrc

# This script isn't magic, it was designed with version 1.0 of PugiXML in mind. If new features have been added, then new commands
# will need to be add to rename those as well. That being said, I did try to code it in such a way 

#disable Bash filename expansion
set -f

#error codes - These match the Header prepending tool
E_BADARGS=1
E_MISSINGPUGIXML=3

#Input Files
PugiCppFile="PugiSrc/pugixml.cpp"
#PugiTempCppFile="PugiSrc/temp.cpp"
PugiHFile="PugiSrc/pugixml.hpp"
PugiConfigFile="PugiSrc/pugiconfig.hpp"
PugiTempHFile="PugiSrc/temp.hpp"


#Output Files
OutDir="../../physgameengine/src"
NewHFileOnly="xml.h"
NewCppFileOnly="xml.cpp"
NewHFile="$OutDir/$NewHFileOnly"
NewCppFile="$OutDir/$NewCppFileOnly"

#Some other variables we will be using
#Copyright Variables
Hardstring="This should not be found on any lineasdfasdfasdfasdf"	# this Should not appear in any of the Files, if it does, change it.
OurLicenseFile="fileheader.txt"
OurCopyright="\n * Software, Files, Libraries and all other items referenced in this clause refers only\n * to the contents of this file and associated documentation.\n *\n"
IncompleteCopyright1=" * Copyright (c) 2006-2010 Arseny Kapoulkine"
CompleteCopyright1="$OurCopyright * Copyright © 2006-2010 Arseny Kapoulkine"
IncompleteCopyright2=" * pugixml parser - version 1.0"
CompleteCopyright2="$OurCopyright * Pugixml parser - version 1.0"
CopyrightAccidentalDoxyTags='\/\*\*'
CopyrightCleantags='\/\*'

#Namespace Variables
PugiUsingNamespace="using namespace pugi"
PugiNamespace="namespace pugi"
OurUsingNamespace="using namespace phys::xml"
#OurUsingNamespace="using namespace phys"
#OurUsingNamespace="using namespace xml"
OurNamespace="namespace xml"
OurExtraNamespace="
namespace phys
{"
OurExtraNamespaceClosing="} // \phys"


#Make the Files to begin appending Source code to.
cat  $OurLicenseFile > $NewCppFile
cat  $OurLicenseFile > $PugiTempHFile

# This lops of the end copyright because we can use the ending from the other file we are merging with
PugiConfigGrabUntil="#endif"
				# The Copyright notices, and other string to search for in the PugiConfig File
				#This next line uses grep to get the line number of the token we are searching for and then sends the results to
				#sed to strip of the : and the token appended to the value we want.
PugiConfigGrabLineCount=`grep "$PugiConfigGrabUntil" $PugiConfigFile -n | head -n1 | sed s/:.*//g`
head -n$PugiConfigGrabLineCount $PugiConfigFile  >> $PugiTempHFile

# This Lops of the first copyright notice by ommision (since this is the last part of the file we will keep the tail copyright) and appends the results to the results of the Config Transformation
PugiHeaderGrabUntil="*/"						# This ends the copyright header in the pugiheader file
PugiHeaderGrabLineCount=`grep "$PugiHeaderGrabUntil" $PugiHFile -n | head -n1 | sed s/:.*//g`
PugiHeaderTotalLineCount=`grep "$Hardstring" $PugiHFile -vc`
PugiHeaderTailLineCount=$[PugiHeaderTotalLineCount-PugiHeaderGrabLineCount]
tail -n$PugiHeaderTailLineCount $PugiHFile | sed -e s/'#include "pugiconfig.hpp"'/'#include "crossplatform.h"\n#include "xmldoc.h"'/g  >> $PugiTempHFile

#This Does a number of transformations on the PugiHeader file before placing the complete converted parts onto the new headerfile
#	- Replaces series of 4 spaces with tabs (seems to be an issue with the original source Files)
#	- Remove reference to old filenames
#	- Appends a notice to Arseny's Copyright that it only covers items arseny wrote.
#	- clean up Copyright Symbols as (c) is meaningless in some jurisdications (as per RMS)
#	- Replace multiple inclusion with names matching our own
#		HEADER_PUGIXML_HPP -> _xml_h
#		HEADER_PUGICONFIG_HPP	-> _xmlconfig_h
#	- Put the results in the final place they belong
cat $PugiTempHFile | sed  	-e s/'    '/'	'/g 	-e s/"$IncompleteCopyright1"/"$CompleteCopyright1"/g 	-e s/$CopyrightAccidentalDoxyTags/$CopyrightCleantags/g	-e s/"$IncompleteCopyright2"/"$CompleteCopyright2"/g 	-e s/\([cC]\)/©/g 	-e s/HEADER_PUGIXML_HPP/_XML_H/g 	-e s/HEADER_PUGICONFIG_HPP/_XMLCONFIG_H/g	-e s/PUGIXML_/XML_/g 	-e s/"$PugiUsingNamespace"/"$OurUsingNamespace"/g	> $NewHFile

# This does mostly the same thing that the header transfortmation does, a bunch of cleanup and putting the code where it belongs
cat $PugiCppFile | sed 	-e s/'#include "pugixml.hpp"'/"#include \"$NewHFileOnly\""/g 	-e s/'    '/'	'/g 	-e s/"$IncompleteCopyright1"/"$CompleteCopyright1"/g 	-e s/"$IncompleteCopyright2"/"$CompleteCopyright2"/g 	-e s/$CopyrightAccidentalDoxyTags/$CopyrightCleantags/g	-e s/\([C]\)/©/g 	-e s/PUGIXML_/XML_/g	-e s/"$PugiUsingNamespace"/"$OurUsingNamespace"/g	>> $NewCppFile

# This will look in file $1 for the bracket that should end the statement that starts with $2 and ends the statement with $4
# while doing this, old instances of $2 and replace them with $3
# In other words
# $1 is the filename
# $2 is Old namespace
# $3 is the new double namespace
# $4 is the item to end the namespace, use "}" if you don't wantanything fancy.
function FixNamespaces
{
	TempFileName="$1.tmp"
	echo -n "" > $TempFileName
	LB="{"						#The character that begins a codeblock
	RB="}"						#The character that ends a codeblock
	LookingForEndBracket=-1	#if this is set to -1 then we are looking for the line of code to start search for our bracket at.
								#if this is set to a positive number, then it is the amount of unclosed left brackets we have found.

	LineCount=0
	OIFS="$IFS"
	IFS=$'\n'
	FileContent=`cat $1`

	#echo -E "$FileContent" > $1.txt.cpp
	FileContent=`echo -E "$FileContent" | sed -e 's/\(.*$\)/\1 /'`
	#echo -E "$FileContent" > $1.txt2.cpp

	for fn in $FileContent; do
		#LineCount=$[LineCount+1]
		#echo $LineCount #: $fn
		if [ $LookingForEndBracket -eq -1 ]; then
			#looking for Namespace
			if [ "$fn" = "${fn/$2/asdf}" ]; then
				#Line has no match in it, so we send it to temp file
				echo -E "$fn" >> $TempFileName
			else
				#This line does match, send to replacement to tempfile and start counting
				LookingForEndBracket=0
				echo -E "$3" >> $TempFileName
			fi
		else
			echo -E "$fn" >> $TempFileName
			#We are looking for a Brackets now
			if [ "$fn" != "${fn/$LB/asdf}" ]; then
				#We found a left bracket we are going deeper
				LookingForEndBracket=$[1+LookingForEndBracket]
			fi
			if [ "$fn" != "${fn/$RB/asdf}" ]; then
				#We found a right bracket we are coming out
				LookingForEndBracket=$[LookingForEndBracket-1]
				if [ $LookingForEndBracket == 0 ]; then
					LookingForEndBracket=-1
					echo -E "$4" >> $TempFileName
				fi
			fi
		fi
	done

	mv $TempFileName $1
	IFS="$OIFS"
}

FixNamespaces $NewHFile "$PugiNamespace" "$OurExtraNamespace $OurNamespace" "$OurExtraNamespaceClosing"
FixNamespaces $NewCppFile "$PugiNamespace" "$OurExtraNamespace $OurNamespace" "$OurExtraNamespaceClosing"

#This will replace all the old PugiXML names in the file providesd in $1 with the new BTS phys::xml names
function FixNames
{
	#FileContent=`cat $1`
	#TempFileName="$1.tmp"
	#echo -E "$FileContent" > $TempFileName

	#A clean line to copy and paste 
	#sed -i -e 's/needle/replacement/'`

	#######################################################################
	#This is the list of items to find/replace to convert the Pugi API into Physgame API

	#Remove the original and grossly incomplete doxygen documentations
	sed -i -e 's|///|////|g' $1								

	#Adjust the names of two word type to varaibles to use CamelCase
	sed -i -e 's/xml_\(.\)\([a-z]*\)_\(.\)/\U\1\L\2\U\3/g' $1		
	sed -i -e 's/xml_\(.\)/\U\1/g' $1

	#These configure the XML API to be exported to a DLL on windows
	sed -i -e 's/XML_CLASS/PHYS_LIB/g' $1					
	sed -i -e 's/XML_FUNCTION/PHYS_LIB/g' $1
	sed -i -e 's/XML_API/PHYS_LIB/g' $1

	#Status and error codes
	sed -i -e 's/status_ok/StatusOk/g' $1										
	sed -i -e 's/status_file_not_found/StatusFileNotFound/g' $1
	sed -i -e 's/status_io_error/StatusIOError/g' $1
	sed -i -e 's/status_out_of_memory/StatusOutOfMemory/g' $1
	sed -i -e 's/status_unrecognized_tag/StatusUnrecognizedTag/g' $1
	sed -i -e 's/status_bad_pi/StatusBadPi/g' $1
	sed -i -e 's/status_bad_comment/StatusBadComment/g' $1
	sed -i -e 's/status_bad_cdata/StatusBadCdata/g' $1
	sed -i -e 's/status_bad_doctype/StatusBadDoctype/g' $1
	sed -i -e 's/status_bad_pcdata/StatusBadPcdata/g' $1
	sed -i -e 's/status_bad_start_element/StatusBadStartElement/g' $1
	sed -i -e 's/status_bad_attribute/StatusBadAttribute/g' $1
	sed -i -e 's/status_bad_end_element/StatusBadEndElement/g' $1
	sed -i -e 's/status_end_element_mismatch/StatusEndElementMismatch/g' $1
	sed -i -e 's/status_internal_error/StatusInternalError/g' $1

	#Fix member ParseStatus.Status, ParseStatus.DocumentEncoding, ParseStatus.Offset and ParseStatus.Description()
	sed -i -e 's/status/Status/g' $1
	sed -i -e 's/encoding/DocumentEncoding/g' $1
	sed -i -e 's/offset\([^o]\)/Offset\1/g' $1
	sed -i -e 's/description/Description/g' $1

	#Fix The Encoding Enum All 1,2 and 3 part variable names
	sed -i -e 's/\(DocumentEncoding\)_\([au][tf]*\)\([a-z0-9]*\)_\([ble]*\)/Encoding\U\2\3\U\4/g' $1
	sed -i -e 's/\(DocumentEncoding\)_\([au][tf]*\)\([a-z0-9]*\)/Encoding\U\2\L\3/g' $1
	sed -i -e 's/DocumentEncoding_wchar/Encodingwchar_t/g' $1

	#Fix the NodeType Enum
	sed -i -e 's|\(n\)\(ode\)_\(.\)\([a-z]*\)|\U\1\L\2\U\3\L\4|g' $1

	#More tightly integrating Character into the XML parser
	sed -i -e 's|typedef XML_CHAR char_t;|typedef Character char_t;|g' $1
	sed -i -e 's|typedef std::basic_string<XML_CHAR, std::char_traits<XML_CHAR>, std::allocator<XML_CHAR> > string_t;|typedef std::basic_string<Character, std::char_traits<Character>, std::allocator<Character> > string_t;|g' $1

	#Renaming 1 and2 part Parse options
	sed -i -e 's|parse_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Parse\U\1\L\2\U\3\L\4|g' $1				
	sed -i -e 's|parse_\(.\)\([a-z]*\)|Parse\U\1\L\2|g' $1
	
	#Renaming 1,2 and 3 part Format options
	sed -i -e 's|format_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Format\U\1\L\2\U\3\L\4\U\5\L\6|g' $1	
	sed -i -e 's|format_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Format\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|format_\(.\)\([a-z]*\)|Format\U\1\L\2|g' $1				
	
	#Renaming 1 and 2 part Xpath Class Names
	sed -i -e 's|xpath_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|XPath\U\1\L\2\U\3\L\4|g' $1	
	sed -i -e 's|xpath_\(.\)\([a-z]*\)|XPath\U\1\L\2|g' $1				

	#The Writer class and compatibility options
	sed -i -e 's|writer|WriterInstance|g' $1
	sed -i -e 's|write|Write|g' $1
	sed -i -e 's|_stream->Write|_stream->write|g' $1	#These 2 lines fixe mistakes made by the above line
	sed -i -e 's|fWrite|fwrite|g' $1

	#

	###############################
	#Documentation that was not put in xmldoc.h

	#Parsing status items
	sed -i -e 's|// Parsing Status (see ParseStatus)|/// @brief Parsing status ( see @ref ParseStatus )|' $1
	sed -i -e 's|// Last parsed Offset (in char_t units from start of input data)|/// @brief Last parsed offset (in char_t units from start of input data)|' $1
	sed -i -e 's|// Source document DocumentEncoding|/// @brief Source document encoding ( see @ref Encoding )|' $1
	sed -i -e 's|// Default constructor, initializes object to failed state|/// @brief Default constructor, initializes object to failed state.|' $1
	sed -i -e 's|// Cast to bool operator|/// @brief Cast to bool operator \\n		/// @return This returns true if the ParseResult::Status member is set to ParseStatus::StatusOk, otherwise this returns false.|' $1
	sed -i -e 's|// Get error Description |/// @brief Uses the Status member to create a text description. \\n		/// @return A const char* with a brief error description based on the ParseResult::Status |' $1
	sed -i -e 's|// Character type used for all internal storage and operations; depends on XML_WCHAR_MODE|/// @brief The character type used the internals of the XML parser, this is defined in datatypes.h.|' $1

	#Writer Interface class
	sed -i -e 's|		virtual ~Writer() {} |		/// @brief Empty Virtual Destructor\n		virtual ~Writer() {} |' $1
	sed -i -e 's|// Write memory chunk into stream/file/whatever |/// @brief This will be used to output xml to an external source such as a file or stream\n		/// @param data This is a pointer to something that will get written to the output\n		/// @param size The size in bytes of whatever was passed in.|' $1

	#WriterFile Class
	sed -i -e 's|// Construct WriterInstance from a FILE\* object; void\* is used to avoid header dependencies on stdio|/// @brief Construct a Writer from a FILE* object.\n		/// @details The use of void* was intended to avoid a depedency on the stdio header, in the original PugiXML. After a review for compatibility this may change to promote better type safety.|' $1
	sed -i -e 's|WriterFile(void\* file);|\n\n		/// @brief Writes data to a file\n		/// @param data A pointer to the data \n		/// @param size The size of the data in bytes.|' $1
	sed -i -e 's|void\* file;|/// @brief A pointer to a FILE as define in stdio\n		/// @internal\n		void* file;|' $1

	#WriterStream Class
	sed -i -e 's|// Construct WriterInstance from an output stream object |/// @brief A constructor that accepts a stream of characters\n		/// @param stream A stream to send stuff to.|' $1
	sed -i -e 's|WriterStream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);|\n		/// @brief A constructor that accepts a stream of wide characters\n		/// @param stream A stream to send stuff to.\n		WriterStream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);\n \n		/// @brief Writes data to the stream\n		/// @param data A pointer to the data \n		/// @param size The size of the data in bytes.|' $1

	#another clean line to copy/paste
	#sed -i -e 's|||' $1
}

FixNames $NewHFile
FixNames $NewCppFile

#we unset this, so we will set it again, even though on *Most* systems this isn't required
set +f
