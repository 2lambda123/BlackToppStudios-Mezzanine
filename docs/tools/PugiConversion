#!/bin/bash
# Takes in PugiXML and emits XML files appropriate for direct inclusion in the Physgame library
# This expects the PugiXML source files to be in the subdirectory call PugiSrc

# This script isn't magic, it was designed with version 1.0 of PugiXML in mind. If new features have been added, then new commands
# will need to be add to rename those as well. That being said, I did try to code it in such a way that it would still work with new versions of the source files...
# I hope this really does simplify things when upgrade time comes around, because that is the sole reason this exists.

#for reference this took 4 to 6 seconds to run on my i7 and 2 minutes to my on my p4.

#disable Bash filename expansion
set -f

#error codes - These match the Header prepending tool
E_BADARGS=1
E_MISSINGPUGIXML=3

#Input Files
PugiCppFile="pugisrc/pugixml.cpp"
#PugiTempCppFile="PugiSrc/temp.cpp"
PugiHFile="pugisrc/pugixml.hpp"
PugiConfigFile="pugisrc/pugiconfig.hpp"
PugiTempHFile="pugisrc/temp.hpp"
PhysxmlifdefFile="ifdef.txt"
PhysxmlendifFile="endif.txt"

#Output Files
OutDir="../../physgameengine/src"
NewHFileOnly="xml.h"
NewCppFileOnly="xml.cpp"
NewHFile="$OutDir/$NewHFileOnly"
NewCppFile="$OutDir/$NewCppFileOnly"

#Some other variables we will be using
#Copyright Variables
Hardstring="This should not be found on any lineasdfasdfasdfasdf"	# this Should not appear in any of the Files, if it does, change it.
OurLicenseFile="fileheader.txt"
OurCopyright="\n * Software, Files, Libraries and all other items referenced in this clause refers only\n * to the contents of this file and associated documentation.\n *\n"
IncompleteCopyright1=" * Copyright (c) 2006-2010 Arseny Kapoulkine"
CompleteCopyright1="$OurCopyright * Copyright © 2006-2010 Arseny Kapoulkine"
IncompleteCopyright2=" * pugixml parser - version 1.0"
CompleteCopyright2="$OurCopyright * Pugixml parser - version 1.0"
CopyrightAccidentalDoxyTags='\/\*\*'
CopyrightCleantags='\/\*'

#Namespace Variables
PugiUsingNamespace="using namespace pugi"
PugiNamespace="namespace pugi"
OurUsingNamespace="using namespace phys::xml"
#OurUsingNamespace="using namespace phys"
#OurUsingNamespace="using namespace xml"
OurNamespace="namespace xml"
OurExtraNamespace="
namespace phys
{"
OurExtraNamespaceClosing="} // \phys"


#Make the Files to begin appending Source code to.
cat  $OurLicenseFile > $NewCppFile
cat  $OurLicenseFile > $PugiTempHFile

# This lops of the end copyright because we can use the ending from the other file we are merging with
PugiConfigGrabUntil="#endif"
				# The Copyright notices, and other string to search for in the PugiConfig File
				#This next line uses grep to get the line number of the token we are searching for and then sends the results to
				#sed to strip of the : and the token appended to the value we want.
PugiConfigGrabLineCount=`grep "$PugiConfigGrabUntil" $PugiConfigFile -n | head -n1 | sed s/:.*//g`
head -n$PugiConfigGrabLineCount $PugiConfigFile  >> $PugiTempHFile

# This Lops of the first copyright notice by ommision (since this is the last part of the file we will keep the tail copyright) and appends the results to the results of the Config Transformation
PugiHeaderGrabUntil="*/"						# This ends the copyright header in the pugiheader file
PugiHeaderGrabLineCount=`grep "$PugiHeaderGrabUntil" $PugiHFile -n | head -n1 | sed s/:.*//g`
PugiHeaderTotalLineCount=`grep "$Hardstring" $PugiHFile -vc`
PugiHeaderTailLineCount=$[PugiHeaderTotalLineCount-PugiHeaderGrabLineCount]
tail -n$PugiHeaderTailLineCount $PugiHFile | sed -e s/'#include "pugiconfig.hpp"'/'#include "crossplatform.h"\n#include "xmldoc.h"\n#include "exception.h"'/g  >> $PugiTempHFile

#This Does a number of transformations on the PugiHeader file before placing the complete converted parts onto the new headerfile
#	- Replaces series of 4 spaces with tabs (seems to be an issue with the original source Files)
#	- Remove reference to old filenames
#	- Appends a notice to Arseny's Copyright that it only covers items arseny wrote.
#	- clean up Copyright Symbols as (c) is meaningless in some jurisdications (as per RMS)
#	- Replace multiple inclusion with names matching our own
#		HEADER_PUGIXML_HPP -> _xml_h
#		HEADER_PUGICONFIG_HPP	-> _xmlconfig_h
#	- Put the results in the final place they belong
cat $PhysxmlifdefFile $PugiTempHFile $PhysxmlendifFile| sed  	-e s/'    '/'	'/g 	-e s/"$IncompleteCopyright1"/"$CompleteCopyright1"/g 	-e s/$CopyrightAccidentalDoxyTags/$CopyrightCleantags/g	-e s/"$IncompleteCopyright2"/"$CompleteCopyright2"/g 	-e s/\([cC]\)/©/g 	-e s/HEADER_PUGIXML_HPP/_XML_H/g 	-e s/HEADER_PUGICONFIG_HPP/_XMLCONFIG_H/g	-e s/PUGIXML_/XML_/g 	-e s/"$PugiUsingNamespace"/"$OurUsingNamespace"/g	> $NewHFile

# This does mostly the same thing that the header transfortmation does, a bunch of cleanup and putting the code where it belongs
cat $PhysxmlifdefFile $PugiCppFile $PhysxmlendifFile| sed 	-e s/'#include "pugixml.hpp"'/"#include \"$NewHFileOnly\""/g 	-e s/'    '/'	'/g 	-e s/"$IncompleteCopyright1"/"$CompleteCopyright1"/g 	-e s/"$IncompleteCopyright2"/"$CompleteCopyright2"/g 	-e s/$CopyrightAccidentalDoxyTags/$CopyrightCleantags/g	-e s/\([C]\)/©/g 	-e s/PUGIXML_/XML_/g	-e s/"$PugiUsingNamespace"/"$OurUsingNamespace"/g	>> $NewCppFile

# This will look in file $1 for the bracket that should end the statement that starts with $2 and ends the statement with $4
# while doing this, old instances of $2 and replace them with $3
# In other words
# $1 is the filename
# $2 is Old namespace
# $3 is the new double namespace
# $4 is the item to end the namespace, use "}" if you don't wantanything fancy.
function FixNamespaces
{
	TempFileName="$1.tmp"
	echo -n "" > $TempFileName
	LB="{"						#The character that begins a codeblock
	RB="}"						#The character that ends a codeblock
	LookingForEndBracket=-1	#if this is set to -1 then we are looking for the line of code to start search for our bracket at.
								#if this is set to a positive number, then it is the amount of unclosed left brackets we have found.

	LineCount=0
	OIFS="$IFS"
	IFS=$'\n'
	FileContent=`cat $1`

	#echo -E "$FileContent" > $1.txt.cpp
	FileContent=`echo -E "$FileContent" | sed -e 's/\(.*$\)/\1 /'`
	#echo -E "$FileContent" > $1.txt2.cpp

	for fn in $FileContent; do
		#LineCount=$[LineCount+1]
		#echo $LineCount #: $fn
		if [ $LookingForEndBracket -eq -1 ]; then
			#looking for Namespace
			if [ "$fn" = "${fn/$2/asdf}" ]; then
				#Line has no match in it, so we send it to temp file
				echo -E "$fn" >> $TempFileName
			else
				#This line does match, send to replacement to tempfile and start counting
				LookingForEndBracket=0
				echo -E "$3" >> $TempFileName
			fi
		else
			echo -E "$fn" >> $TempFileName
			#We are looking for a Brackets now
			if [ "$fn" != "${fn/$LB/asdf}" ]; then
				#We found a left bracket we are going deeper
				LookingForEndBracket=$[1+LookingForEndBracket]
			fi
			if [ "$fn" != "${fn/$RB/asdf}" ]; then
				#We found a right bracket we are coming out
				LookingForEndBracket=$[LookingForEndBracket-1]
				if [ $LookingForEndBracket == 0 ]; then
					LookingForEndBracket=-1
					echo -E "$4" >> $TempFileName
				fi
			fi
		fi
	done

	mv $TempFileName $1
	IFS="$OIFS"
}

FixNamespaces $NewHFile "$PugiNamespace" "$OurExtraNamespace $OurNamespace" "$OurExtraNamespaceClosing"
FixNamespaces $NewCppFile "$PugiNamespace" "$OurExtraNamespace $OurNamespace" "$OurExtraNamespaceClosing"

#This will replace all the old PugiXML names in the file providesd in $1 with the new BTS phys::xml names
function FixNames
{
	#FileContent=`cat $1`
	#TempFileName="$1.tmp"
	#echo -E "$FileContent" > $TempFileName

	#A clean line to copy and paste 
	#sed -i -e 's/needle/replacement/'`

	#######################################################################
	#This is the list of items to find/replace to convert the Pugi API into Physgame API

	#Remove the original and grossly incomplete doxygen documentations
	sed -i -e 's|///|////|g' $1								

	#Adjust the names of two word type to varaibles to use CamelCase
	sed -i -e 's/xml_\(.\)\([a-z]*\)_\(.\)/\U\1\L\2\U\3/g' $1		
	sed -i -e 's/xml_\(.\)/\U\1/g' $1

	#These configure the XML API to be exported to a DLL on windows
	sed -i -e 's/XML_CLASS/PHYS_LIB/g' $1					
	sed -i -e 's/XML_FUNCTION/PHYS_LIB/g' $1
	sed -i -e 's/XML_API/PHYS_LIB/g' $1

	#Status and error codes
	sed -i -e 's/status_ok/StatusOk/g' $1										
	sed -i -e 's/status_file_not_found/StatusFileNotFound/g' $1
	sed -i -e 's/status_io_error/StatusIOError/g' $1
	sed -i -e 's/status_out_of_memory/StatusOutOfMemory/g' $1
	sed -i -e 's/status_unrecognized_tag/StatusUnrecognizedTag/g' $1
	sed -i -e 's/status_bad_pi/StatusBadPi/g' $1
	sed -i -e 's/status_bad_comment/StatusBadComment/g' $1
	sed -i -e 's/status_bad_cdata/StatusBadCdata/g' $1
	sed -i -e 's/status_bad_doctype/StatusBadDoctype/g' $1
	sed -i -e 's/status_bad_pcdata/StatusBadPcdata/g' $1
	sed -i -e 's/status_bad_start_element/StatusBadStartElement/g' $1
	sed -i -e 's/status_bad_attribute/StatusBadAttribute/g' $1
	sed -i -e 's/status_bad_end_element/StatusBadEndElement/g' $1
	sed -i -e 's/status_end_element_mismatch/StatusEndElementMismatch/g' $1
	sed -i -e 's/status_internal_error/StatusInternalError/g' $1

	#Fix member ParseStatus.Status, ParseStatus.DocumentEncoding, ParseStatus.Offset and ParseStatus.Description()
	sed -i -e 's/status/Status/g' $1
	sed -i -e 's/encoding/DocumentEncoding/g' $1
	sed -i -e 's/offset\([^o]\)/Offset\1/g' $1
	sed -i -e 's/description/Description/g' $1

	#Fix The Encoding Enum All 1,2 and 3 part variable names
	sed -i -e 's/\(DocumentEncoding\)_\([au][tf]*\)\([a-z0-9]*\)_\([ble]*\)/Encoding\U\2\3\U\4/g' $1
	sed -i -e 's/\(DocumentEncoding\)_\([au][tf]*\)\([a-z0-9]*\)/Encoding\U\2\L\3/g' $1
	sed -i -e 's/DocumentEncoding_wchar/Encodingwchar_t/g' $1

	#Fix the NodeType Enum
	sed -i -e 's|\(n\)\(ode\)_\(.\)\([a-z]*\)|\U\1\L\2\U\3\L\4|g' $1

	#More tightly integrating Character into the XML parser
	sed -i -e 's|typedef XML_CHAR char_t;|typedef Character char_t;|g' $1
	sed -i -e 's|typedef std::basic_string<XML_CHAR, std::char_traits<XML_CHAR>, std::allocator<XML_CHAR> >;|//typedef std::basic_string<Character, std::char_traits<Character>, std::allocator<Character> > string_t;|g' $1
	sed -i -e 's|string_t|String|g' $1
	
	#sed -i -e 's|\([^w]\)char_t|\1Character|g' $1 #This very breaks the code

	#Renaming 1 and2 part Parse options
	sed -i -e 's|parse_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Parse\U\1\L\2\U\3\L\4|g' $1				
	sed -i -e 's|parse_\(.\)\([a-z]*\)|Parse\U\1\L\2|g' $1
	
	#Renaming 1,2 and 3 part Format options
	sed -i -e 's|format_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Format\U\1\L\2\U\3\L\4\U\5\L\6|g' $1	
	sed -i -e 's|format_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Format\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|format_\(.\)\([a-z]*\)|Format\U\1\L\2|g' $1				
	
	#Renaming 1 and 2 part Xpath Class Names
	sed -i -e 's|xpath_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|XPath\U\1\L\2\U\3\L\4|g' $1	
	sed -i -e 's|xpath_\(.\)\([a-z]*\)|XPath\U\1\L\2|g' $1				

	#The Writer class and compatibility options
	sed -i -e 's|writer|WriterInstance|g' $1
	sed -i -e 's|write|Write|g' $1
	sed -i -e 's|_stream->Write|_stream->write|g' $1	#These 2 lines fixe mistakes made by the above line
	sed -i -e 's|fWrite|fwrite|g' $1

	#sed -i -e 's|struct AttributeStruct;|struct AttributeStruct\n	{\n		AttributeStruct(MemoryPage* page): header(reinterpret_cast<uintptr_t>(page)), Name(0), Value(0), prev_attribute_c(0), GetNextAttribute(0) {} \n		uintptr_t header;\n		char_t* Name;\n		char_t*	Value;\n		AttributeStruct* prev_attribute_c;\n		AttributeStruct* GetNextAttribute;\n	}; |g' $1

	#Common class member
	sed -i -e 's|set_\(.\)\([a-z]*\)|Set\U\1\L\2|g' $1
	sed -i -e 's|as_\(.\)\([a-z]*\)|As\U\1\L\2|g' $1
	sed -i -e 's|next_\(.\)\([a-z]*\)|Next\U\1\L\2|g' $1
	sed -i -e 's|previous_\(.\)\([a-z]*\)|Previous\U\1\L\2|g' $1
	sed -i -e 's|first_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|First\U\1\L\2\U\3\L\4\U\5\L\6\U\7\L\8|g' $1
	sed -i -e 's|first_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|First\U\1\L\2\U\3\L\4\U\5\L\6|g' $1
	sed -i -e 's|first_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|First\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|first_\(.\)\([a-z]*\)|First\U\1\L\2|g' $1
	sed -i -e 's|last_\(.\)\([a-z]*\)|Last\U\1\L\2|g' $1
	sed -i -e 's|hash_value|HashValue|g' $1								
	sed -i -e 's|internal_object|InternalObject|g' $1								

	#The Attribute class
	sed -i -e 's|empty(|Empty(|g' $1
	sed -i -e 's|\([^e]\)name\([^s]\)|\1Name\2|g' $1
	sed -i -e 's|value|Value|g' $1
	sed -i -e 's|NextAttribute|GetNextAttribute|g' $1
	sed -i -e 's|PreviousAttribute|GetPreviousAttribute|g' $1

	sed -i -e 's|float AsFloat() const;|float AsFloat() const;\n		Real AsReal() const;\n		Whole AsWhole() const;\n		Integer AsInteger() const;\n		String AsString() const;|g' $1
	sed -i -e 's|float Attribute::AsFloat() const|Whole Attribute::AsWhole() const\n	{\n		if (!_attr \|\| !_attr->Value) return 0;\n		return ToWhole(_attr->Value);\n	}\n\n	Integer Attribute::AsInteger() const\n	{\n		if (!_attr \|\| !_attr->Value) return 0;\n		return ToInteger(_attr->Value);\n	}\n\n	String Attribute::AsString() const\n	{\n		if (!_attr \|\| !_attr->Value) return 0;\n		return ToString(_attr->Value);\n	}\n\n	Real Attribute::AsReal() const\n	{\n		if (!_attr \|\| !_attr->Value) return 0;\n		return ToReal(_attr->Value);\n	}\n\n	float Attribute::AsFloat() const|g' $1

	#The Node Class
	sed -i -e 's|child_\(.\)\([a-z]*\)|Child\U\1\L\2|g' $1
	sed -i -e 's|append_\(.\)\([a-z]*\)|Append\U\1\L\2|g' $1
	sed -i -e 's|prepend_\(.\)\([a-z]*\)|Prepend\U\1\L\2|g' $1
	sed -i -e 's|insert_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Insert\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|insert_\(.\)\([a-z]*\)|Insert\U\1\L\2|g' $1
	sed -i -e 's|append_\(.\)\([a-z]*\)|Append\U\1\L\2|g' $1
	sed -i -e 's|remove_\(.\)\([a-z]*\)|Remove\U\1\L\2|g' $1
	sed -i -e 's|find_\(.\)\([a-zA-Z]*\)_\(.\)\([a-z]*\)|Find\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|find_\(.\)\([a-z]*\)|Find\U\1\L\2|g' $1
	sed -i -e 's|select_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Find\U\1\L\2\U\3\L\4\U\5\L\6|g' $1
	sed -i -e 's|select_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Find\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|select_\(.\)\([a-z]*\)|Find\U\1\L\2|g' $1
	sed -i -e 's|attr_\(.\)\([a-z]*\)|Attr\U\1\L\2|g' $1


	sed -i -e 's|\([^_]\)type\([^dn]\)|\1Type\2|g' $1
	sed -i -e 's|\([^_]\)attribute\([^_s]\)|\1GetAttribute\2|g' $1
	sed -i -e 's|FirstAttribute|GetFirstAttribute|g' $1
	sed -i -e 's|LastAttribute|GetLastAttribute|g' $1
	sed -i -e 's|\([^s]\)print\([^f]\)|\1Print\2|g' $1
	sed -i -e 's|FirstChild|GetFirstChild|g' $1
	sed -i -e 's|LastChild|GetLastChild|g' $1
	sed -i -e 's|parent|GetParent|g' $1
	sed -i -e 's|root|GetRoot|g' $1
	sed -i -e 's|child|GetChild|g' $1
	sed -i -e 's|NextSibling|GetNextSibling|g' $1
	sed -i -e 's|PreviousSibling|GetPreviousSibling|g' $1
	sed -i -e 's|traverse|Traverse|g' $1
	sed -i -e 's|path|Path|g' $1

	# NodeIterator
	sed -i -e 's|Value_type|value_type|g' $1
	
	# Document
	sed -i -e 's|reset|Reset|g' $1
	sed -i -e 's|load_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Format\U\1\L\2\U\3\L\4\U\5\L\6\U\7\L\8|g' $1	
	sed -i -e 's|load_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Load\U\1\L\2\U\3\L\4\U\5\L\6|g' $1	
	sed -i -e 's|load_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Load\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|load_\(.\)\([a-z]*\)|Load\U\1\L\2|g' $1				
	sed -i -e 's|load|Load|g' $1
	sed -i -e 's|save_\(.\)\([a-z]*\)_\(.\)\([a-z]*\)|Save\U\1\L\2\U\3\L\4|g' $1
	sed -i -e 's|save_\(.\)\([a-z]*\)|Save\U\1\L\2|g' $1				
	sed -i -e 's|save|Save|g' $1
	sed -i -e 's|document_element|DocumentElement|g' $1

	#The TreeWalker Class
	sed -i -e 's|depth|Depth|g' $1

	#XPathVariable
	sed -i -e 's|get_\(.\)\([a-zA-Z]*\)|Get\U\1\L\2|g' $1
	sed -i -e 's|\([^f]\)set(|\1Set(|g' $1

	#XPathVariableSet
	sed -i -e 's|add(|Add(|g' $1
	sed -i -e 's|\([^r]\)get(|\1Get(|g' $1

	#XPathQuery
	sed -i -e 's|evaluate_\(.\)\([a-z]*\)|Evaluate\U\1\L\2|g' $1				
	sed -i -e 's|return_type|ReturnType|g' $1
	sed -i -e 's|result|Result|g' $1
	sed -i -e 's|std::exception|phys::Exception|g' $1

	#XPathNodeSet
	sed -i -e 's|Type_unsorted|TypeUnsorted|g' $1
	sed -i -e 's|Type_sorted_reverse|TypeSortedReverse|g' $1
	sed -i -e 's|Type_sorted|TypeSorted|g' $1
	sed -i -e 's|Type_t|CollectionType|g' $1

	#XPathNode
	sed -i -e 's|\([^_]\)node(|\1GetNode(|g' $1

	#typings and functions
	sed -i -e 's|GetMemory_allocation_function|GetMemoryAllocationFunction|g' $1
	sed -i -e 's|GetMemory_deallocation_function|GetMemoryDeallocationFunction|g' $1
	sed -i -e 's|allocation_function|AllocationFunction|g' $1
	sed -i -e 's|deallocation_function|DeallocationFunction|g' $1
	sed -i -e 's|pugi::|phys::xml::|g' $1

	#Common	
	sed -i -e 's|Nodeset|NodeSet|g' $1
	sed -i -e 's|ReSet|Reset|g' $1

	###############################
	#Documentation that was not put in xmldoc.h

	#Parsing status items
	sed -i -e 's|// Parsing Status (see ParseStatus)|/// @brief Parsing status ( see @ref ParseStatus )|' $1
	sed -i -e 's|// Last parsed Offset (in char_t units from start of input data)|/// @brief Last parsed offset (in char_t units from start of input data)|' $1
	sed -i -e 's|// Source document DocumentEncoding|/// @brief Source document encoding ( see @ref Encoding )|' $1
	sed -i -e 's|// Default constructor, initializes object to failed state|/// @brief Default constructor, initializes object to failed state.|' $1
	sed -i -e 's|// Cast to bool operator|/// @brief Cast to bool operator \n		/// @return This returns true if the ParseResult::Status member is set to ParseStatus::StatusOk, otherwise this returns false.|' $1
	sed -i -e 's|// Get error Description |/// @brief Creates a text description of the error situation, if any exists.\n		/// @return A const char* with a brief error description based on the ParseResult::Status |' $1
	sed -i -e 's|// Character type used for all internal storage and operations; depends on XML_WCHAR_MODE|/// @brief The character type used the internals of the XML parser, this is defined in datatypes.h.|' $1

	#Writer Interface class
	sed -i -e 's|		virtual ~Writer() {} |		/// @brief Empty Virtual Destructor\n		virtual ~Writer() {} |' $1
	sed -i -e 's|// Write memory chunk into stream/file/whatever |/// @brief This will be used to output xml to an external source such as a file or stream\n		/// @param data This is a pointer to something that will get written to the output\n		/// @param size The size in bytes of whatever was passed in.|' $1

	#WriterStream Class
	sed -i -e 's|// Construct WriterInstance from an output stream object |/// @brief A constructor that accepts a stream of characters\n		/// @param stream A stream to send stuff to.|' $1
	sed -i -e 's|WriterStream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream);|\n		/// @brief A constructor that accepts a stream of wide characters\n		/// @param stream A stream to send stuff to.\n		WriterStream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >\& stream);|' $1
	sed -i -e 's|// Safe bool conversion operator|/// @brief Used to convert this to a boolean value in a safe way\n		/// @return Returns true if the internal data is set and false otherwise.|' $1

	#Attribute
	sed -i -e 's|bool SetValue(const char_t\* rhs);|/// @brief Set the value of this.\n		/// @param rhs The new Value.\n		/// @return True if successful, returns false if this is empty or there is not enough memory.\n		/// @todo update this to make the error return code redundant and use an exception instead.\n		/// @todo Review for possiblity of buffer overflow.\n		bool SetValue(const char_t* rhs);|' $1
	sed -i -e 's|bool SetValue(int rhs);|/// @brief Convert rhs to a character array that contains rhs, then use that as the new value.\n		/// @param rhs The new value as an int.\n		/// @return True if successful, returns false if Attribute is empty or there is not enough memory.\n		/// @todo update this to make the error return code redundant and use an exception instead.\n		/// @todo Review for possiblity of buffer overflow.\n		bool SetValue(int rhs);|' $1
	sed -i -e 's|bool SetValue(unsigned int rhs);|/// @brief Convert rhs to a character array that contains rhs, then use that as the new value.\n		/// @param rhs The new value as an unsigned int.\n		/// @return True if successful, returns false if Attribute is empty or there is not enough memory.\n		/// @todo update this to make the error return code redundant and use an exception instead.\n		/// @todo Review for possiblity of buffer overflow.\n		bool SetValue(unsigned int rhs);|' $1
	sed -i -e 's|bool SetValue(double rhs);|/// @brief Convert rhs to a character array that contains rhs, then use that as the new value.\n		/// @param rhs The new value as a double.\n		/// @return True if successful, returns false if Attribute is empty or there is not enough memory.\n		/// @todo update this to make the error return code redundant and use an exception instead.\n		/// @todo Review for possiblity of buffer overflow.\n		bool SetValue(double rhs);|' $1
	sed -i -e 's|bool SetValue(bool rhs);|/// @brief Convert rhs to a character array that contains the meaning of rhs, then use that as the new value.\n		/// @param rhs This with be interpretted, then converted to "true" or "false"  and used as the new value.\n		/// @return True if successful, returns false if Attribute is empty or there is not enough memory.\n		/// @todo update this to make the error return code redundant and use an exception instead.\n		/// @todo Review for possiblity of buffer overflow.\n		bool SetValue(bool rhs);\n\n		/// @brief Convert rhs to a character array that contains the meaning of rhs, then use that as the new value.\n		/// @param rhs This with be converted to a character array using the appropriate streaming operator <<, then used as the new value.\n		/// @return True if successful, returns false if Attribute is empty or there is not enough memory.\n		/// @warning You should not pass classes that stream/serialize to xml into this function, the result will be invalid XML. If you must, find a way to strip out the ">" character, then you can reinsert it later\n		/// @todo Strip ">" automatically and provide a method to reconsitute it.\n		template <class T> bool SetValue(T rhs)\n		{\n			return SetValue(ToString(rhs).c_str());\n		}|' $1


	#Node
	sed -i -e  's|// Constructs node from internal pointer|/// @brief Constructs node from internal pointer\n		/// @param p An internal node pointer.|' $1
	sed -i -e  's|Node GetNextSibling(const char_t\* Name) const; |/// @brief Attempt to retrieve the next sibling of this Node with a matching name.\n		/// @param Name A c-string that has the name of the node you to find.\n		/// @details A sibling of a Node is another Node that shares the same parent. If this is and the sibling nodes are valid, this iterates through Nodes until a sibling with a Matching name is found or all siblings are checked. If a Match is found this retrieves that Node, otherwise this return an empty Node.\n		/// @return A Node that represents a sibling with a matching name, or an empty Node on failure.\n		Node GetNextSibling(const char_t* Name) const; |' $1
	sed -i -e  's|Node GetPreviousSibling(const char_t\* Name) const; |/// @brief Attempt to retrieve the first previous sibling of this Node with a matching name.\n		/// @param Name A c-string that has the name of the node you to find.\n		/// @details A sibling of a Node is another Node that shares the same parent. If this is and the sibling nodes are valid, this iterates through Nodes until a sibling with a Matching name is found or all siblings are checked. If a Match is found this retrieves that Node, otherwise this return an empty Node.\n		/// @return A Node that represents a sibling with a matching name, or an empty Node on failure.\n		Node GetPreviousSibling(const char_t* Name) const; |' $1
	sed -i -e  's|Node GetPreviousSibling() const; |/// @brief Attempt to retrieve the previous sibling of this Node.\n		/// @details A sibling of a Node is another Node that shares the same parent. If this is and the sibling nodes are valid, this retrieves that Node, otherwise this return an empty Node.\n		/// @return A Node that represents a sibling, or an empty Node on failure.\n		Node GetPreviousSibling() const; |' $1
	sed -i -e  's|Attribute AppendAttribute(const char_t\* Name);|\n		/// @brief Creates an Attribute and puts it at the end of this Nodes attributes.\n		/// @param Name The name of the New attribute to be created\n		/// @details This attempts to create an Attribute and stick it at the end of the list of attribute on the current\n		/// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will\n		/// fail and return an empty attribute if this Node is empty.\n		/// @return The created Attribute or an empty Attribute on Failure.\n		Attribute AppendAttribute(const char_t* Name); |' $1
	sed -i -e  's|Attribute AppendCopy(const Attribute& proto);|\n		/// @brief Copies an Attribute and puts the copy at the end of this Nodes attributes.\n		/// @param proto The attribute to be copied.\n		/// @details This attempts to create a copy of an attribute Attribute and stick it at the end of the list of attribute on the current\n		/// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will\n		/// fail and return an empty attribute if this Node is empty.\n		/// @return The created Attribute or an empty Attribute on Failure.\n		Attribute AppendCopy(const Attribute\& proto); |' $1
	sed -i -e  's|Attribute PrependCopy(const Attribute& proto);|\n		/// @brief Copies an Attribute and puts the copy at the beginning of this Nodes attributes.\n		/// @param proto The attribute to be copied.\n		/// @details This attempts to create a copy of an attribute Attribute and stick it at the beginning of the list of attribute on the current\n		/// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will\n		/// fail and return an empty attribute if this Node is empty.\n		/// @return The created Attribute or an empty Attribute on Failure.\n		Attribute PrependCopy(const Attribute\& proto); |' $1
	sed -i -e  's|Attribute InsertCopyAfter(const Attribute& proto, const Attribute& attr);|\n		/// @brief Copies an Attribute and puts the copy into the list of this Nodes attributes.\n		/// @param proto The attribute to be copied.\n		/// @param attr An Attribute that represents an Attribute on this Node, and is just before where you want the new copy of proto.\n		/// @details This attempts to create a copy of an attribute Attribute and stick it in the middle of the list of attributes, just after a selected attribute, on the current\n		/// Node. This will fail and return an Empty Attribute if this Node is neither an Element nor a Declaration. This will\n		/// fail and return an empty attribute if this Node is empty.\n		/// @return The created Attribute or an empty Attribute on Failure.\n		Attribute InsertCopyAfter(const Attribute\& proto, const Attribute\& attr); |' $1
	sed -i -e  's|Node InsertChildAfter(const char_t\* Name, const Node& node);|\n		/// @brief Creates an element Node as a child of this Node, with the given name at the middle of the children\n		/// @param Name The name of the Node to be created.\n		/// @param Node The node just before were the Create node is to be placed.\n		/// @details Calls @ref Node::InsertChildAfter(NodeType, Node); using NodeElement as the NodeType.\n		/// @return The desired Node on success, an empty Node on failure.\n		Node InsertChildAfter(const char_t* Name, const Node\& node);|' $1
	sed -i -e  's|Node PrependCopy(const Node& proto);|\n		/// @brief Copies a Node and puts the copy at the start of the list of this Nodes Childrem.\n		/// @param proto The Node to be copied. If this is emptry, no work is performed.\n		/// @return The copied Node on success, an empty Node on failure.\n		Node PrependCopy(const Node\& proto);|' $1
	sed -i -e  's|bool RemoveChild(const char_t\* Name);|\n		/// @brief Remove child element as specified by name.\n		/// @param Name The name of the Node to remove.\n		/// @return True if the removal was successful, false otherwise\n		bool RemoveChild(const char_t* Name);|' $1
	sed -i -e  's|XPathNodeSet FindNodes(const char_t\* query, XPathVariableSet\* variables = 0) const;|\n		/// @brief Select a group of nodes by evaluating an XPath query.\n		/// @param query The XPath query as a c-string to be evaluated.\n		/// @param XPathVariableSet undocumented.\n		/// @return An XPathNodeSet with the Matchs of the XPath query.\n		XPathNodeSet FindNodes(const char_t* query, XPathVariableSet* variables = 0) const; |' $1
	sed -i -e  's|XPathNodeSet FindNodes(const XPathQuery& query) const;|\n		/// @brief Select a group of nodes by evaluating an XPath query.\n		/// @param query The XPath query XPathQuery class instance.\n		/// @return An XPathNodeSet with the Matchs of the XPath query.\n		/// @param query The XPath query XPathQuery class instance.\n		XPathNodeSet FindNodes(const XPathQuery\& query) const; |' $1

	sed -i -e  's|void Print(Writer& WriterInstance, const char_t\* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto, unsigned int Depth = 0) const;|\n		/// @brief Output the XML document using a Writer.\n		/// @param WriterInstance The Writer that will be used to output the xml text.\n		/// @param indent The Character(s) used to represent a tab in the output, this defaults to one tab character.\n		/// @param flags The output format flags, this is a bitfield that defaults to xml::FormatDefault.\n		/// @param DocumentEncoding The xml::Encoding of the document, whichs defaults to EncodingAuto\n		/// @param Depth This defaults to 0. The amount of times to prepend the indentation to the beginning of each output line.\n		/// @details This will never write a Byte Order Mark(BOM), and will default to not outputing a document declaration.\n		void Print(Writer\& WriterInstance, const char_t* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto, unsigned int Depth = 0) const;|' $1
	sed -i -e  's|void Print(std::basic_ostream<char, std::char_traits<char> >& os, const char_t\* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto, unsigned int Depth = 0) const;|\n		/// @brief Output the XML document using a Output Stream.\n		/// @param os An output stream to send xml text to.\n		/// @param indent The Character(s) used to represent a tab in the outpput, this defaults to one tab character.\n		/// @param flags The output format flags, this is a bitfield that defaults to xml::FormatDefault\n		/// @param DocumentEncoding The xml::Encoding of the document, whichs defaults to EncodingAuto\n		/// @param Depth This defaults to 0. The amount of times to prepend the indentation to the beginning of each output line.\n		/// @details This will never write a Byte Order Mark(BOM), and will default to not outputing a document declaration.\n		void Print(std::basic_ostream<char, std::char_traits<char> >\& os, const char_t* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto, unsigned int Depth = 0) const;|' $1
	sed -i -e  's|void Print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& os, const char_t\* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, unsigned int Depth = 0) const;|\n		/// @brief Output the XML document using a Output Stream.\n		/// @param os An output stream to send xml text to.\n		/// @param indent The Character(s) used to represent a tab in the outpput, this defaults to one tab character.\n		/// @param flags The output format flags, this is a bitfield that defaults to xml::FormatDefault\n		/// @param Depth This defaults to 0. The amount of times to prepend the indentation to the beginning of each output line.\n		/// @details This will never write a Byte Order Mark(BOM), and will default to not outputing a document declaration.\n		void Print(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >\& os, const char_t* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, unsigned int Depth = 0) const;|' $1 

	#Document
	sed -i -e  's|void Save(std::basic_ostream<char, std::char_traits<char> >& stream, const char_t\* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto) const; |/// @brief Save XML document to a stream.\n		/// @param stream The output stream to send the XML document to.\n		/// @param indent The Character(s) used to represent a tab in the output, this defaults to one tab character.\n		/// @param flags The output format flags, this is a bitfield that defaults to xml::FormatDefault.\n		/// @param DocumentEncoding What kind of text is in the stream, this defaults to Encoding::EncodingAuto.\n		void Save(std::basic_ostream<char, std::char_traits<char> >\& stream, const char_t* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault, Encoding DocumentEncoding = EncodingAuto) const;  |' $1 
	sed -i -e  's|void Save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >& stream, const char_t\* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault) const;|/// @brief Save XML document to a stream of wide characters.\n		/// @param stream The output stream of wide characters to send the XML document to.\n		/// @param indent The Character(s) used to represent a tab in the output, this defaults to one tab character.\n		/// @param flags The output format flags, this is a bitfield that defaults to xml::FormatDefault.\n		void Save(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >\& stream, const char_t* indent = XML_TEXT("\\t"), unsigned int flags = FormatDefault) const; |' $1 
	sed -i -e  's|Node DocumentElement() const;|/// @brief Get document element\n		/// @return An xml::Node that is the root element of the xml Document\n		Node DocumentElement() const;|' $1 
	
	#XPathVariable
	sed -i -e  's|// Get variable Name|/// @brief Retrieve the name of this variable.\n		/// @return A const c-style string made of char_t, that contains the name of this variable|' $1
	sed -i -e  's|// Get variable Type|/// @brief Get the variable type.\n		/// @return An XPathValueType specifying the kind of data stored in this variable.|' $1 
	sed -i -e  's|bool Set(double Value);|/// @brief Set variable Value; no Type conversion is performed.\n		/// @param Value The value as a double to attempt to put into this.\n		/// @return True is return, false is returned on Type mismatch error.\n		bool Set(double Value); |' $1 
	sed -i -e  's|bool Set(const char_t\* Value);|/// @brief Set variable Value; no Type conversion is performed.\n		/// @param Value The value as a char_t array to attempt to put into this.\n		/// @return True is return, false is returned on Type mismatch error.\n		bool Set(const char_t* Value); |' $1 
	sed -i -e  's|bool Set(const XPathNodeSet& Value);|/// @brief Set variable Value; no Type conversion is performed.\n		/// @param Value The value to attempt to put into this.\n		/// @return True is return, false is returned on Type mismatch error.\n		bool Set(const XPathNodeSet\& Value); |' $1 

	#XPathVariable
	sed -i -e  's|bool Set(const char_t\* Name, double Value);|/// @brief Set contained variable Value; no Type conversion is performed.\n		/// @param Name The name of variable to change.\n		/// @param Value The value to attempt to put into the named variable.\n		/// @return True is return, false is returned if there is no such variable or on Type mismatch error.\n		bool Set(const char_t* Name, double Value);|' $1
	sed -i -e  's|bool Set(const char_t\* Name, const char_t\* Value);|/// @brief Set contained variable Value; no Type conversion is performed.\n		/// @param Name The name of variable to change.\n		/// @param Value The value to attempt to put into the named variable.\n		/// @return True is return, false is returned if there is no such variable or on Type mismatch error.\n		bool Set(const char_t* Name, const char_t* Value);|' $1 
	sed -i -e  's|bool Set(const char_t\* Name, const XPathNodeSet& Value);|/// @brief Set contained variable Value; no Type conversion is performed.\n		/// @param Name The name of variable to change.\n		/// @param Value The value to attempt to put into the named variable.\n		/// @return True is return, false is returned if there is no such variable or on Type mismatch error.\n		bool Set(const char_t* Name, const XPathNodeSet\& Value);|' $1 

	#XPathQuery
	sed -i -e  's|explicit XPathQuery(const char_t\* query, XPathVariableSet\* variables = 0);|\n		/// @brief Construct a compiled object from XPath expression.\n		/// @param query The query in the form of a c-string style char_t array.\n		/// @param variables Any extra data the query might need, passing a null pointer simply omits passing any arguments.\n		/// @throw If XML_NO_EXCEPTIONS is not defined (which is the default), throws XPathException on compilation errors.\n		explicit XPathQuery(const char_t* query, XPathVariableSet* variables = 0);|' $1
	sed -i -e 's|~XPathQuery();|/// @brief Destructor\n		~XPathQuery();|' $1
	sed -i -e 's|double EvaluateNumber(const XPathNode& n) const;|/// @brief Evaluate expression as double value in the specified context; performs Type conversion if necessary.\n		/// @param n The XPathNode that will serve as the context for the query.\n		/// @throw If XML_NO_EXCEPTIONS is not defined (by default it is not defined), throws std::bad_alloc on out of memory errors.\n		/// @return A result as a double from evaluating the expression.\n		double EvaluateNumber(const XPathNode\& n) const;|' $1
	sed -i -e 's|String EvaluateString(const XPathNode& n) const;|/// @brief Evaluate expression as string value in the specified context; performs Type conversion if necessary.\n		/// @param n The XPathNode that will serve as the context for the query.\n		/// @throw If XML_NO_EXCEPTIONS is not defined (by default it is not defined), throws std::bad_alloc on out of memory errors.\n		/// @return A result as a String from evaluating the expression.\n		String EvaluateString(const XPathNode\& n) const;|' $1
	sed -i -e 's|size_t EvaluateString(char_t\* buffer, size_t capacity, const XPathNode& n) const;|/// @brief Evaluate expression as string value in the specified context; performs Type conversion if necessary.\n		/// @param buffer The place to store the c-style Character array\n		/// @param capacity At most capacity characters are written to the destination buffer.\n		/// @param n The XPathNode that with serve as the context for the query.\n		/// @throw If XML_NO_EXCEPTIONS is not defined (by default it is not defined), throws std::bad_alloc on out of memory errors. If XML_NO_EXCEPTIONS is defined, this returns empty  set instead.\n		/// @return Full result size is returned (includes terminating zero).\n		size_t EvaluateString(char_t* buffer, size_t capacity, const XPathNode\& n) const;|' $1
	sed -i -e 's|XPathNodeSet EvaluateNodeSet(const XPathNode& n) const;|/// @brief Evaluate expression as node set in the specified context.\n		/// @param n The XPathNode that with serve as the context for the query.\n		/// @throw If XML_NO_EXCEPTIONS is not defined (by default it is not defined), throws throws XPathException on Type mismatch and std::bad_alloc on out of memory errors. If XML_NO_EXCEPTIONS is defined, returns empty node set instead.\n		/// @return An XPathNodeSet.\n		XPathNodeSet EvaluateNodeSet(const XPathNode\& n) const;|' $1

	#XPathException
	sed -i -e 's|explicit XPathException(const XPathParseResult& Result);|/// @brief Construct exception from parse Result\n		explicit XPathException(const XPathParseResult\& Result);|' $1

	#XPathNode
	sed -i -e 's|XPathNode(const Attribute& GetAttribute, const Node& GetParent);|/// @brief Construct From a xml::Attribute.\n		/// @param GetAttribute The xml::Attribute this handle should reference.\n		/// @param GetParent The xml::Node the xml::Attribute is on.\n		XPathNode(const Attribute\& GetAttribute, const Node\& GetParent); |' $1
	sed -i -e 's|bool operator==(const XPathNode& n) const;|/// @brief Called when comparing two XPathNode instances for equality.\n		/// @param n The other xml::XPathNode to compare this Node against for equality.\n		/// @return True if this and the other xml::XPathNode are referencing the same item, false otherwise;\n		bool operator==(const XPathNode\& n) const; |' $1
	sed -i -e 's|bool operator!=(const XPathNode& n) const;|\n		/// @brief Called when comparing two XPathNode instances for inequality.\n		/// @param n The other xml::XPathNode to compare this Node against for inequality.\n		/// @return True if this and the other xml::XPathNode are referencing the same item, false otherwise;\n		bool operator!=(const XPathNode\& n) const; |' $1

	#XPathNodeSet
	sed -i -e 's|XPathNodeSet(const XPathNodeSet& ns); |/// @brief Copy constructor.\n		/// @param ns The XPathNodeSet to copy.\n		XPathNodeSet(const XPathNodeSet\& ns); |' $1
sed -i -e 's|size_t size() const;|/// @brief Get collection size.\n		/// @return The number of XPathNode instances as a size_t in the set\n		size_t size() const; |' $1





}

FixNames $NewHFile
FixNames $NewCppFile

#we unset this, so we will set it again, even though on *Most* systems this isn't required
set +f
